
lab3_cpu0.elf:     file format elf32-littlenios2
lab3_cpu0.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x21080190

Program Header:
    LOAD off    0x00001000 vaddr 0x21080000 paddr 0x21080000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x21080020 paddr 0x21080020 align 2**12
         filesz 0x0001e2f8 memsz 0x0001e2f8 flags r-x
    LOAD off    0x00020000 vaddr 0x00000000 paddr 0x2109e318 align 2**12
         filesz 0x00005df8 memsz 0x00006758 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  21080000  21080000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000170  21080020  21080020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0001e188  21080190  21080190  00001190  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00003f30  00000000  2109e318  00020000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001ec8  00003f30  210a2248  00023f30  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000960  00005df8  210a4110  00025df8  2**2
                  ALLOC, SMALL_DATA
  6 .lpddr2       00000000  00006758  00006758  00025df8  2**0
                  CONTENTS
  7 .sram_memory  00000000  210a4110  210a4110  00025df8  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  00025df8  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 000014f8  00000000  00000000  00025e20  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   00040e4a  00000000  00000000  00027318  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 0000f310  00000000  00000000  00068162  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00013c99  00000000  00000000  00077472  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00003a78  00000000  00000000  0008b10c  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000671f  00000000  00000000  0008eb84  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0002fb0a  00000000  00000000  000952a3  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000060  00000000  00000000  000c4db0  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00003e00  00000000  00000000  000c4e10  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000003  00000000  00000000  000ce125  2**0
                  CONTENTS, READONLY
 19 .cpu          00000005  00000000  00000000  000ce128  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  000ce12d  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  000ce12e  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  000ce12f  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  000ce133  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  000ce137  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  000ce13b  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000b  00000000  00000000  000ce146  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000b  00000000  00000000  000ce151  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 0000000b  00000000  00000000  000ce15c  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 00000026  00000000  00000000  000ce167  2**0
                  CONTENTS, READONLY
 30 .jdi          000073e5  00000000  00000000  000ce18d  2**0
                  CONTENTS, READONLY
 31 .sopcinfo     001ace22  00000000  00000000  000d5572  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
21080000 l    d  .entry	00000000 .entry
21080020 l    d  .exceptions	00000000 .exceptions
21080190 l    d  .text	00000000 .text
00000000 l    d  .rodata	00000000 .rodata
00003f30 l    d  .rwdata	00000000 .rwdata
00005df8 l    d  .bss	00000000 .bss
00006758 l    d  .lpddr2	00000000 .lpddr2
210a4110 l    d  .sram_memory	00000000 .sram_memory
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../lab3_cpu0_bsp//obj/HAL/src/crt0.o
210801d8 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 tables.c
00000000 l    df *ABS*	00000000 util.c
00000000 l    df *ABS*	00000000 idct.c
00000000 l    df *ABS*	00000000 lossless_decode.c
00000000 l    df *ABS*	00000000 mjpeg423_decoder.c
210810d8 l     F .text	00000004 dma_callback
00000000 l    df *ABS*	00000000 ycbcr_to_rgb.c
00000000 l    df *ABS*	00000000 FatFileSystem.c
00005e48 l     O .bss	00000140 fInfo.3439
00000000 l    df *ABS*	00000000 FatInternal.c
00005f88 l     O .bss	00000200 szBlock.3487
00000000 l    df *ABS*	00000000 debug.c
00000000 l    df *ABS*	00000000 mmc.c
21083ad0 l     F .text	00000124 mmc_send_status.constprop.4
21083bf4 l     F .text	00000a74 mmc_startup
00000498 l     O .rodata	00000040 multipliers
000004d8 l     O .rodata	00000010 fbase
00006188 l     O .bss	00000040 switch_status.3319
00000000 l    df *ABS*	00000000 ocsdc.c
21084de4 l     F .text	00000100 ocsdc_set_ios
21084ee4 l     F .text	000001e0 ocsdc_send_cmd
210850c4 l     F .text	000000fc ocsdc_init
00000000 l    df *ABS*	00000000 sd_lib.c
00000000 l    df *ABS*	00000000 ece423_vid_ctl.c
2108538c l     F .text	0000020c ece423_video_display_add_text.constprop.2
00000000 l    df *ABS*	00000000 font.c
00000000 l    df *ABS*	00000000 heatshrink.c
00000000 l    df *ABS*	00000000 heatshrink_decoder.c
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    df *ABS*	00000000 uw_logo.c
00000000 l    df *ABS*	00000000 main.c
21089fc0 l     F .text	0000001c timer_ISR
21089fdc l     F .text	00000054 button_ISR
2108a030 l     F .text	00000040 begin_file_browsing
2108a070 l     F .text	00000074 get_next_mpeg_filename
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 mulsf3.c
00000000 l    df *ABS*	00000000 floatunsisf.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
2108d45c l     F .text	0000006c udivmodsi4
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 impure.c
00004130 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 malign.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strrchr.c
00000000 l    df *ABS*	00000000 vfprintf.c
00003b66 l     O .rodata	00000010 zeroes.4240
00003b76 l     O .rodata	00000010 blanks.4239
00000000 l    df *ABS*	00000000 vfprintf.c
00003b86 l     O .rodata	00000010 zeroes.4255
21092724 l     F .text	000000bc __sbprintf
00003b96 l     O .rodata	00000010 blanks.4254
00000000 l    df *ABS*	00000000 vsnprintf.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 dtoa.c
21092bf8 l     F .text	00000200 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
210947b4 l     F .text	00000008 __fp_lock
210947bc l     F .text	00000008 __fp_unlock
210947d0 l     F .text	0000019c __sinit.part.1
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 locale.c
0000497c l     O .rwdata	00000020 lc_ctype_charset
0000495c l     O .rwdata	00000020 lc_message_charset
0000499c l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
00003bc4 l     O .rodata	0000000c p05.2710
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strchr.c
00000000 l    df *ABS*	00000000 vfprintf.c
00003ce8 l     O .rodata	00000010 zeroes.4184
00003cf8 l     O .rodata	00000010 blanks.4183
00000000 l    df *ABS*	00000000 vfprintf.c
21098618 l     F .text	000000fc __sprint_r.part.0
00003d18 l     O .rodata	00000010 blanks.4199
00003d08 l     O .rodata	00000010 zeroes.4200
21099a20 l     F .text	000000bc __sbprintf
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 alt_close.c
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
2109b1b4 l     F .text	00000008 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_exit.c
00000000 l    df *ABS*	00000000 alt_fstat.c
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_lseek.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_read.c
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
00005ddc l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_uncached_free.c
00000000 l    df *ABS*	00000000 alt_uncached_malloc.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00004d2c l     O .rwdata	00001060 jtag_uart_0
00004ce4 l     O .rwdata	00000048 mailbox_simple_0_1
00004c9c l     O .rwdata	00000048 mailbox_simple_1_0
00004c3c l     O .rwdata	00000060 read_dma_y
00004bdc l     O .rwdata	00000060 video_dma
00004b7c l     O .rwdata	00000060 write_dma
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
2109ba64 l     F .text	0000005c altera_avalon_jtag_uart_timeout
2109bac0 l     F .text	000000fc altera_avalon_jtag_uart_irq
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_mailbox_simple.c
2109bfdc l     F .text	00000054 altera_avalon_mailbox_simple_rx_isr
2109c030 l     F .text	0000009c altera_avalon_mailbox_simple_tx_isr
00000000 l    df *ABS*	00000000 altera_avalon_timer_vars.c
00000000 l    df *ABS*	00000000 altera_msgdma.c
2109c5e8 l     F .text	000000cc alt_msgdma_irq
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
00000000 l    df *ABS*	00000000 alt_open.c
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 __atexit.c
00005e44 g     O .bss	00000004 alt_instruction_exception_handler
2109d140 g     F .text	0000013c alt_msgdma_standard_descriptor_async_transfer
2108e400 g     F .text	00000018 putchar
210968b4 g     F .text	00000074 _mprec_log10
2109c380 g     F .text	0000014c altera_avalon_mailbox_send
210899e8 g     F .text	00000338 I2C_Read
210969a0 g     F .text	0000008c __any_on
2109a0e0 g     F .text	00000054 _isatty_r
00003bd0 g     O .rodata	00000028 __mprec_tinytens
2109b4f4 g     F .text	00000060 alt_main
2108e690 g     F .text	00000090 strcpy
2108e418 g     F .text	000000a8 _puts_r
21081c20 g     F .text	00000028 Fat_FileBrowseBegin
00006658 g     O .bss	00000100 alt_irq
2109a134 g     F .text	0000005c _lseek_r
2108194c g     F .text	00000230 ycbcr_to_rgb
210a2248 g       *ABS*	00000000 __flash_rwdata_start
2109af24 g     F .text	00000084 .hidden __eqdf2
2109c724 g     F .text	0000003c alt_msgdma_construct_standard_mm_to_mm_descriptor
00006758 g       *ABS*	00000000 __alt_heap_start
2108e3bc g     F .text	0000003c printf
2109a1ec g     F .text	0000009c _wcrtomb_r
000040b0 g     O .rwdata	00000080 Yquant
2109724c g     F .text	0000005c __sseek
21094b04 g     F .text	00000010 __sinit
21099adc g     F .text	00000138 __swbuf_r
210955b0 g     F .text	0000007c _setlocale_r
2109496c g     F .text	00000068 __sfmoreglue
2109b558 g     F .text	00000004 __malloc_unlock
21087e90 g     F .text	000000a4 ece423_hdmi_kick_up
21081c48 g     F .text	000005a0 Fat_FileBrowseNext
2108a394 g     F .text	00000450 .hidden __divsf3
00005e3c g     O .bss	00000004 altera_avalon_timer_ts_freq
2108320c g     F .text	000000d4 fatIsValidDir
00000f55 g     O .rodata	000029ea logo_compressed
21095930 g     F .text	0000015c memmove
21094aec g     F .text	00000018 _cleanup
21095a8c g     F .text	000000a8 _Balloc
2109c6b4 g     F .text	00000038 alt_msgdma_construct_standard_st_to_mm_descriptor
2108be80 g     F .text	000000e0 .hidden __gtdf2
2109e024 g     F .text	00000008 altera_nios2_gen2_irq_init
00000000  w      *UND*	00000000 __errno
21089dd4 g     F .text	000000e4 i2c_write
21080000 g     F .entry	0000001c __reset
21080020 g       *ABS*	00000000 __flash_exceptions_start
2109a088 g     F .text	00000058 _fstat_r
00005e14 g     O .bss	00000004 errno
210971c8 g     F .text	00000008 __seofread
210975e0 g     F .text	00001038 ___svfiprintf_internal_r
21082cf8 g     F .text	00000180 fatNextCluster
00005e2c g     O .bss	00000004 alt_argv
0000dd8c g       *ABS*	00000000 _gp
2109b850 g     F .text	00000004 usleep
2109c4cc g     F .text	0000011c altera_avalon_mailbox_retrieve_poll
21085780 g     F .text	000002f8 ece423_video_display_color_screen
2109b7f4 g     F .text	0000005c alt_uncached_malloc
00005df8 g     O .bss	00000001 is_pressed
2109ccb8 g     F .text	0000005c alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
000049d4 g     O .rwdata	00000180 alt_fd_list
2108e3f8 g     F .text	00000008 _putchar_r
2109da58 g     F .text	00000078 alt_find_dev
2108e134 g     F .text	00000138 memcpy
210947c4 g     F .text	0000000c _cleanup_r
2108cfdc g     F .text	000000d0 .hidden __floatsidf
2109dbe0 g     F .text	00000110 alt_io_redirect
2109afa8 g     F .text	000000e0 .hidden __ltdf2
2109e318 g       *ABS*	00000000 __DTOR_END__
2109cf6c g     F .text	00000088 alt_msgdma_start_prefetcher_with_extd_desc_list
2109d27c g     F .text	0000016c alt_msgdma_extended_descriptor_async_transfer
2109d130 g     F .text	00000010 alt_msgdma_register_callback
210824a8 g     F .text	000000bc Fat_FileExist
2108e4c0 g     F .text	00000014 puts
2109e17c g     F .text	00000074 alt_exception_cause_generated_bad_addr
2109c0cc g     F .text	00000088 altera_avalon_mailbox_simple_init
21097100 g     F .text	00000074 __fpclassifyd
21096810 g     F .text	000000a4 __ratio
00005da4 g     O .rwdata	00000004 logo_width
210999fc g     F .text	00000024 __vfiprintf_internal
2109bd00 g     F .text	0000013c altera_avalon_jtag_uart_read
2108d8e8 g     F .text	00000014 malloc
2109cb90 g     F .text	00000060 alt_msgdma_prefetcher_add_standard_desc_to_list
2108e390 g     F .text	0000002c _printf_r
21080920 g     F .text	00000628 lossless_decode
2108d578 g     F .text	00000008 .hidden __udivsi3
2109b310 g     F .text	00000090 isatty
00003c20 g     O .rodata	000000c8 __mprec_tens
2109c34c g     F .text	00000034 altera_avalon_mailbox_status
2109c2a0 g     F .text	000000ac altera_avalon_mailbox_close
2109562c g     F .text	0000000c __locale_charset
210928d0 g     F .text	00000040 vsnprintf
21085ee0 g     F .text	00000008 ece423_video_display_set_video_name
2108a320 g     F .text	00000074 .hidden __fixunsdfsi
2109e12c g     F .text	00000050 alt_icache_flush
00005e10 g     O .bss	00000004 __malloc_top_pad
00005db8 g     O .rwdata	00000004 __mb_cur_max
21088c1c g     F .text	00000098 itoa
2109565c g     F .text	0000000c _localeconv_r
21095e98 g     F .text	0000003c __i2b
21094f68 g     F .text	000004c0 __sfvwrite_r
2108e4d4 g     F .text	00000054 _sbrk_r
21088f48 g     F .text	00000004 heatshrink_decoder_free
2109a190 g     F .text	0000005c _read_r
2109b15c g     F .text	00000040 alt_dcache_flush
00005dc0 g     O .rwdata	00000004 alt_max_fd
2108818c g     F .text	00000470 ece423_init_hdmi
210835a0 g     F .text	000001e0 fatMount
21099da4 g     F .text	000000f0 _fclose_r
21086c8c g     F .text	000004fc ece423_video_display_add_text
21094784 g     F .text	00000030 fflush
00005e0c g     O .bss	00000004 __malloc_max_sbrked_mem
2109b254 g     F .text	000000bc alt_irq_register
2108d150 g     F .text	00000110 .hidden __extendsfdf2
2108ad18 g     F .text	0000089c .hidden __adddf3
210832e0 g     F .text	0000000c fatIsUnusedDir
210965b8 g     F .text	0000011c __b2d
2109c930 g     F .text	00000048 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
2109a994 g     F .text	00000590 .hidden __umoddi3
210885fc g     F .text	0000038c ece423_video_display_init
2109b46c g     F .text	00000088 lseek
21080264 g     F .text	00000068 print_dct
00005da8 g     O .rwdata	00000004 _global_impure_ptr
21096b98 g     F .text	00000568 _realloc_r
21088cb4 g     F .text	000001bc decompress
00006758 g       *ABS*	00000000 __bss_end
2109db78 g     F .text	00000068 alt_iic_isr_register
2109b6ec g     F .text	000000f8 alt_tick
2109d050 g     F .text	000000e0 alt_msgdma_init
2109a3d4 g     F .text	000005c0 .hidden __udivdi3
21099ea8 g     F .text	00000184 _fputwc_r
00003bf8 g     O .rodata	00000028 __mprec_bigtens
21095c7c g     F .text	00000104 __s2b
2108d0ac g     F .text	000000a4 .hidden __floatunsidf
21082c18 g     F .text	00000010 SD_ReadBlocks
21096360 g     F .text	00000060 __mcmp
2109d5f0 g     F .text	00000234 alt_msgdma_extended_descriptor_sync_transfer
21082c0c g     F .text	0000000c SD_ReadBlock512
21094b24 g     F .text	00000018 __fp_lock_all
2109db60 g     F .text	00000018 alt_ic_irq_enabled
21089794 g     F .text	00000254 I2C_Write
21082564 g     F .text	00000158 Fat_FileOpen
000061f0 g     O .bss	0000001c state
2109b6b8 g     F .text	00000034 alt_alarm_stop
21088fac g     F .text	00000098 heatshrink_decoder_sink
21081068 g     F .text	00000070 input_AC
00005e24 g     O .bss	00000004 alt_irq_active
21083000 g     F .text	000001f8 fatDelClusterList
210810dc g     F .text	00000870 mjpeg423_decode
210800fc g     F .exceptions	00000068 alt_irq_handler
00004b54 g     O .rwdata	00000028 alt_dev_null
2109c7d8 g     F .text	00000078 alt_msgdma_construct_extended_mm_to_st_descriptor
21089d20 g     F .text	0000006c i2c_start
2109ce24 g     F .text	00000148 alt_msgdma_start_prefetcher_with_std_desc_list
2108e7b8 g     F .text	00000068 strrchr
2109b19c g     F .text	00000018 alt_dcache_flush_all
21095d80 g     F .text	00000068 __hi0bits
210856f8 g     F .text	00000024 ece423_video_display_is_empty
2108cf54 g     F .text	00000088 .hidden __fixdfsi
210851c0 g     F .text	00000008 flush_dcache_range
21085a78 g     F .text	000001a4 ece423_video_display_colored_screen
21088e70 g     F .text	000000d8 heatshrink_decoder_alloc
00005df8 g       *ABS*	00000000 __ram_rwdata_end
00005dc4 g     O .rwdata	00000008 alt_dev_list
21081b7c g     F .text	0000006c Fat_Mount
2109b854 g     F .text	000000e8 write
21096a2c g     F .text	000000a0 _putc_r
00003f30 g       *ABS*	00000000 __ram_rodata_end
2109b1d0 g     F .text	00000084 fstat
2108d5e8 g     F .text	00000024 fprintf
2109afa8 g     F .text	000000e0 .hidden __ledf2
210839b8 g     F .text	0000004c myprintf
210960d0 g     F .text	00000140 __pow5mult
2109872c g     F .text	000012d0 ___vfiprintf_internal_r
00005e20 g     O .bss	00000004 __nlocale_changed
2108d580 g     F .text	00000008 .hidden __umodsi3
21085c1c g     F .text	000002c4 ece423_video_display_add_frame_number
2109c978 g     F .text	00000048 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
00006758 g       *ABS*	00000000 end
210846a4 g     F .text	00000468 mmc_init
2109bbbc g     F .text	00000080 altera_avalon_jtag_uart_init
21080164 g     F .exceptions	0000002c alt_instruction_exception_entry
2109e318 g       *ABS*	00000000 __CTOR_LIST__
10000000 g       *ABS*	00000000 __alt_stack_pointer
2108d3f8 g     F .text	00000064 .hidden __clzsi2
2109be3c g     F .text	000001a0 altera_avalon_jtag_uart_write
21082aa8 g     F .text	00000004 Fat_FileClose
21094b14 g     F .text	00000004 __sfp_lock_acquire
210821e8 g     F .text	0000005c Fat_FileCount
21095848 g     F .text	000000e8 memchr
210907b0 g     F .text	00001f50 ___vfprintf_internal_r
2108e528 g     F .text	00000058 _sprintf_r
21094c78 g     F .text	000002f0 _free_r
2109de94 g     F .text	0000017c alt_printf
00005d90 g     O .rwdata	00000004 font_len_out
21095638 g     F .text	00000010 __locale_mb_cur_max
21092a64 g     F .text	00000194 __call_exitprocs
00005e1c g     O .bss	00000004 __mlocale_changed
00005db0 g     O .rwdata	00000004 __malloc_sbrk_base
21080190 g     F .text	0000004c _start
00005d8c g     O .rwdata	00000004 font_height
00005e38 g     O .bss	00000004 _alt_tick_rate
210801fc g     F .text	00000068 print_block
210802cc g     F .text	00000080 print_bitstream
21096210 g     F .text	00000150 __lshift
00005e34 g     O .bss	00000004 _alt_nticks
2109c6ec g     F .text	00000038 alt_msgdma_construct_standard_mm_to_st_descriptor
2109b55c g     F .text	000000ec read
2109b95c g     F .text	000000cc alt_sys_init
21097414 g     F .text	000001cc __ssprint_r
210855f4 g     F .text	0000004c ece423_video_display_register_written_buffer
2109e204 g     F .text	00000114 __register_exitproc
210826bc g     F .text	00000018 Fat_FileSize
21087c98 g     F .text	00000048 reg_read
21095ed4 g     F .text	000001fc __multiply
2109bc3c g     F .text	00000050 altera_avalon_jtag_uart_close
00003f30 g       *ABS*	00000000 __ram_rwdata_start
00000000 g       *ABS*	00000000 __ram_rodata_start
21084668 g     F .text	0000003c udelay
000061c8 g     O .bss	00000028 __malloc_current_mallinfo
210966d4 g     F .text	0000013c __d2b
21088988 g     F .text	00000294 rgb2ycbcr
21080000 g       *ABS*	00000000 __alt_mem_sram_memory
2109ba28 g     F .text	00000010 altera_avalon_jtag_uart_read_fd
2109e0dc g     F .text	00000050 alt_get_fd
2109d8b8 g     F .text	00000060 alt_busy_sleep
210851c8 g     F .text	000000f0 ocsdc_mmc_init
21099c8c g     F .text	00000054 _close_r
2108333c g     F .text	00000068 fatReadFATSecter
2109c8e4 g     F .text	0000004c alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
210826d4 g     F .text	00000354 Fat_FileRead
2108e0b8 g     F .text	0000007c memcmp
2109ba48 g     F .text	00000010 altera_avalon_jtag_uart_close_fd
00006758 g       *ABS*	00000000 __alt_stack_base
2109ba58 g     F .text	0000000c altera_avalon_jtag_uart_ioctl_fd
2108034c g     F .text	000005d4 idct
2108d60c g     F .text	000000cc _fwrite_r
210834c0 g     F .text	000000e0 fatFindUnusedDirectory
2109c9c0 g     F .text	00000090 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
21092910 g     F .text	00000154 __swsetup_r
2108b5b4 g     F .text	000008cc .hidden __divdf3
210949d4 g     F .text	00000118 __sfp
21096928 g     F .text	00000078 __copybits
00004554 g     O .rwdata	00000408 __malloc_av_
21094b20 g     F .text	00000004 __sinit_lock_release
2108571c g     F .text	00000064 ece423_video_display_clear_screen
210927e0 g     F .text	000000f0 _vsnprintf_r
21089d8c g     F .text	00000048 i2c_stop
21087df0 g     F .text	000000a0 ece423_hdmi_powerdown
2108bf60 g     F .text	00000724 .hidden __muldf3
21097174 g     F .text	00000054 __sread
21082aac g     F .text	00000160 Fat_SpeedTest
2109e02c g     F .text	000000b0 alt_find_file
2109d918 g     F .text	00000078 alt_dev_llist_insert
2109b554 g     F .text	00000004 __malloc_lock
2108d5c0 g     F .text	00000028 _fprintf_r
2109b66c g     F .text	0000004c sbrk
2108e820 g     F .text	00001f90 ___svfprintf_internal_r
21094728 g     F .text	0000005c _fflush_r
21099ce0 g     F .text	000000c4 _calloc_r
21087188 g     F .text	0000051c ece423_video_display_text_frame
21082444 g     F .text	0000005c Fat_CheckExtension
21083430 g     F .text	00000090 fatFindDirectory
21081000 g     F .text	00000068 input_DC
00005df8 g       *ABS*	00000000 __bss_start
2108e26c g     F .text	00000124 memset
2109cff4 g     F .text	0000005c alt_msgdma_open
2108a0e4 g     F .text	0000023c main
210833a4 g     F .text	00000068 fatReadSecter
00005e28 g     O .bss	00000004 alt_envp
00005e08 g     O .bss	00000004 __malloc_max_total_mem
2109cbf0 g     F .text	00000084 alt_msgdma_prefetcher_add_extended_desc_to_list
21083a04 g     F .text	00000064 myprintf_hexarray
2109ba38 g     F .text	00000010 altera_avalon_jtag_uart_write_fd
21089eb8 g     F .text	00000108 i2c_read
21099c14 g     F .text	0000001c __swbuf
210972a8 g     F .text	00000008 __sclose
210832ec g     F .text	00000028 fatDump
10000000 g       *ABS*	00000000 __alt_heap_limit
21099e94 g     F .text	00000014 fclose
2108d260 g     F .text	00000198 .hidden __truncdfsf2
21092df8 g     F .text	00001728 _dtoa_r
2109cd14 g     F .text	00000110 alt_msgdma_start_prefetcher_with_list_addr
2108d910 g     F .text	000007a8 _malloc_r
2109a348 g     F .text	00000030 __ascii_wctomb
00005dd4 g     O .rwdata	00000004 alt_errno
2109cae0 g     F .text	000000b0 alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
21087d2c g     F .text	000000c4 reg_update_bits
21095428 g     F .text	000000c4 _fwalk
210831f8 g     F .text	00000004 fatDumpDate
21096acc g     F .text	000000cc putc
21082a28 g     F .text	00000080 Fat_FileSeek
2108d4c8 g     F .text	00000054 .hidden __divsi3
21094b54 g     F .text	00000124 _malloc_trim_r
2109e318 g       *ABS*	00000000 __CTOR_END__
21087f34 g     F .text	00000258 ece423_hdmi_powerup
2108a7e4 g     F .text	00000424 .hidden __mulsf3
2108e5ec g     F .text	000000a4 strcmp
2109e318 g       *ABS*	00000000 __flash_rodata_start
2109e318 g       *ABS*	00000000 __DTOR_LIST__
21083314 g     F .text	00000028 fatArray2Value
21084cb8 g     F .text	0000012c print_mmcinfo
21089760 g     F .text	00000034 heatshrink_decoder_finish
2109af24 g     F .text	00000084 .hidden __nedf2
21082c88 g     F .text	00000070 fat32ClusterType
2109b93c g     F .text	00000020 alt_irq_init
2109b648 g     F .text	00000024 alt_release_fd
2109d3e8 g     F .text	00000208 alt_msgdma_standard_descriptor_sync_transfer
2108d718 g     F .text	0000001c memalign
2108e580 g     F .text	0000006c sprintf
00003a24 g     O .rodata	00000100 .hidden __clz_tab
210839b4 g     F .text	00000004 debug_output
00005e18 g     O .bss	00000004 _PathLocale
00005e00 g     O .bss	00000004 font_glyph_bitmap
2109e1f0 g     F .text	00000014 atexit
21099c30 g     F .text	0000005c _write_r
21082274 g     F .text	000001d0 fatComposeShortFilename
00005d98 g     O .rwdata	00000004 logo_len_out
21095668 g     F .text	0000001c setlocale
2109ca50 g     F .text	00000090 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
210860d8 g     F .text	00000bb4 ece423_video_display_demo
00005dac g     O .rwdata	00000004 _impure_ptr
00005e30 g     O .bss	00000004 alt_argc
21094520 g     F .text	00000208 __sflush_r
00005e40 g     O .bss	00000004 altera_avalon_timer_ts_base
2109d9f4 g     F .text	00000064 _do_dtors
21095654 g     F .text	00000008 __locale_cjk_lang
21081bf4 g     F .text	0000002c Fat_Type
21083a68 g     F .text	00000068 myprintf_dwordarray
21084b0c g     F .text	000001ac mmc_bread
00003f30 g     O .rwdata	00000100 zigzag_table
21080020 g       .exceptions	00000000 alt_irq_entry
210801dc g     F .text	00000020 error_and_exit
21096558 g     F .text	00000060 __ulp
21094b3c g     F .text	00000018 __fp_unlock_all
21082c28 g     F .text	00000060 fat16ClusterType
00000000 g       *ABS*	00000000 __alt_mem_lpddr2
00000640 g     O .rodata	00000300 font_glyph_dsc
00005dcc g     O .rwdata	00000008 alt_fs_list
210855d4 g     F .text	00000020 ece423_video_display_get_buffer
21087b30 g     F .text	00000010 ece423_video_display_get_descriptor_span
2108340c g     F .text	00000024 fatReadMultiSecter
21080020 g       *ABS*	00000000 __ram_exceptions_start
21095684 g     F .text	0000000c localeconv
21082244 g     F .text	00000030 fatSameLongFilename
2109dadc g     F .text	00000004 alt_ic_isr_register
2108d6d8 g     F .text	00000040 fwrite
00005df8 g       *ABS*	00000000 _edata
210831fc g     F .text	00000004 fatDumpTime
21080f48 g     F .text	000000b8 update_buffer
00006758 g       *ABS*	00000000 _end
21080190 g       *ABS*	00000000 __ram_exceptions_end
2109bc8c g     F .text	00000074 altera_avalon_jtag_uart_ioctl
21085598 g     F .text	0000003c ece423_video_display_buffer_is_available
2109db20 g     F .text	00000040 alt_ic_irq_disable
00005de8 g     O .rwdata	00000008 alt_mailbox_simple_list
210971d0 g     F .text	0000007c __swrite
00005db4 g     O .rwdata	00000004 __malloc_trim_threshold
21095648 g     F .text	0000000c __locale_msgcharset
2108d588 g     F .text	00000038 exit
21083780 g     F .text	00000234 fatMountSdcard
210954ec g     F .text	000000c4 _fwalk_reent
2109cc74 g     F .text	00000044 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
2108ac08 g     F .text	00000110 .hidden __floatunsisf
210963c0 g     F .text	00000198 __mdiff
21087ce0 g     F .text	0000004c reg_write
2108d51c g     F .text	0000005c .hidden __modsi3
2108d734 g     F .text	000001b4 _memalign_r
10000000 g       *ABS*	00000000 __alt_data_end
21080020 g     F .exceptions	00000000 alt_exception
21094b18 g     F .text	00000004 __sfp_lock_release
2109c850 g     F .text	00000094 alt_msgdma_construct_extended_mm_to_mm_descriptor
21085358 g     F .text	00000034 SDLIB_ReadBlocks
210852b8 g     F .text	00000070 SDLIB_Init
2109c760 g     F .text	00000078 alt_msgdma_construct_extended_st_to_mm_descriptor
2109c154 g     F .text	0000014c altera_avalon_mailbox_open
2109b1bc g     F .text	00000014 _exit
2109d824 g     F .text	00000094 alt_alarm_start
21095690 g     F .text	000001b8 __smakebuf_r
00005df0 g     O .rwdata	00000008 alt_msgdma_list
2108e720 g     F .text	00000098 strlen
21085640 g     F .text	00000098 ece423_video_display_switch_frames
21087b40 g     F .text	00000158 ece423_video_display_allocate_buffers
2109dcf0 g     F .text	000001a4 open
210856d8 g     F .text	00000020 ece423_video_display_discard_buffered_frames
2108be80 g     F .text	000000e0 .hidden __gedf2
2109b7e4 g     F .text	00000010 alt_uncached_free
2109e010 g     F .text	00000014 alt_putchar
00000940 g     O .rodata	000005e6 font_compressed
00005dbc g     O .rwdata	00000004 __wctomb
210824a0 g     F .text	00000008 Fat_GetFileName
21098714 g     F .text	00000018 __sprint_r
2109dad0 g     F .text	0000000c alt_icache_flush_all
210972b0 g     F .text	00000164 strchr
00005d94 g     O .rwdata	00000004 font_len
00005dd8 g     O .rwdata	00000004 alt_priority_mask
00004030 g     O .rwdata	00000080 Cquant
210876a4 g     F .text	0000048c ece423_video_display_text_on_last_frame
00005d9c g     O .rwdata	00000004 logo_len
2109dae0 g     F .text	00000040 alt_ic_irq_enable
21092700 g     F .text	00000024 __vfprintf_internal
21082e78 g     F .text	00000188 fatFindUnusedCluster
2109a378 g     F .text	0000005c _wctomb_r
2108c684 g     F .text	000008d0 .hidden __subdf3
00005dfc g     O .bss	00000004 sd_drv
21095de8 g     F .text	000000b0 __lo0bits
21089044 g     F .text	0000071c heatshrink_decoder_poll
00005de0 g     O .rwdata	00000008 alt_alarm_list
2109d990 g     F .text	00000064 _do_ctors
21085ee8 g     F .text	000001f0 ece423_video_display_draw_logo
2109a288 g     F .text	000000c0 wcrtomb
2109b088 g     F .text	000000d4 close
21081be8 g     F .text	0000000c Fat_Unmount
21088f4c g     F .text	00000060 heatshrink_decoder_reset
00005e04 g     O .bss	00000004 logo
2109b3a0 g     F .text	000000cc alt_load
0000620c g     O .bss	0000044c vInfo
2109a02c g     F .text	0000005c fputwc
2108d8fc g     F .text	00000014 free
21094b1c g     F .text	00000004 __sinit_lock_acquire
21095b5c g     F .text	00000120 __multadd
21083200 g     F .text	0000000c fatIsLastDir
21095b34 g     F .text	00000028 _Bfree
00005da0 g     O .rwdata	00000004 logo_height
21085328 g     F .text	00000030 SDLIB_ReadBlock512



Disassembly of section .entry:

21080000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
21080000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
21080004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
21080008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
2108000c:	00bffd16 	blt	zero,r2,21080004 <__flash_rwdata_start+0xfffdddbc>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
21080010:	00484234 	movhi	at,8456
    ori r1, r1, %lo(_start)
21080014:	08406414 	ori	at,at,400
    jmp r1
21080018:	0800683a 	jmp	at
2108001c:	00000000 	call	20000000 <__alt_data_end+0x10000000>

Disassembly of section .exceptions:

21080020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
21080020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
21080024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
21080028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
2108002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
21080030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
21080034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
21080038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
2108003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
21080040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
21080044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
21080048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
2108004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
21080050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
21080054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
21080058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
2108005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
21080060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
21080064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
21080068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
2108006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
21080070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
21080074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
21080078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
2108007c:	10000326 	beq	r2,zero,2108008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
21080080:	20000226 	beq	r4,zero,2108008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
21080084:	10800fc0 	call	210800fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
21080088:	00000706 	br	210800a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
2108008c:	df401215 	stw	ea,72(sp)
        ldhu.n  r2, 0(r4)
        ldhu.n  r3, 2(r4)
        slli.n  r3, r3, 16
        or.n    r2, r2, r3 /* Instruction that caused exception */
#else
        ldw   r2, -4(ea)   /* Instruction that caused exception */
21080090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
21080094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
21080098:	10801640 	call	21080164 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
2108009c:	1000021e 	bne	r2,zero,210800a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
210800a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
210800a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
210800a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
210800ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
210800b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
210800b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
210800b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
210800bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
210800c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
210800c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
210800c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
210800cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
210800d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
210800d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
210800d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
210800dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
210800e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
210800e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
210800e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
210800ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
210800f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
210800f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
210800f8:	ef80083a 	eret

210800fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
210800fc:	defffe04 	addi	sp,sp,-8
21080100:	dfc00115 	stw	ra,4(sp)
21080104:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
21080108:	000b313a 	rdctl	r5,ipending
2108010c:	04000034 	movhi	r16,0
21080110:	84199604 	addi	r16,r16,26200
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
21080114:	2880004c 	andi	r2,r5,1

  active = alt_irq_pending ();

  do
  {
    i = 0;
21080118:	0007883a 	mov	r3,zero
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
2108011c:	1000051e 	bne	r2,zero,21080134 <alt_irq_handler+0x38>
21080120:	00800044 	movi	r2,1
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
21080124:	1085883a 	add	r2,r2,r2
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
21080128:	2888703a 	and	r4,r5,r2
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
      i++;
2108012c:	18c00044 	addi	r3,r3,1
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
21080130:	203ffc26 	beq	r4,zero,21080124 <__flash_rwdata_start+0xfffddedc>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
21080134:	180690fa 	slli	r3,r3,3
21080138:	80c5883a 	add	r2,r16,r3
2108013c:	1007883a 	mov	r3,r2
21080140:	19000117 	ldw	r4,4(r3)
21080144:	10800017 	ldw	r2,0(r2)
21080148:	103ee83a 	callr	r2
2108014c:	000b313a 	rdctl	r5,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
21080150:	283ff01e 	bne	r5,zero,21080114 <__flash_rwdata_start+0xfffddecc>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
21080154:	dfc00117 	ldw	ra,4(sp)
21080158:	dc000017 	ldw	r16,0(sp)
2108015c:	dec00204 	addi	sp,sp,8
21080160:	f800283a 	ret

21080164 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
21080164:	200b883a 	mov	r5,r4
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
21080168:	000531fa 	rdctl	r2,exception
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
2108016c:	000d333a 	rdctl	r6,badaddr
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
21080170:	d0e02e17 	ldw	r3,-32584(gp)
21080174:	18000326 	beq	r3,zero,21080184 <alt_instruction_exception_entry+0x20>
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
21080178:	11001f0c 	andi	r4,r2,124
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
2108017c:	2008d0ba 	srli	r4,r4,2
21080180:	1800683a 	jmp	r3
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
21080184:	003da03a 	break	0
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
}
21080188:	0005883a 	mov	r2,zero
2108018c:	f800283a 	ret

Disassembly of section .text:

21080190 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
21080190:	00900014 	movui	r2,16384
#endif

0:
    initd 0(r2)
21080194:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
21080198:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
2108019c:	00bffd16 	blt	zero,r2,21080194 <__flash_rwdata_start+0xfffddf4c>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
210801a0:	06c40034 	movhi	sp,4096
    ori sp, sp, %lo(__alt_stack_pointer)
210801a4:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
210801a8:	06800034 	movhi	gp,0
    ori gp, gp, %lo(_gp)
210801ac:	d6b76314 	ori	gp,gp,56716
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
210801b0:	00800034 	movhi	r2,0
    ori r2, r2, %lo(__bss_start)
210801b4:	10977e14 	ori	r2,r2,24056

    movhi r3, %hi(__bss_end)
210801b8:	00c00034 	movhi	r3,0
    ori r3, r3, %lo(__bss_end)
210801bc:	18d9d614 	ori	r3,r3,26456

    beq r2, r3, 1f
210801c0:	10c00326 	beq	r2,r3,210801d0 <_start+0x40>

0:
    stw zero, (r2)
210801c4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
210801c8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
210801cc:	10fffd36 	bltu	r2,r3,210801c4 <__flash_rwdata_start+0xfffddf7c>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
210801d0:	109b3a00 	call	2109b3a0 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
210801d4:	109b4f40 	call	2109b4f4 <alt_main>

210801d8 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
210801d8:	003fff06 	br	210801d8 <__flash_rwdata_start+0xfffddf90>

210801dc <error_and_exit>:

#include <stdio.h>
#include <stdlib.h>
#include "util.h"

void error_and_exit(const char* str){
210801dc:	200b883a 	mov	r5,r4
    printf("Error: %s\n", str);
210801e0:	01000034 	movhi	r4,0

#include <stdio.h>
#include <stdlib.h>
#include "util.h"

void error_and_exit(const char* str){
210801e4:	deffff04 	addi	sp,sp,-4
    printf("Error: %s\n", str);
210801e8:	21000004 	addi	r4,r4,0

#include <stdio.h>
#include <stdlib.h>
#include "util.h"

void error_and_exit(const char* str){
210801ec:	dfc00015 	stw	ra,0(sp)
    printf("Error: %s\n", str);
210801f0:	108e3bc0 	call	2108e3bc <printf>
    exit(-1);
210801f4:	013fffc4 	movi	r4,-1
210801f8:	108d5880 	call	2108d588 <exit>

210801fc <print_block>:
}

void print_block(pcolor_block_t b)
{
210801fc:	defffc04 	addi	sp,sp,-16
21080200:	dc800215 	stw	r18,8(sp)
21080204:	dc400115 	stw	r17,4(sp)
21080208:	dfc00315 	stw	ra,12(sp)
2108020c:	dc000015 	stw	r16,0(sp)
21080210:	244001c4 	addi	r17,r4,7
21080214:	248011c4 	addi	r18,r4,71
21080218:	8c3ffe44 	addi	r16,r17,-7
    for (int row = 0; row < 8; row++)
        for(int column = 0; column < 8; column++){
            if(column != 7) printf("%d,", b[row][column]);
2108021c:	81400003 	ldbu	r5,0(r16)
21080220:	01000034 	movhi	r4,0
21080224:	84000044 	addi	r16,r16,1
21080228:	21000304 	addi	r4,r4,12
2108022c:	108e3bc0 	call	2108e3bc <printf>
21080230:	8c3ffa1e 	bne	r17,r16,2108021c <__flash_rwdata_start+0xfffddfd4>
            else printf("%u\n", b[row][column]);
21080234:	89400003 	ldbu	r5,0(r17)
21080238:	01000034 	movhi	r4,0
2108023c:	8c400204 	addi	r17,r17,8
21080240:	21000404 	addi	r4,r4,16
21080244:	108e3bc0 	call	2108e3bc <printf>
    exit(-1);
}

void print_block(pcolor_block_t b)
{
    for (int row = 0; row < 8; row++)
21080248:	8cbff31e 	bne	r17,r18,21080218 <__flash_rwdata_start+0xfffddfd0>
        for(int column = 0; column < 8; column++){
            if(column != 7) printf("%d,", b[row][column]);
            else printf("%u\n", b[row][column]);
        } 
}
2108024c:	dfc00317 	ldw	ra,12(sp)
21080250:	dc800217 	ldw	r18,8(sp)
21080254:	dc400117 	ldw	r17,4(sp)
21080258:	dc000017 	ldw	r16,0(sp)
2108025c:	dec00404 	addi	sp,sp,16
21080260:	f800283a 	ret

21080264 <print_dct>:

void print_dct(pdct_block_t b)
{
21080264:	defffc04 	addi	sp,sp,-16
21080268:	dc800215 	stw	r18,8(sp)
2108026c:	dc400115 	stw	r17,4(sp)
21080270:	dfc00315 	stw	ra,12(sp)
21080274:	dc000015 	stw	r16,0(sp)
21080278:	24400384 	addi	r17,r4,14
2108027c:	24802384 	addi	r18,r4,142
21080280:	8c3ffc84 	addi	r16,r17,-14
    for (int row = 0; row < 8; row++)
        for(int column = 0; column < 8; column++){
            if(column != 7) printf("%d,", b[row][column]);
21080284:	8140000f 	ldh	r5,0(r16)
21080288:	01000034 	movhi	r4,0
2108028c:	84000084 	addi	r16,r16,2
21080290:	21000304 	addi	r4,r4,12
21080294:	108e3bc0 	call	2108e3bc <printf>
21080298:	8c3ffa1e 	bne	r17,r16,21080284 <__flash_rwdata_start+0xfffde03c>
            else printf("%d\n", b[row][column]);
2108029c:	8940000f 	ldh	r5,0(r17)
210802a0:	01000034 	movhi	r4,0
210802a4:	8c400404 	addi	r17,r17,16
210802a8:	21000504 	addi	r4,r4,20
210802ac:	108e3bc0 	call	2108e3bc <printf>
        } 
}

void print_dct(pdct_block_t b)
{
    for (int row = 0; row < 8; row++)
210802b0:	8cbff31e 	bne	r17,r18,21080280 <__flash_rwdata_start+0xfffde038>
        for(int column = 0; column < 8; column++){
            if(column != 7) printf("%d,", b[row][column]);
            else printf("%d\n", b[row][column]);
        } 
}
210802b4:	dfc00317 	ldw	ra,12(sp)
210802b8:	dc800217 	ldw	r18,8(sp)
210802bc:	dc400117 	ldw	r17,4(sp)
210802c0:	dc000017 	ldw	r16,0(sp)
210802c4:	dec00404 	addi	sp,sp,16
210802c8:	f800283a 	ret

210802cc <print_bitstream>:

void print_bitstream(int num_bytes, void* bitstream)
{
    for (int index = 0; index < num_bytes; index++)
210802cc:	01001d0e 	bge	zero,r4,21080344 <print_bitstream+0x78>
            else printf("%d\n", b[row][column]);
        } 
}

void print_bitstream(int num_bytes, void* bitstream)
{
210802d0:	defffb04 	addi	sp,sp,-20
210802d4:	dcc00315 	stw	r19,12(sp)
210802d8:	dc800215 	stw	r18,8(sp)
210802dc:	dc400115 	stw	r17,4(sp)
210802e0:	dfc00415 	stw	ra,16(sp)
210802e4:	dc000015 	stw	r16,0(sp)
210802e8:	2823883a 	mov	r17,r5
210802ec:	2927883a 	add	r19,r5,r4
    for (int index = 0; index < num_bytes; index++)
        for(int x = 0; x < 8 ; x++)
210802f0:	04800204 	movi	r18,8
            else printf("%d\n", b[row][column]);
        } 
}

void print_bitstream(int num_bytes, void* bitstream)
{
210802f4:	0021883a 	mov	r16,zero
    for (int index = 0; index < num_bytes; index++)
        for(int x = 0; x < 8 ; x++)
            printf("%u", (uint8_t)((((uint8_t*)bitstream)[index]) << x) >> 7);
210802f8:	89400003 	ldbu	r5,0(r17)
210802fc:	01000034 	movhi	r4,0
21080300:	21000604 	addi	r4,r4,24
21080304:	2c0a983a 	sll	r5,r5,r16
}

void print_bitstream(int num_bytes, void* bitstream)
{
    for (int index = 0; index < num_bytes; index++)
        for(int x = 0; x < 8 ; x++)
21080308:	84000044 	addi	r16,r16,1
            printf("%u", (uint8_t)((((uint8_t*)bitstream)[index]) << x) >> 7);
2108030c:	29403fcc 	andi	r5,r5,255
21080310:	280ad1fa 	srli	r5,r5,7
21080314:	108e3bc0 	call	2108e3bc <printf>
}

void print_bitstream(int num_bytes, void* bitstream)
{
    for (int index = 0; index < num_bytes; index++)
        for(int x = 0; x < 8 ; x++)
21080318:	84bff71e 	bne	r16,r18,210802f8 <__flash_rwdata_start+0xfffde0b0>
2108031c:	8c400044 	addi	r17,r17,1
        } 
}

void print_bitstream(int num_bytes, void* bitstream)
{
    for (int index = 0; index < num_bytes; index++)
21080320:	8cfff41e 	bne	r17,r19,210802f4 <__flash_rwdata_start+0xfffde0ac>
        for(int x = 0; x < 8 ; x++)
            printf("%u", (uint8_t)((((uint8_t*)bitstream)[index]) << x) >> 7);
    printf("\n");
21080324:	01000284 	movi	r4,10
}
21080328:	dfc00417 	ldw	ra,16(sp)
2108032c:	dcc00317 	ldw	r19,12(sp)
21080330:	dc800217 	ldw	r18,8(sp)
21080334:	dc400117 	ldw	r17,4(sp)
21080338:	dc000017 	ldw	r16,0(sp)
2108033c:	dec00504 	addi	sp,sp,20
void print_bitstream(int num_bytes, void* bitstream)
{
    for (int index = 0; index < num_bytes; index++)
        for(int x = 0; x < 8 ; x++)
            printf("%u", (uint8_t)((((uint8_t*)bitstream)[index]) << x) >> 7);
    printf("\n");
21080340:	108e4001 	jmpi	2108e400 <putchar>
21080344:	01000284 	movi	r4,10
21080348:	108e4001 	jmpi	2108e400 <putchar>

2108034c <idct>:
/* normalize the result between 0 and 255 */
/* this is required to handle precision errors that might cause the decoded result to fall out of range */
#define NORMALIZE(x) (temp = (x), ( (temp < 0) ? 0 : ( (temp > 255) ? 255 : temp  ) ) )

void idct(pdct_block_t DCAC, pcolor_block_t block)
{
2108034c:	deffa904 	addi	sp,sp,-348
21080350:	20800404 	addi	r2,r4,16
21080354:	d8c03804 	addi	r3,sp,224
21080358:	dc804f15 	stw	r18,316(sp)
2108035c:	d8804815 	stw	r2,288(sp)
21080360:	1025883a 	mov	r18,r2
21080364:	d8c04715 	stw	r3,284(sp)
21080368:	d9c00804 	addi	r7,sp,32
2108036c:	da003004 	addi	r8,sp,192
21080370:	dac01004 	addi	r11,sp,64
21080374:	dbc02804 	addi	r15,sp,160
21080378:	d8801804 	addi	r2,sp,96
2108037c:	d8c02004 	addi	r3,sp,128
21080380:	df005515 	stw	fp,340(sp)
21080384:	ddc05415 	stw	r23,336(sp)
21080388:	dd805315 	stw	r22,332(sp)
2108038c:	dd405215 	stw	r21,328(sp)
21080390:	dd005115 	stw	r20,324(sp)
21080394:	dcc05015 	stw	r19,320(sp)
21080398:	dfc05615 	stw	ra,344(sp)
2108039c:	dc404e15 	stw	r17,312(sp)
210803a0:	dc004d15 	stw	r16,308(sp)
210803a4:	d9404915 	stw	r5,292(sp)
210803a8:	27000804 	addi	fp,r4,32
210803ac:	25c01804 	addi	r23,r4,96
210803b0:	25801004 	addi	r22,r4,64
210803b4:	25401c04 	addi	r21,r4,112
210803b8:	25001404 	addi	r20,r4,80
210803bc:	24c00c04 	addi	r19,r4,48
210803c0:	d9c04615 	stw	r7,280(sp)
210803c4:	da004515 	stw	r8,276(sp)
210803c8:	dac04415 	stw	r11,272(sp)
210803cc:	dbc04315 	stw	r15,268(sp)
210803d0:	d8804215 	stw	r2,264(sp)
210803d4:	d8c04115 	stw	r3,260(sp)
    /* Pass 1: process columns from input, store into work array. */
    /* Note results are scaled up by sqrt(8) compared to a true IDCT; */
    /* furthermore, we scale the results by 2**PASS1_BITS. */
    
    inptr = DCAC[0];
    wsptr = workspace;
210803d8:	dec04015 	stw	sp,256(sp)
        /* Odd part per figure 8; the matrix is unitary and hence its
         * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
         */
        
        tmp0 = inptr[DCTSIZE*7];
        tmp1 =inptr[DCTSIZE*5];
210803dc:	a300000f 	ldh	r12,0(r20)
        
        /* Odd part per figure 8; the matrix is unitary and hence its
         * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
         */
        
        tmp0 = inptr[DCTSIZE*7];
210803e0:	aac0000f 	ldh	r11,0(r21)
        tmp1 =inptr[DCTSIZE*5];
        tmp2 = inptr[DCTSIZE*3];
210803e4:	9b80000f 	ldh	r14,0(r19)
        tmp3 = inptr[DCTSIZE*1];
210803e8:	90c0000f 	ldh	r3,0(r18)
    for (ctr = DCTSIZE; ctr > 0; ctr--) {
        
        /* Even part: reverse the even part of the forward DCT. */
        /* The rotator is sqrt(2)*c(-6). */
        
        z2 = inptr[DCTSIZE*2];
210803ec:	e240000f 	ldh	r9,0(fp)
        z3 = inptr[DCTSIZE*6];
210803f0:	ba80000f 	ldh	r10,0(r23)
        tmp2 = inptr[DCTSIZE*3];
        tmp3 = inptr[DCTSIZE*1];
        
        z1 = tmp0 + tmp3;
        z2 = tmp1 + tmp2;
        z3 = tmp0 + tmp2;
210803f4:	5b8d883a 	add	r6,r11,r14
        z4 = tmp1 + tmp3;
210803f8:	60c5883a 	add	r2,r12,r3
        
        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
        tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
        tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
        
        z2 = inptr[DCTSIZE*0];
210803fc:	2440000f 	ldh	r17,0(r4)
        z3 = inptr[DCTSIZE*4];
21080400:	b200000f 	ldh	r8,0(r22)
        
        z1 = tmp0 + tmp3;
        z2 = tmp1 + tmp2;
        z3 = tmp0 + tmp2;
        z4 = tmp1 + tmp3;
        z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
21080404:	309b883a 	add	r13,r6,r2
21080408:	6b496864 	muli	r13,r13,9633
        tmp0 = inptr[DCTSIZE*7];
        tmp1 =inptr[DCTSIZE*5];
        tmp2 = inptr[DCTSIZE*3];
        tmp3 = inptr[DCTSIZE*1];
        
        z1 = tmp0 + tmp3;
2108040c:	58df883a 	add	r15,r11,r3
        tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
        tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
        z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
        z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
        z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
        z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
21080410:	10bce124 	muli	r2,r2,-3196
        /* The rotator is sqrt(2)*c(-6). */
        
        z2 = inptr[DCTSIZE*2];
        z3 = inptr[DCTSIZE*6];
        
        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
21080414:	4abf883a 	add	ra,r9,r10
        
        tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
        tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
        tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
        tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
        z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
21080418:	7bf8cce4 	muli	r15,r15,-7373
        tmp1 =inptr[DCTSIZE*5];
        tmp2 = inptr[DCTSIZE*3];
        tmp3 = inptr[DCTSIZE*1];
        
        z1 = tmp0 + tmp3;
        z2 = tmp1 + tmp2;
2108041c:	63a1883a 	add	r16,r12,r14
        tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
        tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
        tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
        z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
        z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
        z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
21080420:	31b04ee4 	muli	r6,r6,-16069
        /* The rotator is sqrt(2)*c(-6). */
        
        z2 = inptr[DCTSIZE*2];
        z3 = inptr[DCTSIZE*6];
        
        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
21080424:	ffc45464 	muli	ra,ra,4433
        tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
        
        z2 = inptr[DCTSIZE*0];
        z3 = inptr[DCTSIZE*4];
        
        tmp0 = (z2 + z3) << CONST_BITS;
21080428:	8a0b883a 	add	r5,r17,r8
        tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
        tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
        tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
        tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
        z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
        z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
2108042c:	842b7f64 	muli	r16,r16,-20995
        
        z2 = inptr[DCTSIZE*0];
        z3 = inptr[DCTSIZE*4];
        
        tmp0 = (z2 + z3) << CONST_BITS;
        tmp1 = (z2 - z3) << CONST_BITS;
21080430:	8a11c83a 	sub	r8,r17,r8
        z2 = inptr[DCTSIZE*2];
        z3 = inptr[DCTSIZE*6];
        
        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
        tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
        tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
21080434:	4a461fa4 	muli	r9,r9,6270
        z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
        
        tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
        tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
        tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
        tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
21080438:	18cc02e4 	muli	r3,r3,12299
        
        z2 = inptr[DCTSIZE*2];
        z3 = inptr[DCTSIZE*6];
        
        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
        tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
2108043c:	52b137e4 	muli	r10,r10,-15137
        z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
        z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
        z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
        
        z3 += z5;
        z4 += z5;
21080440:	1345883a 	add	r2,r2,r13
        
        z2 = inptr[DCTSIZE*0];
        z3 = inptr[DCTSIZE*4];
        
        tmp0 = (z2 + z3) << CONST_BITS;
        tmp1 = (z2 - z3) << CONST_BITS;
21080444:	4010937a 	slli	r8,r8,13
        tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
        
        z2 = inptr[DCTSIZE*0];
        z3 = inptr[DCTSIZE*4];
        
        tmp0 = (z2 + z3) << CONST_BITS;
21080448:	280a937a 	slli	r5,r5,13
        z4 = tmp1 + tmp3;
        z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
        
        tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
        tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
        tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
2108044c:	73989524 	muli	r14,r14,25172
        z4 += z5;
        
        tmp0 += z1 + z3;
        tmp1 += z2 + z4;
        tmp2 += z2 + z3;
        tmp3 += z1 + z4;
21080450:	788f883a 	add	r7,r15,r2
        z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
        z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
        z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
        z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
        
        z3 += z5;
21080454:	334d883a 	add	r6,r6,r13
        z2 = inptr[DCTSIZE*2];
        z3 = inptr[DCTSIZE*6];
        
        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
        tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
        tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
21080458:	4fd3883a 	add	r9,r9,ra
        z4 += z5;
        
        tmp0 += z1 + z3;
        tmp1 += z2 + z4;
        tmp2 += z2 + z3;
        tmp3 += z1 + z4;
2108045c:	38c7883a 	add	r3,r7,r3
        
        z2 = inptr[DCTSIZE*2];
        z3 = inptr[DCTSIZE*6];
        
        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
        tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
21080460:	57d5883a 	add	r10,r10,ra
        z3 += z5;
        z4 += z5;
        
        tmp0 += z1 + z3;
        tmp1 += z2 + z4;
        tmp2 += z2 + z3;
21080464:	818f883a 	add	r7,r16,r6
        tmp0 = (z2 + z3) << CONST_BITS;
        tmp1 = (z2 - z3) << CONST_BITS;
        
        tmp10 = tmp0 + tmp3;
        tmp13 = tmp0 - tmp3;
        tmp11 = tmp1 + tmp2;
21080468:	42bf883a 	add	ra,r8,r10
        z3 = inptr[DCTSIZE*4];
        
        tmp0 = (z2 + z3) << CONST_BITS;
        tmp1 = (z2 - z3) << CONST_BITS;
        
        tmp10 = tmp0 + tmp3;
2108046c:	2a63883a 	add	r17,r5,r9
        z3 += z5;
        z4 += z5;
        
        tmp0 += z1 + z3;
        tmp1 += z2 + z4;
        tmp2 += z2 + z3;
21080470:	3b8f883a 	add	r7,r7,r14
        z3 = tmp0 + tmp2;
        z4 = tmp1 + tmp3;
        z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
        
        tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
        tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
21080474:	63506ce4 	muli	r13,r12,16819
        
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        
        wsptr[DCTSIZE*0] = (int32_t) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*7] = (int32_t) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*1] = (int32_t) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
21080478:	f9dd883a 	add	r14,ra,r7
        tmp2 += z2 + z3;
        tmp3 += z1 + z4;
        
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        
        wsptr[DCTSIZE*0] = (int32_t) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
2108047c:	88d9883a 	add	r12,r17,r3
        tmp1 = (z2 - z3) << CONST_BITS;
        
        tmp10 = tmp0 + tmp3;
        tmp13 = tmp0 - tmp3;
        tmp11 = tmp1 + tmp2;
        tmp12 = tmp1 - tmp2;
21080480:	4295c83a 	sub	r10,r8,r10
        tmp2 += z2 + z3;
        tmp3 += z1 + z4;
        
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        
        wsptr[DCTSIZE*0] = (int32_t) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
21080484:	63010004 	addi	r12,r12,1024
        wsptr[DCTSIZE*7] = (int32_t) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*1] = (int32_t) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
21080488:	72010004 	addi	r8,r14,1024
        tmp3 += z1 + z4;
        
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        
        wsptr[DCTSIZE*0] = (int32_t) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*7] = (int32_t) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
2108048c:	88c7c83a 	sub	r3,r17,r3
        wsptr[DCTSIZE*1] = (int32_t) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
21080490:	401dd2fa 	srai	r14,r8,11
        tmp2 += z2 + z3;
        tmp3 += z1 + z4;
        
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        
        wsptr[DCTSIZE*0] = (int32_t) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
21080494:	6019d2fa 	srai	r12,r12,11
21080498:	da004017 	ldw	r8,256(sp)
        wsptr[DCTSIZE*7] = (int32_t) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
2108049c:	18c10004 	addi	r3,r3,1024
        z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
        
        z3 += z5;
        z4 += z5;
        
        tmp0 += z1 + z3;
210804a0:	798d883a 	add	r6,r15,r6
        tmp3 += z1 + z4;
        
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        
        wsptr[DCTSIZE*0] = (int32_t) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*7] = (int32_t) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
210804a4:	1807d2fa 	srai	r3,r3,11
210804a8:	dbc04717 	ldw	r15,284(sp)
        z2 = tmp1 + tmp2;
        z3 = tmp0 + tmp2;
        z4 = tmp1 + tmp3;
        z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
        
        tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
210804ac:	5ac263a4 	muli	r11,r11,2446
        
        z3 += z5;
        z4 += z5;
        
        tmp0 += z1 + z3;
        tmp1 += z2 + z4;
210804b0:	8085883a 	add	r2,r16,r2
        tmp2 += z2 + z3;
        tmp3 += z1 + z4;
        
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        
        wsptr[DCTSIZE*0] = (int32_t) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
210804b4:	43000015 	stw	r12,0(r8)
        
        z3 += z5;
        z4 += z5;
        
        tmp0 += z1 + z3;
        tmp1 += z2 + z4;
210804b8:	1345883a 	add	r2,r2,r13
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        
        wsptr[DCTSIZE*0] = (int32_t) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*7] = (int32_t) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*1] = (int32_t) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*6] = (int32_t) DESCALE(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
210804bc:	f9cfc83a 	sub	r7,ra,r7
        tmp3 += z1 + z4;
        
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        
        wsptr[DCTSIZE*0] = (int32_t) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*7] = (int32_t) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
210804c0:	78c00015 	stw	r3,0(r15)
        wsptr[DCTSIZE*1] = (int32_t) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*6] = (int32_t) DESCALE(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*2] = (int32_t) DESCALE(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
210804c4:	509b883a 	add	r13,r10,r2
        
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        
        wsptr[DCTSIZE*0] = (int32_t) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*7] = (int32_t) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*1] = (int32_t) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
210804c8:	d8c04617 	ldw	r3,280(sp)
        wsptr[DCTSIZE*6] = (int32_t) DESCALE(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
210804cc:	39c10004 	addi	r7,r7,1024
        z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
        
        z3 += z5;
        z4 += z5;
        
        tmp0 += z1 + z3;
210804d0:	32d7883a 	add	r11,r6,r11
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        
        wsptr[DCTSIZE*0] = (int32_t) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*7] = (int32_t) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*1] = (int32_t) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*6] = (int32_t) DESCALE(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
210804d4:	da004517 	ldw	r8,276(sp)
        
        tmp0 = (z2 + z3) << CONST_BITS;
        tmp1 = (z2 - z3) << CONST_BITS;
        
        tmp10 = tmp0 + tmp3;
        tmp13 = tmp0 - tmp3;
210804d8:	2a4bc83a 	sub	r5,r5,r9
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        
        wsptr[DCTSIZE*0] = (int32_t) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*7] = (int32_t) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*1] = (int32_t) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*6] = (int32_t) DESCALE(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
210804dc:	380fd2fa 	srai	r7,r7,11
        wsptr[DCTSIZE*2] = (int32_t) DESCALE(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*5] = (int32_t) DESCALE(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
210804e0:	5095c83a 	sub	r10,r10,r2
        
        wsptr[DCTSIZE*0] = (int32_t) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*7] = (int32_t) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*1] = (int32_t) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*6] = (int32_t) DESCALE(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*2] = (int32_t) DESCALE(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
210804e4:	69810004 	addi	r6,r13,1024
        wsptr[DCTSIZE*5] = (int32_t) DESCALE(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*3] = (int32_t) DESCALE(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
210804e8:	2ac5883a 	add	r2,r5,r11
        
        wsptr[DCTSIZE*0] = (int32_t) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*7] = (int32_t) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*1] = (int32_t) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*6] = (int32_t) DESCALE(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*2] = (int32_t) DESCALE(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
210804ec:	301bd2fa 	srai	r13,r6,11
        wsptr[DCTSIZE*5] = (int32_t) DESCALE(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*3] = (int32_t) DESCALE(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*4] = (int32_t) DESCALE(tmp13 - tmp0, CONST_BITS-PASS1_BITS);
210804f0:	2acbc83a 	sub	r5,r5,r11
        wsptr[DCTSIZE*0] = (int32_t) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*7] = (int32_t) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*1] = (int32_t) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*6] = (int32_t) DESCALE(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*2] = (int32_t) DESCALE(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*5] = (int32_t) DESCALE(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
210804f4:	52810004 	addi	r10,r10,1024
        
        wsptr[DCTSIZE*0] = (int32_t) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*7] = (int32_t) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*1] = (int32_t) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*6] = (int32_t) DESCALE(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*2] = (int32_t) DESCALE(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
210804f8:	dac04417 	ldw	r11,272(sp)
        
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        
        wsptr[DCTSIZE*0] = (int32_t) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*7] = (int32_t) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*1] = (int32_t) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
210804fc:	1b800015 	stw	r14,0(r3)
        wsptr[DCTSIZE*6] = (int32_t) DESCALE(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*2] = (int32_t) DESCALE(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*5] = (int32_t) DESCALE(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
21080500:	dbc04317 	ldw	r15,268(sp)
21080504:	5015d2fa 	srai	r10,r10,11
        wsptr[DCTSIZE*3] = (int32_t) DESCALE(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
21080508:	10810004 	addi	r2,r2,1024
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        
        wsptr[DCTSIZE*0] = (int32_t) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*7] = (int32_t) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*1] = (int32_t) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*6] = (int32_t) DESCALE(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
2108050c:	41c00015 	stw	r7,0(r8)
        wsptr[DCTSIZE*2] = (int32_t) DESCALE(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*5] = (int32_t) DESCALE(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*3] = (int32_t) DESCALE(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
21080510:	d8c04217 	ldw	r3,264(sp)
21080514:	1005d2fa 	srai	r2,r2,11
        
        wsptr[DCTSIZE*0] = (int32_t) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*7] = (int32_t) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*1] = (int32_t) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*6] = (int32_t) DESCALE(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*2] = (int32_t) DESCALE(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
21080518:	5b400015 	stw	r13,0(r11)
        wsptr[DCTSIZE*5] = (int32_t) DESCALE(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
2108051c:	7a800015 	stw	r10,0(r15)
        wsptr[DCTSIZE*3] = (int32_t) DESCALE(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
21080520:	18800015 	stw	r2,0(r3)
        wsptr[DCTSIZE*4] = (int32_t) DESCALE(tmp13 - tmp0, CONST_BITS-PASS1_BITS);
        
        inptr++;			/* advance pointers to next column */
        wsptr++;
21080524:	da004017 	ldw	r8,256(sp)
21080528:	dac04717 	ldw	r11,284(sp)
2108052c:	dbc04617 	ldw	r15,280(sp)
21080530:	d8804517 	ldw	r2,276(sp)
        wsptr[DCTSIZE*1] = (int32_t) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*6] = (int32_t) DESCALE(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*2] = (int32_t) DESCALE(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*5] = (int32_t) DESCALE(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*3] = (int32_t) DESCALE(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*4] = (int32_t) DESCALE(tmp13 - tmp0, CONST_BITS-PASS1_BITS);
21080534:	29410004 	addi	r5,r5,1024
21080538:	d9c04117 	ldw	r7,260(sp)
2108053c:	d8c04417 	ldw	r3,272(sp)
21080540:	280bd2fa 	srai	r5,r5,11
        
        inptr++;			/* advance pointers to next column */
        wsptr++;
21080544:	42000104 	addi	r8,r8,4
21080548:	5ac00104 	addi	r11,r11,4
2108054c:	7bc00104 	addi	r15,r15,4
21080550:	10800104 	addi	r2,r2,4
        wsptr[DCTSIZE*1] = (int32_t) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*6] = (int32_t) DESCALE(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*2] = (int32_t) DESCALE(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*5] = (int32_t) DESCALE(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*3] = (int32_t) DESCALE(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*4] = (int32_t) DESCALE(tmp13 - tmp0, CONST_BITS-PASS1_BITS);
21080554:	39400015 	stw	r5,0(r7)
        
        inptr++;			/* advance pointers to next column */
        wsptr++;
21080558:	da004015 	stw	r8,256(sp)
2108055c:	dac04715 	stw	r11,284(sp)
21080560:	dbc04615 	stw	r15,280(sp)
21080564:	d8804515 	stw	r2,276(sp)
21080568:	18c00104 	addi	r3,r3,4
2108056c:	d8c04415 	stw	r3,272(sp)
21080570:	d9c04317 	ldw	r7,268(sp)
21080574:	da004217 	ldw	r8,264(sp)
21080578:	dac04117 	ldw	r11,260(sp)
    /* Note results are scaled up by sqrt(8) compared to a true IDCT; */
    /* furthermore, we scale the results by 2**PASS1_BITS. */
    
    inptr = DCAC[0];
    wsptr = workspace;
    for (ctr = DCTSIZE; ctr > 0; ctr--) {
2108057c:	dbc04817 	ldw	r15,288(sp)
21080580:	39c00104 	addi	r7,r7,4
21080584:	42000104 	addi	r8,r8,4
21080588:	5ac00104 	addi	r11,r11,4
        wsptr[DCTSIZE*2] = (int32_t) DESCALE(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*5] = (int32_t) DESCALE(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*3] = (int32_t) DESCALE(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
        wsptr[DCTSIZE*4] = (int32_t) DESCALE(tmp13 - tmp0, CONST_BITS-PASS1_BITS);
        
        inptr++;			/* advance pointers to next column */
2108058c:	21000084 	addi	r4,r4,2
21080590:	d9c04315 	stw	r7,268(sp)
21080594:	da004215 	stw	r8,264(sp)
21080598:	dac04115 	stw	r11,260(sp)
2108059c:	e7000084 	addi	fp,fp,2
210805a0:	bdc00084 	addi	r23,r23,2
210805a4:	b5800084 	addi	r22,r22,2
210805a8:	ad400084 	addi	r21,r21,2
210805ac:	a5000084 	addi	r20,r20,2
210805b0:	9cc00084 	addi	r19,r19,2
210805b4:	94800084 	addi	r18,r18,2
    /* Note results are scaled up by sqrt(8) compared to a true IDCT; */
    /* furthermore, we scale the results by 2**PASS1_BITS. */
    
    inptr = DCAC[0];
    wsptr = workspace;
    for (ctr = DCTSIZE; ctr > 0; ctr--) {
210805b8:	23ff881e 	bne	r4,r15,210803dc <__flash_rwdata_start+0xfffde194>
210805bc:	dc404917 	ldw	r17,292(sp)
210805c0:	d8800304 	addi	r2,sp,12
210805c4:	d8c00104 	addi	r3,sp,4
210805c8:	dfc00204 	addi	ra,sp,8
210805cc:	d8804815 	stw	r2,288(sp)
210805d0:	d8c04715 	stw	r3,284(sp)
210805d4:	89000044 	addi	r4,r17,1
210805d8:	89c00184 	addi	r7,r17,6
210805dc:	8a000084 	addi	r8,r17,2
210805e0:	8ac00144 	addi	r11,r17,5
210805e4:	8bc000c4 	addi	r15,r17,3
210805e8:	88800104 	addi	r2,r17,4
210805ec:	88c011c4 	addi	r3,r17,71
210805f0:	df000604 	addi	fp,sp,24
210805f4:	ddc00404 	addi	r23,sp,16
210805f8:	dd800704 	addi	r22,sp,28
210805fc:	dd400504 	addi	r21,sp,20
21080600:	8a4001c4 	addi	r9,r17,7
21080604:	d9004615 	stw	r4,280(sp)
21080608:	d9c04515 	stw	r7,276(sp)
2108060c:	da004415 	stw	r8,272(sp)
21080610:	dac04315 	stw	r11,268(sp)
21080614:	dbc04215 	stw	r15,264(sp)
21080618:	d8804115 	stw	r2,260(sp)
2108061c:	d8c04a15 	stw	r3,296(sp)
21080620:	d80d883a 	mov	r6,sp
        tmp1 += z2 + z4;
        tmp2 += z2 + z3;
        tmp3 += z1 + z4;
        
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        outptr[0] = NORMALIZE(DESCALE(tmp10 + tmp3, CONST_BITS+PASS1_BITS+3));
21080624:	04c000b4 	movhi	r19,2
21080628:	05003fc4 	movi	r20,255
2108062c:	f815883a 	mov	r10,ra
21080630:	00005f06 	br	210807b0 <idct+0x464>
21080634:	a1c0010e 	bge	r20,r7,2108063c <idct+0x2f0>
21080638:	01c03fc4 	movi	r7,255
        outptr[7] = NORMALIZE(DESCALE(tmp10 - tmp3, CONST_BITS+PASS1_BITS+3));
2108063c:	2309c83a 	sub	r4,r4,r12
21080640:	24c9883a 	add	r4,r4,r19
        tmp1 += z2 + z4;
        tmp2 += z2 + z3;
        tmp3 += z1 + z4;
        
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        outptr[0] = NORMALIZE(DESCALE(tmp10 + tmp3, CONST_BITS+PASS1_BITS+3));
21080644:	dbc04917 	ldw	r15,292(sp)
        outptr[7] = NORMALIZE(DESCALE(tmp10 - tmp3, CONST_BITS+PASS1_BITS+3));
21080648:	2009d4ba 	srai	r4,r4,18
        tmp1 += z2 + z4;
        tmp2 += z2 + z3;
        tmp3 += z1 + z4;
        
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        outptr[0] = NORMALIZE(DESCALE(tmp10 + tmp3, CONST_BITS+PASS1_BITS+3));
2108064c:	79c00005 	stb	r7,0(r15)
21080650:	2000a316 	blt	r4,zero,210808e0 <idct+0x594>
        outptr[7] = NORMALIZE(DESCALE(tmp10 - tmp3, CONST_BITS+PASS1_BITS+3));
21080654:	a100010e 	bge	r20,r4,2108065c <idct+0x310>
21080658:	01003fc4 	movi	r4,255
        outptr[1] = NORMALIZE(DESCALE(tmp11 + tmp2, CONST_BITS+PASS1_BITS+3));
2108065c:	6947883a 	add	r3,r13,r5
21080660:	1cc7883a 	add	r3,r3,r19
21080664:	1807d4ba 	srai	r3,r3,18
        tmp2 += z2 + z3;
        tmp3 += z1 + z4;
        
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        outptr[0] = NORMALIZE(DESCALE(tmp10 + tmp3, CONST_BITS+PASS1_BITS+3));
        outptr[7] = NORMALIZE(DESCALE(tmp10 - tmp3, CONST_BITS+PASS1_BITS+3));
21080668:	49000005 	stb	r4,0(r9)
2108066c:	18009e16 	blt	r3,zero,210808e8 <idct+0x59c>
        outptr[1] = NORMALIZE(DESCALE(tmp11 + tmp2, CONST_BITS+PASS1_BITS+3));
21080670:	a0c0010e 	bge	r20,r3,21080678 <idct+0x32c>
21080674:	00c03fc4 	movi	r3,255
        outptr[6] = NORMALIZE(DESCALE(tmp11 - tmp2,CONST_BITS+PASS1_BITS+3));
21080678:	694bc83a 	sub	r5,r13,r5
2108067c:	2ccb883a 	add	r5,r5,r19
        tmp3 += z1 + z4;
        
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        outptr[0] = NORMALIZE(DESCALE(tmp10 + tmp3, CONST_BITS+PASS1_BITS+3));
        outptr[7] = NORMALIZE(DESCALE(tmp10 - tmp3, CONST_BITS+PASS1_BITS+3));
        outptr[1] = NORMALIZE(DESCALE(tmp11 + tmp2, CONST_BITS+PASS1_BITS+3));
21080680:	d9004617 	ldw	r4,280(sp)
        outptr[6] = NORMALIZE(DESCALE(tmp11 - tmp2,CONST_BITS+PASS1_BITS+3));
21080684:	280bd4ba 	srai	r5,r5,18
        tmp3 += z1 + z4;
        
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        outptr[0] = NORMALIZE(DESCALE(tmp10 + tmp3, CONST_BITS+PASS1_BITS+3));
        outptr[7] = NORMALIZE(DESCALE(tmp10 - tmp3, CONST_BITS+PASS1_BITS+3));
        outptr[1] = NORMALIZE(DESCALE(tmp11 + tmp2, CONST_BITS+PASS1_BITS+3));
21080688:	20c00005 	stb	r3,0(r4)
2108068c:	28009216 	blt	r5,zero,210808d8 <idct+0x58c>
        outptr[6] = NORMALIZE(DESCALE(tmp11 - tmp2,CONST_BITS+PASS1_BITS+3));
21080690:	a140010e 	bge	r20,r5,21080698 <idct+0x34c>
21080694:	01403fc4 	movi	r5,255
        outptr[2] = NORMALIZE(DESCALE(tmp12 + tmp1,CONST_BITS+PASS1_BITS+3));
21080698:	8207883a 	add	r3,r16,r8
2108069c:	1cc7883a 	add	r3,r3,r19
        
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        outptr[0] = NORMALIZE(DESCALE(tmp10 + tmp3, CONST_BITS+PASS1_BITS+3));
        outptr[7] = NORMALIZE(DESCALE(tmp10 - tmp3, CONST_BITS+PASS1_BITS+3));
        outptr[1] = NORMALIZE(DESCALE(tmp11 + tmp2, CONST_BITS+PASS1_BITS+3));
        outptr[6] = NORMALIZE(DESCALE(tmp11 - tmp2,CONST_BITS+PASS1_BITS+3));
210806a0:	d9c04517 	ldw	r7,276(sp)
        outptr[2] = NORMALIZE(DESCALE(tmp12 + tmp1,CONST_BITS+PASS1_BITS+3));
210806a4:	1807d4ba 	srai	r3,r3,18
        
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        outptr[0] = NORMALIZE(DESCALE(tmp10 + tmp3, CONST_BITS+PASS1_BITS+3));
        outptr[7] = NORMALIZE(DESCALE(tmp10 - tmp3, CONST_BITS+PASS1_BITS+3));
        outptr[1] = NORMALIZE(DESCALE(tmp11 + tmp2, CONST_BITS+PASS1_BITS+3));
        outptr[6] = NORMALIZE(DESCALE(tmp11 - tmp2,CONST_BITS+PASS1_BITS+3));
210806a8:	39400005 	stb	r5,0(r7)
210806ac:	18008816 	blt	r3,zero,210808d0 <idct+0x584>
        outptr[2] = NORMALIZE(DESCALE(tmp12 + tmp1,CONST_BITS+PASS1_BITS+3));
210806b0:	a0c0010e 	bge	r20,r3,210806b8 <idct+0x36c>
210806b4:	00c03fc4 	movi	r3,255
        outptr[5] = NORMALIZE(DESCALE(tmp12 - tmp1,CONST_BITS+PASS1_BITS+3));
210806b8:	8221c83a 	sub	r16,r16,r8
210806bc:	84e1883a 	add	r16,r16,r19
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        outptr[0] = NORMALIZE(DESCALE(tmp10 + tmp3, CONST_BITS+PASS1_BITS+3));
        outptr[7] = NORMALIZE(DESCALE(tmp10 - tmp3, CONST_BITS+PASS1_BITS+3));
        outptr[1] = NORMALIZE(DESCALE(tmp11 + tmp2, CONST_BITS+PASS1_BITS+3));
        outptr[6] = NORMALIZE(DESCALE(tmp11 - tmp2,CONST_BITS+PASS1_BITS+3));
        outptr[2] = NORMALIZE(DESCALE(tmp12 + tmp1,CONST_BITS+PASS1_BITS+3));
210806c0:	da004417 	ldw	r8,272(sp)
        outptr[5] = NORMALIZE(DESCALE(tmp12 - tmp1,CONST_BITS+PASS1_BITS+3));
210806c4:	8021d4ba 	srai	r16,r16,18
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        outptr[0] = NORMALIZE(DESCALE(tmp10 + tmp3, CONST_BITS+PASS1_BITS+3));
        outptr[7] = NORMALIZE(DESCALE(tmp10 - tmp3, CONST_BITS+PASS1_BITS+3));
        outptr[1] = NORMALIZE(DESCALE(tmp11 + tmp2, CONST_BITS+PASS1_BITS+3));
        outptr[6] = NORMALIZE(DESCALE(tmp11 - tmp2,CONST_BITS+PASS1_BITS+3));
        outptr[2] = NORMALIZE(DESCALE(tmp12 + tmp1,CONST_BITS+PASS1_BITS+3));
210806c8:	40c00005 	stb	r3,0(r8)
210806cc:	80007e16 	blt	r16,zero,210808c8 <idct+0x57c>
        outptr[5] = NORMALIZE(DESCALE(tmp12 - tmp1,CONST_BITS+PASS1_BITS+3));
210806d0:	a400010e 	bge	r20,r16,210806d8 <idct+0x38c>
210806d4:	04003fc4 	movi	r16,255
        outptr[3] = NORMALIZE(DESCALE(tmp13 + tmp0,CONST_BITS+PASS1_BITS+3));
210806d8:	1387883a 	add	r3,r2,r14
210806dc:	1cc7883a 	add	r3,r3,r19
        outptr[0] = NORMALIZE(DESCALE(tmp10 + tmp3, CONST_BITS+PASS1_BITS+3));
        outptr[7] = NORMALIZE(DESCALE(tmp10 - tmp3, CONST_BITS+PASS1_BITS+3));
        outptr[1] = NORMALIZE(DESCALE(tmp11 + tmp2, CONST_BITS+PASS1_BITS+3));
        outptr[6] = NORMALIZE(DESCALE(tmp11 - tmp2,CONST_BITS+PASS1_BITS+3));
        outptr[2] = NORMALIZE(DESCALE(tmp12 + tmp1,CONST_BITS+PASS1_BITS+3));
        outptr[5] = NORMALIZE(DESCALE(tmp12 - tmp1,CONST_BITS+PASS1_BITS+3));
210806e0:	dac04317 	ldw	r11,268(sp)
        outptr[3] = NORMALIZE(DESCALE(tmp13 + tmp0,CONST_BITS+PASS1_BITS+3));
210806e4:	1807d4ba 	srai	r3,r3,18
        outptr[0] = NORMALIZE(DESCALE(tmp10 + tmp3, CONST_BITS+PASS1_BITS+3));
        outptr[7] = NORMALIZE(DESCALE(tmp10 - tmp3, CONST_BITS+PASS1_BITS+3));
        outptr[1] = NORMALIZE(DESCALE(tmp11 + tmp2, CONST_BITS+PASS1_BITS+3));
        outptr[6] = NORMALIZE(DESCALE(tmp11 - tmp2,CONST_BITS+PASS1_BITS+3));
        outptr[2] = NORMALIZE(DESCALE(tmp12 + tmp1,CONST_BITS+PASS1_BITS+3));
        outptr[5] = NORMALIZE(DESCALE(tmp12 - tmp1,CONST_BITS+PASS1_BITS+3));
210806e8:	5c000005 	stb	r16,0(r11)
210806ec:	18007416 	blt	r3,zero,210808c0 <idct+0x574>
        outptr[3] = NORMALIZE(DESCALE(tmp13 + tmp0,CONST_BITS+PASS1_BITS+3));
210806f0:	a0c0010e 	bge	r20,r3,210806f8 <idct+0x3ac>
210806f4:	00c03fc4 	movi	r3,255
        outptr[4] = NORMALIZE(DESCALE(tmp13 - tmp0,CONST_BITS+PASS1_BITS+3));
210806f8:	1385c83a 	sub	r2,r2,r14
210806fc:	14c5883a 	add	r2,r2,r19
        outptr[7] = NORMALIZE(DESCALE(tmp10 - tmp3, CONST_BITS+PASS1_BITS+3));
        outptr[1] = NORMALIZE(DESCALE(tmp11 + tmp2, CONST_BITS+PASS1_BITS+3));
        outptr[6] = NORMALIZE(DESCALE(tmp11 - tmp2,CONST_BITS+PASS1_BITS+3));
        outptr[2] = NORMALIZE(DESCALE(tmp12 + tmp1,CONST_BITS+PASS1_BITS+3));
        outptr[5] = NORMALIZE(DESCALE(tmp12 - tmp1,CONST_BITS+PASS1_BITS+3));
        outptr[3] = NORMALIZE(DESCALE(tmp13 + tmp0,CONST_BITS+PASS1_BITS+3));
21080700:	dbc04217 	ldw	r15,264(sp)
        outptr[4] = NORMALIZE(DESCALE(tmp13 - tmp0,CONST_BITS+PASS1_BITS+3));
21080704:	1005d4ba 	srai	r2,r2,18
        outptr[7] = NORMALIZE(DESCALE(tmp10 - tmp3, CONST_BITS+PASS1_BITS+3));
        outptr[1] = NORMALIZE(DESCALE(tmp11 + tmp2, CONST_BITS+PASS1_BITS+3));
        outptr[6] = NORMALIZE(DESCALE(tmp11 - tmp2,CONST_BITS+PASS1_BITS+3));
        outptr[2] = NORMALIZE(DESCALE(tmp12 + tmp1,CONST_BITS+PASS1_BITS+3));
        outptr[5] = NORMALIZE(DESCALE(tmp12 - tmp1,CONST_BITS+PASS1_BITS+3));
        outptr[3] = NORMALIZE(DESCALE(tmp13 + tmp0,CONST_BITS+PASS1_BITS+3));
21080708:	78c00005 	stb	r3,0(r15)
2108070c:	10006a16 	blt	r2,zero,210808b8 <idct+0x56c>
        outptr[4] = NORMALIZE(DESCALE(tmp13 - tmp0,CONST_BITS+PASS1_BITS+3));
21080710:	a080010e 	bge	r20,r2,21080718 <idct+0x3cc>
21080714:	00803fc4 	movi	r2,255
21080718:	d9004817 	ldw	r4,288(sp)
2108071c:	d9c04717 	ldw	r7,284(sp)
21080720:	d8c04117 	ldw	r3,260(sp)
21080724:	da004917 	ldw	r8,292(sp)
21080728:	21000804 	addi	r4,r4,32
2108072c:	39c00804 	addi	r7,r7,32
21080730:	18800005 	stb	r2,0(r3)
21080734:	dac04617 	ldw	r11,280(sp)
21080738:	dbc04517 	ldw	r15,276(sp)
2108073c:	d8804417 	ldw	r2,272(sp)
21080740:	d8c04317 	ldw	r3,268(sp)
21080744:	d9004815 	stw	r4,288(sp)
21080748:	d9c04715 	stw	r7,284(sp)
2108074c:	d9004217 	ldw	r4,264(sp)
21080750:	d9c04117 	ldw	r7,260(sp)
21080754:	42000204 	addi	r8,r8,8
21080758:	da004915 	stw	r8,292(sp)
    /* Pass 2: process rows from work array, store into output array. */
    /* Note that we must descale the results by a factor of 8 == 2**3, */
    /* and also undo the PASS1_BITS scaling. */
    
    wsptr = workspace;
    for (ctr = 0; ctr < DCTSIZE; ctr++) {
2108075c:	da004a17 	ldw	r8,296(sp)
21080760:	5ac00204 	addi	r11,r11,8
21080764:	7bc00204 	addi	r15,r15,8
21080768:	10800204 	addi	r2,r2,8
2108076c:	18c00204 	addi	r3,r3,8
21080770:	21000204 	addi	r4,r4,8
21080774:	39c00204 	addi	r7,r7,8
21080778:	4a400204 	addi	r9,r9,8
2108077c:	dac04615 	stw	r11,280(sp)
21080780:	dbc04515 	stw	r15,276(sp)
21080784:	d8804415 	stw	r2,272(sp)
21080788:	d8c04315 	stw	r3,268(sp)
2108078c:	d9004215 	stw	r4,264(sp)
21080790:	d9c04115 	stw	r7,260(sp)
        outptr[2] = NORMALIZE(DESCALE(tmp12 + tmp1,CONST_BITS+PASS1_BITS+3));
        outptr[5] = NORMALIZE(DESCALE(tmp12 - tmp1,CONST_BITS+PASS1_BITS+3));
        outptr[3] = NORMALIZE(DESCALE(tmp13 + tmp0,CONST_BITS+PASS1_BITS+3));
        outptr[4] = NORMALIZE(DESCALE(tmp13 - tmp0,CONST_BITS+PASS1_BITS+3));
        
        wsptr += DCTSIZE;		/* advance pointer to next row */
21080794:	31800804 	addi	r6,r6,32
21080798:	52800804 	addi	r10,r10,32
2108079c:	e7000804 	addi	fp,fp,32
210807a0:	bdc00804 	addi	r23,r23,32
210807a4:	b5800804 	addi	r22,r22,32
210807a8:	ad400804 	addi	r21,r21,32
    /* Pass 2: process rows from work array, store into output array. */
    /* Note that we must descale the results by a factor of 8 == 2**3, */
    /* and also undo the PASS1_BITS scaling. */
    
    wsptr = workspace;
    for (ctr = 0; ctr < DCTSIZE; ctr++) {
210807ac:	4a005026 	beq	r9,r8,210808f0 <idct+0x5a4>
         */
        
        tmp0 = (int32_t) wsptr[7];
        tmp1 = (int32_t) wsptr[5];
        tmp2 = (int32_t) wsptr[3];
        tmp3 = (int32_t) wsptr[1];
210807b0:	d9c04717 	ldw	r7,284(sp)
         * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
         */
        
        tmp0 = (int32_t) wsptr[7];
        tmp1 = (int32_t) wsptr[5];
        tmp2 = (int32_t) wsptr[3];
210807b4:	d9004817 	ldw	r4,288(sp)
        tmp3 = (int32_t) wsptr[1];
        
        z1 = tmp0 + tmp3;
        z2 = tmp1 + tmp2;
        z3 = tmp0 + tmp2;
        z4 = tmp1 + tmp3;
210807b8:	aac00017 	ldw	r11,0(r21)
         */
        
        tmp0 = (int32_t) wsptr[7];
        tmp1 = (int32_t) wsptr[5];
        tmp2 = (int32_t) wsptr[3];
        tmp3 = (int32_t) wsptr[1];
210807bc:	3b000017 	ldw	r12,0(r7)
         * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
         */
        
        tmp0 = (int32_t) wsptr[7];
        tmp1 = (int32_t) wsptr[5];
        tmp2 = (int32_t) wsptr[3];
210807c0:	21000017 	ldw	r4,0(r4)
        tmp3 = (int32_t) wsptr[1];
        
        z1 = tmp0 + tmp3;
        z2 = tmp1 + tmp2;
        z3 = tmp0 + tmp2;
210807c4:	b2000017 	ldw	r8,0(r22)
        tmp0 = (int32_t) wsptr[7];
        tmp1 = (int32_t) wsptr[5];
        tmp2 = (int32_t) wsptr[3];
        tmp3 = (int32_t) wsptr[1];
        
        z1 = tmp0 + tmp3;
210807c8:	b3c00017 	ldw	r15,0(r22)
         * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
         */
        
        tmp0 = (int32_t) wsptr[7];
        tmp1 = (int32_t) wsptr[5];
        tmp2 = (int32_t) wsptr[3];
210807cc:	d9004b15 	stw	r4,300(sp)
        tmp3 = (int32_t) wsptr[1];
        
        z1 = tmp0 + tmp3;
        z2 = tmp1 + tmp2;
        z3 = tmp0 + tmp2;
210807d0:	413f883a 	add	ra,r8,r4
        z4 = tmp1 + tmp3;
210807d4:	5b11883a 	add	r8,r11,r12
        z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
210807d8:	fa0b883a 	add	r5,ra,r8
        
        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
        tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
        tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
        
        tmp0 = ((int32_t) wsptr[0] + (int32_t) wsptr[4]) << CONST_BITS;
210807dc:	30c00017 	ldw	r3,0(r6)
210807e0:	b9000017 	ldw	r4,0(r23)
        tmp1 = (int32_t) wsptr[5];
        tmp2 = (int32_t) wsptr[3];
        tmp3 = (int32_t) wsptr[1];
        
        z1 = tmp0 + tmp3;
        z2 = tmp1 + tmp2;
210807e4:	d9c04b17 	ldw	r7,300(sp)
        tmp0 = (int32_t) wsptr[7];
        tmp1 = (int32_t) wsptr[5];
        tmp2 = (int32_t) wsptr[3];
        tmp3 = (int32_t) wsptr[1];
        
        z1 = tmp0 + tmp3;
210807e8:	7b1d883a 	add	r14,r15,r12
        z2 = tmp1 + tmp2;
        z3 = tmp0 + tmp2;
        z4 = tmp1 + tmp3;
        z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
210807ec:	29496864 	muli	r5,r5,9633
        tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
        tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
        z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
        z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
        z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
        z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
210807f0:	423ce124 	muli	r8,r8,-3196
        
        tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
        tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
        tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
        tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
        z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
210807f4:	73b8cce4 	muli	r14,r14,-7373
        
        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
        tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
        tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
        
        tmp0 = ((int32_t) wsptr[0] + (int32_t) wsptr[4]) << CONST_BITS;
210807f8:	1905883a 	add	r2,r3,r4
        tmp1 = (int32_t) wsptr[5];
        tmp2 = (int32_t) wsptr[3];
        tmp3 = (int32_t) wsptr[1];
        
        z1 = tmp0 + tmp3;
        z2 = tmp1 + tmp2;
210807fc:	59e3883a 	add	r17,r11,r7
        z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
        
        tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
        tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
        tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
        tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
21080800:	60cc02e4 	muli	r3,r12,12299
        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
        tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
        tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
        
        tmp0 = ((int32_t) wsptr[0] + (int32_t) wsptr[4]) << CONST_BITS;
        tmp1 = ((int32_t) wsptr[0] - (int32_t) wsptr[4]) << CONST_BITS;
21080804:	32c00017 	ldw	r11,0(r6)
21080808:	bbc00017 	ldw	r15,0(r23)
        z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
        z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
        z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
        
        z3 += z5;
        z4 += z5;
2108080c:	4151883a 	add	r8,r8,r5
        outptr = block[ctr];
        
        /* Even part: reverse the even part of the forward DCT. */
        /* The rotator is sqrt(2)*c(-6). */
        
        z2 = (int32_t) wsptr[2];
21080810:	53400017 	ldw	r13,0(r10)
        z3 = (int32_t) wsptr[6];
21080814:	e4000017 	ldw	r16,0(fp)
        z4 += z5;
        
        tmp0 += z1 + z3;
        tmp1 += z2 + z4;
        tmp2 += z2 + z3;
        tmp3 += z1 + z4;
21080818:	7219883a 	add	r12,r14,r8
2108081c:	60d9883a 	add	r12,r12,r3
        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
        tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
        tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
        
        tmp0 = ((int32_t) wsptr[0] + (int32_t) wsptr[4]) << CONST_BITS;
        tmp1 = ((int32_t) wsptr[0] - (int32_t) wsptr[4]) << CONST_BITS;
21080820:	5bc7c83a 	sub	r3,r11,r15
        z2 = tmp1 + tmp2;
        z3 = tmp0 + tmp2;
        z4 = tmp1 + tmp3;
        z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
        
        tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
21080824:	b2c00017 	ldw	r11,0(r22)
        /* The rotator is sqrt(2)*c(-6). */
        
        z2 = (int32_t) wsptr[2];
        z3 = (int32_t) wsptr[6];
        
        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
21080828:	6c25883a 	add	r18,r13,r16
2108082c:	94845464 	muli	r18,r18,4433
        tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
        tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
21080830:	6b461fa4 	muli	r13,r13,6270
        z3 = tmp0 + tmp2;
        z4 = tmp1 + tmp3;
        z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
        
        tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
        tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
21080834:	abc00017 	ldw	r15,0(r21)
        
        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
        tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
        tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
        
        tmp0 = ((int32_t) wsptr[0] + (int32_t) wsptr[4]) << CONST_BITS;
21080838:	1004937a 	slli	r2,r2,13
        z2 = tmp1 + tmp2;
        z3 = tmp0 + tmp2;
        z4 = tmp1 + tmp3;
        z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
        
        tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
2108083c:	5ac263a4 	muli	r11,r11,2446
        z2 = (int32_t) wsptr[2];
        z3 = (int32_t) wsptr[6];
        
        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
        tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
        tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
21080840:	6c9b883a 	add	r13,r13,r18
        z3 = tmp0 + tmp2;
        z4 = tmp1 + tmp3;
        z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
        
        tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
        tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
21080844:	7bd06ce4 	muli	r15,r15,16819
        
        z2 = (int32_t) wsptr[2];
        z3 = (int32_t) wsptr[6];
        
        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
        tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
21080848:	843137e4 	muli	r16,r16,-15137
        tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
        
        tmp0 = ((int32_t) wsptr[0] + (int32_t) wsptr[4]) << CONST_BITS;
        tmp1 = ((int32_t) wsptr[0] - (int32_t) wsptr[4]) << CONST_BITS;
        
        tmp10 = tmp0 + tmp3;
2108084c:	1349883a 	add	r4,r2,r13
        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
        tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
        tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
        
        tmp0 = ((int32_t) wsptr[0] + (int32_t) wsptr[4]) << CONST_BITS;
        tmp1 = ((int32_t) wsptr[0] - (int32_t) wsptr[4]) << CONST_BITS;
21080850:	1806937a 	slli	r3,r3,13
        z2 = tmp1 + tmp2;
        z3 = tmp0 + tmp2;
        z4 = tmp1 + tmp3;
        z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
        
        tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
21080854:	dac04015 	stw	r11,256(sp)
        tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
        tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
21080858:	dac04b17 	ldw	r11,300(sp)
        tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
        z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
        z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
        z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
2108085c:	fff04ee4 	muli	ra,ra,-16069
        tmp1 += z2 + z4;
        tmp2 += z2 + z3;
        tmp3 += z1 + z4;
        
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        outptr[0] = NORMALIZE(DESCALE(tmp10 + tmp3, CONST_BITS+PASS1_BITS+3));
21080860:	230f883a 	add	r7,r4,r12
        tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
        tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
        tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
        tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
        z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
        z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
21080864:	8c6b7f64 	muli	r17,r17,-20995
        z3 = tmp0 + tmp2;
        z4 = tmp1 + tmp3;
        z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
        
        tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
        tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
21080868:	dbc04c15 	stw	r15,304(sp)
        
        z2 = (int32_t) wsptr[2];
        z3 = (int32_t) wsptr[6];
        
        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
        tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
2108086c:	84a1883a 	add	r16,r16,r18
        tmp1 += z2 + z4;
        tmp2 += z2 + z3;
        tmp3 += z1 + z4;
        
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        outptr[0] = NORMALIZE(DESCALE(tmp10 + tmp3, CONST_BITS+PASS1_BITS+3));
21080870:	3ccf883a 	add	r7,r7,r19
        z4 = tmp1 + tmp3;
        z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
        
        tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
        tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
        tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
21080874:	5bd89524 	muli	r15,r11,25172
        
        tmp0 = ((int32_t) wsptr[0] + (int32_t) wsptr[4]) << CONST_BITS;
        tmp1 = ((int32_t) wsptr[0] - (int32_t) wsptr[4]) << CONST_BITS;
        
        tmp10 = tmp0 + tmp3;
        tmp13 = tmp0 - tmp3;
21080878:	1345c83a 	sub	r2,r2,r13
        
        z3 += z5;
        z4 += z5;
        
        tmp0 += z1 + z3;
        tmp1 += z2 + z4;
2108087c:	dac04c17 	ldw	r11,304(sp)
        tmp0 = ((int32_t) wsptr[0] + (int32_t) wsptr[4]) << CONST_BITS;
        tmp1 = ((int32_t) wsptr[0] - (int32_t) wsptr[4]) << CONST_BITS;
        
        tmp10 = tmp0 + tmp3;
        tmp13 = tmp0 - tmp3;
        tmp11 = tmp1 + tmp2;
21080880:	1c1b883a 	add	r13,r3,r16
        tmp1 += z2 + z4;
        tmp2 += z2 + z3;
        tmp3 += z1 + z4;
        
        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
        outptr[0] = NORMALIZE(DESCALE(tmp10 + tmp3, CONST_BITS+PASS1_BITS+3));
21080884:	380fd4ba 	srai	r7,r7,18
        tmp1 = ((int32_t) wsptr[0] - (int32_t) wsptr[4]) << CONST_BITS;
        
        tmp10 = tmp0 + tmp3;
        tmp13 = tmp0 - tmp3;
        tmp11 = tmp1 + tmp2;
        tmp12 = tmp1 - tmp2;
21080888:	1c21c83a 	sub	r16,r3,r16
        z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
        
        z3 += z5;
        z4 += z5;
        
        tmp0 += z1 + z3;
2108088c:	d8c04017 	ldw	r3,256(sp)
        z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
        z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
        z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
        z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
        
        z3 += z5;
21080890:	f94b883a 	add	r5,ra,r5
        z4 += z5;
        
        tmp0 += z1 + z3;
21080894:	715d883a 	add	r14,r14,r5
        tmp1 += z2 + z4;
21080898:	8a11883a 	add	r8,r17,r8
        tmp2 += z2 + z3;
2108089c:	894b883a 	add	r5,r17,r5
        z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
        
        z3 += z5;
        z4 += z5;
        
        tmp0 += z1 + z3;
210808a0:	70dd883a 	add	r14,r14,r3
        tmp1 += z2 + z4;
210808a4:	42d1883a 	add	r8,r8,r11
        tmp2 += z2 + z3;
210808a8:	2bcb883a 	add	r5,r5,r15
210808ac:	383f610e 	bge	r7,zero,21080634 <__flash_rwdata_start+0xfffde3ec>
210808b0:	000f883a 	mov	r7,zero
210808b4:	003f6106 	br	2108063c <__flash_rwdata_start+0xfffde3f4>
210808b8:	0005883a 	mov	r2,zero
210808bc:	003f9606 	br	21080718 <__flash_rwdata_start+0xfffde4d0>
210808c0:	0007883a 	mov	r3,zero
210808c4:	003f8c06 	br	210806f8 <__flash_rwdata_start+0xfffde4b0>
210808c8:	0021883a 	mov	r16,zero
210808cc:	003f8206 	br	210806d8 <__flash_rwdata_start+0xfffde490>
210808d0:	0007883a 	mov	r3,zero
210808d4:	003f7806 	br	210806b8 <__flash_rwdata_start+0xfffde470>
210808d8:	000b883a 	mov	r5,zero
210808dc:	003f6e06 	br	21080698 <__flash_rwdata_start+0xfffde450>
210808e0:	0009883a 	mov	r4,zero
210808e4:	003f5d06 	br	2108065c <__flash_rwdata_start+0xfffde414>
210808e8:	0007883a 	mov	r3,zero
210808ec:	003f6206 	br	21080678 <__flash_rwdata_start+0xfffde430>
        outptr[3] = NORMALIZE(DESCALE(tmp13 + tmp0,CONST_BITS+PASS1_BITS+3));
        outptr[4] = NORMALIZE(DESCALE(tmp13 - tmp0,CONST_BITS+PASS1_BITS+3));
        
        wsptr += DCTSIZE;		/* advance pointer to next row */
    }
}
210808f0:	dfc05617 	ldw	ra,344(sp)
210808f4:	df005517 	ldw	fp,340(sp)
210808f8:	ddc05417 	ldw	r23,336(sp)
210808fc:	dd805317 	ldw	r22,332(sp)
21080900:	dd405217 	ldw	r21,328(sp)
21080904:	dd005117 	ldw	r20,324(sp)
21080908:	dcc05017 	ldw	r19,320(sp)
2108090c:	dc804f17 	ldw	r18,316(sp)
21080910:	dc404e17 	ldw	r17,312(sp)
21080914:	dc004d17 	ldw	r16,308(sp)
21080918:	dec05704 	addi	sp,sp,348
2108091c:	f800283a 	ret

21080920 <lossless_decode>:
 To perform the update, the bitstream pointer is incremented every
 time a new byte in the bistream is shifted in.
 
******************************** */
void lossless_decode(int num_blocks, void* bitstream, dct_block_t* DCACq, dct_block_t quant, BOOL P)
{
21080920:	defff604 	addi	sp,sp,-40
21080924:	dc400115 	stw	r17,4(sp)
21080928:	dfc00915 	stw	ra,36(sp)
2108092c:	df000815 	stw	fp,32(sp)
21080930:	ddc00715 	stw	r23,28(sp)
21080934:	dd800615 	stw	r22,24(sp)
21080938:	dd400515 	stw	r21,20(sp)
2108093c:	dd000415 	stw	r20,16(sp)
21080940:	dcc00315 	stw	r19,12(sp)
21080944:	dc800215 	stw	r18,8(sp)
21080948:	dc000015 	stw	r16,0(sp)
    //remove decoded bits
    (*pbitbuffer) <<= size;
    //total number of bits to be shifted in
    *pbitcount += size;
    if(*pbitcount >= 8){ //we need to shift in at least 1 byte
        *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 8);
2108094c:	2a400003 	ldbu	r9,0(r5)
        *pbitstream = ((uint8_t*)*pbitstream) + 1;
        if(*pbitcount >= 16){ //at least 2 bytes
            *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 16);
21080950:	28800043 	ldbu	r2,1(r5)
            *pbitstream = ((uint8_t*)*pbitstream) + 1;
            if(*pbitcount >= 24){ //at least 3 bytes
                *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 24);
21080954:	28c00083 	ldbu	r3,2(r5)
    //remove decoded bits
    (*pbitbuffer) <<= size;
    //total number of bits to be shifted in
    *pbitcount += size;
    if(*pbitcount >= 8){ //we need to shift in at least 1 byte
        *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 8);
21080958:	4812963a 	slli	r9,r9,24
        *pbitstream = ((uint8_t*)*pbitstream) + 1;
        if(*pbitcount >= 16){ //at least 2 bytes
            *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 16);
2108095c:	1004943a 	slli	r2,r2,16
            *pbitstream = ((uint8_t*)*pbitstream) + 1;
            if(*pbitcount >= 24){ //at least 3 bytes
                *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 24);
                *pbitstream = ((uint8_t*)*pbitstream) + 1;
                if(*pbitcount == 32){ //all 4 bytes shifted in
                    *pbitbuffer |= *((uint8_t*)(*pbitstream));
21080960:	2a0000c3 	ldbu	r8,3(r5)
        *pbitstream = ((uint8_t*)*pbitstream) + 1;
        if(*pbitcount >= 16){ //at least 2 bytes
            *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 16);
            *pbitstream = ((uint8_t*)*pbitstream) + 1;
            if(*pbitcount >= 24){ //at least 3 bytes
                *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 24);
21080964:	1806923a 	slli	r3,r3,8
    *pbitcount += size;
    if(*pbitcount >= 8){ //we need to shift in at least 1 byte
        *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 8);
        *pbitstream = ((uint8_t*)*pbitstream) + 1;
        if(*pbitcount >= 16){ //at least 2 bytes
            *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 16);
21080968:	4884b03a 	or	r2,r9,r2
2108096c:	1204b03a 	or	r2,r2,r8
 To perform the update, the bitstream pointer is incremented every
 time a new byte in the bistream is shifted in.
 
******************************** */
void lossless_decode(int num_blocks, void* bitstream, dct_block_t* DCACq, dct_block_t quant, BOOL P)
{
21080970:	dc400a17 	ldw	r17,40(sp)
            *pbitstream = ((uint8_t*)*pbitstream) + 1;
            if(*pbitcount >= 24){ //at least 3 bytes
                *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 24);
                *pbitstream = ((uint8_t*)*pbitstream) + 1;
                if(*pbitcount == 32){ //all 4 bytes shifted in
                    *pbitbuffer |= *((uint8_t*)(*pbitstream));
21080974:	10d0b03a 	or	r8,r2,r3
                    *pbitstream = ((uint8_t*)*pbitstream) + 1;
21080978:	2b400104 	addi	r13,r5,4
    
    huff_input_t ib;
    //Used for I frame DC differential encoding
    DCTELEM cur = 0;
    
    for(int count = 0; count < num_blocks; count ++){
2108097c:	0100980e 	bge	zero,r4,21080be0 <lossless_decode+0x2c0>
21080980:	200891fa 	slli	r4,r4,7
21080984:	02800034 	movhi	r10,0
21080988:	528fcc04 	addi	r10,r10,16176
2108098c:	3013883a 	mov	r9,r6
21080990:	312f883a 	add	r23,r6,r4
21080994:	003f883a 	mov	ra,zero
21080998:	000d883a 	mov	r6,zero
        ib.e = 0;
        ib.bits = 4;
    }
    else{
        bitbuffer <<= 4;
        ib.e = HUFF_EXTEND(INPUT_BITS(bitbuffer,size),size);
2108099c:	04800804 	movi	r18,32
210809a0:	057fffc4 	movi	r21,-1
{
    //remove decoded bits
    (*pbitbuffer) <<= size;
    //total number of bits to be shifted in
    *pbitcount += size;
    if(*pbitcount >= 8){ //we need to shift in at least 1 byte
210809a4:	070001c4 	movi	fp,7
        *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 8);
        *pbitstream = ((uint8_t*)*pbitstream) + 1;
        if(*pbitcount >= 16){ //at least 2 bytes
210809a8:	03c003c4 	movi	r15,15
            *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 16);
            *pbitstream = ((uint8_t*)*pbitstream) + 1;
            if(*pbitcount >= 24){ //at least 3 bytes
210809ac:	050005c4 	movi	r20,23
                    pe[zigzag_table[index]] = ib.e * (((DCTELEM*)quant)[zigzag_table[index]]);
                }
#else
                pe[zigzag_table[index]] = ib.e;
#endif
                if(index >= 63) break;
210809b0:	04c00f84 	movi	r19,62
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
                            pe[zigzag_table[index]] = 0;
210809b4:	5021883a 	mov	r16,r10
                }
                else {
                    //END
                    if(P == 0){
                        //output all zeros
                        for(; index < 64; index++)
210809b8:	05801004 	movi	r22,64

//DC decode function
huff_input_t input_DC(uint32_t bitbuffer)
{
    huff_input_t ib;
    uint8_t size = INPUT_BITS(bitbuffer, 4);
210809bc:	4006d73a 	srli	r3,r8,28
    if(size == 0){
210809c0:	18015626 	beq	r3,zero,21080f1c <lossless_decode+0x5fc>
        ib.e = 0;
        ib.bits = 4;
    }
    else{
        bitbuffer <<= 4;
210809c4:	4004913a 	slli	r2,r8,4
        ib.e = HUFF_EXTEND(INPUT_BITS(bitbuffer,size),size);
210809c8:	90d7c83a 	sub	r11,r18,r3
210809cc:	197fffc4 	addi	r5,r3,-1
210809d0:	1009883a 	mov	r4,r2
210809d4:	22c4d83a 	srl	r2,r4,r11
210809d8:	1148d83a 	srl	r4,r2,r5
210809dc:	2000031e 	bne	r4,zero,210809ec <lossless_decode+0xcc>
210809e0:	a8c8983a 	sll	r4,r21,r3
210809e4:	21000044 	addi	r4,r4,1
210809e8:	2085883a 	add	r2,r4,r2
210809ec:	18c00104 	addi	r3,r3,4
void update_buffer(uint32_t* pbitbuffer, void** pbitstream, int* pbitcount, uint8_t size)
{
    //remove decoded bits
    (*pbitbuffer) <<= size;
    //total number of bits to be shifted in
    *pbitcount += size;
210809f0:	30cd883a 	add	r6,r6,r3
//update buffer
//The function is written to be endianess - independent
void update_buffer(uint32_t* pbitbuffer, void** pbitstream, int* pbitcount, uint8_t size)
{
    //remove decoded bits
    (*pbitbuffer) <<= size;
210809f4:	40d0983a 	sll	r8,r8,r3
    //total number of bits to be shifted in
    *pbitcount += size;
    if(*pbitcount >= 8){ //we need to shift in at least 1 byte
210809f8:	e180100e 	bge	fp,r6,21080a3c <lossless_decode+0x11c>
        *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 8);
210809fc:	68c00003 	ldbu	r3,0(r13)
21080a00:	313ffe04 	addi	r4,r6,-8
21080a04:	1906983a 	sll	r3,r3,r4
21080a08:	40d0b03a 	or	r8,r8,r3
        *pbitstream = ((uint8_t*)*pbitstream) + 1;
        if(*pbitcount >= 16){ //at least 2 bytes
21080a0c:	7981460e 	bge	r15,r6,21080f28 <lossless_decode+0x608>
            *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 16);
21080a10:	68c00043 	ldbu	r3,1(r13)
21080a14:	313ffc04 	addi	r4,r6,-16
21080a18:	1906983a 	sll	r3,r3,r4
21080a1c:	40d0b03a 	or	r8,r8,r3
            *pbitstream = ((uint8_t*)*pbitstream) + 1;
            if(*pbitcount >= 24){ //at least 3 bytes
21080a20:	a181430e 	bge	r20,r6,21080f30 <lossless_decode+0x610>
                *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 24);
21080a24:	68c00083 	ldbu	r3,2(r13)
21080a28:	313ffa04 	addi	r4,r6,-24
21080a2c:	1906983a 	sll	r3,r3,r4
21080a30:	40d0b03a 	or	r8,r8,r3
                *pbitstream = ((uint8_t*)*pbitstream) + 1;
                if(*pbitcount == 32){ //all 4 bytes shifted in
21080a34:	34814026 	beq	r6,r18,21080f38 <lossless_decode+0x618>
        if(*pbitcount >= 16){ //at least 2 bytes
            *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 16);
            *pbitstream = ((uint8_t*)*pbitstream) + 1;
            if(*pbitcount >= 24){ //at least 3 bytes
                *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 24);
                *pbitstream = ((uint8_t*)*pbitstream) + 1;
21080a38:	6b4000c4 	addi	r13,r13,3
                    *pbitstream = ((uint8_t*)*pbitstream) + 1;
                }
            }
        }
    }
    *pbitcount &= 7; //the resulting *pbitcount should be between 0 and 7
21080a3c:	318001cc 	andi	r6,r6,7
        
        //decode DC coefficients
        ib = input_DC(bitbuffer);
        update_buffer(&bitbuffer, &bitstream, &bitcount, ib.bits);
#ifndef NULL_QUANT
        if(P){ //differential decoding based on previous frame
21080a40:	88013026 	beq	r17,zero,21080f04 <lossless_decode+0x5e4>
            pe[0] += (ib.e * (((DCTELEM*)quant)[0]) );
21080a44:	3900000b 	ldhu	r4,0(r7)
21080a48:	48c0000b 	ldhu	r3,0(r9)
21080a4c:	1105383a 	mul	r2,r2,r4
21080a50:	10c5883a 	add	r2,r2,r3
21080a54:	4880000d 	sth	r2,0(r9)
        }
#else   //null dequantization, no differential
        pe[0] = ib.e;
#endif
        
        uint8_t index = 1; //zig-zag order index for AC values in the 8x8 matrix, [0, 63]
21080a58:	00800044 	movi	r2,1
huff_input_t input_AC(uint32_t bitbuffer)
{
    huff_input_t ib;
    uint8_t size;
    ib.runlength  = INPUT_BITS(bitbuffer, 4);
    bitbuffer <<= 4;
21080a5c:	4006913a 	slli	r3,r8,4
//AC decode function
huff_input_t input_AC(uint32_t bitbuffer)
{
    huff_input_t ib;
    uint8_t size;
    ib.runlength  = INPUT_BITS(bitbuffer, 4);
21080a60:	400ad73a 	srli	r5,r8,28
    bitbuffer <<= 4;
    size  = INPUT_BITS(bitbuffer, 4);
21080a64:	1806d73a 	srli	r3,r3,28
    if(size == 0) {
21080a68:	18002726 	beq	r3,zero,21080b08 <lossless_decode+0x1e8>
        //and if size > 0, the amplitude cannot be 0.
        ib.e = 0;
        ib.bits = 8;
    }
    else{
        bitbuffer <<= 4;
21080a6c:	4018923a 	slli	r12,r8,8
        ib.e = HUFF_EXTEND(INPUT_BITS(bitbuffer,size),size);
21080a70:	90c9c83a 	sub	r4,r18,r3
21080a74:	1affffc4 	addi	r11,r3,-1
21080a78:	6108d83a 	srl	r4,r12,r4
21080a7c:	22d6d83a 	srl	r11,r4,r11
21080a80:	5800031e 	bne	r11,zero,21080a90 <lossless_decode+0x170>
21080a84:	a8d6983a 	sll	r11,r21,r3
21080a88:	5ac00044 	addi	r11,r11,1
21080a8c:	5909883a 	add	r4,r11,r4
21080a90:	18c00204 	addi	r3,r3,8
    //remove decoded bits
    (*pbitbuffer) <<= size;
    //total number of bits to be shifted in
    *pbitcount += size;
    if(*pbitcount >= 8){ //we need to shift in at least 1 byte
        *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 8);
21080a94:	6ac00003 	ldbu	r11,0(r13)
void update_buffer(uint32_t* pbitbuffer, void** pbitstream, int* pbitcount, uint8_t size)
{
    //remove decoded bits
    (*pbitbuffer) <<= size;
    //total number of bits to be shifted in
    *pbitcount += size;
21080a98:	30cd883a 	add	r6,r6,r3
    if(*pbitcount >= 8){ //we need to shift in at least 1 byte
        *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 8);
21080a9c:	333ffe04 	addi	r12,r6,-8
//update buffer
//The function is written to be endianess - independent
void update_buffer(uint32_t* pbitbuffer, void** pbitstream, int* pbitcount, uint8_t size)
{
    //remove decoded bits
    (*pbitbuffer) <<= size;
21080aa0:	40c6983a 	sll	r3,r8,r3
    //total number of bits to be shifted in
    *pbitcount += size;
    if(*pbitcount >= 8){ //we need to shift in at least 1 byte
        *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 8);
21080aa4:	5b10983a 	sll	r8,r11,r12
21080aa8:	40d0b03a 	or	r8,r8,r3
        *pbitstream = ((uint8_t*)*pbitstream) + 1;
        if(*pbitcount >= 16){ //at least 2 bytes
21080aac:	79802c0e 	bge	r15,r6,21080b60 <lossless_decode+0x240>
            *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 16);
21080ab0:	68c00043 	ldbu	r3,1(r13)
21080ab4:	32fffc04 	addi	r11,r6,-16
21080ab8:	1ac6983a 	sll	r3,r3,r11
21080abc:	40d0b03a 	or	r8,r8,r3
            *pbitstream = ((uint8_t*)*pbitstream) + 1;
            if(*pbitcount >= 24){ //at least 3 bytes
21080ac0:	a180f80e 	bge	r20,r6,21080ea4 <lossless_decode+0x584>
                *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 24);
21080ac4:	6ac00083 	ldbu	r11,2(r13)
21080ac8:	30fffa04 	addi	r3,r6,-24
                *pbitstream = ((uint8_t*)*pbitstream) + 1;
21080acc:	6b4000c4 	addi	r13,r13,3
        *pbitstream = ((uint8_t*)*pbitstream) + 1;
        if(*pbitcount >= 16){ //at least 2 bytes
            *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 16);
            *pbitstream = ((uint8_t*)*pbitstream) + 1;
            if(*pbitcount >= 24){ //at least 3 bytes
                *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 24);
21080ad0:	58c6983a 	sll	r3,r11,r3
21080ad4:	40d0b03a 	or	r8,r8,r3
        uint8_t index = 1; //zig-zag order index for AC values in the 8x8 matrix, [0, 63]
        while(1){
            //decode AC coefficient
            ib = input_AC(bitbuffer);
            update_buffer(&bitbuffer, &bitstream, &bitcount, ib.bits);
            if(ib.e == 0){
21080ad8:	20ffffcc 	andi	r3,r4,65535
21080adc:	18e0001c 	xori	r3,r3,32768
21080ae0:	18e00004 	addi	r3,r3,-32768
                    *pbitstream = ((uint8_t*)*pbitstream) + 1;
                }
            }
        }
    }
    *pbitcount &= 7; //the resulting *pbitcount should be between 0 and 7
21080ae4:	318001cc 	andi	r6,r6,7
        uint8_t index = 1; //zig-zag order index for AC values in the 8x8 matrix, [0, 63]
        while(1){
            //decode AC coefficient
            ib = input_AC(bitbuffer);
            update_buffer(&bitbuffer, &bitstream, &bitcount, ib.bits);
            if(ib.e == 0){
21080ae8:	18000a1e 	bne	r3,zero,21080b14 <lossless_decode+0x1f4>
                if(ib.runlength == 15){
21080aec:	2bc0f21e 	bne	r5,r15,21080eb8 <lossless_decode+0x598>
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
21080af0:	88004726 	beq	r17,zero,21080c10 <lossless_decode+0x2f0>
huff_input_t input_AC(uint32_t bitbuffer)
{
    huff_input_t ib;
    uint8_t size;
    ib.runlength  = INPUT_BITS(bitbuffer, 4);
    bitbuffer <<= 4;
21080af4:	4006913a 	slli	r3,r8,4
            update_buffer(&bitbuffer, &bitstream, &bitcount, ib.bits);
            if(ib.e == 0){
                if(ib.runlength == 15){
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
21080af8:	10800404 	addi	r2,r2,16
//AC decode function
huff_input_t input_AC(uint32_t bitbuffer)
{
    huff_input_t ib;
    uint8_t size;
    ib.runlength  = INPUT_BITS(bitbuffer, 4);
21080afc:	400ad73a 	srli	r5,r8,28
    bitbuffer <<= 4;
    size  = INPUT_BITS(bitbuffer, 4);
21080b00:	1806d73a 	srli	r3,r3,28
    if(size == 0) {
21080b04:	183fd91e 	bne	r3,zero,21080a6c <__flash_rwdata_start+0xfffde824>
21080b08:	00c00204 	movi	r3,8
        //return a value of 0. Notice this is ok size if size == 0, then it's either a END or ZRL,
        //and if size > 0, the amplitude cannot be 0.
        ib.e = 0;
21080b0c:	0009883a 	mov	r4,zero
21080b10:	003fe006 	br	21080a94 <__flash_rwdata_start+0xfffde84c>
                    break; //break from while and go to next block
                }
            }
            else{ //ib.e != 0
                if(P) //sum 0 to the next runlength values. This is equivalent to skipping runlength.
                    index += ib.runlength;
21080b14:	288b883a 	add	r5,r5,r2
                    //if P == 1, then don't change the values
                    break; //break from while and go to next block
                }
            }
            else{ //ib.e != 0
                if(P) //sum 0 to the next runlength values. This is equivalent to skipping runlength.
21080b18:	88001326 	beq	r17,zero,21080b68 <lossless_decode+0x248>
                        pe[zigzag_table[index]] = 0;
                }
                //now add the actual value
#ifndef NULL_QUANT
                if(P){ //differential decoding based on previous frame 
                    pe[zigzag_table[index]] += ib.e * (((DCTELEM*)quant)[zigzag_table[index]]);
21080b1c:	28c03fcc 	andi	r3,r5,255
21080b20:	18c7883a 	add	r3,r3,r3
21080b24:	18c7883a 	add	r3,r3,r3
21080b28:	50c7883a 	add	r3,r10,r3
21080b2c:	18800017 	ldw	r2,0(r3)
21080b30:	2ac03fcc 	andi	r11,r5,255
21080b34:	1085883a 	add	r2,r2,r2
21080b38:	3887883a 	add	r3,r7,r2
21080b3c:	1b00000b 	ldhu	r12,0(r3)
21080b40:	4885883a 	add	r2,r9,r2
21080b44:	10c0000b 	ldhu	r3,0(r2)
21080b48:	2309383a 	mul	r4,r4,r12
21080b4c:	20c9883a 	add	r4,r4,r3
21080b50:	1100000d 	sth	r4,0(r2)
                    pe[zigzag_table[index]] = ib.e * (((DCTELEM*)quant)[zigzag_table[index]]);
                }
#else
                pe[zigzag_table[index]] = ib.e;
#endif
                if(index >= 63) break;
21080b54:	9ac02036 	bltu	r19,r11,21080bd8 <lossless_decode+0x2b8>
                index++;
21080b58:	28800044 	addi	r2,r5,1
21080b5c:	003fbf06 	br	21080a5c <__flash_rwdata_start+0xfffde814>
    (*pbitbuffer) <<= size;
    //total number of bits to be shifted in
    *pbitcount += size;
    if(*pbitcount >= 8){ //we need to shift in at least 1 byte
        *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 8);
        *pbitstream = ((uint8_t*)*pbitstream) + 1;
21080b60:	6b400044 	addi	r13,r13,1
21080b64:	003fdc06 	br	21080ad8 <__flash_rwdata_start+0xfffde890>
21080b68:	03000034 	movhi	r12,0
            else{ //ib.e != 0
                if(P) //sum 0 to the next runlength values. This is equivalent to skipping runlength.
                    index += ib.runlength;
                else{ //add runlength zeros 
                    uint8_t terminal = index + ib.runlength;
                    for(; index < terminal; index++)
21080b6c:	10c03fcc 	andi	r3,r2,255
21080b70:	2ac03fcc 	andi	r11,r5,255
21080b74:	630fcc04 	addi	r12,r12,16176
21080b78:	1ac00236 	bltu	r3,r11,21080b84 <lossless_decode+0x264>
21080b7c:	0000cb06 	br	21080eac <lossless_decode+0x58c>
21080b80:	7007883a 	mov	r3,r14
                        pe[zigzag_table[index]] = 0;
21080b84:	18c7883a 	add	r3,r3,r3
21080b88:	18c7883a 	add	r3,r3,r3
21080b8c:	50c7883a 	add	r3,r10,r3
21080b90:	18c00017 	ldw	r3,0(r3)
            else{ //ib.e != 0
                if(P) //sum 0 to the next runlength values. This is equivalent to skipping runlength.
                    index += ib.runlength;
                else{ //add runlength zeros 
                    uint8_t terminal = index + ib.runlength;
                    for(; index < terminal; index++)
21080b94:	10800044 	addi	r2,r2,1
21080b98:	13803fcc 	andi	r14,r2,255
                        pe[zigzag_table[index]] = 0;
21080b9c:	18c7883a 	add	r3,r3,r3
21080ba0:	48c7883a 	add	r3,r9,r3
21080ba4:	1800000d 	sth	zero,0(r3)
            else{ //ib.e != 0
                if(P) //sum 0 to the next runlength values. This is equivalent to skipping runlength.
                    index += ib.runlength;
                else{ //add runlength zeros 
                    uint8_t terminal = index + ib.runlength;
                    for(; index < terminal; index++)
21080ba8:	72fff51e 	bne	r14,r11,21080b80 <__flash_rwdata_start+0xfffde938>
#ifndef NULL_QUANT
                if(P){ //differential decoding based on previous frame 
                    pe[zigzag_table[index]] += ib.e * (((DCTELEM*)quant)[zigzag_table[index]]);
                }
                else{ //no differential decoding
                    pe[zigzag_table[index]] = ib.e * (((DCTELEM*)quant)[zigzag_table[index]]);
21080bac:	5ac5883a 	add	r2,r11,r11
21080bb0:	1085883a 	add	r2,r2,r2
21080bb4:	6099883a 	add	r12,r12,r2
21080bb8:	60800017 	ldw	r2,0(r12)
21080bbc:	1085883a 	add	r2,r2,r2
21080bc0:	3887883a 	add	r3,r7,r2
21080bc4:	18c0000b 	ldhu	r3,0(r3)
21080bc8:	4885883a 	add	r2,r9,r2
21080bcc:	1909383a 	mul	r4,r3,r4
21080bd0:	1100000d 	sth	r4,0(r2)
                }
#else
                pe[zigzag_table[index]] = ib.e;
#endif
                if(index >= 63) break;
21080bd4:	9affe02e 	bgeu	r19,r11,21080b58 <__flash_rwdata_start+0xfffde910>
21080bd8:	4a402004 	addi	r9,r9,128
    
    huff_input_t ib;
    //Used for I frame DC differential encoding
    DCTELEM cur = 0;
    
    for(int count = 0; count < num_blocks; count ++){
21080bdc:	4dff771e 	bne	r9,r23,210809bc <__flash_rwdata_start+0xfffde774>
                if(index >= 63) break;
                index++;
            }
        }
    }
}
21080be0:	dfc00917 	ldw	ra,36(sp)
21080be4:	df000817 	ldw	fp,32(sp)
21080be8:	ddc00717 	ldw	r23,28(sp)
21080bec:	dd800617 	ldw	r22,24(sp)
21080bf0:	dd400517 	ldw	r21,20(sp)
21080bf4:	dd000417 	ldw	r20,16(sp)
21080bf8:	dcc00317 	ldw	r19,12(sp)
21080bfc:	dc800217 	ldw	r18,8(sp)
21080c00:	dc400117 	ldw	r17,4(sp)
21080c04:	dc000017 	ldw	r16,0(sp)
21080c08:	dec00a04 	addi	sp,sp,40
21080c0c:	f800283a 	ret
                if(ib.runlength == 15){
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
21080c10:	11400404 	addi	r5,r2,16
                        for(; index < terminal; index++)
21080c14:	11003fcc 	andi	r4,r2,255
21080c18:	28c03fcc 	andi	r3,r5,255
21080c1c:	20ff8f2e 	bgeu	r4,r3,21080a5c <__flash_rwdata_start+0xfffde814>
                            pe[zigzag_table[index]] = 0;
21080c20:	2109883a 	add	r4,r4,r4
21080c24:	2109883a 	add	r4,r4,r4
21080c28:	5109883a 	add	r4,r10,r4
21080c2c:	22c00017 	ldw	r11,0(r4)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080c30:	13000044 	addi	r12,r2,1
21080c34:	61003fcc 	andi	r4,r12,255
                            pe[zigzag_table[index]] = 0;
21080c38:	5ad7883a 	add	r11,r11,r11
21080c3c:	4ad7883a 	add	r11,r9,r11
21080c40:	5800000d 	sth	zero,0(r11)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080c44:	20c0952e 	bgeu	r4,r3,21080e9c <lossless_decode+0x57c>
                            pe[zigzag_table[index]] = 0;
21080c48:	2109883a 	add	r4,r4,r4
21080c4c:	2109883a 	add	r4,r4,r4
21080c50:	8109883a 	add	r4,r16,r4
21080c54:	22c00017 	ldw	r11,0(r4)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080c58:	13000084 	addi	r12,r2,2
21080c5c:	61003fcc 	andi	r4,r12,255
                            pe[zigzag_table[index]] = 0;
21080c60:	5ad7883a 	add	r11,r11,r11
21080c64:	4ad7883a 	add	r11,r9,r11
21080c68:	5800000d 	sth	zero,0(r11)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080c6c:	20c08b2e 	bgeu	r4,r3,21080e9c <lossless_decode+0x57c>
                            pe[zigzag_table[index]] = 0;
21080c70:	2109883a 	add	r4,r4,r4
21080c74:	2109883a 	add	r4,r4,r4
21080c78:	8109883a 	add	r4,r16,r4
21080c7c:	22c00017 	ldw	r11,0(r4)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080c80:	130000c4 	addi	r12,r2,3
21080c84:	61003fcc 	andi	r4,r12,255
                            pe[zigzag_table[index]] = 0;
21080c88:	5ad7883a 	add	r11,r11,r11
21080c8c:	4ad7883a 	add	r11,r9,r11
21080c90:	5800000d 	sth	zero,0(r11)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080c94:	20c0812e 	bgeu	r4,r3,21080e9c <lossless_decode+0x57c>
                            pe[zigzag_table[index]] = 0;
21080c98:	2109883a 	add	r4,r4,r4
21080c9c:	2109883a 	add	r4,r4,r4
21080ca0:	8109883a 	add	r4,r16,r4
21080ca4:	22c00017 	ldw	r11,0(r4)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080ca8:	13000104 	addi	r12,r2,4
21080cac:	61003fcc 	andi	r4,r12,255
                            pe[zigzag_table[index]] = 0;
21080cb0:	5ad7883a 	add	r11,r11,r11
21080cb4:	4ad7883a 	add	r11,r9,r11
21080cb8:	5800000d 	sth	zero,0(r11)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080cbc:	20c0772e 	bgeu	r4,r3,21080e9c <lossless_decode+0x57c>
                            pe[zigzag_table[index]] = 0;
21080cc0:	2109883a 	add	r4,r4,r4
21080cc4:	2109883a 	add	r4,r4,r4
21080cc8:	8109883a 	add	r4,r16,r4
21080ccc:	22c00017 	ldw	r11,0(r4)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080cd0:	13000144 	addi	r12,r2,5
21080cd4:	61003fcc 	andi	r4,r12,255
                            pe[zigzag_table[index]] = 0;
21080cd8:	5ad7883a 	add	r11,r11,r11
21080cdc:	4ad7883a 	add	r11,r9,r11
21080ce0:	5800000d 	sth	zero,0(r11)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080ce4:	20c06d2e 	bgeu	r4,r3,21080e9c <lossless_decode+0x57c>
                            pe[zigzag_table[index]] = 0;
21080ce8:	2109883a 	add	r4,r4,r4
21080cec:	2109883a 	add	r4,r4,r4
21080cf0:	8109883a 	add	r4,r16,r4
21080cf4:	22c00017 	ldw	r11,0(r4)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080cf8:	13000184 	addi	r12,r2,6
21080cfc:	61003fcc 	andi	r4,r12,255
                            pe[zigzag_table[index]] = 0;
21080d00:	5ad7883a 	add	r11,r11,r11
21080d04:	4ad7883a 	add	r11,r9,r11
21080d08:	5800000d 	sth	zero,0(r11)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080d0c:	20c0632e 	bgeu	r4,r3,21080e9c <lossless_decode+0x57c>
                            pe[zigzag_table[index]] = 0;
21080d10:	2109883a 	add	r4,r4,r4
21080d14:	2109883a 	add	r4,r4,r4
21080d18:	5109883a 	add	r4,r10,r4
21080d1c:	22c00017 	ldw	r11,0(r4)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080d20:	130001c4 	addi	r12,r2,7
21080d24:	61003fcc 	andi	r4,r12,255
                            pe[zigzag_table[index]] = 0;
21080d28:	5ad7883a 	add	r11,r11,r11
21080d2c:	4ad7883a 	add	r11,r9,r11
21080d30:	5800000d 	sth	zero,0(r11)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080d34:	20c0592e 	bgeu	r4,r3,21080e9c <lossless_decode+0x57c>
                            pe[zigzag_table[index]] = 0;
21080d38:	2109883a 	add	r4,r4,r4
21080d3c:	2109883a 	add	r4,r4,r4
21080d40:	5109883a 	add	r4,r10,r4
21080d44:	22c00017 	ldw	r11,0(r4)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080d48:	13000204 	addi	r12,r2,8
21080d4c:	61003fcc 	andi	r4,r12,255
                            pe[zigzag_table[index]] = 0;
21080d50:	5ad7883a 	add	r11,r11,r11
21080d54:	4ad7883a 	add	r11,r9,r11
21080d58:	5800000d 	sth	zero,0(r11)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080d5c:	20c04f2e 	bgeu	r4,r3,21080e9c <lossless_decode+0x57c>
                            pe[zigzag_table[index]] = 0;
21080d60:	2109883a 	add	r4,r4,r4
21080d64:	2109883a 	add	r4,r4,r4
21080d68:	5109883a 	add	r4,r10,r4
21080d6c:	22c00017 	ldw	r11,0(r4)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080d70:	13000244 	addi	r12,r2,9
21080d74:	61003fcc 	andi	r4,r12,255
                            pe[zigzag_table[index]] = 0;
21080d78:	5ad7883a 	add	r11,r11,r11
21080d7c:	4ad7883a 	add	r11,r9,r11
21080d80:	5800000d 	sth	zero,0(r11)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080d84:	20c0452e 	bgeu	r4,r3,21080e9c <lossless_decode+0x57c>
                            pe[zigzag_table[index]] = 0;
21080d88:	2109883a 	add	r4,r4,r4
21080d8c:	2109883a 	add	r4,r4,r4
21080d90:	5109883a 	add	r4,r10,r4
21080d94:	22c00017 	ldw	r11,0(r4)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080d98:	13000284 	addi	r12,r2,10
21080d9c:	61003fcc 	andi	r4,r12,255
                            pe[zigzag_table[index]] = 0;
21080da0:	5ad7883a 	add	r11,r11,r11
21080da4:	4ad7883a 	add	r11,r9,r11
21080da8:	5800000d 	sth	zero,0(r11)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080dac:	20c03b2e 	bgeu	r4,r3,21080e9c <lossless_decode+0x57c>
                            pe[zigzag_table[index]] = 0;
21080db0:	2109883a 	add	r4,r4,r4
21080db4:	2109883a 	add	r4,r4,r4
21080db8:	5109883a 	add	r4,r10,r4
21080dbc:	22c00017 	ldw	r11,0(r4)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080dc0:	130002c4 	addi	r12,r2,11
21080dc4:	61003fcc 	andi	r4,r12,255
                            pe[zigzag_table[index]] = 0;
21080dc8:	5ad7883a 	add	r11,r11,r11
21080dcc:	4ad7883a 	add	r11,r9,r11
21080dd0:	5800000d 	sth	zero,0(r11)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080dd4:	20c0312e 	bgeu	r4,r3,21080e9c <lossless_decode+0x57c>
                            pe[zigzag_table[index]] = 0;
21080dd8:	2109883a 	add	r4,r4,r4
21080ddc:	2109883a 	add	r4,r4,r4
21080de0:	5109883a 	add	r4,r10,r4
21080de4:	22c00017 	ldw	r11,0(r4)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080de8:	13000304 	addi	r12,r2,12
21080dec:	61003fcc 	andi	r4,r12,255
                            pe[zigzag_table[index]] = 0;
21080df0:	5ad7883a 	add	r11,r11,r11
21080df4:	4ad7883a 	add	r11,r9,r11
21080df8:	5800000d 	sth	zero,0(r11)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080dfc:	20c0272e 	bgeu	r4,r3,21080e9c <lossless_decode+0x57c>
                            pe[zigzag_table[index]] = 0;
21080e00:	2109883a 	add	r4,r4,r4
21080e04:	2109883a 	add	r4,r4,r4
21080e08:	5109883a 	add	r4,r10,r4
21080e0c:	22c00017 	ldw	r11,0(r4)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080e10:	13000344 	addi	r12,r2,13
21080e14:	61003fcc 	andi	r4,r12,255
                            pe[zigzag_table[index]] = 0;
21080e18:	5ad7883a 	add	r11,r11,r11
21080e1c:	4ad7883a 	add	r11,r9,r11
21080e20:	5800000d 	sth	zero,0(r11)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080e24:	20c01d2e 	bgeu	r4,r3,21080e9c <lossless_decode+0x57c>
                            pe[zigzag_table[index]] = 0;
21080e28:	2109883a 	add	r4,r4,r4
21080e2c:	2109883a 	add	r4,r4,r4
21080e30:	5109883a 	add	r4,r10,r4
21080e34:	22c00017 	ldw	r11,0(r4)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080e38:	13000384 	addi	r12,r2,14
21080e3c:	61003fcc 	andi	r4,r12,255
                            pe[zigzag_table[index]] = 0;
21080e40:	5ad7883a 	add	r11,r11,r11
21080e44:	4ad7883a 	add	r11,r9,r11
21080e48:	5800000d 	sth	zero,0(r11)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080e4c:	20c0132e 	bgeu	r4,r3,21080e9c <lossless_decode+0x57c>
                            pe[zigzag_table[index]] = 0;
21080e50:	2109883a 	add	r4,r4,r4
21080e54:	2109883a 	add	r4,r4,r4
21080e58:	5109883a 	add	r4,r10,r4
21080e5c:	22c00017 	ldw	r11,0(r4)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080e60:	108003c4 	addi	r2,r2,15
21080e64:	11003fcc 	andi	r4,r2,255
                            pe[zigzag_table[index]] = 0;
21080e68:	5ad7883a 	add	r11,r11,r11
21080e6c:	4ad7883a 	add	r11,r9,r11
21080e70:	5800000d 	sth	zero,0(r11)
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080e74:	20fef92e 	bgeu	r4,r3,21080a5c <__flash_rwdata_start+0xfffde814>
                            pe[zigzag_table[index]] = 0;
21080e78:	2109883a 	add	r4,r4,r4
21080e7c:	2109883a 	add	r4,r4,r4
21080e80:	5109883a 	add	r4,r10,r4
21080e84:	20c00017 	ldw	r3,0(r4)
21080e88:	2805883a 	mov	r2,r5
21080e8c:	18c7883a 	add	r3,r3,r3
21080e90:	48c7883a 	add	r3,r9,r3
21080e94:	1800000d 	sth	zero,0(r3)
21080e98:	003ef006 	br	21080a5c <__flash_rwdata_start+0xfffde814>
                    //EZL
                    if(P) //sum 0 to the next 16 values. This is equivalent to skipping 16.
                        index += 16;
                    else{ //add 16 zeros
                        uint8_t terminal = index + 16;
                        for(; index < terminal; index++)
21080e9c:	6005883a 	mov	r2,r12
21080ea0:	003eee06 	br	21080a5c <__flash_rwdata_start+0xfffde814>
    if(*pbitcount >= 8){ //we need to shift in at least 1 byte
        *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 8);
        *pbitstream = ((uint8_t*)*pbitstream) + 1;
        if(*pbitcount >= 16){ //at least 2 bytes
            *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 16);
            *pbitstream = ((uint8_t*)*pbitstream) + 1;
21080ea4:	6b400084 	addi	r13,r13,2
21080ea8:	003f0b06 	br	21080ad8 <__flash_rwdata_start+0xfffde890>
            else{ //ib.e != 0
                if(P) //sum 0 to the next runlength values. This is equivalent to skipping runlength.
                    index += ib.runlength;
                else{ //add runlength zeros 
                    uint8_t terminal = index + ib.runlength;
                    for(; index < terminal; index++)
21080eac:	100b883a 	mov	r5,r2
21080eb0:	1817883a 	mov	r11,r3
21080eb4:	003f3d06 	br	21080bac <__flash_rwdata_start+0xfffde964>
                            pe[zigzag_table[index]] = 0;
                    }
                }
                else {
                    //END
                    if(P == 0){
21080eb8:	883f471e 	bne	r17,zero,21080bd8 <__flash_rwdata_start+0xfffde990>
                        //output all zeros
                        for(; index < 64; index++)
21080ebc:	10c03fcc 	andi	r3,r2,255
21080ec0:	01000fc4 	movi	r4,63
21080ec4:	20c0022e 	bgeu	r4,r3,21080ed0 <lossless_decode+0x5b0>
21080ec8:	003f4306 	br	21080bd8 <__flash_rwdata_start+0xfffde990>
21080ecc:	2007883a 	mov	r3,r4
                            pe[zigzag_table[index]] = 0;
21080ed0:	18c7883a 	add	r3,r3,r3
21080ed4:	18c7883a 	add	r3,r3,r3
21080ed8:	50c7883a 	add	r3,r10,r3
21080edc:	18c00017 	ldw	r3,0(r3)
                }
                else {
                    //END
                    if(P == 0){
                        //output all zeros
                        for(; index < 64; index++)
21080ee0:	10800044 	addi	r2,r2,1
21080ee4:	11003fcc 	andi	r4,r2,255
                            pe[zigzag_table[index]] = 0;
21080ee8:	18c7883a 	add	r3,r3,r3
21080eec:	48c7883a 	add	r3,r9,r3
21080ef0:	1800000d 	sth	zero,0(r3)
                }
                else {
                    //END
                    if(P == 0){
                        //output all zeros
                        for(; index < 64; index++)
21080ef4:	25bff51e 	bne	r4,r22,21080ecc <__flash_rwdata_start+0xfffdec84>
21080ef8:	4a402004 	addi	r9,r9,128
    
    huff_input_t ib;
    //Used for I frame DC differential encoding
    DCTELEM cur = 0;
    
    for(int count = 0; count < num_blocks; count ++){
21080efc:	4dfeaf1e 	bne	r9,r23,210809bc <__flash_rwdata_start+0xfffde774>
21080f00:	003f3706 	br	21080be0 <__flash_rwdata_start+0xfffde998>
        if(P){ //differential decoding based on previous frame
            pe[0] += (ib.e * (((DCTELEM*)quant)[0]) );
        }
        else{ //differential decoding based on previous block
            cur += ib.e;
            pe[0] = cur * (((DCTELEM*)quant)[0]);
21080f04:	38c0000b 	ldhu	r3,0(r7)
#ifndef NULL_QUANT
        if(P){ //differential decoding based on previous frame
            pe[0] += (ib.e * (((DCTELEM*)quant)[0]) );
        }
        else{ //differential decoding based on previous block
            cur += ib.e;
21080f08:	17c5883a 	add	r2,r2,ra
21080f0c:	103f883a 	mov	ra,r2
            pe[0] = cur * (((DCTELEM*)quant)[0]);
21080f10:	10c5383a 	mul	r2,r2,r3
21080f14:	4880000d 	sth	r2,0(r9)
21080f18:	003ecf06 	br	21080a58 <__flash_rwdata_start+0xfffde810>
//DC decode function
huff_input_t input_DC(uint32_t bitbuffer)
{
    huff_input_t ib;
    uint8_t size = INPUT_BITS(bitbuffer, 4);
    if(size == 0){
21080f1c:	00c00104 	movi	r3,4
21080f20:	0005883a 	mov	r2,zero
21080f24:	003eb206 	br	210809f0 <__flash_rwdata_start+0xfffde7a8>
    (*pbitbuffer) <<= size;
    //total number of bits to be shifted in
    *pbitcount += size;
    if(*pbitcount >= 8){ //we need to shift in at least 1 byte
        *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 8);
        *pbitstream = ((uint8_t*)*pbitstream) + 1;
21080f28:	6b400044 	addi	r13,r13,1
21080f2c:	003ec306 	br	21080a3c <__flash_rwdata_start+0xfffde7f4>
        if(*pbitcount >= 16){ //at least 2 bytes
            *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 16);
            *pbitstream = ((uint8_t*)*pbitstream) + 1;
21080f30:	6b400084 	addi	r13,r13,2
21080f34:	003ec106 	br	21080a3c <__flash_rwdata_start+0xfffde7f4>
            if(*pbitcount >= 24){ //at least 3 bytes
                *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 24);
                *pbitstream = ((uint8_t*)*pbitstream) + 1;
                if(*pbitcount == 32){ //all 4 bytes shifted in
                    *pbitbuffer |= *((uint8_t*)(*pbitstream));
21080f38:	68c000c3 	ldbu	r3,3(r13)
                    *pbitstream = ((uint8_t*)*pbitstream) + 1;
21080f3c:	6b400104 	addi	r13,r13,4
            *pbitstream = ((uint8_t*)*pbitstream) + 1;
            if(*pbitcount >= 24){ //at least 3 bytes
                *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 24);
                *pbitstream = ((uint8_t*)*pbitstream) + 1;
                if(*pbitcount == 32){ //all 4 bytes shifted in
                    *pbitbuffer |= *((uint8_t*)(*pbitstream));
21080f40:	40d0b03a 	or	r8,r8,r3
21080f44:	003ebd06 	br	21080a3c <__flash_rwdata_start+0xfffde7f4>

21080f48 <update_buffer>:
//update buffer
//The function is written to be endianess - independent
void update_buffer(uint32_t* pbitbuffer, void** pbitstream, int* pbitcount, uint8_t size)
{
    //remove decoded bits
    (*pbitbuffer) <<= size;
21080f48:	20800017 	ldw	r2,0(r4)
21080f4c:	39c03fcc 	andi	r7,r7,255
    //total number of bits to be shifted in
    *pbitcount += size;
21080f50:	30c00017 	ldw	r3,0(r6)
//update buffer
//The function is written to be endianess - independent
void update_buffer(uint32_t* pbitbuffer, void** pbitstream, int* pbitcount, uint8_t size)
{
    //remove decoded bits
    (*pbitbuffer) <<= size;
21080f54:	11c4983a 	sll	r2,r2,r7
    //total number of bits to be shifted in
    *pbitcount += size;
21080f58:	38cf883a 	add	r7,r7,r3
//update buffer
//The function is written to be endianess - independent
void update_buffer(uint32_t* pbitbuffer, void** pbitstream, int* pbitcount, uint8_t size)
{
    //remove decoded bits
    (*pbitbuffer) <<= size;
21080f5c:	20800015 	stw	r2,0(r4)
    //total number of bits to be shifted in
    *pbitcount += size;
21080f60:	31c00015 	stw	r7,0(r6)
    if(*pbitcount >= 8){ //we need to shift in at least 1 byte
21080f64:	00c001c4 	movi	r3,7
21080f68:	19c01c0e 	bge	r3,r7,21080fdc <update_buffer+0x94>
        *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 8);
21080f6c:	28c00017 	ldw	r3,0(r5)
21080f70:	3a3ffe04 	addi	r8,r7,-8
21080f74:	1a400003 	ldbu	r9,0(r3)
        *pbitstream = ((uint8_t*)*pbitstream) + 1;
21080f78:	1a800044 	addi	r10,r3,1
    //remove decoded bits
    (*pbitbuffer) <<= size;
    //total number of bits to be shifted in
    *pbitcount += size;
    if(*pbitcount >= 8){ //we need to shift in at least 1 byte
        *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 8);
21080f7c:	4a10983a 	sll	r8,r9,r8
21080f80:	4084b03a 	or	r2,r8,r2
21080f84:	20800015 	stw	r2,0(r4)
        *pbitstream = ((uint8_t*)*pbitstream) + 1;
21080f88:	2a800015 	stw	r10,0(r5)
        if(*pbitcount >= 16){ //at least 2 bytes
21080f8c:	020003c4 	movi	r8,15
21080f90:	41c0120e 	bge	r8,r7,21080fdc <update_buffer+0x94>
            *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 16);
21080f94:	1a400043 	ldbu	r9,1(r3)
21080f98:	3a3ffc04 	addi	r8,r7,-16
            *pbitstream = ((uint8_t*)*pbitstream) + 1;
21080f9c:	1a800084 	addi	r10,r3,2
    *pbitcount += size;
    if(*pbitcount >= 8){ //we need to shift in at least 1 byte
        *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 8);
        *pbitstream = ((uint8_t*)*pbitstream) + 1;
        if(*pbitcount >= 16){ //at least 2 bytes
            *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 16);
21080fa0:	4a10983a 	sll	r8,r9,r8
21080fa4:	1204b03a 	or	r2,r2,r8
21080fa8:	20800015 	stw	r2,0(r4)
            *pbitstream = ((uint8_t*)*pbitstream) + 1;
21080fac:	2a800015 	stw	r10,0(r5)
            if(*pbitcount >= 24){ //at least 3 bytes
21080fb0:	020005c4 	movi	r8,23
21080fb4:	41c0090e 	bge	r8,r7,21080fdc <update_buffer+0x94>
                *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 24);
21080fb8:	1a400083 	ldbu	r9,2(r3)
21080fbc:	3a3ffa04 	addi	r8,r7,-24
                *pbitstream = ((uint8_t*)*pbitstream) + 1;
21080fc0:	1a8000c4 	addi	r10,r3,3
        *pbitstream = ((uint8_t*)*pbitstream) + 1;
        if(*pbitcount >= 16){ //at least 2 bytes
            *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 16);
            *pbitstream = ((uint8_t*)*pbitstream) + 1;
            if(*pbitcount >= 24){ //at least 3 bytes
                *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 24);
21080fc4:	4a10983a 	sll	r8,r9,r8
21080fc8:	1204b03a 	or	r2,r2,r8
21080fcc:	20800015 	stw	r2,0(r4)
                *pbitstream = ((uint8_t*)*pbitstream) + 1;
21080fd0:	2a800015 	stw	r10,0(r5)
                if(*pbitcount == 32){ //all 4 bytes shifted in
21080fd4:	02000804 	movi	r8,32
21080fd8:	3a000326 	beq	r7,r8,21080fe8 <update_buffer+0xa0>
                    *pbitstream = ((uint8_t*)*pbitstream) + 1;
                }
            }
        }
    }
    *pbitcount &= 7; //the resulting *pbitcount should be between 0 and 7
21080fdc:	39c001cc 	andi	r7,r7,7
21080fe0:	31c00015 	stw	r7,0(r6)
21080fe4:	f800283a 	ret
            *pbitstream = ((uint8_t*)*pbitstream) + 1;
            if(*pbitcount >= 24){ //at least 3 bytes
                *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 24);
                *pbitstream = ((uint8_t*)*pbitstream) + 1;
                if(*pbitcount == 32){ //all 4 bytes shifted in
                    *pbitbuffer |= *((uint8_t*)(*pbitstream));
21080fe8:	1a0000c3 	ldbu	r8,3(r3)
                    *pbitstream = ((uint8_t*)*pbitstream) + 1;
21080fec:	18c00104 	addi	r3,r3,4
            *pbitstream = ((uint8_t*)*pbitstream) + 1;
            if(*pbitcount >= 24){ //at least 3 bytes
                *pbitbuffer |= *((uint8_t*)(*pbitstream)) << (*pbitcount - 24);
                *pbitstream = ((uint8_t*)*pbitstream) + 1;
                if(*pbitcount == 32){ //all 4 bytes shifted in
                    *pbitbuffer |= *((uint8_t*)(*pbitstream));
21080ff0:	1204b03a 	or	r2,r2,r8
21080ff4:	20800015 	stw	r2,0(r4)
                    *pbitstream = ((uint8_t*)*pbitstream) + 1;
21080ff8:	28c00015 	stw	r3,0(r5)
21080ffc:	003ff706 	br	21080fdc <__flash_rwdata_start+0xfffded94>

21081000 <input_DC>:

//DC decode function
huff_input_t input_DC(uint32_t bitbuffer)
{
    huff_input_t ib;
    uint8_t size = INPUT_BITS(bitbuffer, 4);
21081000:	2006d73a 	srli	r3,r4,28
//extract num bits from the buffer and returns them
#define INPUT_BITS(buffer, num) (buffer) >> (32 - (num))

//DC decode function
huff_input_t input_DC(uint32_t bitbuffer)
{
21081004:	deffff04 	addi	sp,sp,-4
    huff_input_t ib;
    uint8_t size = INPUT_BITS(bitbuffer, 4);
    if(size == 0){
21081008:	18001426 	beq	r3,zero,2108105c <input_DC+0x5c>
        ib.e = 0;
        ib.bits = 4;
    }
    else{
        bitbuffer <<= 4;
2108100c:	2008913a 	slli	r4,r4,4
        ib.e = HUFF_EXTEND(INPUT_BITS(bitbuffer,size),size);
21081010:	00800804 	movi	r2,32
21081014:	10c5c83a 	sub	r2,r2,r3
21081018:	2088d83a 	srl	r4,r4,r2
2108101c:	18bfffc4 	addi	r2,r3,-1
21081020:	2084d83a 	srl	r2,r4,r2
21081024:	10000826 	beq	r2,zero,21081048 <input_DC+0x48>
        ib.bits = size + 4;
21081028:	18c00104 	addi	r3,r3,4
    }
    return ib;
2108102c:	d8c00005 	stb	r3,0(sp)
21081030:	d8000045 	stb	zero,1(sp)
21081034:	d880000b 	ldhu	r2,0(sp)
21081038:	2008943a 	slli	r4,r4,16
}
2108103c:	1104b03a 	or	r2,r2,r4
21081040:	dec00104 	addi	sp,sp,4
21081044:	f800283a 	ret
        ib.e = 0;
        ib.bits = 4;
    }
    else{
        bitbuffer <<= 4;
        ib.e = HUFF_EXTEND(INPUT_BITS(bitbuffer,size),size);
21081048:	00bfffc4 	movi	r2,-1
2108104c:	10c4983a 	sll	r2,r2,r3
21081050:	10800044 	addi	r2,r2,1
21081054:	1109883a 	add	r4,r2,r4
21081058:	003ff306 	br	21081028 <__flash_rwdata_start+0xfffdede0>
huff_input_t input_DC(uint32_t bitbuffer)
{
    huff_input_t ib;
    uint8_t size = INPUT_BITS(bitbuffer, 4);
    if(size == 0){
        ib.e = 0;
2108105c:	0009883a 	mov	r4,zero
        ib.bits = 4;
21081060:	00c00104 	movi	r3,4
21081064:	003ff106 	br	2108102c <__flash_rwdata_start+0xfffdede4>

21081068 <input_AC>:
huff_input_t input_AC(uint32_t bitbuffer)
{
    huff_input_t ib;
    uint8_t size;
    ib.runlength  = INPUT_BITS(bitbuffer, 4);
    bitbuffer <<= 4;
21081068:	2006913a 	slli	r3,r4,4
    return ib;
}

//AC decode function
huff_input_t input_AC(uint32_t bitbuffer)
{
2108106c:	deffff04 	addi	sp,sp,-4
    huff_input_t ib;
    uint8_t size;
    ib.runlength  = INPUT_BITS(bitbuffer, 4);
21081070:	200ad73a 	srli	r5,r4,28
    bitbuffer <<= 4;
    size  = INPUT_BITS(bitbuffer, 4);
21081074:	1806d73a 	srli	r3,r3,28
    if(size == 0) {
21081078:	18001426 	beq	r3,zero,210810cc <input_AC+0x64>
        //and if size > 0, the amplitude cannot be 0.
        ib.e = 0;
        ib.bits = 8;
    }
    else{
        bitbuffer <<= 4;
2108107c:	2008923a 	slli	r4,r4,8
        ib.e = HUFF_EXTEND(INPUT_BITS(bitbuffer,size),size);
21081080:	00800804 	movi	r2,32
21081084:	10c5c83a 	sub	r2,r2,r3
21081088:	2088d83a 	srl	r4,r4,r2
2108108c:	18bfffc4 	addi	r2,r3,-1
21081090:	2084d83a 	srl	r2,r4,r2
21081094:	10000826 	beq	r2,zero,210810b8 <input_AC+0x50>
        ib.bits = size + 8;
21081098:	18c00204 	addi	r3,r3,8
    }
    return ib;
2108109c:	d8c00005 	stb	r3,0(sp)
210810a0:	d9400045 	stb	r5,1(sp)
210810a4:	d880000b 	ldhu	r2,0(sp)
210810a8:	2008943a 	slli	r4,r4,16
}
210810ac:	1104b03a 	or	r2,r2,r4
210810b0:	dec00104 	addi	sp,sp,4
210810b4:	f800283a 	ret
        ib.e = 0;
        ib.bits = 8;
    }
    else{
        bitbuffer <<= 4;
        ib.e = HUFF_EXTEND(INPUT_BITS(bitbuffer,size),size);
210810b8:	00bfffc4 	movi	r2,-1
210810bc:	10c4983a 	sll	r2,r2,r3
210810c0:	10800044 	addi	r2,r2,1
210810c4:	1109883a 	add	r4,r2,r4
210810c8:	003ff306 	br	21081098 <__flash_rwdata_start+0xfffdee50>
    bitbuffer <<= 4;
    size  = INPUT_BITS(bitbuffer, 4);
    if(size == 0) {
        //return a value of 0. Notice this is ok size if size == 0, then it's either a END or ZRL,
        //and if size > 0, the amplitude cannot be 0.
        ib.e = 0;
210810cc:	0009883a 	mov	r4,zero
        ib.bits = 8;
210810d0:	00c00204 	movi	r3,8
210810d4:	003ff106 	br	2108109c <__flash_rwdata_start+0xfffdee54>

210810d8 <dma_callback>:
}

static void dma_callback(void *p_display)
{
    // output to video hardware module
	ece423_video_display_register_written_buffer((ece423_video_display*)p_display);
210810d8:	10855f41 	jmpi	210855f4 <ece423_video_display_register_written_buffer>

210810dc <mjpeg423_decode>:
	}
}

// main decoder function
void mjpeg423_decode(FAT_FILE_HANDLE file_handle, ece423_video_display* p_display, alt_msgdma_dev *read_dma_y, alt_msgdma_dev *write_dma)
{
210810dc:	deffe004 	addi	sp,sp,-128
210810e0:	dc001615 	stw	r16,88(sp)
	volatile int playback = 1;
210810e4:	00800044 	movi	r2,1
	}
}

// main decoder function
void mjpeg423_decode(FAT_FILE_HANDLE file_handle, ece423_video_display* p_display, alt_msgdma_dev *read_dma_y, alt_msgdma_dev *write_dma)
{
210810e8:	2021883a 	mov	r16,r4
	volatile int playback = 1;
	int frame_index_cpu1;
	uint message[2];
	message_t *msg = (message_t*)malloc(sizeof(message_t));
210810ec:	01000404 	movi	r4,16
	}
}

// main decoder function
void mjpeg423_decode(FAT_FILE_HANDLE file_handle, ece423_video_display* p_display, alt_msgdma_dev *read_dma_y, alt_msgdma_dev *write_dma)
{
210810f0:	dfc01f15 	stw	ra,124(sp)
210810f4:	ddc01d15 	stw	r23,116(sp)
210810f8:	dd401b15 	stw	r21,108(sp)
210810fc:	dc801815 	stw	r18,96(sp)
21081100:	df001e15 	stw	fp,120(sp)
21081104:	dd801c15 	stw	r22,112(sp)
21081108:	dd001a15 	stw	r20,104(sp)
2108110c:	dcc01915 	stw	r19,100(sp)
21081110:	dc401715 	stw	r17,92(sp)
21081114:	d9c01015 	stw	r7,64(sp)
21081118:	282f883a 	mov	r23,r5
2108111c:	d9801415 	stw	r6,80(sp)
	volatile int playback = 1;
21081120:	d8800c15 	stw	r2,48(sp)
	int frame_index_cpu1;
	uint message[2];
	message_t *msg = (message_t*)malloc(sizeof(message_t));
21081124:	108d8e80 	call	2108d8e8 <malloc>
	altera_avalon_mailbox_dev *signal_cpu1;
	altera_avalon_mailbox_dev *receive_cpu1;

	// setup the mailboxes
	signal_cpu1 = altera_avalon_mailbox_open(MAILBOX_SIMPLE_0_1_NAME, NULL, NULL);
21081128:	01000034 	movhi	r4,0
2108112c:	21000704 	addi	r4,r4,28
21081130:	000b883a 	mov	r5,zero
21081134:	000d883a 	mov	r6,zero
void mjpeg423_decode(FAT_FILE_HANDLE file_handle, ece423_video_display* p_display, alt_msgdma_dev *read_dma_y, alt_msgdma_dev *write_dma)
{
	volatile int playback = 1;
	int frame_index_cpu1;
	uint message[2];
	message_t *msg = (message_t*)malloc(sizeof(message_t));
21081138:	102b883a 	mov	r21,r2
	altera_avalon_mailbox_dev *signal_cpu1;
	altera_avalon_mailbox_dev *receive_cpu1;

	// setup the mailboxes
	signal_cpu1 = altera_avalon_mailbox_open(MAILBOX_SIMPLE_0_1_NAME, NULL, NULL);
2108113c:	109c1540 	call	2109c154 <altera_avalon_mailbox_open>
	receive_cpu1 = altera_avalon_mailbox_open(MAILBOX_SIMPLE_1_0_NAME, NULL, NULL);
21081140:	01000034 	movhi	r4,0
	message_t *msg = (message_t*)malloc(sizeof(message_t));
	altera_avalon_mailbox_dev *signal_cpu1;
	altera_avalon_mailbox_dev *receive_cpu1;

	// setup the mailboxes
	signal_cpu1 = altera_avalon_mailbox_open(MAILBOX_SIMPLE_0_1_NAME, NULL, NULL);
21081144:	1025883a 	mov	r18,r2
	receive_cpu1 = altera_avalon_mailbox_open(MAILBOX_SIMPLE_1_0_NAME, NULL, NULL);
21081148:	21000d04 	addi	r4,r4,52
2108114c:	000b883a 	mov	r5,zero
21081150:	000d883a 	mov	r6,zero
21081154:	109c1540 	call	2109c154 <altera_avalon_mailbox_open>

	if (!signal_cpu1 || !receive_cpu1)
21081158:	90019126 	beq	r18,zero,210817a0 <mjpeg423_decode+0x6c4>
2108115c:	102d883a 	mov	r22,r2
21081160:	10018f26 	beq	r2,zero,210817a0 <mjpeg423_decode+0x6c4>
	{
		fprintf(stderr, "ERROR: failed to open mailbox\n");
		return;
	}

	alt_msgdma_standard_descriptor *read_desc_y = (alt_msgdma_standard_descriptor *) malloc(sizeof(alt_msgdma_standard_descriptor));
21081164:	01000404 	movi	r4,16
21081168:	108d8e80 	call	2108d8e8 <malloc>
	alt_msgdma_standard_descriptor *write_desc = (alt_msgdma_standard_descriptor *) malloc(sizeof(alt_msgdma_standard_descriptor));
2108116c:	01000404 	movi	r4,16
	{
		fprintf(stderr, "ERROR: failed to open mailbox\n");
		return;
	}

	alt_msgdma_standard_descriptor *read_desc_y = (alt_msgdma_standard_descriptor *) malloc(sizeof(alt_msgdma_standard_descriptor));
21081170:	d8801115 	stw	r2,68(sp)
	alt_msgdma_standard_descriptor *write_desc = (alt_msgdma_standard_descriptor *) malloc(sizeof(alt_msgdma_standard_descriptor));
21081174:	108d8e80 	call	2108d8e8 <malloc>

	alt_msgdma_register_callback(write_dma, dma_callback, ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK, (void*)p_display);  // register write_dma callback to register frame
21081178:	d9001017 	ldw	r4,64(sp)
2108117c:	01484234 	movhi	r5,8456
21081180:	29443604 	addi	r5,r5,4312
21081184:	01800404 	movi	r6,16
21081188:	b80f883a 	mov	r7,r23
		fprintf(stderr, "ERROR: failed to open mailbox\n");
		return;
	}

	alt_msgdma_standard_descriptor *read_desc_y = (alt_msgdma_standard_descriptor *) malloc(sizeof(alt_msgdma_standard_descriptor));
	alt_msgdma_standard_descriptor *write_desc = (alt_msgdma_standard_descriptor *) malloc(sizeof(alt_msgdma_standard_descriptor));
2108118c:	d8801215 	stw	r2,72(sp)

	alt_msgdma_register_callback(write_dma, dma_callback, ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK, (void*)p_display);  // register write_dma callback to register frame
21081190:	109d1300 	call	2109d130 <alt_msgdma_register_callback>
#if PROFILE
    alt_u32 time;
#endif

    // good to reset
    is_pressed = NONE_PRESSED;
21081194:	008003c4 	movi	r2,15

    // read header
    if(Fat_FileRead(file_handle, &num_frames, sizeof(uint32_t)) == FALSE)
21081198:	8009883a 	mov	r4,r16
2108119c:	d9400b04 	addi	r5,sp,44
210811a0:	01800104 	movi	r6,4
#if PROFILE
    alt_u32 time;
#endif

    // good to reset
    is_pressed = NONE_PRESSED;
210811a4:	d0a01b05 	stb	r2,-32660(gp)

    // read header
    if(Fat_FileRead(file_handle, &num_frames, sizeof(uint32_t)) == FALSE)
210811a8:	10826d40 	call	210826d4 <Fat_FileRead>
210811ac:	10019626 	beq	r2,zero,21081808 <mjpeg423_decode+0x72c>
    }
#if DEBUG
    DEBUG_PRINT_ARG("Decoder start. Num frames #%u\n", num_frames)
#endif

    if(Fat_FileRead(file_handle, &w_size, sizeof(uint32_t)) == FALSE)
210811b0:	8009883a 	mov	r4,r16
210811b4:	d9400a04 	addi	r5,sp,40
210811b8:	01800104 	movi	r6,4
210811bc:	10826d40 	call	210826d4 <Fat_FileRead>
210811c0:	10018d26 	beq	r2,zero,210817f8 <mjpeg423_decode+0x71c>
    }
#if DEBUG
    DEBUG_PRINT_ARG("Width %u\n", w_size)
#endif

    if(Fat_FileRead(file_handle, &h_size, sizeof(uint32_t)) == FALSE)
210811c4:	8009883a 	mov	r4,r16
210811c8:	d9400904 	addi	r5,sp,36
210811cc:	01800104 	movi	r6,4
210811d0:	10826d40 	call	210826d4 <Fat_FileRead>
210811d4:	10018426 	beq	r2,zero,210817e8 <mjpeg423_decode+0x70c>
    }
#if DEBUG
    DEBUG_PRINT_ARG("Height %u\n", h_size)
#endif

    if(Fat_FileRead(file_handle, &num_iframes, sizeof(uint32_t)) == FALSE)
210811d8:	8009883a 	mov	r4,r16
210811dc:	d9400804 	addi	r5,sp,32
210811e0:	01800104 	movi	r6,4
210811e4:	10826d40 	call	210826d4 <Fat_FileRead>
210811e8:	10017b26 	beq	r2,zero,210817d8 <mjpeg423_decode+0x6fc>
    }
#if DEBUG
    DEBUG_PRINT_ARG("Num i frames %u\n", num_iframes)
#endif

    if(Fat_FileRead(file_handle, &payload_size, sizeof(uint32_t)) == FALSE)
210811ec:	8009883a 	mov	r4,r16
210811f0:	d9400704 	addi	r5,sp,28
210811f4:	01800104 	movi	r6,4
210811f8:	10826d40 	call	210826d4 <Fat_FileRead>
210811fc:	10017226 	beq	r2,zero,210817c8 <mjpeg423_decode+0x6ec>
    {
    	error_and_exit("cannot read input file");
    }

    int hCb_size = h_size/8;           // number of chrominance blocks
21081200:	dc400917 	ldw	r17,36(sp)
    int wCb_size = w_size/8;
21081204:	dcc00a17 	ldw	r19,40(sp)
    msg->block_size = hCb_size * wCb_size;

    // give cpu1 block size so it can do its allocations
	message[0] = 0;
	message[1] = msg;
	printf("Sending blocksize.number %d, size %d  \n", message[0], msg->block_size);
21081208:	01000034 	movhi	r4,0
    if(Fat_FileRead(file_handle, &payload_size, sizeof(uint32_t)) == FALSE)
    {
    	error_and_exit("cannot read input file");
    }

    int hCb_size = h_size/8;           // number of chrominance blocks
2108120c:	8822d0fa 	srli	r17,r17,3
    int wCb_size = w_size/8;
21081210:	9826d0fa 	srli	r19,r19,3
    msg->block_size = hCb_size * wCb_size;

    // give cpu1 block size so it can do its allocations
	message[0] = 0;
	message[1] = msg;
	printf("Sending blocksize.number %d, size %d  \n", message[0], msg->block_size);
21081214:	21002104 	addi	r4,r4,132
21081218:	000b883a 	mov	r5,zero
    int hCb_size = h_size/8;           // number of chrominance blocks
    int wCb_size = w_size/8;
    int hYb_size = h_size/8;           // number of luminance blocks. Same as chrominance in the sample app
    int wYb_size = w_size/8;
    
    msg->block_size = hCb_size * wCb_size;
2108121c:	8cf9383a 	mul	fp,r17,r19

    // give cpu1 block size so it can do its allocations
	message[0] = 0;
21081220:	d8000115 	stw	zero,4(sp)
	message[1] = msg;
21081224:	dd400215 	stw	r21,8(sp)
	printf("Sending blocksize.number %d, size %d  \n", message[0], msg->block_size);
21081228:	e00d883a 	mov	r6,fp
    int hCb_size = h_size/8;           // number of chrominance blocks
    int wCb_size = w_size/8;
    int hYb_size = h_size/8;           // number of luminance blocks. Same as chrominance in the sample app
    int wYb_size = w_size/8;
    
    msg->block_size = hCb_size * wCb_size;
2108122c:	af000315 	stw	fp,12(r21)

    // give cpu1 block size so it can do its allocations
	message[0] = 0;
	message[1] = msg;
	printf("Sending blocksize.number %d, size %d  \n", message[0], msg->block_size);
21081230:	108e3bc0 	call	2108e3bc <printf>

	// flush cache
	alt_dcache_flush_all();
21081234:	109b19c0 	call	2109b19c <alt_dcache_flush_all>
	while (altera_avalon_mailbox_send(signal_cpu1, message, 0, POLL));
21081238:	9009883a 	mov	r4,r18
2108123c:	d9400104 	addi	r5,sp,4
21081240:	000d883a 	mov	r6,zero
21081244:	01c00044 	movi	r7,1
21081248:	109c3800 	call	2109c380 <altera_avalon_mailbox_send>
2108124c:	103ffa1e 	bne	r2,zero,21081238 <__flash_rwdata_start+0xfffdeff0>

	//waiting for reply
	while (1)
			{
				altera_avalon_mailbox_retrieve_poll(receive_cpu1, message, 0);
21081250:	b009883a 	mov	r4,r22
21081254:	d9400104 	addi	r5,sp,4
21081258:	000d883a 	mov	r6,zero
2108125c:	109c4cc0 	call	2109c4cc <altera_avalon_mailbox_retrieve_poll>
				}
				else
				{
//					alt_dcache_flush_all();
					frame_index_cpu1 = message[0];
					printf("Receive blocksize reply Size:%d, index: %d \n", msg->block_size,  message[0]);
21081260:	a9400317 	ldw	r5,12(r21)
21081264:	d9800117 	ldw	r6,4(sp)
21081268:	01000034 	movhi	r4,0
2108126c:	21002b04 	addi	r4,r4,172
21081270:	108e3bc0 	call	2108e3bc <printf>
					break;
				}
			}

    // trailer structure
    iframe_trailer_t* trailer = (iframe_trailer_t*)malloc(sizeof(iframe_trailer_t)*num_iframes);
21081274:	d9000817 	ldw	r4,32(sp)
21081278:	200890fa 	slli	r4,r4,3
2108127c:	108d8e80 	call	2108d8e8 <malloc>
    
    // main data structures. See lab manual for explanation
    alt_u32* p_buffer;
    dct_block_t* YDCAC;
    if((YDCAC = (dct_block_t*)memalign(128, hYb_size * wYb_size * 64 * sizeof(DCTELEM))) == NULL)
21081280:	e00a91fa 	slli	r5,fp,7
21081284:	01002004 	movi	r4,128
					break;
				}
			}

    // trailer structure
    iframe_trailer_t* trailer = (iframe_trailer_t*)malloc(sizeof(iframe_trailer_t)*num_iframes);
21081288:	1029883a 	mov	r20,r2
    
    // main data structures. See lab manual for explanation
    alt_u32* p_buffer;
    dct_block_t* YDCAC;
    if((YDCAC = (dct_block_t*)memalign(128, hYb_size * wYb_size * 64 * sizeof(DCTELEM))) == NULL)
2108128c:	108d7180 	call	2108d718 <memalign>
21081290:	d8800e15 	stw	r2,56(sp)
21081294:	10017826 	beq	r2,zero,21081878 <mjpeg423_decode+0x79c>

    // Ybitstream is assigned a size sufficient to hold all bistreams
    // the bitstream is then read from the file into Ybitstream
    // the remaining pointers simply point to the beginning of the Cb and Cr streams within Ybitstream
    uint8_t* Ybitstream;
    if((Ybitstream = malloc(hYb_size * wYb_size * 64 * sizeof(DCTELEM) + 2 * hCb_size * wCb_size * 64 * sizeof(DCTELEM))) == NULL)
21081298:	882291fa 	slli	r17,r17,7
2108129c:	e00891ba 	slli	r4,fp,6
210812a0:	8ce3383a 	mul	r17,r17,r19
210812a4:	8909883a 	add	r4,r17,r4
210812a8:	2109883a 	add	r4,r4,r4
210812ac:	dc401315 	stw	r17,76(sp)
210812b0:	108d8e80 	call	2108d8e8 <malloc>
210812b4:	d8800d15 	stw	r2,52(sp)
210812b8:	10016b26 	beq	r2,zero,21081868 <mjpeg423_decode+0x78c>
    	error_and_exit("cannot allocate bitstream");
    }
    
    // read trailer. Note: the trailer information is not used in the sample decoder app
    // set file to beginning of trailer
    if(Fat_FileSeek(file_handle, FILE_SEEK_BEGIN, 5 * sizeof(uint32_t) + payload_size) == FALSE)
210812bc:	d9800717 	ldw	r6,28(sp)
210812c0:	8009883a 	mov	r4,r16
210812c4:	000b883a 	mov	r5,zero
210812c8:	31800504 	addi	r6,r6,20
210812cc:	1082a280 	call	21082a28 <Fat_FileSeek>
210812d0:	10015526 	beq	r2,zero,21081828 <mjpeg423_decode+0x74c>
    {
    	error_and_exit("cannot seek into file");
    }
    for(int count = 0; count < num_iframes; count++)
210812d4:	d8800817 	ldw	r2,32(sp)
210812d8:	10001b26 	beq	r2,zero,21081348 <mjpeg423_decode+0x26c>
210812dc:	a023883a 	mov	r17,r20
210812e0:	0027883a 	mov	r19,zero
210812e4:	00000806 	br	21081308 <mjpeg423_decode+0x22c>
    {
        if(Fat_FileRead(file_handle, &(trailer[count].frame_index), sizeof(uint32_t)) == FALSE) error_and_exit("cannot read input file");
        if(Fat_FileRead(file_handle, &(trailer[count].frame_position), sizeof(uint32_t)) == FALSE) error_and_exit("cannot read input file");
210812e8:	89400104 	addi	r5,r17,4
210812ec:	8009883a 	mov	r4,r16
210812f0:	01800104 	movi	r6,4
210812f4:	10826d40 	call	210826d4 <Fat_FileRead>
210812f8:	10000d26 	beq	r2,zero,21081330 <mjpeg423_decode+0x254>
    // set file to beginning of trailer
    if(Fat_FileSeek(file_handle, FILE_SEEK_BEGIN, 5 * sizeof(uint32_t) + payload_size) == FALSE)
    {
    	error_and_exit("cannot seek into file");
    }
    for(int count = 0; count < num_iframes; count++)
210812fc:	d8800817 	ldw	r2,32(sp)
21081300:	8c400204 	addi	r17,r17,8
21081304:	9880102e 	bgeu	r19,r2,21081348 <mjpeg423_decode+0x26c>
    {
        if(Fat_FileRead(file_handle, &(trailer[count].frame_index), sizeof(uint32_t)) == FALSE) error_and_exit("cannot read input file");
21081308:	880b883a 	mov	r5,r17
2108130c:	8009883a 	mov	r4,r16
21081310:	01800104 	movi	r6,4
21081314:	10826d40 	call	210826d4 <Fat_FileRead>
    // set file to beginning of trailer
    if(Fat_FileSeek(file_handle, FILE_SEEK_BEGIN, 5 * sizeof(uint32_t) + payload_size) == FALSE)
    {
    	error_and_exit("cannot seek into file");
    }
    for(int count = 0; count < num_iframes; count++)
21081318:	9cc00044 	addi	r19,r19,1
    {
        if(Fat_FileRead(file_handle, &(trailer[count].frame_index), sizeof(uint32_t)) == FALSE) error_and_exit("cannot read input file");
2108131c:	103ff21e 	bne	r2,zero,210812e8 <__flash_rwdata_start+0xfffdf0a0>
21081320:	01000034 	movhi	r4,0
21081324:	21001b04 	addi	r4,r4,108
21081328:	10801dc0 	call	210801dc <error_and_exit>
2108132c:	003fee06 	br	210812e8 <__flash_rwdata_start+0xfffdf0a0>
        if(Fat_FileRead(file_handle, &(trailer[count].frame_position), sizeof(uint32_t)) == FALSE) error_and_exit("cannot read input file");
21081330:	01000034 	movhi	r4,0
21081334:	21001b04 	addi	r4,r4,108
21081338:	10801dc0 	call	210801dc <error_and_exit>
    // set file to beginning of trailer
    if(Fat_FileSeek(file_handle, FILE_SEEK_BEGIN, 5 * sizeof(uint32_t) + payload_size) == FALSE)
    {
    	error_and_exit("cannot seek into file");
    }
    for(int count = 0; count < num_iframes; count++)
2108133c:	d8800817 	ldw	r2,32(sp)
21081340:	8c400204 	addi	r17,r17,8
21081344:	98bff036 	bltu	r19,r2,21081308 <__flash_rwdata_start+0xfffdf0c0>
        DEBUG_PRINT_ARG("I frame index %u, ", trailer[count].frame_index)
        DEBUG_PRINT_ARG("position %u\n", trailer[count].frame_position)
#endif
    }
    // set it back to beginning of payload
    if(Fat_FileSeek(file_handle, FILE_SEEK_BEGIN, 5 * sizeof(uint32_t)) == FALSE)
21081348:	8009883a 	mov	r4,r16
2108134c:	000b883a 	mov	r5,zero
21081350:	01800504 	movi	r6,20
21081354:	1082a280 	call	21082a28 <Fat_FileSeek>
21081358:	10012f26 	beq	r2,zero,21081818 <mjpeg423_decode+0x73c>
    {
    	error_and_exit("cannot seek into file");
    }
    
    // read and decode frames
    for(int frame_index = 0; frame_index < num_frames; frame_index ++)
2108135c:	d8800b17 	ldw	r2,44(sp)
21081360:	0023883a 	mov	r17,zero
21081364:	1000a426 	beq	r2,zero,210815f8 <mjpeg423_decode+0x51c>
21081368:	a0c00404 	addi	r3,r20,16
2108136c:	d8c00f15 	stw	r3,60(sp)
#if PROFILE_SD_READ
    	alt_timestamp_start();
#endif

        // read frame payload
        if(Fat_FileRead(file_handle, &frame_size, sizeof(uint32_t)) == FALSE)
21081370:	df001515 	stw	fp,84(sp)
    // read and decode frames
    for(int frame_index = 0; frame_index < num_frames; frame_index ++)
    {
    	do
    	{
			switch(is_pressed)
21081374:	04c00084 	movi	r19,2
21081378:	07000104 	movi	fp,4
2108137c:	d0a01b03 	ldbu	r2,-32660(gp)
21081380:	10803fcc 	andi	r2,r2,255
21081384:	14c0c726 	beq	r2,r19,210816a4 <mjpeg423_decode+0x5c8>
21081388:	9880b92e 	bgeu	r19,r2,21081670 <mjpeg423_decode+0x594>
2108138c:	1700cb26 	beq	r2,fp,210816bc <mjpeg423_decode+0x5e0>
21081390:	00c00204 	movi	r3,8
21081394:	10c0251e 	bne	r2,r3,2108142c <mjpeg423_decode+0x350>
					break;
				}
				// Rewind
				case BUTTON_3:
				{
					printf("Rewind\n");
21081398:	01000034 	movhi	r4,0
2108139c:	21005304 	addi	r4,r4,332
210813a0:	108e4c00 	call	2108e4c0 <puts>
#define DEBUG 0

static iframe_trailer_t *closest_iframe_index(iframe_trailer_t *trailer, int num_iframes, int frame_index)
{
	int closest_index = 0;
	int closest_distance = abs(frame_index - trailer[0].frame_index);
210813a4:	a0800017 	ldw	r2,0(r20)
				}
				// Rewind
				case BUTTON_3:
				{
					printf("Rewind\n");
					frame_index = jump_to_iframe(file_handle, closest_iframe_index(trailer, num_iframes, frame_index - FRAME_RATE * 5));
210813a8:	8c7fe204 	addi	r17,r17,-120
210813ac:	d9c00817 	ldw	r7,32(sp)
#define DEBUG 0

static iframe_trailer_t *closest_iframe_index(iframe_trailer_t *trailer, int num_iframes, int frame_index)
{
	int closest_index = 0;
	int closest_distance = abs(frame_index - trailer[0].frame_index);
210813b0:	8885c83a 	sub	r2,r17,r2
210813b4:	10012416 	blt	r2,zero,21081848 <mjpeg423_decode+0x76c>

	for (int i = 1; i < num_iframes; i++)
210813b8:	00c00044 	movi	r3,1
210813bc:	19c1260e 	bge	r3,r7,21081858 <mjpeg423_decode+0x77c>
	{
		int current_distance = abs(frame_index - trailer[i].frame_index);
210813c0:	a1800217 	ldw	r6,8(r20)
210813c4:	898dc83a 	sub	r6,r17,r6
210813c8:	30011b16 	blt	r6,zero,21081838 <mjpeg423_decode+0x75c>

		// Should always be shrinking, otherwise we found the closest one already
		if (current_distance > closest_distance)
210813cc:	11812216 	blt	r2,r6,21081858 <mjpeg423_decode+0x77c>
210813d0:	01400044 	movi	r5,1
static iframe_trailer_t *closest_iframe_index(iframe_trailer_t *trailer, int num_iframes, int frame_index)
{
	int closest_index = 0;
	int closest_distance = abs(frame_index - trailer[0].frame_index);

	for (int i = 1; i < num_iframes; i++)
210813d4:	29000044 	addi	r4,r5,1
210813d8:	d8c00f17 	ldw	r3,60(sp)
210813dc:	39000926 	beq	r7,r4,21081404 <mjpeg423_decode+0x328>
	{
		int current_distance = abs(frame_index - trailer[i].frame_index);
210813e0:	18800017 	ldw	r2,0(r3)
210813e4:	18c00204 	addi	r3,r3,8
210813e8:	8885c83a 	sub	r2,r17,r2
210813ec:	10009e16 	blt	r2,zero,21081668 <mjpeg423_decode+0x58c>

		// Should always be shrinking, otherwise we found the closest one already
		if (current_distance > closest_distance)
210813f0:	30800416 	blt	r6,r2,21081404 <mjpeg423_decode+0x328>
210813f4:	200b883a 	mov	r5,r4
static iframe_trailer_t *closest_iframe_index(iframe_trailer_t *trailer, int num_iframes, int frame_index)
{
	int closest_index = 0;
	int closest_distance = abs(frame_index - trailer[0].frame_index);

	for (int i = 1; i < num_iframes; i++)
210813f8:	29000044 	addi	r4,r5,1
	{
		int current_distance = abs(frame_index - trailer[i].frame_index);

		// Should always be shrinking, otherwise we found the closest one already
		if (current_distance > closest_distance)
210813fc:	100d883a 	mov	r6,r2
static iframe_trailer_t *closest_iframe_index(iframe_trailer_t *trailer, int num_iframes, int frame_index)
{
	int closest_index = 0;
	int closest_distance = abs(frame_index - trailer[0].frame_index);

	for (int i = 1; i < num_iframes; i++)
21081400:	393ff71e 	bne	r7,r4,210813e0 <__flash_rwdata_start+0xfffdf198>
21081404:	280a90fa 	slli	r5,r5,3

		closest_distance = current_distance;
		closest_index = i;
	}

	return &trailer[closest_index];
21081408:	a163883a 	add	r17,r20,r5
}

// Returns frame number that we jumped to, -1 for error
static int jump_to_iframe(FAT_FILE_HANDLE file_handle, iframe_trailer_t *iframe)
{
	if (Fat_FileSeek(file_handle, FILE_SEEK_BEGIN, iframe->frame_position) == FALSE)
2108140c:	89800117 	ldw	r6,4(r17)
21081410:	8009883a 	mov	r4,r16
21081414:	000b883a 	mov	r5,zero
21081418:	1082a280 	call	21082a28 <Fat_FileSeek>
2108141c:	1000d426 	beq	r2,zero,21081770 <mjpeg423_decode+0x694>
	{
		error_and_exit("cannot seek into file");
	}
	return iframe->frame_index;
21081420:	8c400017 	ldw	r17,0(r17)
				// Rewind
				case BUTTON_3:
				{
					printf("Rewind\n");
					frame_index = jump_to_iframe(file_handle, closest_iframe_index(trailer, num_iframes, frame_index - FRAME_RATE * 5));
					is_pressed = NONE_PRESSED;
21081424:	008003c4 	movi	r2,15
21081428:	d0a01b05 	stb	r2,-32660(gp)
				default:
				{
					break;
				}
			}
    	} while (!playback);
2108142c:	d8800c17 	ldw	r2,48(sp)
21081430:	103fd226 	beq	r2,zero,2108137c <__flash_rwdata_start+0xfffdf134>
#if PROFILE_SD_READ
    	alt_timestamp_start();
#endif

        // read frame payload
        if(Fat_FileRead(file_handle, &frame_size, sizeof(uint32_t)) == FALSE)
21081434:	8009883a 	mov	r4,r16
21081438:	d9400404 	addi	r5,sp,16
2108143c:	01800104 	movi	r6,4
21081440:	10826d40 	call	210826d4 <Fat_FileRead>
21081444:	10013d26 	beq	r2,zero,2108193c <mjpeg423_decode+0x860>
		}
#if DEBUG
        DEBUG_PRINT_ARG("Frame_size %u\n", frame_size)
#endif

        if(Fat_FileRead(file_handle, &frame_type, sizeof(uint32_t)) == FALSE)
21081448:	8009883a 	mov	r4,r16
2108144c:	d9400304 	addi	r5,sp,12
21081450:	01800104 	movi	r6,4
21081454:	10826d40 	call	210826d4 <Fat_FileRead>
21081458:	10013426 	beq	r2,zero,2108192c <mjpeg423_decode+0x850>
        }
#if DEBUG
        DEBUG_PRINT_ARG("Frame_type %u\n", frame_type)
#endif

        if(Fat_FileRead(file_handle, &Ysize, sizeof(uint32_t)) == FALSE)
2108145c:	8009883a 	mov	r4,r16
21081460:	d9400604 	addi	r5,sp,24
21081464:	01800104 	movi	r6,4
21081468:	10826d40 	call	210826d4 <Fat_FileRead>
2108146c:	10012b26 	beq	r2,zero,2108191c <mjpeg423_decode+0x840>
        {
        	error_and_exit("cannot read input file");
        }
        if(Fat_FileRead(file_handle, &Cbsize, sizeof(uint32_t)) == FALSE)
21081470:	8009883a 	mov	r4,r16
21081474:	d9400504 	addi	r5,sp,20
21081478:	01800104 	movi	r6,4
2108147c:	10826d40 	call	210826d4 <Fat_FileRead>
21081480:	10012226 	beq	r2,zero,2108190c <mjpeg423_decode+0x830>
        {
        	error_and_exit("cannot read input file");
        }
        if(Fat_FileRead(file_handle, Ybitstream, frame_size - 4 * sizeof(uint32_t)) == FALSE)
21081484:	d9800417 	ldw	r6,16(sp)
21081488:	d9400d17 	ldw	r5,52(sp)
2108148c:	8009883a 	mov	r4,r16
21081490:	31bffc04 	addi	r6,r6,-16
21081494:	10826d40 	call	210826d4 <Fat_FileRead>
21081498:	10011826 	beq	r2,zero,210818fc <mjpeg423_decode+0x820>
    	time = alt_timestamp();
    	printf("%u\n", time);
#endif

    	// get bit streams
    	Cbbitstream = Ybitstream + Ysize;
2108149c:	d8c00d17 	ldw	r3,52(sp)
210814a0:	d8800617 	ldw	r2,24(sp)

        // lossless decoding
        // signal cpu1 to decode Cb/Cr
		message[0] = frame_index;
		message[1] = msg;
		printf("Sending frame.  number: %d, Cb: %d \n", frame_index, msg->Cbbitstream);
210814a4:	01000034 	movhi	r4,0
210814a8:	21005504 	addi	r4,r4,340
    	time = alt_timestamp();
    	printf("%u\n", time);
#endif

    	// get bit streams
    	Cbbitstream = Ybitstream + Ysize;
210814ac:	1885883a 	add	r2,r3,r2
    	Crbitstream = Cbbitstream + Cbsize;
210814b0:	d8c00517 	ldw	r3,20(sp)

        // lossless decoding
        // signal cpu1 to decode Cb/Cr
		message[0] = frame_index;
		message[1] = msg;
		printf("Sending frame.  number: %d, Cb: %d \n", frame_index, msg->Cbbitstream);
210814b4:	100d883a 	mov	r6,r2
    	// get bit streams
    	Cbbitstream = Ybitstream + Ysize;
    	Crbitstream = Cbbitstream + Cbsize;

        // populate message
        msg->Cbbitstream = Cbbitstream;
210814b8:	a8800015 	stw	r2,0(r21)
    	printf("%u\n", time);
#endif

    	// get bit streams
    	Cbbitstream = Ybitstream + Ysize;
    	Crbitstream = Cbbitstream + Cbsize;
210814bc:	10c7883a 	add	r3,r2,r3

        // populate message
        msg->Cbbitstream = Cbbitstream;
        msg->Crbitstream = Crbitstream;
        msg->frame_type  = frame_type;
210814c0:	d8800317 	ldw	r2,12(sp)

        // lossless decoding
        // signal cpu1 to decode Cb/Cr
		message[0] = frame_index;
		message[1] = msg;
		printf("Sending frame.  number: %d, Cb: %d \n", frame_index, msg->Cbbitstream);
210814c4:	880b883a 	mov	r5,r17
    	Cbbitstream = Ybitstream + Ysize;
    	Crbitstream = Cbbitstream + Cbsize;

        // populate message
        msg->Cbbitstream = Cbbitstream;
        msg->Crbitstream = Crbitstream;
210814c8:	a8c00115 	stw	r3,4(r21)
        msg->frame_type  = frame_type;
210814cc:	a8800215 	stw	r2,8(r21)

        // lossless decoding
        // signal cpu1 to decode Cb/Cr
		message[0] = frame_index;
210814d0:	dc400115 	stw	r17,4(sp)
		message[1] = msg;
210814d4:	dd400215 	stw	r21,8(sp)
		printf("Sending frame.  number: %d, Cb: %d \n", frame_index, msg->Cbbitstream);
210814d8:	108e3bc0 	call	2108e3bc <printf>
		alt_dcache_flush_all();
210814dc:	109b19c0 	call	2109b19c <alt_dcache_flush_all>
		while (altera_avalon_mailbox_send(signal_cpu1, message, 0, POLL));
210814e0:	9009883a 	mov	r4,r18
210814e4:	d9400104 	addi	r5,sp,4
210814e8:	000d883a 	mov	r6,zero
210814ec:	01c00044 	movi	r7,1
210814f0:	109c3800 	call	2109c380 <altera_avalon_mailbox_send>
210814f4:	103ffa1e 	bne	r2,zero,210814e0 <__flash_rwdata_start+0xfffdf298>
        lossless_decode(hYb_size * wYb_size, Ybitstream, YDCAC, Yquant, frame_type);
210814f8:	d8800317 	ldw	r2,12(sp)
210814fc:	d9001517 	ldw	r4,84(sp)
21081500:	d9400d17 	ldw	r5,52(sp)
21081504:	d9800e17 	ldw	r6,56(sp)
21081508:	01c00034 	movhi	r7,0
2108150c:	39d02c04 	addi	r7,r7,16560
21081510:	d8800015 	stw	r2,0(sp)
21081514:	10809200 	call	21080920 <lossless_decode>

		// get free buffer
		while (ece423_video_display_buffer_is_available(p_display) != 0) {};
21081518:	b809883a 	mov	r4,r23
2108151c:	10855980 	call	21085598 <ece423_video_display_buffer_is_available>
21081520:	103ffd1e 	bne	r2,zero,21081518 <__flash_rwdata_start+0xfffdf2d0>
		p_buffer = ece423_video_display_get_buffer(p_display);
21081524:	b809883a 	mov	r4,r23
21081528:	10855d40 	call	210855d4 <ece423_video_display_get_buffer>
2108152c:	1027883a 	mov	r19,r2
        // idct
#if PROFILE_IDCT_FRAME
        alt_timestamp_start();
#endif
        // flush cache
        alt_dcache_flush_all();
21081530:	109b19c0 	call	2109b19c <alt_dcache_flush_all>

static void dma_read(alt_msgdma_dev *device, alt_msgdma_standard_descriptor *descriptor, alt_u32 *address, alt_u32 len, bool is_sync)
{
	int ret;

	ret = alt_msgdma_construct_standard_mm_to_st_descriptor(device, descriptor, address, len, 0);
21081534:	d9001417 	ldw	r4,80(sp)
21081538:	d9401117 	ldw	r5,68(sp)
2108153c:	d9800e17 	ldw	r6,56(sp)
21081540:	d9c01317 	ldw	r7,76(sp)
21081544:	d8000015 	stw	zero,0(sp)
21081548:	109c6ec0 	call	2109c6ec <alt_msgdma_construct_standard_mm_to_st_descriptor>
	if (ret != 0)
2108154c:	1000e11e 	bne	r2,zero,210818d4 <mjpeg423_decode+0x7f8>
	{
		fprintf(stderr, "ERROR CPU0: dma_read can't make descriptor\n");
	}

	ret = is_sync ? alt_msgdma_standard_descriptor_sync_transfer(device, descriptor) : alt_msgdma_standard_descriptor_async_transfer(device, descriptor);
21081550:	d9001417 	ldw	r4,80(sp)
21081554:	d9401117 	ldw	r5,68(sp)
21081558:	109d1400 	call	2109d140 <alt_msgdma_standard_descriptor_async_transfer>
	if (ret != 0)
2108155c:	1000ca1e 	bne	r2,zero,21081888 <mjpeg423_decode+0x7ac>
	{
		fprintf(stderr, "ERROR CPU0: dma_read can't transfer: %d\n", ret);
	}
	else
	{
		printf("CPU0: dma_read success.\n");
21081560:	01000034 	movhi	r4,0
21081564:	21007504 	addi	r4,r4,468
21081568:	108e4c00 	call	2108e4c0 <puts>

static void dma_write(alt_msgdma_dev *device, alt_msgdma_standard_descriptor *descriptor, alt_u32 *address, alt_u32 len, bool is_sync)
{
	int ret;

	ret = alt_msgdma_construct_standard_st_to_mm_descriptor(device, descriptor, address, len, 0);
2108156c:	d9001017 	ldw	r4,64(sp)
21081570:	d9401217 	ldw	r5,72(sp)
21081574:	d8000015 	stw	zero,0(sp)
21081578:	980d883a 	mov	r6,r19
2108157c:	01c20004 	movi	r7,2048
21081580:	109c6b40 	call	2109c6b4 <alt_msgdma_construct_standard_st_to_mm_descriptor>
	if (ret != 0)
21081584:	1000c91e 	bne	r2,zero,210818ac <mjpeg423_decode+0x7d0>
	{
		fprintf(stderr, "ERROR CPU0: dma_write can't make descriptor\n");
	}

	ret = is_sync ? alt_msgdma_standard_descriptor_sync_transfer(device, descriptor) : alt_msgdma_standard_descriptor_async_transfer(device, descriptor);
21081588:	d9001017 	ldw	r4,64(sp)
2108158c:	d9401217 	ldw	r5,72(sp)
21081590:	109d1400 	call	2109d140 <alt_msgdma_standard_descriptor_async_transfer>
	if (ret != 0)
21081594:	10000826 	beq	r2,zero,210815b8 <mjpeg423_decode+0x4dc>
	{
		fprintf(stderr, "ERROR CPU0: dma_write can't transfer: %d\n", ret);
21081598:	01000034 	movhi	r4,0
2108159c:	21176b04 	addi	r4,r4,23980
210815a0:	20c00017 	ldw	r3,0(r4)
210815a4:	01400034 	movhi	r5,0
210815a8:	29408704 	addi	r5,r5,540
210815ac:	19000317 	ldw	r4,12(r3)
210815b0:	100d883a 	mov	r6,r2
210815b4:	108d5e80 	call	2108d5e8 <fprintf>

#if PROFILE_IDCT_FRAME
        time = alt_timestamp();
        printf("%u\n", time);
#endif
        printf("waiting for frame # %d ,\n", frame_index);
210815b8:	01000034 	movhi	r4,0
210815bc:	880b883a 	mov	r5,r17
210815c0:	21009204 	addi	r4,r4,584
210815c4:	108e3bc0 	call	2108e3bc <printf>
		// wait for message from cpu1 saying it's done
        while (1)
		{
			altera_avalon_mailbox_retrieve_poll(receive_cpu1, message, 0);
210815c8:	b009883a 	mov	r4,r22
210815cc:	d9400104 	addi	r5,sp,4
210815d0:	000d883a 	mov	r6,zero
210815d4:	109c4cc0 	call	2109c4cc <altera_avalon_mailbox_retrieve_poll>
			{
				printf("Receive Error\n");
			}
			else
			{
				alt_dcache_flush_all();
210815d8:	109b19c0 	call	2109b19c <alt_dcache_flush_all>
				frame_index_cpu1 = message[0];
				printf("received frame index %d \n", message[0]);
210815dc:	d9400117 	ldw	r5,4(sp)
210815e0:	01000034 	movhi	r4,0
210815e4:	21009904 	addi	r4,r4,612
210815e8:	108e3bc0 	call	2108e3bc <printf>
    {
    	error_and_exit("cannot seek into file");
    }
    
    // read and decode frames
    for(int frame_index = 0; frame_index < num_frames; frame_index ++)
210815ec:	d8800b17 	ldw	r2,44(sp)
210815f0:	8c400044 	addi	r17,r17,1
210815f4:	88bf5f36 	bltu	r17,r2,21081374 <__flash_rwdata_start+0xfffdf12c>
    DEBUG_PRINT("\nDecoder done.\n\n\n")
#endif
    
exit_decode:
    // clean up
    ece423_video_display_discard_buffered_frames(p_display);
210815f8:	b809883a 	mov	r4,r23
210815fc:	10856d80 	call	210856d8 <ece423_video_display_discard_buffered_frames>

	altera_avalon_mailbox_close(signal_cpu1);
21081600:	9009883a 	mov	r4,r18
21081604:	109c2a00 	call	2109c2a0 <altera_avalon_mailbox_close>
    altera_avalon_mailbox_close(receive_cpu1);
21081608:	b009883a 	mov	r4,r22
2108160c:	109c2a00 	call	2109c2a0 <altera_avalon_mailbox_close>

    free(YDCAC);
21081610:	d9000e17 	ldw	r4,56(sp)
21081614:	108d8fc0 	call	2108d8fc <free>
    free(Ybitstream);
21081618:	d9000d17 	ldw	r4,52(sp)
2108161c:	108d8fc0 	call	2108d8fc <free>

    free(msg);
21081620:	a809883a 	mov	r4,r21
21081624:	108d8fc0 	call	2108d8fc <free>
    free(read_desc_y);
21081628:	d9001117 	ldw	r4,68(sp)
2108162c:	108d8fc0 	call	2108d8fc <free>
    free(write_desc);
21081630:	d9001217 	ldw	r4,72(sp)
21081634:	108d8fc0 	call	2108d8fc <free>

    return;
}
21081638:	dfc01f17 	ldw	ra,124(sp)
2108163c:	df001e17 	ldw	fp,120(sp)
21081640:	ddc01d17 	ldw	r23,116(sp)
21081644:	dd801c17 	ldw	r22,112(sp)
21081648:	dd401b17 	ldw	r21,108(sp)
2108164c:	dd001a17 	ldw	r20,104(sp)
21081650:	dcc01917 	ldw	r19,100(sp)
21081654:	dc801817 	ldw	r18,96(sp)
21081658:	dc401717 	ldw	r17,92(sp)
2108165c:	dc001617 	ldw	r16,88(sp)
21081660:	dec02004 	addi	sp,sp,128
21081664:	f800283a 	ret
	int closest_index = 0;
	int closest_distance = abs(frame_index - trailer[0].frame_index);

	for (int i = 1; i < num_iframes; i++)
	{
		int current_distance = abs(frame_index - trailer[i].frame_index);
21081668:	0085c83a 	sub	r2,zero,r2
2108166c:	003f6006 	br	210813f0 <__flash_rwdata_start+0xfffdf1a8>
    // read and decode frames
    for(int frame_index = 0; frame_index < num_frames; frame_index ++)
    {
    	do
    	{
			switch(is_pressed)
21081670:	00c00044 	movi	r3,1
21081674:	10ff6d1e 	bne	r2,r3,2108142c <__flash_rwdata_start+0xfffdf1e4>
			{
				// Play/Pause
				case BUTTON_0:
				{
					printf("Play/Pause\n");
21081678:	01000034 	movhi	r4,0
2108167c:	21004a04 	addi	r4,r4,296
21081680:	108e4c00 	call	2108e4c0 <puts>
					is_pressed = NONE_PRESSED;
21081684:	008003c4 	movi	r2,15
21081688:	d0a01b05 	stb	r2,-32660(gp)
					playback = !playback;
2108168c:	d8800c17 	ldw	r2,48(sp)
21081690:	1005003a 	cmpeq	r2,r2,zero
21081694:	d8800c15 	stw	r2,48(sp)
				default:
				{
					break;
				}
			}
    	} while (!playback);
21081698:	d8800c17 	ldw	r2,48(sp)
2108169c:	103f3726 	beq	r2,zero,2108137c <__flash_rwdata_start+0xfffdf134>
210816a0:	003f6406 	br	21081434 <__flash_rwdata_start+0xfffdf1ec>
					break;
				}
				// Stop
				case BUTTON_1:
				{
					printf("Stop\n");
210816a4:	01000034 	movhi	r4,0
210816a8:	21004d04 	addi	r4,r4,308
210816ac:	108e4c00 	call	2108e4c0 <puts>
					is_pressed = NONE_PRESSED;
210816b0:	008003c4 	movi	r2,15
210816b4:	d0a01b05 	stb	r2,-32660(gp)

					goto exit_decode;
210816b8:	003fcf06 	br	210815f8 <__flash_rwdata_start+0xfffdf3b0>
				}
				// Fast forward
				case BUTTON_2:
				{
					printf("Fast Forward\n");
210816bc:	01000034 	movhi	r4,0
210816c0:	21004f04 	addi	r4,r4,316
210816c4:	108e4c00 	call	2108e4c0 <puts>
					is_pressed = NONE_PRESSED;
210816c8:	008003c4 	movi	r2,15
210816cc:	d0a01b05 	stb	r2,-32660(gp)

					// if fast forward past end of video
					if (frame_index + FRAME_RATE * 5 > num_frames - 1)
210816d0:	d8800b17 	ldw	r2,44(sp)
210816d4:	8c401e04 	addi	r17,r17,120
210816d8:	10bfffc4 	addi	r2,r2,-1
210816dc:	147fc636 	bltu	r2,r17,210815f8 <__flash_rwdata_start+0xfffdf3b0>
#define DEBUG 0

static iframe_trailer_t *closest_iframe_index(iframe_trailer_t *trailer, int num_iframes, int frame_index)
{
	int closest_index = 0;
	int closest_distance = abs(frame_index - trailer[0].frame_index);
210816e0:	a0800017 	ldw	r2,0(r20)
					// if fast forward past end of video
					if (frame_index + FRAME_RATE * 5 > num_frames - 1)
					{
						goto exit_decode;
					}
					frame_index = jump_to_iframe(file_handle, closest_iframe_index(trailer, num_iframes, frame_index + FRAME_RATE * 5));
210816e4:	d9c00817 	ldw	r7,32(sp)
#define DEBUG 0

static iframe_trailer_t *closest_iframe_index(iframe_trailer_t *trailer, int num_iframes, int frame_index)
{
	int closest_index = 0;
	int closest_distance = abs(frame_index - trailer[0].frame_index);
210816e8:	8885c83a 	sub	r2,r17,r2
210816ec:	10005816 	blt	r2,zero,21081850 <mjpeg423_decode+0x774>

	for (int i = 1; i < num_iframes; i++)
210816f0:	00c00044 	movi	r3,1
210816f4:	19c05a0e 	bge	r3,r7,21081860 <mjpeg423_decode+0x784>
	{
		int current_distance = abs(frame_index - trailer[i].frame_index);
210816f8:	a1800217 	ldw	r6,8(r20)
210816fc:	898dc83a 	sub	r6,r17,r6
21081700:	30004f16 	blt	r6,zero,21081840 <mjpeg423_decode+0x764>

		// Should always be shrinking, otherwise we found the closest one already
		if (current_distance > closest_distance)
21081704:	11805616 	blt	r2,r6,21081860 <mjpeg423_decode+0x784>
21081708:	01400044 	movi	r5,1
static iframe_trailer_t *closest_iframe_index(iframe_trailer_t *trailer, int num_iframes, int frame_index)
{
	int closest_index = 0;
	int closest_distance = abs(frame_index - trailer[0].frame_index);

	for (int i = 1; i < num_iframes; i++)
2108170c:	29000044 	addi	r4,r5,1
21081710:	d8c00f17 	ldw	r3,60(sp)
21081714:	39000926 	beq	r7,r4,2108173c <mjpeg423_decode+0x660>
	{
		int current_distance = abs(frame_index - trailer[i].frame_index);
21081718:	18800017 	ldw	r2,0(r3)
2108171c:	18c00204 	addi	r3,r3,8
21081720:	8885c83a 	sub	r2,r17,r2
21081724:	10001016 	blt	r2,zero,21081768 <mjpeg423_decode+0x68c>

		// Should always be shrinking, otherwise we found the closest one already
		if (current_distance > closest_distance)
21081728:	30800416 	blt	r6,r2,2108173c <mjpeg423_decode+0x660>
2108172c:	200b883a 	mov	r5,r4
static iframe_trailer_t *closest_iframe_index(iframe_trailer_t *trailer, int num_iframes, int frame_index)
{
	int closest_index = 0;
	int closest_distance = abs(frame_index - trailer[0].frame_index);

	for (int i = 1; i < num_iframes; i++)
21081730:	29000044 	addi	r4,r5,1
	{
		int current_distance = abs(frame_index - trailer[i].frame_index);

		// Should always be shrinking, otherwise we found the closest one already
		if (current_distance > closest_distance)
21081734:	100d883a 	mov	r6,r2
static iframe_trailer_t *closest_iframe_index(iframe_trailer_t *trailer, int num_iframes, int frame_index)
{
	int closest_index = 0;
	int closest_distance = abs(frame_index - trailer[0].frame_index);

	for (int i = 1; i < num_iframes; i++)
21081738:	393ff71e 	bne	r7,r4,21081718 <__flash_rwdata_start+0xfffdf4d0>
2108173c:	280a90fa 	slli	r5,r5,3

		closest_distance = current_distance;
		closest_index = i;
	}

	return &trailer[closest_index];
21081740:	a163883a 	add	r17,r20,r5
}

// Returns frame number that we jumped to, -1 for error
static int jump_to_iframe(FAT_FILE_HANDLE file_handle, iframe_trailer_t *iframe)
{
	if (Fat_FileSeek(file_handle, FILE_SEEK_BEGIN, iframe->frame_position) == FALSE)
21081744:	89800117 	ldw	r6,4(r17)
21081748:	8009883a 	mov	r4,r16
2108174c:	000b883a 	mov	r5,zero
21081750:	1082a280 	call	21082a28 <Fat_FileSeek>
21081754:	10000d26 	beq	r2,zero,2108178c <mjpeg423_decode+0x6b0>
	{
		error_and_exit("cannot seek into file");
	}
	return iframe->frame_index;
21081758:	8c400017 	ldw	r17,0(r17)
				default:
				{
					break;
				}
			}
    	} while (!playback);
2108175c:	d8800c17 	ldw	r2,48(sp)
21081760:	103f0626 	beq	r2,zero,2108137c <__flash_rwdata_start+0xfffdf134>
21081764:	003f3306 	br	21081434 <__flash_rwdata_start+0xfffdf1ec>
	int closest_index = 0;
	int closest_distance = abs(frame_index - trailer[0].frame_index);

	for (int i = 1; i < num_iframes; i++)
	{
		int current_distance = abs(frame_index - trailer[i].frame_index);
21081768:	0085c83a 	sub	r2,zero,r2
2108176c:	003fee06 	br	21081728 <__flash_rwdata_start+0xfffdf4e0>
// Returns frame number that we jumped to, -1 for error
static int jump_to_iframe(FAT_FILE_HANDLE file_handle, iframe_trailer_t *iframe)
{
	if (Fat_FileSeek(file_handle, FILE_SEEK_BEGIN, iframe->frame_position) == FALSE)
	{
		error_and_exit("cannot seek into file");
21081770:	01000034 	movhi	r4,0
21081774:	21004404 	addi	r4,r4,272
21081778:	10801dc0 	call	210801dc <error_and_exit>
				// Rewind
				case BUTTON_3:
				{
					printf("Rewind\n");
					frame_index = jump_to_iframe(file_handle, closest_iframe_index(trailer, num_iframes, frame_index - FRAME_RATE * 5));
					is_pressed = NONE_PRESSED;
2108177c:	008003c4 	movi	r2,15
{
	if (Fat_FileSeek(file_handle, FILE_SEEK_BEGIN, iframe->frame_position) == FALSE)
	{
		error_and_exit("cannot seek into file");
	}
	return iframe->frame_index;
21081780:	8c400017 	ldw	r17,0(r17)
				// Rewind
				case BUTTON_3:
				{
					printf("Rewind\n");
					frame_index = jump_to_iframe(file_handle, closest_iframe_index(trailer, num_iframes, frame_index - FRAME_RATE * 5));
					is_pressed = NONE_PRESSED;
21081784:	d0a01b05 	stb	r2,-32660(gp)
21081788:	003f2806 	br	2108142c <__flash_rwdata_start+0xfffdf1e4>
// Returns frame number that we jumped to, -1 for error
static int jump_to_iframe(FAT_FILE_HANDLE file_handle, iframe_trailer_t *iframe)
{
	if (Fat_FileSeek(file_handle, FILE_SEEK_BEGIN, iframe->frame_position) == FALSE)
	{
		error_and_exit("cannot seek into file");
2108178c:	01000034 	movhi	r4,0
21081790:	21004404 	addi	r4,r4,272
21081794:	10801dc0 	call	210801dc <error_and_exit>
	}
	return iframe->frame_index;
21081798:	8c400017 	ldw	r17,0(r17)
2108179c:	003fef06 	br	2108175c <__flash_rwdata_start+0xfffdf514>
	signal_cpu1 = altera_avalon_mailbox_open(MAILBOX_SIMPLE_0_1_NAME, NULL, NULL);
	receive_cpu1 = altera_avalon_mailbox_open(MAILBOX_SIMPLE_1_0_NAME, NULL, NULL);

	if (!signal_cpu1 || !receive_cpu1)
	{
		fprintf(stderr, "ERROR: failed to open mailbox\n");
210817a0:	00800034 	movhi	r2,0
210817a4:	10976b04 	addi	r2,r2,23980
210817a8:	10800017 	ldw	r2,0(r2)
210817ac:	01000034 	movhi	r4,0
210817b0:	21001304 	addi	r4,r4,76
210817b4:	11c00317 	ldw	r7,12(r2)
210817b8:	01400044 	movi	r5,1
210817bc:	01800784 	movi	r6,30
210817c0:	108d6d80 	call	2108d6d8 <fwrite>
		return;
210817c4:	003f9c06 	br	21081638 <__flash_rwdata_start+0xfffdf3f0>
    DEBUG_PRINT_ARG("Num i frames %u\n", num_iframes)
#endif

    if(Fat_FileRead(file_handle, &payload_size, sizeof(uint32_t)) == FALSE)
    {
    	error_and_exit("cannot read input file");
210817c8:	01000034 	movhi	r4,0
210817cc:	21001b04 	addi	r4,r4,108
210817d0:	10801dc0 	call	210801dc <error_and_exit>
210817d4:	003e8a06 	br	21081200 <__flash_rwdata_start+0xfffdefb8>
    DEBUG_PRINT_ARG("Height %u\n", h_size)
#endif

    if(Fat_FileRead(file_handle, &num_iframes, sizeof(uint32_t)) == FALSE)
    {
    	error_and_exit("cannot read input file");
210817d8:	01000034 	movhi	r4,0
210817dc:	21001b04 	addi	r4,r4,108
210817e0:	10801dc0 	call	210801dc <error_and_exit>
210817e4:	003e8106 	br	210811ec <__flash_rwdata_start+0xfffdefa4>
    DEBUG_PRINT_ARG("Width %u\n", w_size)
#endif

    if(Fat_FileRead(file_handle, &h_size, sizeof(uint32_t)) == FALSE)
    {
    	error_and_exit("cannot read input file");
210817e8:	01000034 	movhi	r4,0
210817ec:	21001b04 	addi	r4,r4,108
210817f0:	10801dc0 	call	210801dc <error_and_exit>
210817f4:	003e7806 	br	210811d8 <__flash_rwdata_start+0xfffdef90>
    DEBUG_PRINT_ARG("Decoder start. Num frames #%u\n", num_frames)
#endif

    if(Fat_FileRead(file_handle, &w_size, sizeof(uint32_t)) == FALSE)
    {
    	error_and_exit("cannot read input file");
210817f8:	01000034 	movhi	r4,0
210817fc:	21001b04 	addi	r4,r4,108
21081800:	10801dc0 	call	210801dc <error_and_exit>
21081804:	003e6f06 	br	210811c4 <__flash_rwdata_start+0xfffdef7c>
    is_pressed = NONE_PRESSED;

    // read header
    if(Fat_FileRead(file_handle, &num_frames, sizeof(uint32_t)) == FALSE)
    {
    	error_and_exit("cannot read input file");
21081808:	01000034 	movhi	r4,0
2108180c:	21001b04 	addi	r4,r4,108
21081810:	10801dc0 	call	210801dc <error_and_exit>
21081814:	003e6606 	br	210811b0 <__flash_rwdata_start+0xfffdef68>
#endif
    }
    // set it back to beginning of payload
    if(Fat_FileSeek(file_handle, FILE_SEEK_BEGIN, 5 * sizeof(uint32_t)) == FALSE)
    {
    	error_and_exit("cannot seek into file");
21081818:	01000034 	movhi	r4,0
2108181c:	21004404 	addi	r4,r4,272
21081820:	10801dc0 	call	210801dc <error_and_exit>
21081824:	003ecd06 	br	2108135c <__flash_rwdata_start+0xfffdf114>
    
    // read trailer. Note: the trailer information is not used in the sample decoder app
    // set file to beginning of trailer
    if(Fat_FileSeek(file_handle, FILE_SEEK_BEGIN, 5 * sizeof(uint32_t) + payload_size) == FALSE)
    {
    	error_and_exit("cannot seek into file");
21081828:	01000034 	movhi	r4,0
2108182c:	21004404 	addi	r4,r4,272
21081830:	10801dc0 	call	210801dc <error_and_exit>
21081834:	003ea706 	br	210812d4 <__flash_rwdata_start+0xfffdf08c>
	int closest_index = 0;
	int closest_distance = abs(frame_index - trailer[0].frame_index);

	for (int i = 1; i < num_iframes; i++)
	{
		int current_distance = abs(frame_index - trailer[i].frame_index);
21081838:	018dc83a 	sub	r6,zero,r6
2108183c:	003ee306 	br	210813cc <__flash_rwdata_start+0xfffdf184>
21081840:	018dc83a 	sub	r6,zero,r6
21081844:	003faf06 	br	21081704 <__flash_rwdata_start+0xfffdf4bc>
#define DEBUG 0

static iframe_trailer_t *closest_iframe_index(iframe_trailer_t *trailer, int num_iframes, int frame_index)
{
	int closest_index = 0;
	int closest_distance = abs(frame_index - trailer[0].frame_index);
21081848:	0085c83a 	sub	r2,zero,r2
2108184c:	003eda06 	br	210813b8 <__flash_rwdata_start+0xfffdf170>
21081850:	0085c83a 	sub	r2,zero,r2
21081854:	003fa606 	br	210816f0 <__flash_rwdata_start+0xfffdf4a8>
	for (int i = 1; i < num_iframes; i++)
	{
		int current_distance = abs(frame_index - trailer[i].frame_index);

		// Should always be shrinking, otherwise we found the closest one already
		if (current_distance > closest_distance)
21081858:	000b883a 	mov	r5,zero
2108185c:	003eea06 	br	21081408 <__flash_rwdata_start+0xfffdf1c0>
21081860:	000b883a 	mov	r5,zero
21081864:	003fb606 	br	21081740 <__flash_rwdata_start+0xfffdf4f8>
    // the bitstream is then read from the file into Ybitstream
    // the remaining pointers simply point to the beginning of the Cb and Cr streams within Ybitstream
    uint8_t* Ybitstream;
    if((Ybitstream = malloc(hYb_size * wYb_size * 64 * sizeof(DCTELEM) + 2 * hCb_size * wCb_size * 64 * sizeof(DCTELEM))) == NULL)
    {
    	error_and_exit("cannot allocate bitstream");
21081868:	01000034 	movhi	r4,0
2108186c:	21003d04 	addi	r4,r4,244
21081870:	10801dc0 	call	210801dc <error_and_exit>
21081874:	003e9106 	br	210812bc <__flash_rwdata_start+0xfffdf074>
    // main data structures. See lab manual for explanation
    alt_u32* p_buffer;
    dct_block_t* YDCAC;
    if((YDCAC = (dct_block_t*)memalign(128, hYb_size * wYb_size * 64 * sizeof(DCTELEM))) == NULL)
    {
    	error_and_exit("cannot allocate YDCAC");
21081878:	01000034 	movhi	r4,0
2108187c:	21003704 	addi	r4,r4,220
21081880:	10801dc0 	call	210801dc <error_and_exit>
21081884:	003e8406 	br	21081298 <__flash_rwdata_start+0xfffdf050>
	}

	ret = is_sync ? alt_msgdma_standard_descriptor_sync_transfer(device, descriptor) : alt_msgdma_standard_descriptor_async_transfer(device, descriptor);
	if (ret != 0)
	{
		fprintf(stderr, "ERROR CPU0: dma_read can't transfer: %d\n", ret);
21081888:	01000034 	movhi	r4,0
2108188c:	21176b04 	addi	r4,r4,23980
21081890:	20c00017 	ldw	r3,0(r4)
21081894:	01400034 	movhi	r5,0
21081898:	29406a04 	addi	r5,r5,424
2108189c:	19000317 	ldw	r4,12(r3)
210818a0:	100d883a 	mov	r6,r2
210818a4:	108d5e80 	call	2108d5e8 <fprintf>
210818a8:	003f3006 	br	2108156c <__flash_rwdata_start+0xfffdf324>
	int ret;

	ret = alt_msgdma_construct_standard_st_to_mm_descriptor(device, descriptor, address, len, 0);
	if (ret != 0)
	{
		fprintf(stderr, "ERROR CPU0: dma_write can't make descriptor\n");
210818ac:	00c00034 	movhi	r3,0
210818b0:	18d76b04 	addi	r3,r3,23980
210818b4:	18800017 	ldw	r2,0(r3)
210818b8:	01000034 	movhi	r4,0
210818bc:	21007b04 	addi	r4,r4,492
210818c0:	11c00317 	ldw	r7,12(r2)
210818c4:	01400044 	movi	r5,1
210818c8:	01800b04 	movi	r6,44
210818cc:	108d6d80 	call	2108d6d8 <fwrite>
210818d0:	003f2d06 	br	21081588 <__flash_rwdata_start+0xfffdf340>
	int ret;

	ret = alt_msgdma_construct_standard_mm_to_st_descriptor(device, descriptor, address, len, 0);
	if (ret != 0)
	{
		fprintf(stderr, "ERROR CPU0: dma_read can't make descriptor\n");
210818d4:	01000034 	movhi	r4,0
210818d8:	21176b04 	addi	r4,r4,23980
210818dc:	20800017 	ldw	r2,0(r4)
210818e0:	01000034 	movhi	r4,0
210818e4:	21005f04 	addi	r4,r4,380
210818e8:	11c00317 	ldw	r7,12(r2)
210818ec:	01400044 	movi	r5,1
210818f0:	01800ac4 	movi	r6,43
210818f4:	108d6d80 	call	2108d6d8 <fwrite>
210818f8:	003f1506 	br	21081550 <__flash_rwdata_start+0xfffdf308>
        {
        	error_and_exit("cannot read input file");
        }
        if(Fat_FileRead(file_handle, Ybitstream, frame_size - 4 * sizeof(uint32_t)) == FALSE)
        {
        	error_and_exit("cannot read input file");
210818fc:	01000034 	movhi	r4,0
21081900:	21001b04 	addi	r4,r4,108
21081904:	10801dc0 	call	210801dc <error_and_exit>
21081908:	003ee406 	br	2108149c <__flash_rwdata_start+0xfffdf254>
        {
        	error_and_exit("cannot read input file");
        }
        if(Fat_FileRead(file_handle, &Cbsize, sizeof(uint32_t)) == FALSE)
        {
        	error_and_exit("cannot read input file");
2108190c:	01000034 	movhi	r4,0
21081910:	21001b04 	addi	r4,r4,108
21081914:	10801dc0 	call	210801dc <error_and_exit>
21081918:	003eda06 	br	21081484 <__flash_rwdata_start+0xfffdf23c>
        DEBUG_PRINT_ARG("Frame_type %u\n", frame_type)
#endif

        if(Fat_FileRead(file_handle, &Ysize, sizeof(uint32_t)) == FALSE)
        {
        	error_and_exit("cannot read input file");
2108191c:	01000034 	movhi	r4,0
21081920:	21001b04 	addi	r4,r4,108
21081924:	10801dc0 	call	210801dc <error_and_exit>
21081928:	003ed106 	br	21081470 <__flash_rwdata_start+0xfffdf228>
        DEBUG_PRINT_ARG("Frame_size %u\n", frame_size)
#endif

        if(Fat_FileRead(file_handle, &frame_type, sizeof(uint32_t)) == FALSE)
        {
        	error_and_exit("cannot read input file");
2108192c:	01000034 	movhi	r4,0
21081930:	21001b04 	addi	r4,r4,108
21081934:	10801dc0 	call	210801dc <error_and_exit>
21081938:	003ec806 	br	2108145c <__flash_rwdata_start+0xfffdf214>
#endif

        // read frame payload
        if(Fat_FileRead(file_handle, &frame_size, sizeof(uint32_t)) == FALSE)
		{
			error_and_exit("cannot read input file");
2108193c:	01000034 	movhi	r4,0
21081940:	21001b04 	addi	r4,r4,108
21081944:	10801dc0 	call	210801dc <error_and_exit>
21081948:	003ebf06 	br	21081448 <__flash_rwdata_start+0xfffdf200>

2108194c <ycbcr_to_rgb>:

#else

//null implementation
void ycbcr_to_rgb(int h, int w, uint32_t w_size, pcolor_block_t Y, pcolor_block_t Cb, pcolor_block_t Cr, rgb_pixel_t* rgbblock)
{
2108194c:	2189383a 	mul	r4,r4,r6
21081950:	3185883a 	add	r2,r6,r6
21081954:	defff404 	addi	sp,sp,-48
21081958:	1085883a 	add	r2,r2,r2
2108195c:	da800c17 	ldw	r10,48(sp)
21081960:	da400d17 	ldw	r9,52(sp)
21081964:	290b883a 	add	r5,r5,r4
21081968:	d8800015 	stw	r2,0(sp)
2108196c:	d8800e17 	ldw	r2,56(sp)
21081970:	2957883a 	add	r11,r5,r5
21081974:	5ad7883a 	add	r11,r11,r11
21081978:	dfc00b15 	stw	ra,44(sp)
2108197c:	df000a15 	stw	fp,40(sp)
21081980:	ddc00915 	stw	r23,36(sp)
21081984:	dd800815 	stw	r22,32(sp)
21081988:	dd400715 	stw	r21,28(sp)
2108198c:	dd000615 	stw	r20,24(sp)
21081990:	dcc00515 	stw	r19,20(sp)
21081994:	dc800415 	stw	r18,16(sp)
21081998:	dc400315 	stw	r17,12(sp)
2108199c:	dc000215 	stw	r16,8(sp)
210819a0:	12d7883a 	add	r11,r2,r11
210819a4:	57c00044 	addi	ra,r10,1
210819a8:	3f000044 	addi	fp,r7,1
210819ac:	4dc00044 	addi	r23,r9,1
210819b0:	55800084 	addi	r22,r10,2
210819b4:	3d400084 	addi	r21,r7,2
210819b8:	4d000084 	addi	r20,r9,2
210819bc:	54c000c4 	addi	r19,r10,3
210819c0:	3c8000c4 	addi	r18,r7,3
210819c4:	4c4000c4 	addi	r17,r9,3
210819c8:	54000104 	addi	r16,r10,4
210819cc:	3bc00104 	addi	r15,r7,4
210819d0:	4b800104 	addi	r14,r9,4
210819d4:	53400144 	addi	r13,r10,5
210819d8:	03000204 	movi	r12,8
210819dc:	d9800115 	stw	r6,4(sp)
        index = (h+y) * w_size + w;
        for(int x = 0; x < 8; x++)
        {
        	pixel = &rgbblock[index];
        	*pixel = Cb[y][x]  |
        			 Y[y][x] << 8 |
210819e0:	3a000003 	ldbu	r8,0(r7)
        		     Cr[y][x] << 16  |
210819e4:	48c00003 	ldbu	r3,0(r9)
    for (int y = 0; y < 8; y++){
        index = (h+y) * w_size + w;
        for(int x = 0; x < 8; x++)
        {
        	pixel = &rgbblock[index];
        	*pixel = Cb[y][x]  |
210819e8:	51000003 	ldbu	r4,0(r10)
        			 Y[y][x] << 8 |
210819ec:	4010923a 	slli	r8,r8,8
        		     Cr[y][x] << 16  |
210819f0:	1806943a 	slli	r3,r3,16
    for (int y = 0; y < 8; y++){
        index = (h+y) * w_size + w;
        for(int x = 0; x < 8; x++)
        {
        	pixel = &rgbblock[index];
        	*pixel = Cb[y][x]  |
210819f4:	d9800e17 	ldw	r6,56(sp)
        			 Y[y][x] << 8 |
        		     Cr[y][x] << 16  |
        			 0 << 24;

            index++;
210819f8:	28800044 	addi	r2,r5,1
210819fc:	40c6b03a 	or	r3,r8,r3
        for(int x = 0; x < 8; x++)
        {
        	pixel = &rgbblock[index];
        	*pixel = Cb[y][x]  |
        			 Y[y][x] << 8 |
        		     Cr[y][x] << 16  |
21081a00:	1906b03a 	or	r3,r3,r4
    for (int y = 0; y < 8; y++){
        index = (h+y) * w_size + w;
        for(int x = 0; x < 8; x++)
        {
        	pixel = &rgbblock[index];
        	*pixel = Cb[y][x]  |
21081a04:	58c00015 	stw	r3,0(r11)
        			 Y[y][x] << 8 |
21081a08:	e2000003 	ldbu	r8,0(fp)
        		     Cr[y][x] << 16  |
21081a0c:	b8c00003 	ldbu	r3,0(r23)
    for (int y = 0; y < 8; y++){
        index = (h+y) * w_size + w;
        for(int x = 0; x < 8; x++)
        {
        	pixel = &rgbblock[index];
        	*pixel = Cb[y][x]  |
21081a10:	f9000003 	ldbu	r4,0(ra)
        			 Y[y][x] << 8 |
21081a14:	4010923a 	slli	r8,r8,8
        		     Cr[y][x] << 16  |
21081a18:	1806943a 	slli	r3,r3,16

    for (int y = 0; y < 8; y++){
        index = (h+y) * w_size + w;
        for(int x = 0; x < 8; x++)
        {
        	pixel = &rgbblock[index];
21081a1c:	1085883a 	add	r2,r2,r2
21081a20:	1085883a 	add	r2,r2,r2
21081a24:	40c6b03a 	or	r3,r8,r3
        	*pixel = Cb[y][x]  |
21081a28:	3085883a 	add	r2,r6,r2
        			 Y[y][x] << 8 |
        		     Cr[y][x] << 16  |
21081a2c:	1906b03a 	or	r3,r3,r4
    for (int y = 0; y < 8; y++){
        index = (h+y) * w_size + w;
        for(int x = 0; x < 8; x++)
        {
        	pixel = &rgbblock[index];
        	*pixel = Cb[y][x]  |
21081a30:	10c00015 	stw	r3,0(r2)
        			 Y[y][x] << 8 |
21081a34:	aa000003 	ldbu	r8,0(r21)
        		     Cr[y][x] << 16  |
21081a38:	a0c00003 	ldbu	r3,0(r20)
    for (int y = 0; y < 8; y++){
        index = (h+y) * w_size + w;
        for(int x = 0; x < 8; x++)
        {
        	pixel = &rgbblock[index];
        	*pixel = Cb[y][x]  |
21081a3c:	b1000003 	ldbu	r4,0(r22)
        			 Y[y][x] << 8 |
21081a40:	4010923a 	slli	r8,r8,8
        		     Cr[y][x] << 16  |
21081a44:	1806943a 	slli	r3,r3,16
21081a48:	39c00204 	addi	r7,r7,8
21081a4c:	4a400204 	addi	r9,r9,8
21081a50:	40c6b03a 	or	r3,r8,r3
21081a54:	1906b03a 	or	r3,r3,r4
    for (int y = 0; y < 8; y++){
        index = (h+y) * w_size + w;
        for(int x = 0; x < 8; x++)
        {
        	pixel = &rgbblock[index];
        	*pixel = Cb[y][x]  |
21081a58:	10c00115 	stw	r3,4(r2)
        			 Y[y][x] << 8 |
21081a5c:	92000003 	ldbu	r8,0(r18)
        		     Cr[y][x] << 16  |
21081a60:	88c00003 	ldbu	r3,0(r17)
    for (int y = 0; y < 8; y++){
        index = (h+y) * w_size + w;
        for(int x = 0; x < 8; x++)
        {
        	pixel = &rgbblock[index];
        	*pixel = Cb[y][x]  |
21081a64:	99000003 	ldbu	r4,0(r19)
        			 Y[y][x] << 8 |
21081a68:	4010923a 	slli	r8,r8,8
        		     Cr[y][x] << 16  |
21081a6c:	1806943a 	slli	r3,r3,16
21081a70:	52800204 	addi	r10,r10,8
21081a74:	d9800017 	ldw	r6,0(sp)
21081a78:	40c6b03a 	or	r3,r8,r3
21081a7c:	1906b03a 	or	r3,r3,r4
    for (int y = 0; y < 8; y++){
        index = (h+y) * w_size + w;
        for(int x = 0; x < 8; x++)
        {
        	pixel = &rgbblock[index];
        	*pixel = Cb[y][x]  |
21081a80:	10c00215 	stw	r3,8(r2)
        			 Y[y][x] << 8 |
21081a84:	7a000003 	ldbu	r8,0(r15)
        		     Cr[y][x] << 16  |
21081a88:	70c00003 	ldbu	r3,0(r14)
    for (int y = 0; y < 8; y++){
        index = (h+y) * w_size + w;
        for(int x = 0; x < 8; x++)
        {
        	pixel = &rgbblock[index];
        	*pixel = Cb[y][x]  |
21081a8c:	81000003 	ldbu	r4,0(r16)
        			 Y[y][x] << 8 |
21081a90:	4010923a 	slli	r8,r8,8
        		     Cr[y][x] << 16  |
21081a94:	1806943a 	slli	r3,r3,16
21081a98:	5997883a 	add	r11,r11,r6
21081a9c:	d9800117 	ldw	r6,4(sp)
21081aa0:	40c6b03a 	or	r3,r8,r3
21081aa4:	1906b03a 	or	r3,r3,r4
    for (int y = 0; y < 8; y++){
        index = (h+y) * w_size + w;
        for(int x = 0; x < 8; x++)
        {
        	pixel = &rgbblock[index];
        	*pixel = Cb[y][x]  |
21081aa8:	10c00315 	stw	r3,12(r2)
        			 Y[y][x] << 8 |
21081aac:	3a3fff43 	ldbu	r8,-3(r7)
        		     Cr[y][x] << 16  |
21081ab0:	48ffff43 	ldbu	r3,-3(r9)
    for (int y = 0; y < 8; y++){
        index = (h+y) * w_size + w;
        for(int x = 0; x < 8; x++)
        {
        	pixel = &rgbblock[index];
        	*pixel = Cb[y][x]  |
21081ab4:	69000003 	ldbu	r4,0(r13)
        			 Y[y][x] << 8 |
21081ab8:	4010923a 	slli	r8,r8,8
        		     Cr[y][x] << 16  |
21081abc:	1806943a 	slli	r3,r3,16
21081ac0:	633fffc4 	addi	r12,r12,-1
21081ac4:	298b883a 	add	r5,r5,r6
21081ac8:	40c6b03a 	or	r3,r8,r3
21081acc:	1906b03a 	or	r3,r3,r4
    for (int y = 0; y < 8; y++){
        index = (h+y) * w_size + w;
        for(int x = 0; x < 8; x++)
        {
        	pixel = &rgbblock[index];
        	*pixel = Cb[y][x]  |
21081ad0:	10c00415 	stw	r3,16(r2)
        			 Y[y][x] << 8 |
21081ad4:	3a3fff83 	ldbu	r8,-2(r7)
        		     Cr[y][x] << 16  |
21081ad8:	48ffff83 	ldbu	r3,-2(r9)
    for (int y = 0; y < 8; y++){
        index = (h+y) * w_size + w;
        for(int x = 0; x < 8; x++)
        {
        	pixel = &rgbblock[index];
        	*pixel = Cb[y][x]  |
21081adc:	513fff83 	ldbu	r4,-2(r10)
        			 Y[y][x] << 8 |
21081ae0:	4010923a 	slli	r8,r8,8
        		     Cr[y][x] << 16  |
21081ae4:	1806943a 	slli	r3,r3,16
21081ae8:	ffc00204 	addi	ra,ra,8
21081aec:	e7000204 	addi	fp,fp,8
21081af0:	40c6b03a 	or	r3,r8,r3
21081af4:	1906b03a 	or	r3,r3,r4
    for (int y = 0; y < 8; y++){
        index = (h+y) * w_size + w;
        for(int x = 0; x < 8; x++)
        {
        	pixel = &rgbblock[index];
        	*pixel = Cb[y][x]  |
21081af8:	10c00515 	stw	r3,20(r2)
        			 Y[y][x] << 8 |
21081afc:	3a3fffc3 	ldbu	r8,-1(r7)
        		     Cr[y][x] << 16  |
21081b00:	48ffffc3 	ldbu	r3,-1(r9)
    for (int y = 0; y < 8; y++){
        index = (h+y) * w_size + w;
        for(int x = 0; x < 8; x++)
        {
        	pixel = &rgbblock[index];
        	*pixel = Cb[y][x]  |
21081b04:	513fffc3 	ldbu	r4,-1(r10)
        			 Y[y][x] << 8 |
21081b08:	4010923a 	slli	r8,r8,8
        		     Cr[y][x] << 16  |
21081b0c:	1806943a 	slli	r3,r3,16
21081b10:	bdc00204 	addi	r23,r23,8
21081b14:	b5800204 	addi	r22,r22,8
21081b18:	40c6b03a 	or	r3,r8,r3
21081b1c:	1906b03a 	or	r3,r3,r4
    for (int y = 0; y < 8; y++){
        index = (h+y) * w_size + w;
        for(int x = 0; x < 8; x++)
        {
        	pixel = &rgbblock[index];
        	*pixel = Cb[y][x]  |
21081b20:	10c00615 	stw	r3,24(r2)
21081b24:	ad400204 	addi	r21,r21,8
21081b28:	a5000204 	addi	r20,r20,8
21081b2c:	9cc00204 	addi	r19,r19,8
21081b30:	94800204 	addi	r18,r18,8
21081b34:	8c400204 	addi	r17,r17,8
21081b38:	84000204 	addi	r16,r16,8
21081b3c:	7bc00204 	addi	r15,r15,8
21081b40:	73800204 	addi	r14,r14,8
21081b44:	6b400204 	addi	r13,r13,8
void ycbcr_to_rgb(int h, int w, uint32_t w_size, pcolor_block_t Y, pcolor_block_t Cb, pcolor_block_t Cr, rgb_pixel_t* rgbblock)
{
    int index;
    uint32_t *pixel;

    for (int y = 0; y < 8; y++){
21081b48:	603fa51e 	bne	r12,zero,210819e0 <__flash_rwdata_start+0xfffdf798>
        			 0 << 24;

            index++;
        }
    }
}
21081b4c:	dfc00b17 	ldw	ra,44(sp)
21081b50:	df000a17 	ldw	fp,40(sp)
21081b54:	ddc00917 	ldw	r23,36(sp)
21081b58:	dd800817 	ldw	r22,32(sp)
21081b5c:	dd400717 	ldw	r21,28(sp)
21081b60:	dd000617 	ldw	r20,24(sp)
21081b64:	dcc00517 	ldw	r19,20(sp)
21081b68:	dc800417 	ldw	r18,16(sp)
21081b6c:	dc400317 	ldw	r17,12(sp)
21081b70:	dc000217 	ldw	r16,8(sp)
21081b74:	dec00c04 	addi	sp,sp,48
21081b78:	f800283a 	ret

21081b7c <Fat_Mount>:
bool fatSameLongFilename(alt_u16 *p1, alt_u16 *p2);




FAT_HANDLE Fat_Mount(){
21081b7c:	defffe04 	addi	sp,sp,-8
    
	bool bSuccess = SDLIB_Init(SD_CONT_BASE);
21081b80:	01080034 	movhi	r4,8192
bool fatSameLongFilename(alt_u16 *p1, alt_u16 *p2);




FAT_HANDLE Fat_Mount(){
21081b84:	dfc00115 	stw	ra,4(sp)
21081b88:	dc000015 	stw	r16,0(sp)
    
	bool bSuccess = SDLIB_Init(SD_CONT_BASE);
21081b8c:	10852b80 	call	210852b8 <SDLIB_Init>
	for (int i = 0; i < 5 && !bSuccess; i++) { // try 5 time at max
21081b90:	1000091e 	bne	r2,zero,21081bb8 <Fat_Mount+0x3c>
		bSuccess = SDLIB_Init(SD_CONT_BASE);
21081b94:	01080034 	movhi	r4,8192
21081b98:	10852b80 	call	210852b8 <SDLIB_Init>
21081b9c:	04000104 	movi	r16,4
21081ba0:	01080034 	movhi	r4,8192
21081ba4:	843fffc4 	addi	r16,r16,-1


FAT_HANDLE Fat_Mount(){
    
	bool bSuccess = SDLIB_Init(SD_CONT_BASE);
	for (int i = 0; i < 5 && !bSuccess; i++) { // try 5 time at max
21081ba8:	1000031e 	bne	r2,zero,21081bb8 <Fat_Mount+0x3c>
		bSuccess = SDLIB_Init(SD_CONT_BASE);
21081bac:	10852b80 	call	210852b8 <SDLIB_Init>


FAT_HANDLE Fat_Mount(){
    
	bool bSuccess = SDLIB_Init(SD_CONT_BASE);
	for (int i = 0; i < 5 && !bSuccess; i++) { // try 5 time at max
21081bb0:	803ffb1e 	bne	r16,zero,21081ba0 <__flash_rwdata_start+0xfffdf958>
		bSuccess = SDLIB_Init(SD_CONT_BASE);
	}
	if (!bSuccess) {
21081bb4:	10000426 	beq	r2,zero,21081bc8 <Fat_Mount+0x4c>
	}

    FAT_HANDLE hFat = 0;
    hFat = fatMountSdcard();
    return hFat;      
}
21081bb8:	dfc00117 	ldw	ra,4(sp)
21081bbc:	dc000017 	ldw	r16,0(sp)
21081bc0:	dec00204 	addi	sp,sp,8
		printf("Failed to initiate the SDCARD\n\r");
		return -1;
	}

    FAT_HANDLE hFat = 0;
    hFat = fatMountSdcard();
21081bc4:	10837801 	jmpi	21083780 <fatMountSdcard>
	bool bSuccess = SDLIB_Init(SD_CONT_BASE);
	for (int i = 0; i < 5 && !bSuccess; i++) { // try 5 time at max
		bSuccess = SDLIB_Init(SD_CONT_BASE);
	}
	if (!bSuccess) {
		printf("Failed to initiate the SDCARD\n\r");
21081bc8:	01000034 	movhi	r4,0
21081bcc:	2100a004 	addi	r4,r4,640
21081bd0:	108e3bc0 	call	2108e3bc <printf>
	}

    FAT_HANDLE hFat = 0;
    hFat = fatMountSdcard();
    return hFat;      
}
21081bd4:	00bfffc4 	movi	r2,-1
21081bd8:	dfc00117 	ldw	ra,4(sp)
21081bdc:	dc000017 	ldw	r16,0(sp)
21081be0:	dec00204 	addi	sp,sp,8
21081be4:	f800283a 	ret

21081be8 <Fat_Unmount>:

void Fat_Unmount(FAT_HANDLE Fat){
    VOLUME_INFO *pVol = (VOLUME_INFO *)Fat;
    if (!pVol)
21081be8:	20000126 	beq	r4,zero,21081bf0 <Fat_Unmount+0x8>
    if (pVol->szFatTable){
        free(pVol->szFatTable);
        pVol->szFatTable = 0;
    }        
#endif //#ifdef FAT_READONLY
    pVol->bMount = FALSE;
21081bec:	20000515 	stw	zero,20(r4)
21081bf0:	f800283a 	ret

21081bf4 <Fat_Type>:
}   

FAT_TYPE Fat_Type(FAT_HANDLE Fat){
    VOLUME_INFO *pVol = (VOLUME_INFO *)Fat;
    FAT_TYPE Type = FAT_UNKNOWN;
    if (pVol){
21081bf4:	20000826 	beq	r4,zero,21081c18 <Fat_Type+0x24>
        if (pVol->Partition_Type == PARTITION_FAT16)
21081bf8:	20800417 	ldw	r2,16(r4)
21081bfc:	00c00184 	movi	r3,6
21081c00:	10c00326 	beq	r2,r3,21081c10 <Fat_Type+0x1c>
            Type = FAT_FAT16;
        else if (pVol->Partition_Type == PARTITION_FAT32)
            Type = FAT_FAT32;
21081c04:	108002e0 	cmpeqi	r2,r2,11
21081c08:	1004907a 	slli	r2,r2,1
21081c0c:	f800283a 	ret
FAT_TYPE Fat_Type(FAT_HANDLE Fat){
    VOLUME_INFO *pVol = (VOLUME_INFO *)Fat;
    FAT_TYPE Type = FAT_UNKNOWN;
    if (pVol){
        if (pVol->Partition_Type == PARTITION_FAT16)
            Type = FAT_FAT16;
21081c10:	00800044 	movi	r2,1
        else if (pVol->Partition_Type == PARTITION_FAT32)
            Type = FAT_FAT32;
    }
    return Type;        
}
21081c14:	f800283a 	ret
    //free(pVol);
}   

FAT_TYPE Fat_Type(FAT_HANDLE Fat){
    VOLUME_INFO *pVol = (VOLUME_INFO *)Fat;
    FAT_TYPE Type = FAT_UNKNOWN;
21081c18:	0005883a 	mov	r2,zero
21081c1c:	f800283a 	ret

21081c20 <Fat_FileBrowseBegin>:
    return Type;        
}

bool Fat_FileBrowseBegin(FAT_HANDLE hFat, FAT_BROWSE_HANDLE *pFatBrowseHandle){
    VOLUME_INFO *pVol = (VOLUME_INFO *)hFat;
    if (!pVol)
21081c20:	20000726 	beq	r4,zero,21081c40 <Fat_FileBrowseBegin+0x20>
        return FALSE;
    if (!pVol->bMount)
21081c24:	20800517 	ldw	r2,20(r4)
21081c28:	10000626 	beq	r2,zero,21081c44 <Fat_FileBrowseBegin+0x24>
        return FALSE;
    pFatBrowseHandle->DirectoryIndex = -1;
21081c2c:	00bfffc4 	movi	r2,-1
21081c30:	28800015 	stw	r2,0(r5)
    pFatBrowseHandle->hFat = hFat;
21081c34:	29000115 	stw	r4,4(r5)
    return TRUE;
21081c38:	00800044 	movi	r2,1
21081c3c:	f800283a 	ret
}

bool Fat_FileBrowseBegin(FAT_HANDLE hFat, FAT_BROWSE_HANDLE *pFatBrowseHandle){
    VOLUME_INFO *pVol = (VOLUME_INFO *)hFat;
    if (!pVol)
        return FALSE;
21081c40:	0005883a 	mov	r2,zero
    if (!pVol->bMount)
        return FALSE;
    pFatBrowseHandle->DirectoryIndex = -1;
    pFatBrowseHandle->hFat = hFat;
    return TRUE;
}
21081c44:	f800283a 	ret

21081c48 <Fat_FileBrowseNext>:

bool Fat_FileBrowseNext(FAT_BROWSE_HANDLE *pFatBrowseHandle, FILE_CONTEXT *pFileContext){
21081c48:	defff804 	addi	sp,sp,-32
21081c4c:	dc800215 	stw	r18,8(sp)
    bool bFind = FALSE, bError=FALSE, bLongFilename = FALSE;
    int OrderValue = 0;
    FAT_DIRECTORY *pDir;
    //unsigned int nSecter, nSecterOffset,nByteOffset;
    VOLUME_INFO *pVol = (VOLUME_INFO *)pFatBrowseHandle->hFat;
21081c50:	24800117 	ldw	r18,4(r4)
    pFatBrowseHandle->DirectoryIndex = -1;
    pFatBrowseHandle->hFat = hFat;
    return TRUE;
}

bool Fat_FileBrowseNext(FAT_BROWSE_HANDLE *pFatBrowseHandle, FILE_CONTEXT *pFileContext){
21081c54:	dfc00715 	stw	ra,28(sp)
21081c58:	dd800615 	stw	r22,24(sp)
21081c5c:	dd400515 	stw	r21,20(sp)
21081c60:	dd000415 	stw	r20,16(sp)
21081c64:	dcc00315 	stw	r19,12(sp)
21081c68:	dc400115 	stw	r17,4(sp)
21081c6c:	dc000015 	stw	r16,0(sp)
    int OrderValue = 0;
    FAT_DIRECTORY *pDir;
    //unsigned int nSecter, nSecterOffset,nByteOffset;
    VOLUME_INFO *pVol = (VOLUME_INFO *)pFatBrowseHandle->hFat;
    
    if (!pVol)
21081c70:	90001426 	beq	r18,zero,21081cc4 <Fat_FileBrowseNext+0x7c>
        return FALSE;    
    
    if (!pVol->bMount)
21081c74:	90800517 	ldw	r2,20(r18)
21081c78:	10001a26 	beq	r2,zero,21081ce4 <Fat_FileBrowseNext+0x9c>
21081c7c:	2827883a 	mov	r19,r5
21081c80:	2023883a 	mov	r17,r4
21081c84:	002d883a 	mov	r22,zero
21081c88:	0029883a 	mov	r20,zero
        if (!pDir)
            bError = TRUE;
            
        if (!bError){                        
            if (fatIsValidDir(pDir) && !fatIsUnusedDir(pDir)){
                if ((pDir->Attribute & ATTR_LONG_NAME) == ATTR_LONG_NAME){
21081c8c:	054003c4 	movi	r21,15
    if (!pVol->bMount)
        return FALSE;
    
    
    do{  // search Directory Table
        pFatBrowseHandle->DirectoryIndex++;        
21081c90:	89400017 	ldw	r5,0(r17)
        pDir = fatFindDirectory(pVol,pFatBrowseHandle->DirectoryIndex);
21081c94:	9009883a 	mov	r4,r18
    if (!pVol->bMount)
        return FALSE;
    
    
    do{  // search Directory Table
        pFatBrowseHandle->DirectoryIndex++;        
21081c98:	29400044 	addi	r5,r5,1
21081c9c:	89400015 	stw	r5,0(r17)
        pDir = fatFindDirectory(pVol,pFatBrowseHandle->DirectoryIndex);
21081ca0:	10834300 	call	21083430 <fatFindDirectory>
21081ca4:	1021883a 	mov	r16,r2
        if (!pDir)
21081ca8:	10000b26 	beq	r2,zero,21081cd8 <Fat_FileBrowseNext+0x90>
            bError = TRUE;
            
        if (!bError){                        
            if (fatIsValidDir(pDir) && !fatIsUnusedDir(pDir)){
21081cac:	1009883a 	mov	r4,r2
21081cb0:	108320c0 	call	2108320c <fatIsValidDir>
21081cb4:	1000151e 	bne	r2,zero,21081d0c <Fat_FileBrowseNext+0xc4>
                        pFileContext->FileSize = pDir->FileSize;
                    }                        
                }                    
            }                
        }            
    }while (!bFind && !fatIsLastDir(pDir) && !bError);
21081cb8:	8009883a 	mov	r4,r16
21081cbc:	10832000 	call	21083200 <fatIsLastDir>
21081cc0:	103ff326 	beq	r2,zero,21081c90 <__flash_rwdata_start+0xfffdfa48>
21081cc4:	0005883a 	mov	r2,zero
21081cc8:	00000606 	br	21081ce4 <Fat_FileBrowseNext+0x9c>
                                bError = TRUE;
                            else
                                OrderValue = pLDIR->LDIR_Ord & 0x3F;
                            memset(pFileContext->szName, 0, sizeof(pFileContext->szName));
                        }else{
                            if ((pLDIR->LDIR_Ord & 0x3F) != OrderValue)
21081ccc:	80800003 	ldbu	r2,0(r16)
21081cd0:	10800fcc 	andi	r2,r2,63
21081cd4:	1580bf26 	beq	r2,r22,21081fd4 <Fat_FileBrowseNext+0x38c>
                        pFileContext->FileSize = pDir->FileSize;
                    }                        
                }                    
            }                
        }            
    }while (!bFind && !fatIsLastDir(pDir) && !bError);
21081cd8:	8009883a 	mov	r4,r16
21081cdc:	10832000 	call	21083200 <fatIsLastDir>
21081ce0:	0005883a 	mov	r2,zero
    
    return bFind;
    
}
21081ce4:	dfc00717 	ldw	ra,28(sp)
21081ce8:	dd800617 	ldw	r22,24(sp)
21081cec:	dd400517 	ldw	r21,20(sp)
21081cf0:	dd000417 	ldw	r20,16(sp)
21081cf4:	dcc00317 	ldw	r19,12(sp)
21081cf8:	dc800217 	ldw	r18,8(sp)
21081cfc:	dc400117 	ldw	r17,4(sp)
21081d00:	dc000017 	ldw	r16,0(sp)
21081d04:	dec00804 	addi	sp,sp,32
21081d08:	f800283a 	ret
        pDir = fatFindDirectory(pVol,pFatBrowseHandle->DirectoryIndex);
        if (!pDir)
            bError = TRUE;
            
        if (!bError){                        
            if (fatIsValidDir(pDir) && !fatIsUnusedDir(pDir)){
21081d0c:	8009883a 	mov	r4,r16
21081d10:	10832e00 	call	210832e0 <fatIsUnusedDir>
21081d14:	103fe81e 	bne	r2,zero,21081cb8 <__flash_rwdata_start+0xfffdfa70>
                if ((pDir->Attribute & ATTR_LONG_NAME) == ATTR_LONG_NAME){
21081d18:	808002c3 	ldbu	r2,11(r16)
21081d1c:	10c003cc 	andi	r3,r2,15
21081d20:	1d40a426 	beq	r3,r21,21081fb4 <Fat_FileBrowseNext+0x36c>
                        memcpy(pFileContext->szName+BaseOffset, pLDIR->LDIR_Name1, 10);
                        memcpy(pFileContext->szName+BaseOffset+10, pLDIR->LDIR_Name2, 12);
                        memcpy(pFileContext->szName+BaseOffset+22, pLDIR->LDIR_Name3, 4);
                    }                        
                }else{
                    if (bLongFilename){
21081d24:	a0004126 	beq	r20,zero,21081e2c <Fat_FileBrowseNext+0x1e4>
                        pFileContext->Attribute = ATTR_LONG_NAME;
21081d28:	008003c4 	movi	r2,15
21081d2c:	98804505 	stb	r2,276(r19)
                        if ((pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY)) == 0)
21081d30:	808002c3 	ldbu	r2,11(r16)
21081d34:	10800c0c 	andi	r2,r2,48
21081d38:	103fe726 	beq	r2,zero,21081cd8 <__flash_rwdata_start+0xfffdfa90>
                        bFind = TRUE;
                    }
                    
                    if (bFind){
                        // my ext
                        pFileContext->bLongFilename = bLongFilename;
21081d3c:	9d004015 	stw	r20,256(r19)
                        pFileContext->bFile = (pDir->Attribute & ATTR_ARCHIVE)?TRUE:FALSE;
21081d40:	80c002c3 	ldbu	r3,11(r16)
                        pFileContext->LastAccessDate = pDir->LastAccessDate;
                        pFileContext->FirstLogicalClusterHi = pDir->FirstLogicalClusterHi;
                        pFileContext->LastWriteTime = pDir->LastWriteTime;
                        pFileContext->LastWriteDate = pDir->LastWriteDate;
                        pFileContext->FirstLogicalCluster = pDir->FirstLogicalCluster;
                        pFileContext->FileSize = pDir->FileSize;
21081d44:	00800044 	movi	r2,1
                        // my ext
                        pFileContext->bLongFilename = bLongFilename;
                        pFileContext->bFile = (pDir->Attribute & ATTR_ARCHIVE)?TRUE:FALSE;
                        pFileContext->bDirectory = (pDir->Attribute & ATTR_DIRECTORY)?TRUE:FALSE;
                        pFileContext->bVolume = (pDir->Attribute & ATTR_VOLUME_ID)?TRUE:FALSE;
                        pFileContext->DirEntryIndex = pFatBrowseHandle->DirectoryIndex; // add in v2.0.0
21081d48:	89000017 	ldw	r4,0(r17)
                    }
                    
                    if (bFind){
                        // my ext
                        pFileContext->bLongFilename = bLongFilename;
                        pFileContext->bFile = (pDir->Attribute & ATTR_ARCHIVE)?TRUE:FALSE;
21081d4c:	1806d17a 	srli	r3,r3,5
21081d50:	1886703a 	and	r3,r3,r2
21081d54:	98c04115 	stw	r3,260(r19)
                        pFileContext->bDirectory = (pDir->Attribute & ATTR_DIRECTORY)?TRUE:FALSE;
21081d58:	80c002c3 	ldbu	r3,11(r16)
21081d5c:	1806d13a 	srli	r3,r3,4
21081d60:	1886703a 	and	r3,r3,r2
21081d64:	98c04215 	stw	r3,264(r19)
                        pFileContext->bVolume = (pDir->Attribute & ATTR_VOLUME_ID)?TRUE:FALSE;
21081d68:	80c002c3 	ldbu	r3,11(r16)
                        pFileContext->DirEntryIndex = pFatBrowseHandle->DirectoryIndex; // add in v2.0.0
21081d6c:	99004415 	stw	r4,272(r19)
                    if (bFind){
                        // my ext
                        pFileContext->bLongFilename = bLongFilename;
                        pFileContext->bFile = (pDir->Attribute & ATTR_ARCHIVE)?TRUE:FALSE;
                        pFileContext->bDirectory = (pDir->Attribute & ATTR_DIRECTORY)?TRUE:FALSE;
                        pFileContext->bVolume = (pDir->Attribute & ATTR_VOLUME_ID)?TRUE:FALSE;
21081d70:	1806d0fa 	srli	r3,r3,3
21081d74:	1886703a 	and	r3,r3,r2
21081d78:	98c04315 	stw	r3,268(r19)
                        pFileContext->DirEntryIndex = pFatBrowseHandle->DirectoryIndex; // add in v2.0.0
                        
                        //
                        pFileContext->Attribute = pDir->Attribute;
21081d7c:	80c002c3 	ldbu	r3,11(r16)
21081d80:	98c04505 	stb	r3,276(r19)
                        pFileContext->CreateTime = pDir->CreateTime;
21081d84:	80c003c3 	ldbu	r3,15(r16)
21081d88:	81000383 	ldbu	r4,14(r16)
21081d8c:	1806923a 	slli	r3,r3,8
21081d90:	1906b03a 	or	r3,r3,r4
21081d94:	98c0458d 	sth	r3,278(r19)
                        pFileContext->LastAccessDate = pDir->LastAccessDate;
21081d98:	80c004c3 	ldbu	r3,19(r16)
21081d9c:	81000483 	ldbu	r4,18(r16)
21081da0:	1806923a 	slli	r3,r3,8
21081da4:	1906b03a 	or	r3,r3,r4
21081da8:	98c0468d 	sth	r3,282(r19)
                        pFileContext->FirstLogicalClusterHi = pDir->FirstLogicalClusterHi;
21081dac:	80c00543 	ldbu	r3,21(r16)
21081db0:	81000503 	ldbu	r4,20(r16)
21081db4:	1806923a 	slli	r3,r3,8
21081db8:	1906b03a 	or	r3,r3,r4
21081dbc:	98c0470d 	sth	r3,284(r19)
                        pFileContext->LastWriteTime = pDir->LastWriteTime;
21081dc0:	80c005c3 	ldbu	r3,23(r16)
21081dc4:	81000583 	ldbu	r4,22(r16)
21081dc8:	1806923a 	slli	r3,r3,8
21081dcc:	1906b03a 	or	r3,r3,r4
21081dd0:	98c0478d 	sth	r3,286(r19)
                        pFileContext->LastWriteDate = pDir->LastWriteDate;
21081dd4:	80c00643 	ldbu	r3,25(r16)
21081dd8:	81000603 	ldbu	r4,24(r16)
21081ddc:	1806923a 	slli	r3,r3,8
21081de0:	1906b03a 	or	r3,r3,r4
21081de4:	98c0480d 	sth	r3,288(r19)
                        pFileContext->FirstLogicalCluster = pDir->FirstLogicalCluster;
21081de8:	80c006c3 	ldbu	r3,27(r16)
21081dec:	81000683 	ldbu	r4,26(r16)
21081df0:	1806923a 	slli	r3,r3,8
21081df4:	1906b03a 	or	r3,r3,r4
21081df8:	98c0488d 	sth	r3,290(r19)
                        pFileContext->FileSize = pDir->FileSize;
21081dfc:	81000743 	ldbu	r4,29(r16)
21081e00:	80c00783 	ldbu	r3,30(r16)
21081e04:	818007c3 	ldbu	r6,31(r16)
21081e08:	81400703 	ldbu	r5,28(r16)
21081e0c:	2008923a 	slli	r4,r4,8
21081e10:	1806943a 	slli	r3,r3,16
21081e14:	300c963a 	slli	r6,r6,24
21081e18:	2148b03a 	or	r4,r4,r5
21081e1c:	1906b03a 	or	r3,r3,r4
21081e20:	30c6b03a 	or	r3,r6,r3
21081e24:	98c04915 	stw	r3,292(r19)
21081e28:	003fae06 	br	21081ce4 <__flash_rwdata_start+0xfffdfa9c>

void fatComposeShortFilename(FAT_DIRECTORY *pDir, char *szFilename){
    int i,nPos=0;
    
    i=0;
    while(i < 8 && pDir->Name[i] != 0 && pDir->Name[i] != ' ')
21081e2c:	81400003 	ldbu	r5,0(r16)
21081e30:	00fff7c4 	movi	r3,-33
21081e34:	28c8703a 	and	r4,r5,r3
21081e38:	21003fcc 	andi	r4,r4,255
21081e3c:	2100201c 	xori	r4,r4,128
21081e40:	213fe004 	addi	r4,r4,-128
21081e44:	2000b226 	beq	r4,zero,21082110 <Fat_FileBrowseNext+0x4c8>
        szFilename[nPos++] = pDir->Name[i++];
21081e48:	99400005 	stb	r5,0(r19)

void fatComposeShortFilename(FAT_DIRECTORY *pDir, char *szFilename){
    int i,nPos=0;
    
    i=0;
    while(i < 8 && pDir->Name[i] != 0 && pDir->Name[i] != ' ')
21081e4c:	81000043 	ldbu	r4,1(r16)
21081e50:	20c4703a 	and	r2,r4,r3
21081e54:	10803fcc 	andi	r2,r2,255
21081e58:	1080201c 	xori	r2,r2,128
21081e5c:	10bfe004 	addi	r2,r2,-128
21081e60:	1000b126 	beq	r2,zero,21082128 <Fat_FileBrowseNext+0x4e0>
        szFilename[nPos++] = pDir->Name[i++];
21081e64:	99000045 	stb	r4,1(r19)

void fatComposeShortFilename(FAT_DIRECTORY *pDir, char *szFilename){
    int i,nPos=0;
    
    i=0;
    while(i < 8 && pDir->Name[i] != 0 && pDir->Name[i] != ' ')
21081e68:	81000083 	ldbu	r4,2(r16)
21081e6c:	20c4703a 	and	r2,r4,r3
21081e70:	10803fcc 	andi	r2,r2,255
21081e74:	1080201c 	xori	r2,r2,128
21081e78:	10bfe004 	addi	r2,r2,-128
21081e7c:	10009526 	beq	r2,zero,210820d4 <Fat_FileBrowseNext+0x48c>
        szFilename[nPos++] = pDir->Name[i++];
21081e80:	99000085 	stb	r4,2(r19)

void fatComposeShortFilename(FAT_DIRECTORY *pDir, char *szFilename){
    int i,nPos=0;
    
    i=0;
    while(i < 8 && pDir->Name[i] != 0 && pDir->Name[i] != ' ')
21081e84:	810000c3 	ldbu	r4,3(r16)
21081e88:	20c4703a 	and	r2,r4,r3
21081e8c:	10803fcc 	andi	r2,r2,255
21081e90:	1080201c 	xori	r2,r2,128
21081e94:	10bfe004 	addi	r2,r2,-128
21081e98:	1000bf26 	beq	r2,zero,21082198 <Fat_FileBrowseNext+0x550>
        szFilename[nPos++] = pDir->Name[i++];
21081e9c:	990000c5 	stb	r4,3(r19)

void fatComposeShortFilename(FAT_DIRECTORY *pDir, char *szFilename){
    int i,nPos=0;
    
    i=0;
    while(i < 8 && pDir->Name[i] != 0 && pDir->Name[i] != ' ')
21081ea0:	81000103 	ldbu	r4,4(r16)
21081ea4:	20c4703a 	and	r2,r4,r3
21081ea8:	10803fcc 	andi	r2,r2,255
21081eac:	1080201c 	xori	r2,r2,128
21081eb0:	10bfe004 	addi	r2,r2,-128
21081eb4:	1000b126 	beq	r2,zero,2108217c <Fat_FileBrowseNext+0x534>
        szFilename[nPos++] = pDir->Name[i++];
21081eb8:	99000105 	stb	r4,4(r19)

void fatComposeShortFilename(FAT_DIRECTORY *pDir, char *szFilename){
    int i,nPos=0;
    
    i=0;
    while(i < 8 && pDir->Name[i] != 0 && pDir->Name[i] != ' ')
21081ebc:	81000143 	ldbu	r4,5(r16)
21081ec0:	00bff7c4 	movi	r2,-33
21081ec4:	2086703a 	and	r3,r4,r2
21081ec8:	18c03fcc 	andi	r3,r3,255
21081ecc:	18c0201c 	xori	r3,r3,128
21081ed0:	18ffe004 	addi	r3,r3,-128
21081ed4:	1800a226 	beq	r3,zero,21082160 <Fat_FileBrowseNext+0x518>
        szFilename[nPos++] = pDir->Name[i++];
21081ed8:	99000145 	stb	r4,5(r19)

void fatComposeShortFilename(FAT_DIRECTORY *pDir, char *szFilename){
    int i,nPos=0;
    
    i=0;
    while(i < 8 && pDir->Name[i] != 0 && pDir->Name[i] != ' ')
21081edc:	81000183 	ldbu	r4,6(r16)
21081ee0:	2086703a 	and	r3,r4,r2
21081ee4:	18c03fcc 	andi	r3,r3,255
21081ee8:	18c0201c 	xori	r3,r3,128
21081eec:	18ffe004 	addi	r3,r3,-128
21081ef0:	18009426 	beq	r3,zero,21082144 <Fat_FileBrowseNext+0x4fc>
        szFilename[nPos++] = pDir->Name[i++];
21081ef4:	99000185 	stb	r4,6(r19)

void fatComposeShortFilename(FAT_DIRECTORY *pDir, char *szFilename){
    int i,nPos=0;
    
    i=0;
    while(i < 8 && pDir->Name[i] != 0 && pDir->Name[i] != ' ')
21081ef8:	80c001c3 	ldbu	r3,7(r16)
21081efc:	1884703a 	and	r2,r3,r2
21081f00:	10803fcc 	andi	r2,r2,255
21081f04:	1080201c 	xori	r2,r2,128
21081f08:	10bfe004 	addi	r2,r2,-128
21081f0c:	1000a926 	beq	r2,zero,210821b4 <Fat_FileBrowseNext+0x56c>
        szFilename[nPos++] = pDir->Name[i++];
21081f10:	98c001c5 	stb	r3,7(r19)
21081f14:	808002c3 	ldbu	r2,11(r16)
21081f18:	01c00304 	movi	r7,12
21081f1c:	018002c4 	movi	r6,11
21081f20:	01400284 	movi	r5,10
21081f24:	01000244 	movi	r4,9
21081f28:	00c00204 	movi	r3,8
    
    if (pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY)){
21081f2c:	10800c0c 	andi	r2,r2,48
21081f30:	10001d26 	beq	r2,zero,21081fa8 <Fat_FileBrowseNext+0x360>
        if (pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY))     
            szFilename[nPos++] = '.';   
21081f34:	98c7883a 	add	r3,r19,r3
21081f38:	00800b84 	movi	r2,46
21081f3c:	18800005 	stb	r2,0(r3)
        i=0;
        while(i < 3 && pDir->Extension[i] != 0 && pDir->Extension[i] != ' ')
21081f40:	80c00203 	ldbu	r3,8(r16)
21081f44:	00bff7c4 	movi	r2,-33
21081f48:	1890703a 	and	r8,r3,r2
21081f4c:	42003fcc 	andi	r8,r8,255
21081f50:	4200201c 	xori	r8,r8,128
21081f54:	423fe004 	addi	r8,r8,-128
21081f58:	4000a126 	beq	r8,zero,210821e0 <Fat_FileBrowseNext+0x598>
            szFilename[nPos++] = pDir->Extension[i++];
21081f5c:	9909883a 	add	r4,r19,r4
21081f60:	20c00005 	stb	r3,0(r4)
    
    if (pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY)){
        if (pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY))     
            szFilename[nPos++] = '.';   
        i=0;
        while(i < 3 && pDir->Extension[i] != 0 && pDir->Extension[i] != ' ')
21081f64:	81000243 	ldbu	r4,9(r16)
21081f68:	2086703a 	and	r3,r4,r2
21081f6c:	18c03fcc 	andi	r3,r3,255
21081f70:	18c0201c 	xori	r3,r3,128
21081f74:	18ffe004 	addi	r3,r3,-128
21081f78:	18009526 	beq	r3,zero,210821d0 <Fat_FileBrowseNext+0x588>
            szFilename[nPos++] = pDir->Extension[i++];
21081f7c:	994b883a 	add	r5,r19,r5
21081f80:	29000005 	stb	r4,0(r5)
    
    if (pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY)){
        if (pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY))     
            szFilename[nPos++] = '.';   
        i=0;
        while(i < 3 && pDir->Extension[i] != 0 && pDir->Extension[i] != ' ')
21081f84:	80c00283 	ldbu	r3,10(r16)
21081f88:	1884703a 	and	r2,r3,r2
21081f8c:	10803fcc 	andi	r2,r2,255
21081f90:	1080201c 	xori	r2,r2,128
21081f94:	10bfe004 	addi	r2,r2,-128
21081f98:	10008f26 	beq	r2,zero,210821d8 <Fat_FileBrowseNext+0x590>
            szFilename[nPos++] = pDir->Extension[i++];
21081f9c:	998d883a 	add	r6,r19,r6
21081fa0:	30c00005 	stb	r3,0(r6)
21081fa4:	3807883a 	mov	r3,r7
    }            
    szFilename[nPos++] = 0;
21081fa8:	98c7883a 	add	r3,r19,r3
21081fac:	18000005 	stb	zero,0(r3)
21081fb0:	003f6206 	br	21081d3c <__flash_rwdata_start+0xfffdfaf4>
                    // check attribute
                    if ((pLDIR->LDIR_Attr & ATTR_LONG_NAME) != ATTR_LONG_NAME){
                        bError = TRUE;
                    }else{                        
                        // check order
                        if (OrderValue == 0){
21081fb4:	b03f451e 	bne	r22,zero,21081ccc <__flash_rwdata_start+0xfffdfa84>
                            // last entry
                            if (bLongFilename || ((OrderValue & LAST_LONG_ENTRY) != OrderValue))
21081fb8:	a0004d1e 	bne	r20,zero,210820f0 <Fat_FileBrowseNext+0x4a8>
                                bError = TRUE;
                            else
                                OrderValue = pLDIR->LDIR_Ord & 0x3F;
21081fbc:	85800003 	ldbu	r22,0(r16)
                            memset(pFileContext->szName, 0, sizeof(pFileContext->szName));
21081fc0:	9809883a 	mov	r4,r19
21081fc4:	000b883a 	mov	r5,zero
21081fc8:	01804004 	movi	r6,256
                        if (OrderValue == 0){
                            // last entry
                            if (bLongFilename || ((OrderValue & LAST_LONG_ENTRY) != OrderValue))
                                bError = TRUE;
                            else
                                OrderValue = pLDIR->LDIR_Ord & 0x3F;
21081fcc:	b5800fcc 	andi	r22,r22,63
                            memset(pFileContext->szName, 0, sizeof(pFileContext->szName));
21081fd0:	108e26c0 	call	2108e26c <memset>
                    
                    //                        
                    if (!bError){
                        int BaseOffset;
                        bLongFilename = TRUE;
                        OrderValue--;
21081fd4:	b5bfffc4 	addi	r22,r22,-1
                        BaseOffset = OrderValue * 26;
21081fd8:	b10006a4 	muli	r4,r22,26
                        // cast filename
                        memcpy(pFileContext->szName+BaseOffset, pLDIR->LDIR_Name1, 10);
21081fdc:	81800044 	addi	r6,r16,1
21081fe0:	30800003 	ldbu	r2,0(r6)
21081fe4:	990b883a 	add	r5,r19,r4
                        memcpy(pFileContext->szName+BaseOffset+10, pLDIR->LDIR_Name2, 12);
21081fe8:	80c00384 	addi	r3,r16,14
                        int BaseOffset;
                        bLongFilename = TRUE;
                        OrderValue--;
                        BaseOffset = OrderValue * 26;
                        // cast filename
                        memcpy(pFileContext->szName+BaseOffset, pLDIR->LDIR_Name1, 10);
21081fec:	28800005 	stb	r2,0(r5)
21081ff0:	81c00083 	ldbu	r7,2(r16)
                        memcpy(pFileContext->szName+BaseOffset+10, pLDIR->LDIR_Name2, 12);
21081ff4:	20800284 	addi	r2,r4,10
21081ff8:	9885883a 	add	r2,r19,r2
                        int BaseOffset;
                        bLongFilename = TRUE;
                        OrderValue--;
                        BaseOffset = OrderValue * 26;
                        // cast filename
                        memcpy(pFileContext->szName+BaseOffset, pLDIR->LDIR_Name1, 10);
21081ffc:	29c00045 	stb	r7,1(r5)
21082000:	820000c3 	ldbu	r8,3(r16)
                        memcpy(pFileContext->szName+BaseOffset+10, pLDIR->LDIR_Name2, 12);
                        memcpy(pFileContext->szName+BaseOffset+22, pLDIR->LDIR_Name3, 4);
21082004:	81c00704 	addi	r7,r16,28
21082008:	21000584 	addi	r4,r4,22
                        int BaseOffset;
                        bLongFilename = TRUE;
                        OrderValue--;
                        BaseOffset = OrderValue * 26;
                        // cast filename
                        memcpy(pFileContext->szName+BaseOffset, pLDIR->LDIR_Name1, 10);
2108200c:	2a000085 	stb	r8,2(r5)
21082010:	82000103 	ldbu	r8,4(r16)
                        memcpy(pFileContext->szName+BaseOffset+10, pLDIR->LDIR_Name2, 12);
                        memcpy(pFileContext->szName+BaseOffset+22, pLDIR->LDIR_Name3, 4);
21082014:	9909883a 	add	r4,r19,r4
                    }
                    
                    //                        
                    if (!bError){
                        int BaseOffset;
                        bLongFilename = TRUE;
21082018:	05000044 	movi	r20,1
                        OrderValue--;
                        BaseOffset = OrderValue * 26;
                        // cast filename
                        memcpy(pFileContext->szName+BaseOffset, pLDIR->LDIR_Name1, 10);
2108201c:	2a0000c5 	stb	r8,3(r5)
21082020:	82000143 	ldbu	r8,5(r16)
21082024:	2a000105 	stb	r8,4(r5)
21082028:	82000183 	ldbu	r8,6(r16)
2108202c:	2a000145 	stb	r8,5(r5)
21082030:	820001c3 	ldbu	r8,7(r16)
21082034:	2a000185 	stb	r8,6(r5)
21082038:	82000203 	ldbu	r8,8(r16)
2108203c:	2a0001c5 	stb	r8,7(r5)
21082040:	82000243 	ldbu	r8,9(r16)
21082044:	2a000205 	stb	r8,8(r5)
21082048:	81800283 	ldbu	r6,10(r16)
2108204c:	29800245 	stb	r6,9(r5)
                        memcpy(pFileContext->szName+BaseOffset+10, pLDIR->LDIR_Name2, 12);
21082050:	19400003 	ldbu	r5,0(r3)
21082054:	11400005 	stb	r5,0(r2)
21082058:	814003c3 	ldbu	r5,15(r16)
2108205c:	11400045 	stb	r5,1(r2)
21082060:	81400403 	ldbu	r5,16(r16)
21082064:	11400085 	stb	r5,2(r2)
21082068:	81400443 	ldbu	r5,17(r16)
2108206c:	114000c5 	stb	r5,3(r2)
21082070:	81400483 	ldbu	r5,18(r16)
21082074:	11400105 	stb	r5,4(r2)
21082078:	814004c3 	ldbu	r5,19(r16)
2108207c:	11400145 	stb	r5,5(r2)
21082080:	81400503 	ldbu	r5,20(r16)
21082084:	11400185 	stb	r5,6(r2)
21082088:	81400543 	ldbu	r5,21(r16)
2108208c:	114001c5 	stb	r5,7(r2)
21082090:	81400583 	ldbu	r5,22(r16)
21082094:	11400205 	stb	r5,8(r2)
21082098:	814005c3 	ldbu	r5,23(r16)
2108209c:	11400245 	stb	r5,9(r2)
210820a0:	81400603 	ldbu	r5,24(r16)
210820a4:	11400285 	stb	r5,10(r2)
210820a8:	80c00643 	ldbu	r3,25(r16)
210820ac:	10c002c5 	stb	r3,11(r2)
                        memcpy(pFileContext->szName+BaseOffset+22, pLDIR->LDIR_Name3, 4);
210820b0:	38800003 	ldbu	r2,0(r7)
210820b4:	20800005 	stb	r2,0(r4)
210820b8:	80800743 	ldbu	r2,29(r16)
210820bc:	20800045 	stb	r2,1(r4)
210820c0:	80800783 	ldbu	r2,30(r16)
210820c4:	20800085 	stb	r2,2(r4)
210820c8:	808007c3 	ldbu	r2,31(r16)
210820cc:	208000c5 	stb	r2,3(r4)
210820d0:	003ef906 	br	21081cb8 <__flash_rwdata_start+0xfffdfa70>
210820d4:	808002c3 	ldbu	r2,11(r16)

void fatComposeShortFilename(FAT_DIRECTORY *pDir, char *szFilename){
    int i,nPos=0;
    
    i=0;
    while(i < 8 && pDir->Name[i] != 0 && pDir->Name[i] != ' ')
210820d8:	01c00184 	movi	r7,6
210820dc:	01800144 	movi	r6,5
210820e0:	01400104 	movi	r5,4
210820e4:	010000c4 	movi	r4,3
210820e8:	00c00084 	movi	r3,2
210820ec:	003f8f06 	br	21081f2c <__flash_rwdata_start+0xfffdfce4>
                            // last entry
                            if (bLongFilename || ((OrderValue & LAST_LONG_ENTRY) != OrderValue))
                                bError = TRUE;
                            else
                                OrderValue = pLDIR->LDIR_Ord & 0x3F;
                            memset(pFileContext->szName, 0, sizeof(pFileContext->szName));
210820f0:	000b883a 	mov	r5,zero
210820f4:	01804004 	movi	r6,256
210820f8:	9809883a 	mov	r4,r19
210820fc:	108e26c0 	call	2108e26c <memset>
                        pFileContext->FileSize = pDir->FileSize;
                    }                        
                }                    
            }                
        }            
    }while (!bFind && !fatIsLastDir(pDir) && !bError);
21082100:	8009883a 	mov	r4,r16
21082104:	10832000 	call	21083200 <fatIsLastDir>
21082108:	0005883a 	mov	r2,zero
2108210c:	003ef506 	br	21081ce4 <__flash_rwdata_start+0xfffdfa9c>

void fatComposeShortFilename(FAT_DIRECTORY *pDir, char *szFilename){
    int i,nPos=0;
    
    i=0;
    while(i < 8 && pDir->Name[i] != 0 && pDir->Name[i] != ' ')
21082110:	01c00104 	movi	r7,4
21082114:	018000c4 	movi	r6,3
21082118:	01400084 	movi	r5,2
2108211c:	01000044 	movi	r4,1
21082120:	0007883a 	mov	r3,zero
21082124:	003f8106 	br	21081f2c <__flash_rwdata_start+0xfffdfce4>
21082128:	808002c3 	ldbu	r2,11(r16)
2108212c:	01c00144 	movi	r7,5
21082130:	01800104 	movi	r6,4
21082134:	014000c4 	movi	r5,3
21082138:	01000084 	movi	r4,2
2108213c:	00c00044 	movi	r3,1
21082140:	003f7a06 	br	21081f2c <__flash_rwdata_start+0xfffdfce4>
21082144:	808002c3 	ldbu	r2,11(r16)
21082148:	01c00284 	movi	r7,10
2108214c:	01800244 	movi	r6,9
21082150:	01400204 	movi	r5,8
21082154:	010001c4 	movi	r4,7
21082158:	00c00184 	movi	r3,6
2108215c:	003f7306 	br	21081f2c <__flash_rwdata_start+0xfffdfce4>
21082160:	808002c3 	ldbu	r2,11(r16)
21082164:	01c00244 	movi	r7,9
21082168:	01800204 	movi	r6,8
2108216c:	014001c4 	movi	r5,7
21082170:	01000184 	movi	r4,6
21082174:	00c00144 	movi	r3,5
21082178:	003f6c06 	br	21081f2c <__flash_rwdata_start+0xfffdfce4>
2108217c:	808002c3 	ldbu	r2,11(r16)
21082180:	01c00204 	movi	r7,8
21082184:	018001c4 	movi	r6,7
21082188:	01400184 	movi	r5,6
2108218c:	01000144 	movi	r4,5
21082190:	00c00104 	movi	r3,4
21082194:	003f6506 	br	21081f2c <__flash_rwdata_start+0xfffdfce4>
21082198:	808002c3 	ldbu	r2,11(r16)
2108219c:	01c001c4 	movi	r7,7
210821a0:	01800184 	movi	r6,6
210821a4:	01400144 	movi	r5,5
210821a8:	01000104 	movi	r4,4
210821ac:	00c000c4 	movi	r3,3
210821b0:	003f5e06 	br	21081f2c <__flash_rwdata_start+0xfffdfce4>
210821b4:	808002c3 	ldbu	r2,11(r16)
210821b8:	01c002c4 	movi	r7,11
210821bc:	01800284 	movi	r6,10
210821c0:	01400244 	movi	r5,9
210821c4:	01000204 	movi	r4,8
210821c8:	00c001c4 	movi	r3,7
210821cc:	003f5706 	br	21081f2c <__flash_rwdata_start+0xfffdfce4>
    
    if (pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY)){
        if (pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY))     
            szFilename[nPos++] = '.';   
        i=0;
        while(i < 3 && pDir->Extension[i] != 0 && pDir->Extension[i] != ' ')
210821d0:	2807883a 	mov	r3,r5
210821d4:	003f7406 	br	21081fa8 <__flash_rwdata_start+0xfffdfd60>
210821d8:	3007883a 	mov	r3,r6
210821dc:	003f7206 	br	21081fa8 <__flash_rwdata_start+0xfffdfd60>
210821e0:	2007883a 	mov	r3,r4
210821e4:	003f7006 	br	21081fa8 <__flash_rwdata_start+0xfffdfd60>

210821e8 <Fat_FileCount>:
    return bFind;
    
}


unsigned int Fat_FileCount(FAT_HANDLE Fat){
210821e8:	deffb204 	addi	sp,sp,-312
210821ec:	dfc04d15 	stw	ra,308(sp)
210821f0:	dc004c15 	stw	r16,304(sp)
    return Type;        
}

bool Fat_FileBrowseBegin(FAT_HANDLE hFat, FAT_BROWSE_HANDLE *pFatBrowseHandle){
    VOLUME_INFO *pVol = (VOLUME_INFO *)hFat;
    if (!pVol)
210821f4:	20000d26 	beq	r4,zero,2108222c <Fat_FileCount+0x44>
        return FALSE;
    if (!pVol->bMount)
210821f8:	20800517 	ldw	r2,20(r4)
210821fc:	10000b26 	beq	r2,zero,2108222c <Fat_FileCount+0x44>
        return FALSE;
    pFatBrowseHandle->DirectoryIndex = -1;
21082200:	00bfffc4 	movi	r2,-1
21082204:	d8804a15 	stw	r2,296(sp)
    pFatBrowseHandle->hFat = hFat;
21082208:	d9004b15 	stw	r4,300(sp)
2108220c:	0021883a 	mov	r16,zero
21082210:	00000106 	br	21082218 <Fat_FileCount+0x30>
    FAT_BROWSE_HANDLE hBrowse;
    FILE_CONTEXT FileContext;
    
    if (Fat_FileBrowseBegin(Fat, &hBrowse)){
        while(Fat_FileBrowseNext(&hBrowse, &FileContext))
            nCount++;
21082214:	84000044 	addi	r16,r16,1
    unsigned int nCount = 0;
    FAT_BROWSE_HANDLE hBrowse;
    FILE_CONTEXT FileContext;
    
    if (Fat_FileBrowseBegin(Fat, &hBrowse)){
        while(Fat_FileBrowseNext(&hBrowse, &FileContext))
21082218:	d9004a04 	addi	r4,sp,296
2108221c:	d80b883a 	mov	r5,sp
21082220:	1081c480 	call	21081c48 <Fat_FileBrowseNext>
21082224:	103ffb1e 	bne	r2,zero,21082214 <__flash_rwdata_start+0xfffdffcc>
21082228:	00000106 	br	21082230 <Fat_FileCount+0x48>
    
}


unsigned int Fat_FileCount(FAT_HANDLE Fat){
    unsigned int nCount = 0;
2108222c:	0021883a 	mov	r16,zero
        while(Fat_FileBrowseNext(&hBrowse, &FileContext))
            nCount++;
    }
    
    return nCount;
}
21082230:	8005883a 	mov	r2,r16
21082234:	dfc04d17 	ldw	ra,308(sp)
21082238:	dc004c17 	ldw	r16,304(sp)
2108223c:	dec04e04 	addi	sp,sp,312
21082240:	f800283a 	ret

21082244 <fatSameLongFilename>:

bool fatSameLongFilename(alt_u16 *p1, alt_u16 *p2){
    bool bSame = TRUE;
    
    while(bSame && ((*p1 != 0) || (*p2 != 0))){
21082244:	2080000b 	ldhu	r2,0(r4)
        if (*p1 != *p2){
            bSame = FALSE;
        }
        p1++;
21082248:	21000084 	addi	r4,r4,2
}

bool fatSameLongFilename(alt_u16 *p1, alt_u16 *p2){
    bool bSame = TRUE;
    
    while(bSame && ((*p1 != 0) || (*p2 != 0))){
2108224c:	1000031e 	bne	r2,zero,2108225c <fatSameLongFilename+0x18>
21082250:	2880000b 	ldhu	r2,0(r5)
21082254:	1005003a 	cmpeq	r2,r2,zero
21082258:	f800283a 	ret
        if (*p1 != *p2){
2108225c:	28c0000b 	ldhu	r3,0(r5)
            bSame = FALSE;
        }
        p1++;
        p2++;
21082260:	29400084 	addi	r5,r5,2
}

bool fatSameLongFilename(alt_u16 *p1, alt_u16 *p2){
    bool bSame = TRUE;
    
    while(bSame && ((*p1 != 0) || (*p2 != 0))){
21082264:	18ffffcc 	andi	r3,r3,65535
21082268:	10fff626 	beq	r2,r3,21082244 <__flash_rwdata_start+0xfffdfffc>
2108226c:	0005883a 	mov	r2,zero
        p2++;
        
    }
    
    return bSame;
}
21082270:	f800283a 	ret

21082274 <fatComposeShortFilename>:

void fatComposeShortFilename(FAT_DIRECTORY *pDir, char *szFilename){
    int i,nPos=0;
    
    i=0;
    while(i < 8 && pDir->Name[i] != 0 && pDir->Name[i] != ' ')
21082274:	21800003 	ldbu	r6,0(r4)
21082278:	00bff7c4 	movi	r2,-33
2108227c:	3086703a 	and	r3,r6,r2
21082280:	18c03fcc 	andi	r3,r3,255
21082284:	18c0201c 	xori	r3,r3,128
21082288:	18ffe004 	addi	r3,r3,-128
2108228c:	18005b26 	beq	r3,zero,210823fc <fatComposeShortFilename+0x188>
        szFilename[nPos++] = pDir->Name[i++];
21082290:	29800005 	stb	r6,0(r5)

void fatComposeShortFilename(FAT_DIRECTORY *pDir, char *szFilename){
    int i,nPos=0;
    
    i=0;
    while(i < 8 && pDir->Name[i] != 0 && pDir->Name[i] != ' ')
21082294:	21800043 	ldbu	r6,1(r4)
21082298:	3086703a 	and	r3,r6,r2
2108229c:	18c03fcc 	andi	r3,r3,255
210822a0:	18c0201c 	xori	r3,r3,128
210822a4:	18ffe004 	addi	r3,r3,-128
210822a8:	18005626 	beq	r3,zero,21082404 <fatComposeShortFilename+0x190>
        szFilename[nPos++] = pDir->Name[i++];
210822ac:	29800045 	stb	r6,1(r5)

void fatComposeShortFilename(FAT_DIRECTORY *pDir, char *szFilename){
    int i,nPos=0;
    
    i=0;
    while(i < 8 && pDir->Name[i] != 0 && pDir->Name[i] != ' ')
210822b0:	21800083 	ldbu	r6,2(r4)
210822b4:	3086703a 	and	r3,r6,r2
210822b8:	18c03fcc 	andi	r3,r3,255
210822bc:	18c0201c 	xori	r3,r3,128
210822c0:	18ffe004 	addi	r3,r3,-128
210822c4:	18005126 	beq	r3,zero,2108240c <fatComposeShortFilename+0x198>
        szFilename[nPos++] = pDir->Name[i++];
210822c8:	29800085 	stb	r6,2(r5)

void fatComposeShortFilename(FAT_DIRECTORY *pDir, char *szFilename){
    int i,nPos=0;
    
    i=0;
    while(i < 8 && pDir->Name[i] != 0 && pDir->Name[i] != ' ')
210822cc:	218000c3 	ldbu	r6,3(r4)
210822d0:	3086703a 	and	r3,r6,r2
210822d4:	18c03fcc 	andi	r3,r3,255
210822d8:	18c0201c 	xori	r3,r3,128
210822dc:	18ffe004 	addi	r3,r3,-128
210822e0:	18004c26 	beq	r3,zero,21082414 <fatComposeShortFilename+0x1a0>
        szFilename[nPos++] = pDir->Name[i++];
210822e4:	298000c5 	stb	r6,3(r5)

void fatComposeShortFilename(FAT_DIRECTORY *pDir, char *szFilename){
    int i,nPos=0;
    
    i=0;
    while(i < 8 && pDir->Name[i] != 0 && pDir->Name[i] != ' ')
210822e8:	21800103 	ldbu	r6,4(r4)
210822ec:	3086703a 	and	r3,r6,r2
210822f0:	18c03fcc 	andi	r3,r3,255
210822f4:	18c0201c 	xori	r3,r3,128
210822f8:	18ffe004 	addi	r3,r3,-128
210822fc:	18004726 	beq	r3,zero,2108241c <fatComposeShortFilename+0x1a8>
        szFilename[nPos++] = pDir->Name[i++];
21082300:	29800105 	stb	r6,4(r5)

void fatComposeShortFilename(FAT_DIRECTORY *pDir, char *szFilename){
    int i,nPos=0;
    
    i=0;
    while(i < 8 && pDir->Name[i] != 0 && pDir->Name[i] != ' ')
21082304:	21800143 	ldbu	r6,5(r4)
21082308:	3086703a 	and	r3,r6,r2
2108230c:	18c03fcc 	andi	r3,r3,255
21082310:	18c0201c 	xori	r3,r3,128
21082314:	18ffe004 	addi	r3,r3,-128
21082318:	18004226 	beq	r3,zero,21082424 <fatComposeShortFilename+0x1b0>
        szFilename[nPos++] = pDir->Name[i++];
2108231c:	29800145 	stb	r6,5(r5)

void fatComposeShortFilename(FAT_DIRECTORY *pDir, char *szFilename){
    int i,nPos=0;
    
    i=0;
    while(i < 8 && pDir->Name[i] != 0 && pDir->Name[i] != ' ')
21082320:	21800183 	ldbu	r6,6(r4)
21082324:	3086703a 	and	r3,r6,r2
21082328:	18c03fcc 	andi	r3,r3,255
2108232c:	18c0201c 	xori	r3,r3,128
21082330:	18ffe004 	addi	r3,r3,-128
21082334:	18003d26 	beq	r3,zero,2108242c <fatComposeShortFilename+0x1b8>
        szFilename[nPos++] = pDir->Name[i++];
21082338:	29800185 	stb	r6,6(r5)

void fatComposeShortFilename(FAT_DIRECTORY *pDir, char *szFilename){
    int i,nPos=0;
    
    i=0;
    while(i < 8 && pDir->Name[i] != 0 && pDir->Name[i] != ' ')
2108233c:	20c001c3 	ldbu	r3,7(r4)
21082340:	1884703a 	and	r2,r3,r2
21082344:	10803fcc 	andi	r2,r2,255
21082348:	1080201c 	xori	r2,r2,128
2108234c:	10bfe004 	addi	r2,r2,-128
21082350:	10003826 	beq	r2,zero,21082434 <fatComposeShortFilename+0x1c0>
        szFilename[nPos++] = pDir->Name[i++];
21082354:	28c001c5 	stb	r3,7(r5)
21082358:	00800204 	movi	r2,8
    
    if (pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY)){
2108235c:	20c002c3 	ldbu	r3,11(r4)
21082360:	18c00c0c 	andi	r3,r3,48
21082364:	18002026 	beq	r3,zero,210823e8 <fatComposeShortFilename+0x174>
        if (pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY))     
            szFilename[nPos++] = '.';   
21082368:	2887883a 	add	r3,r5,r2
2108236c:	01800b84 	movi	r6,46
21082370:	19800005 	stb	r6,0(r3)
        i=0;
        while(i < 3 && pDir->Extension[i] != 0 && pDir->Extension[i] != ' ')
21082374:	22000203 	ldbu	r8,8(r4)
21082378:	00fff7c4 	movi	r3,-33
    while(i < 8 && pDir->Name[i] != 0 && pDir->Name[i] != ' ')
        szFilename[nPos++] = pDir->Name[i++];
    
    if (pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY)){
        if (pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY))     
            szFilename[nPos++] = '.';   
2108237c:	11c00044 	addi	r7,r2,1
        i=0;
        while(i < 3 && pDir->Extension[i] != 0 && pDir->Extension[i] != ' ')
21082380:	40cc703a 	and	r6,r8,r3
21082384:	31803fcc 	andi	r6,r6,255
21082388:	3180201c 	xori	r6,r6,128
2108238c:	31bfe004 	addi	r6,r6,-128
21082390:	30001826 	beq	r6,zero,210823f4 <fatComposeShortFilename+0x180>
            szFilename[nPos++] = pDir->Extension[i++];
21082394:	29cf883a 	add	r7,r5,r7
21082398:	3a000005 	stb	r8,0(r7)
    
    if (pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY)){
        if (pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY))     
            szFilename[nPos++] = '.';   
        i=0;
        while(i < 3 && pDir->Extension[i] != 0 && pDir->Extension[i] != ' ')
2108239c:	22000243 	ldbu	r8,9(r4)
            szFilename[nPos++] = pDir->Extension[i++];
210823a0:	11c00084 	addi	r7,r2,2
    
    if (pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY)){
        if (pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY))     
            szFilename[nPos++] = '.';   
        i=0;
        while(i < 3 && pDir->Extension[i] != 0 && pDir->Extension[i] != ' ')
210823a4:	40cc703a 	and	r6,r8,r3
210823a8:	31803fcc 	andi	r6,r6,255
210823ac:	3180201c 	xori	r6,r6,128
210823b0:	31bfe004 	addi	r6,r6,-128
210823b4:	30000f26 	beq	r6,zero,210823f4 <fatComposeShortFilename+0x180>
            szFilename[nPos++] = pDir->Extension[i++];
210823b8:	29cf883a 	add	r7,r5,r7
210823bc:	3a000005 	stb	r8,0(r7)
    
    if (pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY)){
        if (pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY))     
            szFilename[nPos++] = '.';   
        i=0;
        while(i < 3 && pDir->Extension[i] != 0 && pDir->Extension[i] != ' ')
210823c0:	21800283 	ldbu	r6,10(r4)
            szFilename[nPos++] = pDir->Extension[i++];
210823c4:	110000c4 	addi	r4,r2,3
    
    if (pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY)){
        if (pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY))     
            szFilename[nPos++] = '.';   
        i=0;
        while(i < 3 && pDir->Extension[i] != 0 && pDir->Extension[i] != ' ')
210823c8:	30c6703a 	and	r3,r6,r3
210823cc:	18c03fcc 	andi	r3,r3,255
210823d0:	18c0201c 	xori	r3,r3,128
210823d4:	18ffe004 	addi	r3,r3,-128
210823d8:	18001826 	beq	r3,zero,2108243c <fatComposeShortFilename+0x1c8>
            szFilename[nPos++] = pDir->Extension[i++];
210823dc:	2909883a 	add	r4,r5,r4
210823e0:	10800104 	addi	r2,r2,4
210823e4:	21800005 	stb	r6,0(r4)
    }            
    szFilename[nPos++] = 0;
210823e8:	288b883a 	add	r5,r5,r2
210823ec:	28000005 	stb	zero,0(r5)
210823f0:	f800283a 	ret
    if (pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY)){
        if (pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY))     
            szFilename[nPos++] = '.';   
        i=0;
        while(i < 3 && pDir->Extension[i] != 0 && pDir->Extension[i] != ' ')
            szFilename[nPos++] = pDir->Extension[i++];
210823f4:	3805883a 	mov	r2,r7
210823f8:	003ffb06 	br	210823e8 <__flash_rwdata_start+0xfffe01a0>
    return bSame;
}


void fatComposeShortFilename(FAT_DIRECTORY *pDir, char *szFilename){
    int i,nPos=0;
210823fc:	0005883a 	mov	r2,zero
21082400:	003fd606 	br	2108235c <__flash_rwdata_start+0xfffe0114>
    
    i=0;
    while(i < 8 && pDir->Name[i] != 0 && pDir->Name[i] != ' ')
        szFilename[nPos++] = pDir->Name[i++];
21082404:	00800044 	movi	r2,1
21082408:	003fd406 	br	2108235c <__flash_rwdata_start+0xfffe0114>
2108240c:	00800084 	movi	r2,2
21082410:	003fd206 	br	2108235c <__flash_rwdata_start+0xfffe0114>
21082414:	008000c4 	movi	r2,3
21082418:	003fd006 	br	2108235c <__flash_rwdata_start+0xfffe0114>
2108241c:	00800104 	movi	r2,4
21082420:	003fce06 	br	2108235c <__flash_rwdata_start+0xfffe0114>
21082424:	00800144 	movi	r2,5
21082428:	003fcc06 	br	2108235c <__flash_rwdata_start+0xfffe0114>
2108242c:	00800184 	movi	r2,6
21082430:	003fca06 	br	2108235c <__flash_rwdata_start+0xfffe0114>
21082434:	008001c4 	movi	r2,7
21082438:	003fc806 	br	2108235c <__flash_rwdata_start+0xfffe0114>
    if (pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY)){
        if (pDir->Attribute & (ATTR_ARCHIVE | ATTR_DIRECTORY))     
            szFilename[nPos++] = '.';   
        i=0;
        while(i < 3 && pDir->Extension[i] != 0 && pDir->Extension[i] != ' ')
            szFilename[nPos++] = pDir->Extension[i++];
2108243c:	2005883a 	mov	r2,r4
21082440:	003fe906 	br	210823e8 <__flash_rwdata_start+0xfffe01a0>

21082444 <Fat_CheckExtension>:
    szFilename[nPos++] = 0;
}


bool Fat_CheckExtension(FILE_CONTEXT *pFileContext, char* ext){
	if(pFileContext == NULL)
21082444:	20001426 	beq	r4,zero,21082498 <Fat_CheckExtension+0x54>
    }            
    szFilename[nPos++] = 0;
}


bool Fat_CheckExtension(FILE_CONTEXT *pFileContext, char* ext){
21082448:	defffe04 	addi	sp,sp,-8
2108244c:	dc000015 	stw	r16,0(sp)
21082450:	2821883a 	mov	r16,r5
	if(pFileContext == NULL)
		return 0;

	char * point;
	if ((point = strrchr(pFileContext->szName, '.')) != NULL) {
21082454:	01400b84 	movi	r5,46
    }            
    szFilename[nPos++] = 0;
}


bool Fat_CheckExtension(FILE_CONTEXT *pFileContext, char* ext){
21082458:	dfc00115 	stw	ra,4(sp)
	if(pFileContext == NULL)
		return 0;

	char * point;
	if ((point = strrchr(pFileContext->szName, '.')) != NULL) {
2108245c:	108e7b80 	call	2108e7b8 <strrchr>
21082460:	10000826 	beq	r2,zero,21082484 <Fat_CheckExtension+0x40>
		if (strcmp(point, ext) == 0) {
21082464:	1009883a 	mov	r4,r2
21082468:	800b883a 	mov	r5,r16
2108246c:	108e5ec0 	call	2108e5ec <strcmp>
21082470:	1005003a 	cmpeq	r2,r2,zero
			return 1;
		}
	}

	return 0;
}
21082474:	dfc00117 	ldw	ra,4(sp)
21082478:	dc000017 	ldw	r16,0(sp)
2108247c:	dec00204 	addi	sp,sp,8
21082480:	f800283a 	ret
		if (strcmp(point, ext) == 0) {
			return 1;
		}
	}

	return 0;
21082484:	0005883a 	mov	r2,zero
}
21082488:	dfc00117 	ldw	ra,4(sp)
2108248c:	dc000017 	ldw	r16,0(sp)
21082490:	dec00204 	addi	sp,sp,8
21082494:	f800283a 	ret
}


bool Fat_CheckExtension(FILE_CONTEXT *pFileContext, char* ext){
	if(pFileContext == NULL)
		return 0;
21082498:	0005883a 	mov	r2,zero
			return 1;
		}
	}

	return 0;
}
2108249c:	f800283a 	ret

210824a0 <Fat_GetFileName>:
char* Fat_GetFileName(FILE_CONTEXT *pFileContext){
	if(pFileContext == NULL)
		return 0;
	else
		return pFileContext->szName;
}
210824a0:	2005883a 	mov	r2,r4
210824a4:	f800283a 	ret

210824a8 <Fat_FileExist>:
    return Type;        
}

bool Fat_FileBrowseBegin(FAT_HANDLE hFat, FAT_BROWSE_HANDLE *pFatBrowseHandle){
    VOLUME_INFO *pVol = (VOLUME_INFO *)hFat;
    if (!pVol)
210824a8:	20001926 	beq	r4,zero,21082510 <Fat_FileExist+0x68>
        return FALSE;
    if (!pVol->bMount)
210824ac:	20800517 	ldw	r2,20(r4)
210824b0:	10001726 	beq	r2,zero,21082510 <Fat_FileExist+0x68>
		return 0;
	else
		return pFileContext->szName;
}

bool Fat_FileExist(FAT_HANDLE Fat, const char *pFilename){
210824b4:	deffb204 	addi	sp,sp,-312
    VOLUME_INFO *pVol = (VOLUME_INFO *)hFat;
    if (!pVol)
        return FALSE;
    if (!pVol->bMount)
        return FALSE;
    pFatBrowseHandle->DirectoryIndex = -1;
210824b8:	00bfffc4 	movi	r2,-1
		return 0;
	else
		return pFileContext->szName;
}

bool Fat_FileExist(FAT_HANDLE Fat, const char *pFilename){
210824bc:	dc004c15 	stw	r16,304(sp)
210824c0:	dfc04d15 	stw	ra,308(sp)
210824c4:	2821883a 	mov	r16,r5
    VOLUME_INFO *pVol = (VOLUME_INFO *)hFat;
    if (!pVol)
        return FALSE;
    if (!pVol->bMount)
        return FALSE;
    pFatBrowseHandle->DirectoryIndex = -1;
210824c8:	d8804a15 	stw	r2,296(sp)
    pFatBrowseHandle->hFat = hFat;
210824cc:	d9004b15 	stw	r4,300(sp)
bool Fat_FileExist(FAT_HANDLE Fat, const char *pFilename){
    bool bFind = FALSE;
    FAT_BROWSE_HANDLE hBrowse;     
    FILE_CONTEXT FileContext;
    if (Fat_FileBrowseBegin(Fat, &hBrowse)){
        while (!bFind && Fat_FileBrowseNext(&hBrowse, &FileContext)){
210824d0:	d9004a04 	addi	r4,sp,296
210824d4:	d80b883a 	mov	r5,sp
210824d8:	1081c480 	call	21081c48 <Fat_FileBrowseNext>
210824dc:	10001c26 	beq	r2,zero,21082550 <Fat_FileExist+0xa8>
            if (FileContext.bLongFilename){
210824e0:	d8804017 	ldw	r2,256(sp)
210824e4:	10000c1e 	bne	r2,zero,21082518 <Fat_FileExist+0x70>
                bFind = fatSameLongFilename((alt_u16 *)FileContext.szName, (alt_u16 *)pFilename);
            }else{
                if (strcmp(FileContext.szName, pFilename) == 0)
210824e8:	d809883a 	mov	r4,sp
210824ec:	800b883a 	mov	r5,r16
210824f0:	108e5ec0 	call	2108e5ec <strcmp>
210824f4:	1005003a 	cmpeq	r2,r2,zero
bool Fat_FileExist(FAT_HANDLE Fat, const char *pFilename){
    bool bFind = FALSE;
    FAT_BROWSE_HANDLE hBrowse;     
    FILE_CONTEXT FileContext;
    if (Fat_FileBrowseBegin(Fat, &hBrowse)){
        while (!bFind && Fat_FileBrowseNext(&hBrowse, &FileContext)){
210824f8:	103ff526 	beq	r2,zero,210824d0 <__flash_rwdata_start+0xfffe0288>
210824fc:	00800044 	movi	r2,1
            }    
        } // while 
        Fat_FileClose(Fat); 
    }
    return bFind;            
}    
21082500:	dfc04d17 	ldw	ra,308(sp)
21082504:	dc004c17 	ldw	r16,304(sp)
21082508:	dec04e04 	addi	sp,sp,312
2108250c:	f800283a 	ret
	else
		return pFileContext->szName;
}

bool Fat_FileExist(FAT_HANDLE Fat, const char *pFilename){
    bool bFind = FALSE;
21082510:	0005883a 	mov	r2,zero
            }    
        } // while 
        Fat_FileClose(Fat); 
    }
    return bFind;            
}    
21082514:	f800283a 	ret
21082518:	8009883a 	mov	r4,r16
    bool bFind = FALSE;
    FAT_BROWSE_HANDLE hBrowse;     
    FILE_CONTEXT FileContext;
    if (Fat_FileBrowseBegin(Fat, &hBrowse)){
        while (!bFind && Fat_FileBrowseNext(&hBrowse, &FileContext)){
            if (FileContext.bLongFilename){
2108251c:	d805883a 	mov	r2,sp
}

bool fatSameLongFilename(alt_u16 *p1, alt_u16 *p2){
    bool bSame = TRUE;
    
    while(bSame && ((*p1 != 0) || (*p2 != 0))){
21082520:	10c0000b 	ldhu	r3,0(r2)
        if (*p1 != *p2){
            bSame = FALSE;
        }
        p1++;
21082524:	10800084 	addi	r2,r2,2
}

bool fatSameLongFilename(alt_u16 *p1, alt_u16 *p2){
    bool bSame = TRUE;
    
    while(bSame && ((*p1 != 0) || (*p2 != 0))){
21082528:	1800041e 	bne	r3,zero,2108253c <Fat_FileExist+0x94>
2108252c:	2080000b 	ldhu	r2,0(r4)
21082530:	1005003a 	cmpeq	r2,r2,zero
bool Fat_FileExist(FAT_HANDLE Fat, const char *pFilename){
    bool bFind = FALSE;
    FAT_BROWSE_HANDLE hBrowse;     
    FILE_CONTEXT FileContext;
    if (Fat_FileBrowseBegin(Fat, &hBrowse)){
        while (!bFind && Fat_FileBrowseNext(&hBrowse, &FileContext)){
21082534:	103fe626 	beq	r2,zero,210824d0 <__flash_rwdata_start+0xfffe0288>
21082538:	003ff006 	br	210824fc <__flash_rwdata_start+0xfffe02b4>

bool fatSameLongFilename(alt_u16 *p1, alt_u16 *p2){
    bool bSame = TRUE;
    
    while(bSame && ((*p1 != 0) || (*p2 != 0))){
        if (*p1 != *p2){
2108253c:	2180000b 	ldhu	r6,0(r4)
            bSame = FALSE;
        }
        p1++;
        p2++;
21082540:	21000084 	addi	r4,r4,2
}

bool fatSameLongFilename(alt_u16 *p1, alt_u16 *p2){
    bool bSame = TRUE;
    
    while(bSame && ((*p1 != 0) || (*p2 != 0))){
21082544:	31bfffcc 	andi	r6,r6,65535
21082548:	30fff526 	beq	r6,r3,21082520 <__flash_rwdata_start+0xfffe02d8>
2108254c:	003fe006 	br	210824d0 <__flash_rwdata_start+0xfffe0288>
	else
		return pFileContext->szName;
}

bool Fat_FileExist(FAT_HANDLE Fat, const char *pFilename){
    bool bFind = FALSE;
21082550:	0005883a 	mov	r2,zero
            }    
        } // while 
        Fat_FileClose(Fat); 
    }
    return bFind;            
}    
21082554:	dfc04d17 	ldw	ra,308(sp)
21082558:	dc004c17 	ldw	r16,304(sp)
2108255c:	dec04e04 	addi	sp,sp,312
21082560:	f800283a 	ret

21082564 <Fat_FileOpen>:
    return Type;        
}

bool Fat_FileBrowseBegin(FAT_HANDLE hFat, FAT_BROWSE_HANDLE *pFatBrowseHandle){
    VOLUME_INFO *pVol = (VOLUME_INFO *)hFat;
    if (!pVol)
21082564:	20004926 	beq	r4,zero,2108268c <Fat_FileOpen+0x128>
        return FALSE;
    if (!pVol->bMount)
21082568:	20800517 	ldw	r2,20(r4)
2108256c:	10004726 	beq	r2,zero,2108268c <Fat_FileOpen+0x128>
    }
    return bFind;            
}    
 
// File Access
FAT_FILE_HANDLE Fat_FileOpen(FAT_HANDLE Fat, const char *pFilename){
21082570:	deff7004 	addi	sp,sp,-576
    VOLUME_INFO *pVol = (VOLUME_INFO *)hFat;
    if (!pVol)
        return FALSE;
    if (!pVol->bMount)
        return FALSE;
    pFatBrowseHandle->DirectoryIndex = -1;
21082574:	00bfffc4 	movi	r2,-1
    }
    return bFind;            
}    
 
// File Access
FAT_FILE_HANDLE Fat_FileOpen(FAT_HANDLE Fat, const char *pFilename){
21082578:	dc808e15 	stw	r18,568(sp)
2108257c:	dc408d15 	stw	r17,564(sp)
21082580:	dc008c15 	stw	r16,560(sp)
21082584:	dfc08f15 	stw	ra,572(sp)
21082588:	2821883a 	mov	r16,r5
2108258c:	2023883a 	mov	r17,r4
    VOLUME_INFO *pVol = (VOLUME_INFO *)hFat;
    if (!pVol)
        return FALSE;
    if (!pVol->bMount)
        return FALSE;
    pFatBrowseHandle->DirectoryIndex = -1;
21082590:	d8808a15 	stw	r2,552(sp)
    pFatBrowseHandle->hFat = hFat;
21082594:	d9008b15 	stw	r4,556(sp)
                alt_u16 *pData16;
                alt_u8 *pData8;
                pData16 = (alt_u16 *)FileContext.szName;
                pData8 = FileContext.szName;
                while(*pData16){
                    if (*pData8 && *pData8 != ' ')
21082598:	04bff7c4 	movi	r18,-33
    FAT_FILE_INFO *pFile = 0;
    int nPos = 0;
    char szWaveFilename[MAX_FILENAME_LENGTH];
    
    if (Fat_FileBrowseBegin(Fat, &hBrowse)){
        while (!bFind && Fat_FileBrowseNext(&hBrowse, &FileContext)){
2108259c:	d9008a04 	addi	r4,sp,552
210825a0:	d80b883a 	mov	r5,sp
210825a4:	1081c480 	call	21081c48 <Fat_FileBrowseNext>
210825a8:	10004026 	beq	r2,zero,210826ac <Fat_FileOpen+0x148>
            if (FileContext.bLongFilename){
210825ac:	d8804017 	ldw	r2,256(sp)
210825b0:	10003826 	beq	r2,zero,21082694 <Fat_FileOpen+0x130>
                nPos = 0;
                alt_u16 *pData16;
                alt_u8 *pData8;
                pData16 = (alt_u16 *)FileContext.szName;
                pData8 = FileContext.szName;
                while(*pData16){
210825b4:	d880000b 	ldhu	r2,0(sp)
210825b8:	10003e26 	beq	r2,zero,210826b4 <Fat_FileOpen+0x150>
210825bc:	d9000044 	addi	r4,sp,1
210825c0:	d805883a 	mov	r2,sp
210825c4:	000d883a 	mov	r6,zero
                    if (*pData8 && *pData8 != ' ')
210825c8:	11400003 	ldbu	r5,0(r2)
                        szWaveFilename[nPos++] = *pData8;
210825cc:	d8c04a04 	addi	r3,sp,296
210825d0:	198f883a 	add	r7,r3,r6
                alt_u16 *pData16;
                alt_u8 *pData8;
                pData16 = (alt_u16 *)FileContext.szName;
                pData8 = FileContext.szName;
                while(*pData16){
                    if (*pData8 && *pData8 != ' ')
210825d4:	2c86703a 	and	r3,r5,r18
210825d8:	18c03fcc 	andi	r3,r3,255
210825dc:	10800084 	addi	r2,r2,2
210825e0:	18000226 	beq	r3,zero,210825ec <Fat_FileOpen+0x88>
                        szWaveFilename[nPos++] = *pData8;
210825e4:	39400005 	stb	r5,0(r7)
210825e8:	31800044 	addi	r6,r6,1
                    pData8++;
                    if (*pData8 && *pData8 != ' ')
210825ec:	21400003 	ldbu	r5,0(r4)
                        szWaveFilename[nPos++] = *pData8;
210825f0:	d8c04a04 	addi	r3,sp,296
210825f4:	198f883a 	add	r7,r3,r6
                pData8 = FileContext.szName;
                while(*pData16){
                    if (*pData8 && *pData8 != ' ')
                        szWaveFilename[nPos++] = *pData8;
                    pData8++;
                    if (*pData8 && *pData8 != ' ')
210825f8:	2c86703a 	and	r3,r5,r18
210825fc:	18c03fcc 	andi	r3,r3,255
21082600:	21000084 	addi	r4,r4,2
21082604:	18000226 	beq	r3,zero,21082610 <Fat_FileOpen+0xac>
                        szWaveFilename[nPos++] = *pData8;
21082608:	39400005 	stb	r5,0(r7)
2108260c:	31800044 	addi	r6,r6,1
                nPos = 0;
                alt_u16 *pData16;
                alt_u8 *pData8;
                pData16 = (alt_u16 *)FileContext.szName;
                pData8 = FileContext.szName;
                while(*pData16){
21082610:	10c0000b 	ldhu	r3,0(r2)
21082614:	183fec1e 	bne	r3,zero,210825c8 <__flash_rwdata_start+0xfffe0380>
                        szWaveFilename[nPos++] = *pData8;
                    pData8++;                    
                    //    
                    pData16++;
                }
                szWaveFilename[nPos] = 0;
21082618:	d8804a04 	addi	r2,sp,296
2108261c:	118d883a 	add	r6,r2,r6
                
                if(strcmp(pFilename,szWaveFilename) == 0)
21082620:	8009883a 	mov	r4,r16
21082624:	100b883a 	mov	r5,r2
                        szWaveFilename[nPos++] = *pData8;
                    pData8++;                    
                    //    
                    pData16++;
                }
                szWaveFilename[nPos] = 0;
21082628:	30000005 	stb	zero,0(r6)
                
                if(strcmp(pFilename,szWaveFilename) == 0)
2108262c:	108e5ec0 	call	2108e5ec <strcmp>
21082630:	1005003a 	cmpeq	r2,r2,zero
    FAT_FILE_INFO *pFile = 0;
    int nPos = 0;
    char szWaveFilename[MAX_FILENAME_LENGTH];
    
    if (Fat_FileBrowseBegin(Fat, &hBrowse)){
        while (!bFind && Fat_FileBrowseNext(&hBrowse, &FileContext)){
21082634:	103fd926 	beq	r2,zero,2108259c <__flash_rwdata_start+0xfffe0354>
        } // while 
        
        if (bFind){
        	pFile = &fInfo;
            if (pFile){
                pFile->OpenAttribute = FILE_OPEN_READ; 
21082638:	04000034 	movhi	r16,0
2108263c:	84179204 	addi	r16,r16,24136
21082640:	04800044 	movi	r18,1
                pFile->SeekPos = 0;
                pFile->Directory = FileContext;
21082644:	d80b883a 	mov	r5,sp
21082648:	81000504 	addi	r4,r16,20
2108264c:	01804a04 	movi	r6,296
        } // while 
        
        if (bFind){
        	pFile = &fInfo;
            if (pFile){
                pFile->OpenAttribute = FILE_OPEN_READ; 
21082650:	84800115 	stw	r18,4(r16)
                pFile->SeekPos = 0;
21082654:	80000215 	stw	zero,8(r16)
                pFile->Directory = FileContext;
21082658:	108e1340 	call	2108e134 <memcpy>
                pFile->IsOpened = TRUE;
                pFile->Cluster = FileContext.FirstLogicalCluster;
2108265c:	d880488b 	ldhu	r2,290(sp)
        	pFile = &fInfo;
            if (pFile){
                pFile->OpenAttribute = FILE_OPEN_READ; 
                pFile->SeekPos = 0;
                pFile->Directory = FileContext;
                pFile->IsOpened = TRUE;
21082660:	84800015 	stw	r18,0(r16)
                pFile->Cluster = FileContext.FirstLogicalCluster;
                pFile->ClusterSeq = 0;
21082664:	80000415 	stw	zero,16(r16)
            if (pFile){
                pFile->OpenAttribute = FILE_OPEN_READ; 
                pFile->SeekPos = 0;
                pFile->Directory = FileContext;
                pFile->IsOpened = TRUE;
                pFile->Cluster = FileContext.FirstLogicalCluster;
21082668:	80800315 	stw	r2,12(r16)
                pFile->ClusterSeq = 0;
                pFile->Fat = Fat;
2108266c:	84404f15 	stw	r17,316(r16)
                    bFind = TRUE;
            }    
        } // while 
        
        if (bFind){
        	pFile = &fInfo;
21082670:	8005883a 	mov	r2,r16
        }    
    }  

    
    return (FAT_FILE_HANDLE)pFile;  
}
21082674:	dfc08f17 	ldw	ra,572(sp)
21082678:	dc808e17 	ldw	r18,568(sp)
2108267c:	dc408d17 	ldw	r17,564(sp)
21082680:	dc008c17 	ldw	r16,560(sp)
21082684:	dec09004 	addi	sp,sp,576
21082688:	f800283a 	ret
FAT_FILE_HANDLE Fat_FileOpen(FAT_HANDLE Fat, const char *pFilename){
    bool bFind = FALSE;
    FAT_BROWSE_HANDLE hBrowse;     
    FILE_CONTEXT FileContext;
    static FAT_FILE_INFO fInfo;
    FAT_FILE_INFO *pFile = 0;
2108268c:	0005883a 	mov	r2,zero
        }    
    }  

    
    return (FAT_FILE_HANDLE)pFile;  
}
21082690:	f800283a 	ret
                szWaveFilename[nPos] = 0;
                
                if(strcmp(pFilename,szWaveFilename) == 0)
                    bFind = TRUE;
            }else{
                if (strcmp(FileContext.szName, pFilename) == 0)
21082694:	d809883a 	mov	r4,sp
21082698:	800b883a 	mov	r5,r16
2108269c:	108e5ec0 	call	2108e5ec <strcmp>
210826a0:	1005003a 	cmpeq	r2,r2,zero
    FAT_FILE_INFO *pFile = 0;
    int nPos = 0;
    char szWaveFilename[MAX_FILENAME_LENGTH];
    
    if (Fat_FileBrowseBegin(Fat, &hBrowse)){
        while (!bFind && Fat_FileBrowseNext(&hBrowse, &FileContext)){
210826a4:	103fbd26 	beq	r2,zero,2108259c <__flash_rwdata_start+0xfffe0354>
210826a8:	003fe306 	br	21082638 <__flash_rwdata_start+0xfffe03f0>
FAT_FILE_HANDLE Fat_FileOpen(FAT_HANDLE Fat, const char *pFilename){
    bool bFind = FALSE;
    FAT_BROWSE_HANDLE hBrowse;     
    FILE_CONTEXT FileContext;
    static FAT_FILE_INFO fInfo;
    FAT_FILE_INFO *pFile = 0;
210826ac:	0005883a 	mov	r2,zero
210826b0:	003ff006 	br	21082674 <__flash_rwdata_start+0xfffe042c>
                nPos = 0;
                alt_u16 *pData16;
                alt_u8 *pData8;
                pData16 = (alt_u16 *)FileContext.szName;
                pData8 = FileContext.szName;
                while(*pData16){
210826b4:	000d883a 	mov	r6,zero
210826b8:	003fd706 	br	21082618 <__flash_rwdata_start+0xfffe03d0>

210826bc <Fat_FileSize>:
}


unsigned int Fat_FileSize(FAT_FILE_HANDLE hFileHandle){
    FAT_FILE_INFO *f = (FAT_FILE_INFO *)hFileHandle;
    if (f->IsOpened)
210826bc:	20800017 	ldw	r2,0(r4)
210826c0:	10000226 	beq	r2,zero,210826cc <Fat_FileSize+0x10>
        return f->Directory.FileSize;
210826c4:	20804e17 	ldw	r2,312(r4)
210826c8:	f800283a 	ret
    return 0;        
210826cc:	0005883a 	mov	r2,zero
}
210826d0:	f800283a 	ret

210826d4 <Fat_FileRead>:
    alt_u32 Pos, PhysicalSecter, NextCluster, Cluster;
    alt_u32 BytesPerCluster, nReadCount=0, nClusterSeq;
    int s;
    bool bSuccess= TRUE;
    
    if (!f || !f->Fat)
210826d4:	2000ab26 	beq	r4,zero,21082984 <Fat_FileRead+0x2b0>
        return f->Directory.FileSize;
    return 0;        
}


bool Fat_FileRead(FAT_FILE_HANDLE hFileHandle, void *pBuffer, const int nBufferSize){
210826d8:	defff404 	addi	sp,sp,-48
210826dc:	dcc00515 	stw	r19,20(sp)
    alt_u32 Pos, PhysicalSecter, NextCluster, Cluster;
    alt_u32 BytesPerCluster, nReadCount=0, nClusterSeq;
    int s;
    bool bSuccess= TRUE;
    
    if (!f || !f->Fat)
210826e0:	24c04f17 	ldw	r19,316(r4)
        return f->Directory.FileSize;
    return 0;        
}


bool Fat_FileRead(FAT_FILE_HANDLE hFileHandle, void *pBuffer, const int nBufferSize){
210826e4:	dfc00b15 	stw	ra,44(sp)
210826e8:	df000a15 	stw	fp,40(sp)
210826ec:	ddc00915 	stw	r23,36(sp)
210826f0:	dd800815 	stw	r22,32(sp)
210826f4:	dd400715 	stw	r21,28(sp)
210826f8:	dd000615 	stw	r20,24(sp)
210826fc:	dc800415 	stw	r18,16(sp)
21082700:	dc400315 	stw	r17,12(sp)
21082704:	dc000215 	stw	r16,8(sp)
    alt_u32 Pos, PhysicalSecter, NextCluster, Cluster;
    alt_u32 BytesPerCluster, nReadCount=0, nClusterSeq;
    int s;
    bool bSuccess= TRUE;
    
    if (!f || !f->Fat)
21082708:	98005026 	beq	r19,zero,2108284c <Fat_FileRead+0x178>
        return FALSE;
    pVol = (VOLUME_INFO *)f->Fat;        
    
    if (!f->IsOpened){
2108270c:	20800017 	ldw	r2,0(r4)
21082710:	10005b26 	beq	r2,zero,21082880 <Fat_FileRead+0x1ac>
        FAT_DEBUG(("[FAT] Fat_FileRead, file not opened\r\n"));
        return bSuccess;
    }        
        
    BytesPerCluster = pVol->nBytesPerCluster; //gVolumeInfo.BPB_BytsPerSec * gVolumeInfo.BPB_SecPerCluster;  
21082714:	9c000d17 	ldw	r16,52(r19)
    Pos = f->SeekPos;
    if (BytesPerCluster == 65536){
21082718:	00800074 	movhi	r2,1
        FAT_DEBUG(("[FAT] Fat_FileRead, file not opened\r\n"));
        return bSuccess;
    }        
        
    BytesPerCluster = pVol->nBytesPerCluster; //gVolumeInfo.BPB_BytsPerSec * gVolumeInfo.BPB_SecPerCluster;  
    Pos = f->SeekPos;
2108271c:	24800217 	ldw	r18,8(r4)
    if (BytesPerCluster == 65536){
21082720:	80809326 	beq	r16,r2,21082970 <Fat_FileRead+0x29c>
    	nClusterSeq = Pos >> 16;
    	Pos -= (f->ClusterSeq << 16);
    }else if (BytesPerCluster == 32768){
21082724:	00a00014 	movui	r2,32768
21082728:	80809826 	beq	r16,r2,2108298c <Fat_FileRead+0x2b8>
        nClusterSeq = Pos >> 15;
        Pos -= (f->ClusterSeq << 15);
    }else if (BytesPerCluster == 16384){
2108272c:	00900004 	movi	r2,16384
21082730:	80806826 	beq	r16,r2,210828d4 <Fat_FileRead+0x200>
        nClusterSeq = Pos >> 14;
        Pos -= (f->ClusterSeq << 14);
    }else if (BytesPerCluster == 2048){
21082734:	00820004 	movi	r2,2048
21082738:	80809926 	beq	r16,r2,210829a0 <Fat_FileRead+0x2cc>
        nClusterSeq = Pos >> 11;
        Pos -= (f->ClusterSeq << 11);
    }else{        
        nClusterSeq = Pos/BytesPerCluster;
        Pos -= f->ClusterSeq*BytesPerCluster;
2108273c:	20800417 	ldw	r2,16(r4)
        Pos -= (f->ClusterSeq << 14);
    }else if (BytesPerCluster == 2048){
        nClusterSeq = Pos >> 11;
        Pos -= (f->ClusterSeq << 11);
    }else{        
        nClusterSeq = Pos/BytesPerCluster;
21082740:	9407203a 	divu	r3,r18,r16
        Pos -= f->ClusterSeq*BytesPerCluster;
21082744:	140f383a 	mul	r7,r2,r16
21082748:	91e5c83a 	sub	r18,r18,r7
2108274c:	d9800115 	stw	r6,4(sp)
21082750:	282b883a 	mov	r21,r5
21082754:	2023883a 	mov	r17,r4
    }    
        
       
    Cluster = f->Cluster;
21082758:	25000317 	ldw	r20,12(r4)
    if (nClusterSeq != f->ClusterSeq){
2108275c:	18800c26 	beq	r3,r2,21082790 <Fat_FileRead+0xbc>
        Cluster = f->Cluster;  //11/20/2007, richard
        // move to first cluster for reading
        while (Pos >= BytesPerCluster && bSuccess){
21082760:	94000b36 	bltu	r18,r16,21082790 <Fat_FileRead+0xbc>
            // go to next cluster
            NextCluster = fatNextCluster(pVol, Cluster); 
21082764:	a00b883a 	mov	r5,r20
21082768:	9809883a 	mov	r4,r19
2108276c:	1082cf80 	call	21082cf8 <fatNextCluster>
            if (NextCluster == 0){
21082770:	10005d26 	beq	r2,zero,210828e8 <Fat_FileRead+0x214>
            }else{
                Cluster = NextCluster;
            }        
            Pos -= BytesPerCluster;
            f->Cluster = Cluster;
            f->ClusterSeq++; 
21082774:	88c00417 	ldw	r3,16(r17)
                bSuccess = FALSE;
                FAT_DEBUG(("[FAT] Fat_FileRead, no next Cluster [1], current Cluster=%d\r\n", Cluster));
            }else{
                Cluster = NextCluster;
            }        
            Pos -= BytesPerCluster;
21082778:	9425c83a 	sub	r18,r18,r16
            f->Cluster = Cluster;
2108277c:	88800315 	stw	r2,12(r17)
            f->ClusterSeq++; 
21082780:	18c00044 	addi	r3,r3,1
21082784:	88c00415 	stw	r3,16(r17)
21082788:	1029883a 	mov	r20,r2
       
    Cluster = f->Cluster;
    if (nClusterSeq != f->ClusterSeq){
        Cluster = f->Cluster;  //11/20/2007, richard
        // move to first cluster for reading
        while (Pos >= BytesPerCluster && bSuccess){
2108278c:	943ff52e 	bgeu	r18,r16,21082764 <__flash_rwdata_start+0xfffe051c>
21082790:	00c00044 	movi	r3,1
21082794:	d8c00015 	stw	r3,0(sp)
    //-----------------------------------------------------------------------------
#ifdef MULT_SEC
    alt_u32 SectorOffset, ByteOffset, SectorsToRead;
    int nCopyCount, nCopySectors;

    SectorOffset = Pos >> 9;
21082798:	902ed27a 	srli	r23,r18,9
    ByteOffset = Pos - SectorOffset*pVol->BPB_BytsPerSec;
2108279c:	98800717 	ldw	r2,28(r19)

    PhysicalSecter = (Cluster-2)*pVol->BPB_SecPerCluster + pVol->DataEntrySecter; // -2: FAT0 & FAT1 are reserved
210827a0:	9c000817 	ldw	r16,32(r19)
210827a4:	9f001017 	ldw	fp,64(r19)
#ifdef MULT_SEC
    alt_u32 SectorOffset, ByteOffset, SectorsToRead;
    int nCopyCount, nCopySectors;

    SectorOffset = Pos >> 9;
    ByteOffset = Pos - SectorOffset*pVol->BPB_BytsPerSec;
210827a8:	b885383a 	mul	r2,r23,r2

    PhysicalSecter = (Cluster-2)*pVol->BPB_SecPerCluster + pVol->DataEntrySecter; // -2: FAT0 & FAT1 are reserved
210827ac:	a13fff84 	addi	r4,r20,-2
210827b0:	2409383a 	mul	r4,r4,r16
210827b4:	bf39883a 	add	fp,r23,fp
#ifdef MULT_SEC
    alt_u32 SectorOffset, ByteOffset, SectorsToRead;
    int nCopyCount, nCopySectors;

    SectorOffset = Pos >> 9;
    ByteOffset = Pos - SectorOffset*pVol->BPB_BytsPerSec;
210827b8:	90a5c83a 	sub	r18,r18,r2

    PhysicalSecter = (Cluster-2)*pVol->BPB_SecPerCluster + pVol->DataEntrySecter; // -2: FAT0 & FAT1 are reserved
    PhysicalSecter += SectorOffset;
210827bc:	e139883a 	add	fp,fp,r4
    nReadCount = 0;

    // case: partial read of the first sector
    if((ByteOffset > 0) || (nBufferSize < 512)){
210827c0:	9000501e 	bne	r18,zero,21082904 <Fat_FileRead+0x230>
210827c4:	d8c00117 	ldw	r3,4(sp)
210827c8:	00807fc4 	movi	r2,511
210827cc:	10c04d0e 	bge	r2,r3,21082904 <Fat_FileRead+0x230>
    		SectorOffset++;
    		PhysicalSecter++;
    	}
    }

    SectorsToRead = (nBufferSize - nReadCount) >> 9;
210827d0:	1824d27a 	srli	r18,r3,9
    SectorOffset = Pos >> 9;
    ByteOffset = Pos - SectorOffset*pVol->BPB_BytsPerSec;

    PhysicalSecter = (Cluster-2)*pVol->BPB_SecPerCluster + pVol->DataEntrySecter; // -2: FAT0 & FAT1 are reserved
    PhysicalSecter += SectorOffset;
    nReadCount = 0;
210827d4:	002d883a 	mov	r22,zero
    	}
    }

    SectorsToRead = (nBufferSize - nReadCount) >> 9;

    while(SectorsToRead > 0){
210827d8:	90008926 	beq	r18,zero,21082a00 <Fat_FileRead+0x32c>
210827dc:	8005883a 	mov	r2,r16
    	if(SectorsToRead < (pVol->BPB_SecPerCluster - SectorOffset)){
210827e0:	15e1c83a 	sub	r16,r2,r23
210827e4:	9400012e 	bgeu	r18,r16,210827ec <Fat_FileRead+0x118>
    		nCopySectors = SectorsToRead;
210827e8:	9021883a 	mov	r16,r18
    	} else {
    		nCopySectors = pVol->BPB_SecPerCluster - SectorOffset;
    	}

        if(!fatReadMultiSecter(pVol, PhysicalSecter, nCopySectors, pBuffer+nReadCount)){
210827ec:	9809883a 	mov	r4,r19
210827f0:	e00b883a 	mov	r5,fp
210827f4:	ad8f883a 	add	r7,r21,r22
210827f8:	800d883a 	mov	r6,r16
210827fc:	108340c0 	call	2108340c <fatReadMultiSecter>
			FAT_DEBUG(("[FAT] Fat_FileRead, couldn't read sectors: %d - %d\r\n", PhysicalSecter, nCopySectors));
			return FALSE;
        }
        SectorsToRead -= nCopySectors;
        nReadCount += nCopySectors << 9;
21082800:	8008927a 	slli	r4,r16,9
    		nCopySectors = SectorsToRead;
    	} else {
    		nCopySectors = pVol->BPB_SecPerCluster - SectorOffset;
    	}

        if(!fatReadMultiSecter(pVol, PhysicalSecter, nCopySectors, pBuffer+nReadCount)){
21082804:	10001126 	beq	r2,zero,2108284c <Fat_FileRead+0x178>
        SectorsToRead -= nCopySectors;
        nReadCount += nCopySectors << 9;
        PhysicalSecter += nCopySectors;

        // find next sector if all the sectors in current clusters are read and there is still data to read
        if(nCopySectors == (pVol->BPB_SecPerCluster - SectorOffset) && nReadCount < nBufferSize){
21082808:	98800817 	ldw	r2,32(r19)
        if(!fatReadMultiSecter(pVol, PhysicalSecter, nCopySectors, pBuffer+nReadCount)){
			FAT_DEBUG(("[FAT] Fat_FileRead, couldn't read sectors: %d - %d\r\n", PhysicalSecter, nCopySectors));
			return FALSE;
        }
        SectorsToRead -= nCopySectors;
        nReadCount += nCopySectors << 9;
2108280c:	b12d883a 	add	r22,r22,r4

        if(!fatReadMultiSecter(pVol, PhysicalSecter, nCopySectors, pBuffer+nReadCount)){
			FAT_DEBUG(("[FAT] Fat_FileRead, couldn't read sectors: %d - %d\r\n", PhysicalSecter, nCopySectors));
			return FALSE;
        }
        SectorsToRead -= nCopySectors;
21082810:	9425c83a 	sub	r18,r18,r16
        nReadCount += nCopySectors << 9;
        PhysicalSecter += nCopySectors;

        // find next sector if all the sectors in current clusters are read and there is still data to read
        if(nCopySectors == (pVol->BPB_SecPerCluster - SectorOffset) && nReadCount < nBufferSize){
21082814:	15c9c83a 	sub	r4,r2,r23
			FAT_DEBUG(("[FAT] Fat_FileRead, couldn't read sectors: %d - %d\r\n", PhysicalSecter, nCopySectors));
			return FALSE;
        }
        SectorsToRead -= nCopySectors;
        nReadCount += nCopySectors << 9;
        PhysicalSecter += nCopySectors;
21082818:	e439883a 	add	fp,fp,r16

        // find next sector if all the sectors in current clusters are read and there is still data to read
        if(nCopySectors == (pVol->BPB_SecPerCluster - SectorOffset) && nReadCount < nBufferSize){
2108281c:	81001a26 	beq	r16,r4,21082888 <Fat_FileRead+0x1b4>
    	}
    }

    SectorsToRead = (nBufferSize - nReadCount) >> 9;

    while(SectorsToRead > 0){
21082820:	903fef1e 	bne	r18,zero,210827e0 <__flash_rwdata_start+0xfffe0598>
			PhysicalSecter = (Cluster-2)*pVol->BPB_SecPerCluster + pVol->DataEntrySecter; // -2: FAT0 & FAT1 are reserved
			SectorOffset = 0;
        }
    }

    if(nReadCount < nBufferSize){
21082824:	d8c00117 	ldw	r3,4(sp)
21082828:	b0c07536 	bltu	r22,r3,21082a00 <Fat_FileRead+0x32c>
            f->Cluster = Cluster;
        }                    
    }
#endif
    
    if (bSuccess){
2108282c:	d8c00017 	ldw	r3,0(sp)
21082830:	18000626 	beq	r3,zero,2108284c <Fat_FileRead+0x178>
        f->SeekPos += nBufferSize;
21082834:	88c00217 	ldw	r3,8(r17)
21082838:	d9000117 	ldw	r4,4(sp)
2108283c:	00800044 	movi	r2,1
21082840:	192d883a 	add	r22,r3,r4
21082844:	8d800215 	stw	r22,8(r17)
21082848:	00000106 	br	21082850 <Fat_FileRead+0x17c>
    alt_u32 BytesPerCluster, nReadCount=0, nClusterSeq;
    int s;
    bool bSuccess= TRUE;
    
    if (!f || !f->Fat)
        return FALSE;
2108284c:	0005883a 	mov	r2,zero
        f->SeekPos += nBufferSize;
    }        
        
    
    return bSuccess;
}
21082850:	dfc00b17 	ldw	ra,44(sp)
21082854:	df000a17 	ldw	fp,40(sp)
21082858:	ddc00917 	ldw	r23,36(sp)
2108285c:	dd800817 	ldw	r22,32(sp)
21082860:	dd400717 	ldw	r21,28(sp)
21082864:	dd000617 	ldw	r20,24(sp)
21082868:	dcc00517 	ldw	r19,20(sp)
2108286c:	dc800417 	ldw	r18,16(sp)
21082870:	dc400317 	ldw	r17,12(sp)
21082874:	dc000217 	ldw	r16,8(sp)
21082878:	dec00c04 	addi	sp,sp,48
2108287c:	f800283a 	ret
        return FALSE;
    pVol = (VOLUME_INFO *)f->Fat;        
    
    if (!f->IsOpened){
        FAT_DEBUG(("[FAT] Fat_FileRead, file not opened\r\n"));
        return bSuccess;
21082880:	00800044 	movi	r2,1
21082884:	003ff206 	br	21082850 <__flash_rwdata_start+0xfffe0608>
        SectorsToRead -= nCopySectors;
        nReadCount += nCopySectors << 9;
        PhysicalSecter += nCopySectors;

        // find next sector if all the sectors in current clusters are read and there is still data to read
        if(nCopySectors == (pVol->BPB_SecPerCluster - SectorOffset) && nReadCount < nBufferSize){
21082888:	d8c00117 	ldw	r3,4(sp)
2108288c:	b0ffe42e 	bgeu	r22,r3,21082820 <__flash_rwdata_start+0xfffe05d8>
			NextCluster = fatNextCluster(pVol, Cluster);
21082890:	a00b883a 	mov	r5,r20
21082894:	9809883a 	mov	r4,r19
21082898:	1082cf80 	call	21082cf8 <fatNextCluster>
2108289c:	1029883a 	mov	r20,r2
			}else{
				Cluster = NextCluster;
			}
			f->ClusterSeq++;
			f->Cluster = Cluster;
			PhysicalSecter = (Cluster-2)*pVol->BPB_SecPerCluster + pVol->DataEntrySecter; // -2: FAT0 & FAT1 are reserved
210828a0:	10ffff84 	addi	r3,r2,-2
        PhysicalSecter += nCopySectors;

        // find next sector if all the sectors in current clusters are read and there is still data to read
        if(nCopySectors == (pVol->BPB_SecPerCluster - SectorOffset) && nReadCount < nBufferSize){
			NextCluster = fatNextCluster(pVol, Cluster);
			if (NextCluster == 0){
210828a4:	103fe926 	beq	r2,zero,2108284c <__flash_rwdata_start+0xfffe0604>
			}else{
				Cluster = NextCluster;
			}
			f->ClusterSeq++;
			f->Cluster = Cluster;
			PhysicalSecter = (Cluster-2)*pVol->BPB_SecPerCluster + pVol->DataEntrySecter; // -2: FAT0 & FAT1 are reserved
210828a8:	98800817 	ldw	r2,32(r19)
                FAT_DEBUG(("[FAT] Fat_FileRead, no next Cluster [3], current Cluster=%d\r\n", Cluster));
				return FALSE;
			}else{
				Cluster = NextCluster;
			}
			f->ClusterSeq++;
210828ac:	89000417 	ldw	r4,16(r17)
			f->Cluster = Cluster;
			PhysicalSecter = (Cluster-2)*pVol->BPB_SecPerCluster + pVol->DataEntrySecter; // -2: FAT0 & FAT1 are reserved
210828b0:	9f001017 	ldw	fp,64(r19)
210828b4:	1887383a 	mul	r3,r3,r2
                FAT_DEBUG(("[FAT] Fat_FileRead, no next Cluster [3], current Cluster=%d\r\n", Cluster));
				return FALSE;
			}else{
				Cluster = NextCluster;
			}
			f->ClusterSeq++;
210828b8:	21000044 	addi	r4,r4,1
210828bc:	89000415 	stw	r4,16(r17)
			f->Cluster = Cluster;
210828c0:	8d000315 	stw	r20,12(r17)
			PhysicalSecter = (Cluster-2)*pVol->BPB_SecPerCluster + pVol->DataEntrySecter; // -2: FAT0 & FAT1 are reserved
210828c4:	1f39883a 	add	fp,r3,fp
			SectorOffset = 0;
210828c8:	002f883a 	mov	r23,zero
    	}
    }

    SectorsToRead = (nBufferSize - nReadCount) >> 9;

    while(SectorsToRead > 0){
210828cc:	903fc41e 	bne	r18,zero,210827e0 <__flash_rwdata_start+0xfffe0598>
210828d0:	003fd406 	br	21082824 <__flash_rwdata_start+0xfffe05dc>
    }else if (BytesPerCluster == 32768){
        nClusterSeq = Pos >> 15;
        Pos -= (f->ClusterSeq << 15);
    }else if (BytesPerCluster == 16384){
        nClusterSeq = Pos >> 14;
        Pos -= (f->ClusterSeq << 14);
210828d4:	20800417 	ldw	r2,16(r4)
    	Pos -= (f->ClusterSeq << 16);
    }else if (BytesPerCluster == 32768){
        nClusterSeq = Pos >> 15;
        Pos -= (f->ClusterSeq << 15);
    }else if (BytesPerCluster == 16384){
        nClusterSeq = Pos >> 14;
210828d8:	9006d3ba 	srli	r3,r18,14
        Pos -= (f->ClusterSeq << 14);
210828dc:	100e93ba 	slli	r7,r2,14
210828e0:	91e5c83a 	sub	r18,r18,r7
210828e4:	003f9906 	br	2108274c <__flash_rwdata_start+0xfffe0504>
            }else{
                Cluster = NextCluster;
            }        
            Pos -= BytesPerCluster;
            f->Cluster = Cluster;
            f->ClusterSeq++; 
210828e8:	88800417 	ldw	r2,16(r17)
                bSuccess = FALSE;
                FAT_DEBUG(("[FAT] Fat_FileRead, no next Cluster [1], current Cluster=%d\r\n", Cluster));
            }else{
                Cluster = NextCluster;
            }        
            Pos -= BytesPerCluster;
210828ec:	9425c83a 	sub	r18,r18,r16
            f->Cluster = Cluster;
210828f0:	8d000315 	stw	r20,12(r17)
            f->ClusterSeq++; 
210828f4:	10800044 	addi	r2,r2,1
210828f8:	88800415 	stw	r2,16(r17)
        // move to first cluster for reading
        while (Pos >= BytesPerCluster && bSuccess){
            // go to next cluster
            NextCluster = fatNextCluster(pVol, Cluster); 
            if (NextCluster == 0){
                bSuccess = FALSE;
210828fc:	d8000015 	stw	zero,0(sp)
21082900:	003fa506 	br	21082798 <__flash_rwdata_start+0xfffe0550>
    PhysicalSecter += SectorOffset;
    nReadCount = 0;

    // case: partial read of the first sector
    if((ByteOffset > 0) || (nBufferSize < 512)){
    	if(!fatReadSecter(pVol, PhysicalSecter)){
21082904:	9809883a 	mov	r4,r19
21082908:	e00b883a 	mov	r5,fp
2108290c:	10833a40 	call	210833a4 <fatReadSecter>
21082910:	103fce26 	beq	r2,zero,2108284c <__flash_rwdata_start+0xfffe0604>
			FAT_DEBUG(("[FAT] Fat_FileRead, couldn't read sector %d\r\n", PhysicalSecter));
			return FALSE;
        }

    	nCopyCount = nBufferSize > (512 - ByteOffset)? 512 - ByteOffset : nBufferSize;
21082914:	d8c00117 	ldw	r3,4(sp)
21082918:	02008004 	movi	r8,512
2108291c:	44adc83a 	sub	r22,r8,r18
21082920:	1d80012e 	bgeu	r3,r22,21082928 <Fat_FileRead+0x254>
21082924:	182d883a 	mov	r22,r3
    	memcpy(pBuffer, pVol->Secter_Data+ByteOffset, nCopyCount);
21082928:	91409204 	addi	r5,r18,584
2108292c:	a809883a 	mov	r4,r21
21082930:	994b883a 	add	r5,r19,r5
21082934:	b00d883a 	mov	r6,r22
21082938:	108e1340 	call	2108e134 <memcpy>
    	nReadCount = nCopyCount;

		if(nReadCount < nBufferSize && SectorOffset == pVol->BPB_SecPerCluster - 1){
2108293c:	d8c00117 	ldw	r3,4(sp)
21082940:	b0c0032e 	bgeu	r22,r3,21082950 <Fat_FileRead+0x27c>
21082944:	9c000817 	ldw	r16,32(r19)
21082948:	80bfffc4 	addi	r2,r16,-1
2108294c:	15c01926 	beq	r2,r23,210829b4 <Fat_FileRead+0x2e0>
    		SectorOffset++;
    		PhysicalSecter++;
    	}
    }

    SectorsToRead = (nBufferSize - nReadCount) >> 9;
21082950:	d8c00117 	ldw	r3,4(sp)
			f->ClusterSeq++;
			f->Cluster = Cluster;
			PhysicalSecter = (Cluster-2)*pVol->BPB_SecPerCluster + pVol->DataEntrySecter; // -2: FAT0 & FAT1 are reserved
			SectorOffset = 0;
    	} else {
    		SectorOffset++;
21082954:	bdc00044 	addi	r23,r23,1
    		PhysicalSecter++;
21082958:	e7000044 	addi	fp,fp,1
    	}
    }

    SectorsToRead = (nBufferSize - nReadCount) >> 9;
2108295c:	1da5c83a 	sub	r18,r3,r22
21082960:	9024d27a 	srli	r18,r18,9

    while(SectorsToRead > 0){
21082964:	903faf26 	beq	r18,zero,21082824 <__flash_rwdata_start+0xfffe05dc>
21082968:	9c000817 	ldw	r16,32(r19)
2108296c:	003f9b06 	br	210827dc <__flash_rwdata_start+0xfffe0594>
        
    BytesPerCluster = pVol->nBytesPerCluster; //gVolumeInfo.BPB_BytsPerSec * gVolumeInfo.BPB_SecPerCluster;  
    Pos = f->SeekPos;
    if (BytesPerCluster == 65536){
    	nClusterSeq = Pos >> 16;
    	Pos -= (f->ClusterSeq << 16);
21082970:	20800417 	ldw	r2,16(r4)
    }        
        
    BytesPerCluster = pVol->nBytesPerCluster; //gVolumeInfo.BPB_BytsPerSec * gVolumeInfo.BPB_SecPerCluster;  
    Pos = f->SeekPos;
    if (BytesPerCluster == 65536){
    	nClusterSeq = Pos >> 16;
21082974:	9006d43a 	srli	r3,r18,16
    	Pos -= (f->ClusterSeq << 16);
21082978:	100e943a 	slli	r7,r2,16
2108297c:	91e5c83a 	sub	r18,r18,r7
21082980:	003f7206 	br	2108274c <__flash_rwdata_start+0xfffe0504>
    alt_u32 BytesPerCluster, nReadCount=0, nClusterSeq;
    int s;
    bool bSuccess= TRUE;
    
    if (!f || !f->Fat)
        return FALSE;
21082984:	0005883a 	mov	r2,zero
        f->SeekPos += nBufferSize;
    }        
        
    
    return bSuccess;
}
21082988:	f800283a 	ret
    if (BytesPerCluster == 65536){
    	nClusterSeq = Pos >> 16;
    	Pos -= (f->ClusterSeq << 16);
    }else if (BytesPerCluster == 32768){
        nClusterSeq = Pos >> 15;
        Pos -= (f->ClusterSeq << 15);
2108298c:	20800417 	ldw	r2,16(r4)
    Pos = f->SeekPos;
    if (BytesPerCluster == 65536){
    	nClusterSeq = Pos >> 16;
    	Pos -= (f->ClusterSeq << 16);
    }else if (BytesPerCluster == 32768){
        nClusterSeq = Pos >> 15;
21082990:	9006d3fa 	srli	r3,r18,15
        Pos -= (f->ClusterSeq << 15);
21082994:	100e93fa 	slli	r7,r2,15
21082998:	91e5c83a 	sub	r18,r18,r7
2108299c:	003f6b06 	br	2108274c <__flash_rwdata_start+0xfffe0504>
    }else if (BytesPerCluster == 16384){
        nClusterSeq = Pos >> 14;
        Pos -= (f->ClusterSeq << 14);
    }else if (BytesPerCluster == 2048){
        nClusterSeq = Pos >> 11;
        Pos -= (f->ClusterSeq << 11);
210829a0:	20800417 	ldw	r2,16(r4)
        Pos -= (f->ClusterSeq << 15);
    }else if (BytesPerCluster == 16384){
        nClusterSeq = Pos >> 14;
        Pos -= (f->ClusterSeq << 14);
    }else if (BytesPerCluster == 2048){
        nClusterSeq = Pos >> 11;
210829a4:	9006d2fa 	srli	r3,r18,11
        Pos -= (f->ClusterSeq << 11);
210829a8:	100e92fa 	slli	r7,r2,11
210829ac:	91e5c83a 	sub	r18,r18,r7
210829b0:	003f6606 	br	2108274c <__flash_rwdata_start+0xfffe0504>
    	memcpy(pBuffer, pVol->Secter_Data+ByteOffset, nCopyCount);
    	nReadCount = nCopyCount;

		if(nReadCount < nBufferSize && SectorOffset == pVol->BPB_SecPerCluster - 1){
			// case: last sector of the cluster
			NextCluster = fatNextCluster(pVol, Cluster);
210829b4:	a00b883a 	mov	r5,r20
210829b8:	9809883a 	mov	r4,r19
210829bc:	1082cf80 	call	21082cf8 <fatNextCluster>
210829c0:	1029883a 	mov	r20,r2
			if (NextCluster == 0){
210829c4:	103fa126 	beq	r2,zero,2108284c <__flash_rwdata_start+0xfffe0604>
    		SectorOffset++;
    		PhysicalSecter++;
    	}
    }

    SectorsToRead = (nBufferSize - nReadCount) >> 9;
210829c8:	d9000117 	ldw	r4,4(sp)
			}

			Cluster = NextCluster;
			f->ClusterSeq++;
			f->Cluster = Cluster;
			PhysicalSecter = (Cluster-2)*pVol->BPB_SecPerCluster + pVol->DataEntrySecter; // -2: FAT0 & FAT1 are reserved
210829cc:	9c000817 	ldw	r16,32(r19)
                FAT_DEBUG(("[FAT] Fat_FileRead, no next Cluster [2], current Cluster=%d\r\n", Cluster));
				return FALSE;
			}

			Cluster = NextCluster;
			f->ClusterSeq++;
210829d0:	88c00417 	ldw	r3,16(r17)
			f->Cluster = Cluster;
			PhysicalSecter = (Cluster-2)*pVol->BPB_SecPerCluster + pVol->DataEntrySecter; // -2: FAT0 & FAT1 are reserved
210829d4:	10bfff84 	addi	r2,r2,-2
    		SectorOffset++;
    		PhysicalSecter++;
    	}
    }

    SectorsToRead = (nBufferSize - nReadCount) >> 9;
210829d8:	25a5c83a 	sub	r18,r4,r22
			}

			Cluster = NextCluster;
			f->ClusterSeq++;
			f->Cluster = Cluster;
			PhysicalSecter = (Cluster-2)*pVol->BPB_SecPerCluster + pVol->DataEntrySecter; // -2: FAT0 & FAT1 are reserved
210829dc:	9f001017 	ldw	fp,64(r19)
210829e0:	1405383a 	mul	r2,r2,r16
    		SectorOffset++;
    		PhysicalSecter++;
    	}
    }

    SectorsToRead = (nBufferSize - nReadCount) >> 9;
210829e4:	9024d27a 	srli	r18,r18,9
                FAT_DEBUG(("[FAT] Fat_FileRead, no next Cluster [2], current Cluster=%d\r\n", Cluster));
				return FALSE;
			}

			Cluster = NextCluster;
			f->ClusterSeq++;
210829e8:	18c00044 	addi	r3,r3,1
210829ec:	88c00415 	stw	r3,16(r17)
			f->Cluster = Cluster;
210829f0:	8d000315 	stw	r20,12(r17)
			PhysicalSecter = (Cluster-2)*pVol->BPB_SecPerCluster + pVol->DataEntrySecter; // -2: FAT0 & FAT1 are reserved
210829f4:	1739883a 	add	fp,r2,fp
			SectorOffset = 0;
210829f8:	002f883a 	mov	r23,zero
    	}
    }

    SectorsToRead = (nBufferSize - nReadCount) >> 9;

    while(SectorsToRead > 0){
210829fc:	903f771e 	bne	r18,zero,210827dc <__flash_rwdata_start+0xfffe0594>
			SectorOffset = 0;
        }
    }

    if(nReadCount < nBufferSize){
    	if(!fatReadSecter(pVol, PhysicalSecter)){
21082a00:	9809883a 	mov	r4,r19
21082a04:	e00b883a 	mov	r5,fp
21082a08:	10833a40 	call	210833a4 <fatReadSecter>
21082a0c:	103f8f26 	beq	r2,zero,2108284c <__flash_rwdata_start+0xfffe0604>
			FAT_DEBUG(("[FAT] Fat_FileRead, couldn't read sector\r\n"));
			return FALSE;
        }

    	nCopyCount = nBufferSize - nReadCount;
    	memcpy(pBuffer+nReadCount, pVol->Secter_Data, nCopyCount);
21082a10:	d8c00117 	ldw	r3,4(sp)
21082a14:	ad89883a 	add	r4,r21,r22
21082a18:	99409204 	addi	r5,r19,584
21082a1c:	1d8dc83a 	sub	r6,r3,r22
21082a20:	108e1340 	call	2108e134 <memcpy>
21082a24:	003f8106 	br	2108282c <__flash_rwdata_start+0xfffe05e4>

21082a28 <Fat_FileSeek>:
bool Fat_FileSeek(FAT_FILE_HANDLE hFileHandle, const FAT_SEEK_POS SeekPos, const int nOffset){
    FAT_FILE_INFO *f = (FAT_FILE_INFO *)hFileHandle;
    VOLUME_INFO *pVol;
    bool bSuccess= TRUE;

    if (!f || !f->Fat)
21082a28:	20001026 	beq	r4,zero,21082a6c <Fat_FileSeek+0x44>
21082a2c:	20804f17 	ldw	r2,316(r4)
21082a30:	10000e26 	beq	r2,zero,21082a6c <Fat_FileSeek+0x44>
        return FALSE;
    pVol = (VOLUME_INFO *)f->Fat;        
    
    if (!f->IsOpened)
21082a34:	20800017 	ldw	r2,0(r4)
21082a38:	10000d26 	beq	r2,zero,21082a70 <Fat_FileSeek+0x48>
        return FALSE;
        
    switch(SeekPos){
21082a3c:	00800044 	movi	r2,1
21082a40:	28800c26 	beq	r5,r2,21082a74 <Fat_FileSeek+0x4c>
21082a44:	28000e26 	beq	r5,zero,21082a80 <Fat_FileSeek+0x58>
21082a48:	00c00084 	movi	r3,2
21082a4c:	28c0111e 	bne	r5,r3,21082a94 <Fat_FileSeek+0x6c>
            break;
        case FILE_SEEK_CURRENT: 
            f->SeekPos += nOffset; 
            break;
        case FILE_SEEK_END: 
            f->SeekPos = f->Directory.FileSize+nOffset; 
21082a50:	20c04e17 	ldw	r3,312(r4)
            bSuccess = FALSE;
            break;    
              
    }
    f->Cluster = f->Directory.FirstLogicalCluster;
    f->ClusterSeq = 0;
21082a54:	20000415 	stw	zero,16(r4)
            break;
        case FILE_SEEK_CURRENT: 
            f->SeekPos += nOffset; 
            break;
        case FILE_SEEK_END: 
            f->SeekPos = f->Directory.FileSize+nOffset; 
21082a58:	30cd883a 	add	r6,r6,r3
        default:
            bSuccess = FALSE;
            break;    
              
    }
    f->Cluster = f->Directory.FirstLogicalCluster;
21082a5c:	20c04d8b 	ldhu	r3,310(r4)
            break;
        case FILE_SEEK_CURRENT: 
            f->SeekPos += nOffset; 
            break;
        case FILE_SEEK_END: 
            f->SeekPos = f->Directory.FileSize+nOffset; 
21082a60:	21800215 	stw	r6,8(r4)
        default:
            bSuccess = FALSE;
            break;    
              
    }
    f->Cluster = f->Directory.FirstLogicalCluster;
21082a64:	20c00315 	stw	r3,12(r4)
    f->ClusterSeq = 0;
    
    return bSuccess;
21082a68:	f800283a 	ret
    FAT_FILE_INFO *f = (FAT_FILE_INFO *)hFileHandle;
    VOLUME_INFO *pVol;
    bool bSuccess= TRUE;

    if (!f || !f->Fat)
        return FALSE;
21082a6c:	0005883a 	mov	r2,zero
    f->Cluster = f->Directory.FirstLogicalCluster;
    f->ClusterSeq = 0;
    
    return bSuccess;
    
}
21082a70:	f800283a 	ret
    switch(SeekPos){
        case FILE_SEEK_BEGIN: 
            f->SeekPos = nOffset; 
            break;
        case FILE_SEEK_CURRENT: 
            f->SeekPos += nOffset; 
21082a74:	20c00217 	ldw	r3,8(r4)


bool Fat_FileSeek(FAT_FILE_HANDLE hFileHandle, const FAT_SEEK_POS SeekPos, const int nOffset){
    FAT_FILE_INFO *f = (FAT_FILE_INFO *)hFileHandle;
    VOLUME_INFO *pVol;
    bool bSuccess= TRUE;
21082a78:	2805883a 	mov	r2,r5
    switch(SeekPos){
        case FILE_SEEK_BEGIN: 
            f->SeekPos = nOffset; 
            break;
        case FILE_SEEK_CURRENT: 
            f->SeekPos += nOffset; 
21082a7c:	198d883a 	add	r6,r3,r6
        default:
            bSuccess = FALSE;
            break;    
              
    }
    f->Cluster = f->Directory.FirstLogicalCluster;
21082a80:	20c04d8b 	ldhu	r3,310(r4)
    switch(SeekPos){
        case FILE_SEEK_BEGIN: 
            f->SeekPos = nOffset; 
            break;
        case FILE_SEEK_CURRENT: 
            f->SeekPos += nOffset; 
21082a84:	21800215 	stw	r6,8(r4)
            bSuccess = FALSE;
            break;    
              
    }
    f->Cluster = f->Directory.FirstLogicalCluster;
    f->ClusterSeq = 0;
21082a88:	20000415 	stw	zero,16(r4)
        default:
            bSuccess = FALSE;
            break;    
              
    }
    f->Cluster = f->Directory.FirstLogicalCluster;
21082a8c:	20c00315 	stw	r3,12(r4)
    f->ClusterSeq = 0;
    
    return bSuccess;
21082a90:	f800283a 	ret
        default:
            bSuccess = FALSE;
            break;    
              
    }
    f->Cluster = f->Directory.FirstLogicalCluster;
21082a94:	20c04d8b 	ldhu	r3,310(r4)
            break;
        case FILE_SEEK_END: 
            f->SeekPos = f->Directory.FileSize+nOffset; 
            break;
        default:
            bSuccess = FALSE;
21082a98:	0005883a 	mov	r2,zero
            break;    
              
    }
    f->Cluster = f->Directory.FirstLogicalCluster;
    f->ClusterSeq = 0;
21082a9c:	20000415 	stw	zero,16(r4)
        default:
            bSuccess = FALSE;
            break;    
              
    }
    f->Cluster = f->Directory.FirstLogicalCluster;
21082aa0:	20c00315 	stw	r3,12(r4)
    f->ClusterSeq = 0;
    
    return bSuccess;
21082aa4:	f800283a 	ret

21082aa8 <Fat_FileClose>:
    
}

void Fat_FileClose(FAT_FILE_HANDLE hFileHandle){
21082aa8:	f800283a 	ret

21082aac <Fat_SpeedTest>:
    alt_u32 time_start, time_finish, time_elapsed, TotalReadBytes=0;
    int nSecter = 0;
    float fMegaBytePerSec = 0;
    char szBlock[512];
    VOLUME_INFO *pVol = (VOLUME_INFO *)hFat;
    if (!pVol)
21082aac:	20005526 	beq	r4,zero,21082c04 <Fat_SpeedTest+0x158>
    //free(f);
}



float Fat_SpeedTest(FAT_HANDLE hFat, alt_u32 TestDurInMs){
21082ab0:	deff7904 	addi	sp,sp,-540
21082ab4:	dd008415 	stw	r20,528(sp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
21082ab8:	05000034 	movhi	r20,0
21082abc:	dc808215 	stw	r18,520(sp)
21082ac0:	a5178e04 	addi	r20,r20,24120
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
21082ac4:	04800034 	movhi	r18,0
21082ac8:	94978d04 	addi	r18,r18,24116
21082acc:	dc408115 	stw	r17,516(sp)
    char szBlock[512];
    VOLUME_INFO *pVol = (VOLUME_INFO *)hFat;
    if (!pVol)
        return 0;
    time_start = alt_nticks();
    time_finish = alt_nticks() + TestDurInMs * 1000 / alt_ticks_per_second();
21082ad0:	2940fa24 	muli	r5,r5,1000
21082ad4:	2023883a 	mov	r17,r4
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
21082ad8:	a1000017 	ldw	r4,0(r20)
    //free(f);
}



float Fat_SpeedTest(FAT_HANDLE hFat, alt_u32 TestDurInMs){
21082adc:	dd408515 	stw	r21,532(sp)
21082ae0:	dcc08315 	stw	r19,524(sp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
21082ae4:	95400017 	ldw	r21,0(r18)
21082ae8:	94c00017 	ldw	r19,0(r18)
21082aec:	90800017 	ldw	r2,0(r18)
    char szBlock[512];
    VOLUME_INFO *pVol = (VOLUME_INFO *)hFat;
    if (!pVol)
        return 0;
    time_start = alt_nticks();
    time_finish = alt_nticks() + TestDurInMs * 1000 / alt_ticks_per_second();
21082af0:	290b203a 	divu	r5,r5,r4
    //free(f);
}



float Fat_SpeedTest(FAT_HANDLE hFat, alt_u32 TestDurInMs){
21082af4:	dc008015 	stw	r16,512(sp)
21082af8:	dfc08615 	stw	ra,536(sp)
    char szBlock[512];
    VOLUME_INFO *pVol = (VOLUME_INFO *)hFat;
    if (!pVol)
        return 0;
    time_start = alt_nticks();
    time_finish = alt_nticks() + TestDurInMs * 1000 / alt_ticks_per_second();
21082afc:	2ce7883a 	add	r19,r5,r19
    while(alt_nticks() < time_finish && bSuccess){
21082b00:	0021883a 	mov	r16,zero
21082b04:	14c00236 	bltu	r2,r19,21082b10 <Fat_SpeedTest+0x64>
21082b08:	00000e06 	br	21082b44 <Fat_SpeedTest+0x98>
21082b0c:	10003926 	beq	r2,zero,21082bf4 <Fat_SpeedTest+0x148>
        bSuccess = pVol->ReadBlock512(pVol->DiskHandle, nSecter, szBlock);
21082b10:	89000017 	ldw	r4,0(r17)
21082b14:	88800117 	ldw	r2,4(r17)
21082b18:	800b883a 	mov	r5,r16
21082b1c:	d80d883a 	mov	r6,sp
21082b20:	103ee83a 	callr	r2
21082b24:	90c00017 	ldw	r3,0(r18)
        nSecter++;
21082b28:	84000044 	addi	r16,r16,1
21082b2c:	8008927a 	slli	r4,r16,9
    VOLUME_INFO *pVol = (VOLUME_INFO *)hFat;
    if (!pVol)
        return 0;
    time_start = alt_nticks();
    time_finish = alt_nticks() + TestDurInMs * 1000 / alt_ticks_per_second();
    while(alt_nticks() < time_finish && bSuccess){
21082b30:	1cfff636 	bltu	r3,r19,21082b0c <__flash_rwdata_start+0xfffe08c4>
        bSuccess = pVol->ReadBlock512(pVol->DiskHandle, nSecter, szBlock);
        nSecter++;
        TotalReadBytes += sizeof(szBlock);
        
    }        
    if (bSuccess){
21082b34:	10002f26 	beq	r2,zero,21082bf4 <Fat_SpeedTest+0x148>
21082b38:	108ac080 	call	2108ac08 <__floatunsisf>
21082b3c:	a1000017 	ldw	r4,0(r20)
21082b40:	1021883a 	mov	r16,r2
        time_elapsed = alt_nticks() - time_start;
        fMegaBytePerSec = (float)TotalReadBytes * (float)alt_ticks_per_second() / (float)time_elapsed / 1024.0 / 1024.0;
21082b44:	108ac080 	call	2108ac08 <__floatunsisf>
21082b48:	94400017 	ldw	r17,0(r18)
21082b4c:	800b883a 	mov	r5,r16
21082b50:	1009883a 	mov	r4,r2
21082b54:	108a7e40 	call	2108a7e4 <__mulsf3>
21082b58:	8d49c83a 	sub	r4,r17,r21
21082b5c:	1021883a 	mov	r16,r2
21082b60:	108ac080 	call	2108ac08 <__floatunsisf>
21082b64:	8009883a 	mov	r4,r16
21082b68:	100b883a 	mov	r5,r2
21082b6c:	108a3940 	call	2108a394 <__divsf3>
21082b70:	1009883a 	mov	r4,r2
21082b74:	108d1500 	call	2108d150 <__extendsfdf2>
21082b78:	1009883a 	mov	r4,r2
21082b7c:	180b883a 	mov	r5,r3
21082b80:	000d883a 	mov	r6,zero
21082b84:	01cfd434 	movhi	r7,16208
21082b88:	108bf600 	call	2108bf60 <__muldf3>
21082b8c:	000d883a 	mov	r6,zero
21082b90:	01cfd434 	movhi	r7,16208
21082b94:	1009883a 	mov	r4,r2
21082b98:	180b883a 	mov	r5,r3
21082b9c:	108bf600 	call	2108bf60 <__muldf3>
21082ba0:	180b883a 	mov	r5,r3
21082ba4:	1009883a 	mov	r4,r2
21082ba8:	108d2600 	call	2108d260 <__truncdfsf2>
21082bac:	1009883a 	mov	r4,r2
21082bb0:	1021883a 	mov	r16,r2
21082bb4:	108d1500 	call	2108d150 <__extendsfdf2>
21082bb8:	100b883a 	mov	r5,r2
21082bbc:	180d883a 	mov	r6,r3
    } 
    
    printf("\n--------speed:%f---------\n",fMegaBytePerSec);       
21082bc0:	01000034 	movhi	r4,0
21082bc4:	2100a804 	addi	r4,r4,672
21082bc8:	108e3bc0 	call	2108e3bc <printf>
    return fMegaBytePerSec;
21082bcc:	8005883a 	mov	r2,r16
    
   
}
21082bd0:	dfc08617 	ldw	ra,536(sp)
21082bd4:	dd408517 	ldw	r21,532(sp)
21082bd8:	dd008417 	ldw	r20,528(sp)
21082bdc:	dcc08317 	ldw	r19,524(sp)
21082be0:	dc808217 	ldw	r18,520(sp)
21082be4:	dc408117 	ldw	r17,516(sp)
21082be8:	dc008017 	ldw	r16,512(sp)
21082bec:	dec08704 	addi	sp,sp,540
21082bf0:	f800283a 	ret
21082bf4:	000b883a 	mov	r5,zero
21082bf8:	000d883a 	mov	r6,zero

float Fat_SpeedTest(FAT_HANDLE hFat, alt_u32 TestDurInMs){
    bool bSuccess = TRUE;
    alt_u32 time_start, time_finish, time_elapsed, TotalReadBytes=0;
    int nSecter = 0;
    float fMegaBytePerSec = 0;
21082bfc:	0021883a 	mov	r16,zero
21082c00:	003fef06 	br	21082bc0 <__flash_rwdata_start+0xfffe0978>
    char szBlock[512];
    VOLUME_INFO *pVol = (VOLUME_INFO *)hFat;
    if (!pVol)
        return 0;
21082c04:	0005883a 	mov	r2,zero
21082c08:	f800283a 	ret

21082c0c <SD_ReadBlock512>:

//===================== SUPPORT_SD_CARD =================================================
#ifdef SUPPORT_SD_CARD

bool SD_ReadBlock512(DISK_HANDLE DiskHandle, alt_u32 PysicalSelector, alt_u8 szBuf[512]){
    return SDLIB_ReadBlock512(PysicalSelector, szBuf);
21082c0c:	2809883a 	mov	r4,r5
21082c10:	300b883a 	mov	r5,r6
21082c14:	10853281 	jmpi	21085328 <SDLIB_ReadBlock512>

21082c18 <SD_ReadBlocks>:
}

bool SD_ReadBlocks(DISK_HANDLE DiskHandle, alt_u32 PysicalSelector, alt_u32 n, alt_u8* szBuf){
    return SDLIB_ReadBlocks(PysicalSelector, n, szBuf);
21082c18:	2809883a 	mov	r4,r5
21082c1c:	300b883a 	mov	r5,r6
21082c20:	380d883a 	mov	r6,r7
21082c24:	10853581 	jmpi	21085358 <SDLIB_ReadBlocks>

21082c28 <fat16ClusterType>:

VOLUME_INFO vInfo;

CLUSTER_TYPE fat16ClusterType(alt_u32 Fat){
    CLUSTER_TYPE Type;
    Fat = Fat & 0xFFFF; // 16 bits
21082c28:	213fffcc 	andi	r4,r4,65535
    
    if (Fat > 0 && Fat < 0xFFF0)
21082c2c:	20ffffc4 	addi	r3,r4,-1
21082c30:	017ffb94 	movui	r5,65518
21082c34:	28c00236 	bltu	r5,r3,21082c40 <fat16ClusterType+0x18>
        Type = CLUSTER_NEXT_INFILE;
21082c38:	00800104 	movi	r2,4
21082c3c:	f800283a 	ret
    else if (Fat >= 0xFFF8) // && Fat <= (unsigned short)0xFFFF)
21082c40:	00fffdd4 	movui	r3,65527
21082c44:	1900022e 	bgeu	r3,r4,21082c50 <fat16ClusterType+0x28>
        Type = CLUSTER_LAST_INFILE;
21082c48:	008000c4 	movi	r2,3
21082c4c:	f800283a 	ret
    else if (Fat == (alt_u16)0x00)
21082c50:	20000926 	beq	r4,zero,21082c78 <fat16ClusterType+0x50>
        Type = CLUSTER_UNUSED;
    else if (Fat >= 0xFFF0 && Fat <= 0xFFF6)
21082c54:	017ffff4 	movhi	r5,65535
21082c58:	29400404 	addi	r5,r5,16
21082c5c:	214b883a 	add	r5,r4,r5
21082c60:	01800184 	movi	r6,6
21082c64:	3140022e 	bgeu	r6,r5,21082c70 <fat16ClusterType+0x48>
        Type = CLUSTER_RESERVED;
    else if (Fat == 0xFFF7)
21082c68:	20c00526 	beq	r4,r3,21082c80 <fat16ClusterType+0x58>
        Type = CLUSTER_BAD;
        
    return Type;        
         
}
21082c6c:	f800283a 	ret
    else if (Fat >= 0xFFF8) // && Fat <= (unsigned short)0xFFFF)
        Type = CLUSTER_LAST_INFILE;
    else if (Fat == (alt_u16)0x00)
        Type = CLUSTER_UNUSED;
    else if (Fat >= 0xFFF0 && Fat <= 0xFFF6)
        Type = CLUSTER_RESERVED;
21082c70:	00800044 	movi	r2,1
21082c74:	003ffd06 	br	21082c6c <__flash_rwdata_start+0xfffe0a24>
    if (Fat > 0 && Fat < 0xFFF0)
        Type = CLUSTER_NEXT_INFILE;
    else if (Fat >= 0xFFF8) // && Fat <= (unsigned short)0xFFFF)
        Type = CLUSTER_LAST_INFILE;
    else if (Fat == (alt_u16)0x00)
        Type = CLUSTER_UNUSED;
21082c78:	0005883a 	mov	r2,zero
21082c7c:	f800283a 	ret
    else if (Fat >= 0xFFF0 && Fat <= 0xFFF6)
        Type = CLUSTER_RESERVED;
    else if (Fat == 0xFFF7)
        Type = CLUSTER_BAD;
21082c80:	00800084 	movi	r2,2
21082c84:	f800283a 	ret

21082c88 <fat32ClusterType>:
         
}

CLUSTER_TYPE fat32ClusterType(alt_u32 Fat){
    CLUSTER_TYPE Type;
    Fat = Fat & 0xFFFFFFF; // 28 bits
21082c88:	00c40034 	movhi	r3,4096
21082c8c:	18ffffc4 	addi	r3,r3,-1
21082c90:	20c8703a 	and	r4,r4,r3
    
    if (Fat > 0 && Fat < 0xFFFFFF0)
21082c94:	01440034 	movhi	r5,4096
21082c98:	20ffffc4 	addi	r3,r4,-1
21082c9c:	297ffb84 	addi	r5,r5,-18
21082ca0:	28c00236 	bltu	r5,r3,21082cac <fat32ClusterType+0x24>
        Type = CLUSTER_NEXT_INFILE;
21082ca4:	00800104 	movi	r2,4
21082ca8:	f800283a 	ret
    else if (Fat >= 0xFFFFFF8) // && Fat <= (unsigned short)0xFFFF)
21082cac:	00c40034 	movhi	r3,4096
21082cb0:	18fffdc4 	addi	r3,r3,-9
21082cb4:	1900022e 	bgeu	r3,r4,21082cc0 <fat32ClusterType+0x38>
        Type = CLUSTER_LAST_INFILE;
21082cb8:	008000c4 	movi	r2,3
21082cbc:	f800283a 	ret
    else if (Fat == (alt_u32)0x00)
21082cc0:	20000926 	beq	r4,zero,21082ce8 <fat32ClusterType+0x60>
        Type = CLUSTER_UNUSED;
    else if (Fat >= 0xFFFFFF0 && Fat <= 0xFFFFFF6)
21082cc4:	017c0034 	movhi	r5,61440
21082cc8:	29400404 	addi	r5,r5,16
21082ccc:	214b883a 	add	r5,r4,r5
21082cd0:	01800184 	movi	r6,6
21082cd4:	3140022e 	bgeu	r6,r5,21082ce0 <fat32ClusterType+0x58>
        Type = CLUSTER_RESERVED;
    else if (Fat == 0xFFFFFF7)
21082cd8:	20c00526 	beq	r4,r3,21082cf0 <fat32ClusterType+0x68>
        Type = CLUSTER_BAD;
        
    return Type;        
         
}
21082cdc:	f800283a 	ret
    else if (Fat >= 0xFFFFFF8) // && Fat <= (unsigned short)0xFFFF)
        Type = CLUSTER_LAST_INFILE;
    else if (Fat == (alt_u32)0x00)
        Type = CLUSTER_UNUSED;
    else if (Fat >= 0xFFFFFF0 && Fat <= 0xFFFFFF6)
        Type = CLUSTER_RESERVED;
21082ce0:	00800044 	movi	r2,1
21082ce4:	003ffd06 	br	21082cdc <__flash_rwdata_start+0xfffe0a94>
    if (Fat > 0 && Fat < 0xFFFFFF0)
        Type = CLUSTER_NEXT_INFILE;
    else if (Fat >= 0xFFFFFF8) // && Fat <= (unsigned short)0xFFFF)
        Type = CLUSTER_LAST_INFILE;
    else if (Fat == (alt_u32)0x00)
        Type = CLUSTER_UNUSED;
21082ce8:	0005883a 	mov	r2,zero
21082cec:	f800283a 	ret
    else if (Fat >= 0xFFFFFF0 && Fat <= 0xFFFFFF6)
        Type = CLUSTER_RESERVED;
    else if (Fat == 0xFFFFFF7)
        Type = CLUSTER_BAD;
21082cf0:	00800084 	movi	r2,2
21082cf4:	f800283a 	ret

21082cf8 <fatNextCluster>:
alt_u32 fatNextCluster(VOLUME_INFO *pVol, alt_u32 ThisCluster){
    CLUSTER_TYPE ClusterType;
    alt_u32 NextCluster;

    alt_32 nFatEntryPerSecter;
    const alt_32 nFatEntrySize = (pVol->Partition_Type == PARTITION_FAT32)?4:2; // 2 byte for FAT16
21082cf8:	20c00417 	ldw	r3,16(r4)
        
    return Type;        
         
}

alt_u32 fatNextCluster(VOLUME_INFO *pVol, alt_u32 ThisCluster){
21082cfc:	defff504 	addi	sp,sp,-44
21082d00:	dd800715 	stw	r22,28(sp)
21082d04:	dc800315 	stw	r18,12(sp)
21082d08:	dfc00a15 	stw	ra,40(sp)
21082d0c:	df000915 	stw	fp,36(sp)
21082d10:	ddc00815 	stw	r23,32(sp)
21082d14:	dd400615 	stw	r21,24(sp)
21082d18:	dd000515 	stw	r20,20(sp)
21082d1c:	dcc00415 	stw	r19,16(sp)
21082d20:	dc400215 	stw	r17,8(sp)
21082d24:	dc000115 	stw	r16,4(sp)
    CLUSTER_TYPE ClusterType;
    alt_u32 NextCluster;

    alt_32 nFatEntryPerSecter;
    const alt_32 nFatEntrySize = (pVol->Partition_Type == PARTITION_FAT32)?4:2; // 2 byte for FAT16
21082d28:	008002c4 	movi	r2,11
        
    return Type;        
         
}

alt_u32 fatNextCluster(VOLUME_INFO *pVol, alt_u32 ThisCluster){
21082d2c:	202d883a 	mov	r22,r4
21082d30:	2825883a 	mov	r18,r5
    CLUSTER_TYPE ClusterType;
    alt_u32 NextCluster;

    alt_32 nFatEntryPerSecter;
    const alt_32 nFatEntrySize = (pVol->Partition_Type == PARTITION_FAT32)?4:2; // 2 byte for FAT16
21082d34:	18804e26 	beq	r3,r2,21082e70 <fatNextCluster+0x178>
21082d38:	07000084 	movi	fp,2
21082d3c:	e4a9383a 	mul	r20,fp,r18
21082d40:	b0809117 	ldw	r2,580(r22)
//// add in v2.0
bool fatReadFATSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;

    if (nSecter != pVol->FAT_Index){
        if (!pVol->ReadBlock512(pVol->DiskHandle, nSecter, pVol->FAT_Data)){
21082d44:	b0c01104 	addi	r3,r22,68
alt_u32 fatNextCluster(VOLUME_INFO *pVol, alt_u32 ThisCluster){
    CLUSTER_TYPE ClusterType;
    alt_u32 NextCluster;

    alt_32 nFatEntryPerSecter;
    const alt_32 nFatEntrySize = (pVol->Partition_Type == PARTITION_FAT32)?4:2; // 2 byte for FAT16
21082d48:	05c000c4 	movi	r23,3
    while (trials > 0) {
		nFatEntryPerSecter = pVol->BPB_BytsPerSec/nFatEntrySize;
		Secter = pVol->FatEntrySecter + (ThisCluster*nFatEntrySize)/pVol->BPB_BytsPerSec;

		if (fatReadFATSecter(pVol, Secter)){
			if (pVol->Partition_Type == PARTITION_FAT32){
21082d4c:	04c002c4 	movi	r19,11
//// add in v2.0
bool fatReadFATSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;

    if (nSecter != pVol->FAT_Index){
        if (!pVol->ReadBlock512(pVol->DiskHandle, nSecter, pVol->FAT_Data)){
21082d50:	d8c00015 	stw	r3,0(sp)
    const alt_32 nFatEntrySize = (pVol->Partition_Type == PARTITION_FAT32)?4:2; // 2 byte for FAT16
    alt_u32 Secter;
    alt_u32 trials = 3;

    while (trials > 0) {
		nFatEntryPerSecter = pVol->BPB_BytsPerSec/nFatEntrySize;
21082d54:	b0c00717 	ldw	r3,28(r22)
		Secter = pVol->FatEntrySecter + (ThisCluster*nFatEntrySize)/pVol->BPB_BytsPerSec;
21082d58:	b1000e17 	ldw	r4,56(r22)
21082d5c:	a0d5203a 	divu	r10,r20,r3
21082d60:	5123883a 	add	r17,r10,r4
    const alt_32 nFatEntrySize = (pVol->Partition_Type == PARTITION_FAT32)?4:2; // 2 byte for FAT16
    alt_u32 Secter;
    alt_u32 trials = 3;

    while (trials > 0) {
		nFatEntryPerSecter = pVol->BPB_BytsPerSec/nFatEntrySize;
21082d64:	1f21203a 	divu	r16,r3,fp
//=================================================================================
//// add in v2.0
bool fatReadFATSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;

    if (nSecter != pVol->FAT_Index){
21082d68:	14400726 	beq	r2,r17,21082d88 <fatNextCluster+0x90>
        if (!pVol->ReadBlock512(pVol->DiskHandle, nSecter, pVol->FAT_Data)){
21082d6c:	b0800117 	ldw	r2,4(r22)
21082d70:	b1000017 	ldw	r4,0(r22)
21082d74:	d9800017 	ldw	r6,0(sp)
21082d78:	880b883a 	mov	r5,r17
21082d7c:	103ee83a 	callr	r2
21082d80:	10000f26 	beq	r2,zero,21082dc0 <fatNextCluster+0xc8>
            pVol->FAT_Index = -1;
            bSuccess = FALSE;
        }else{
            pVol->FAT_Index = nSecter;
21082d84:	b4409115 	stw	r17,580(r22)
    while (trials > 0) {
		nFatEntryPerSecter = pVol->BPB_BytsPerSec/nFatEntrySize;
		Secter = pVol->FatEntrySecter + (ThisCluster*nFatEntrySize)/pVol->BPB_BytsPerSec;

		if (fatReadFATSecter(pVol, Secter)){
			if (pVol->Partition_Type == PARTITION_FAT32){
21082d88:	b0800417 	ldw	r2,16(r22)
21082d8c:	14c02726 	beq	r2,r19,21082e2c <fatNextCluster+0x134>
				NextCluster = *(alt_u32*)(pVol->FAT_Data + (ThisCluster%nFatEntryPerSecter)*nFatEntrySize);
				ClusterType = fat32ClusterType(NextCluster);
			}else{
				NextCluster = *(alt_u16 *)(pVol->FAT_Data + (ThisCluster%nFatEntryPerSecter)*nFatEntrySize);
21082d90:	9407203a 	divu	r3,r18,r16
21082d94:	1c07383a 	mul	r3,r3,r16

CLUSTER_TYPE fat16ClusterType(alt_u32 Fat){
    CLUSTER_TYPE Type;
    Fat = Fat & 0xFFFF; // 16 bits
    
    if (Fat > 0 && Fat < 0xFFF0)
21082d98:	013ffb94 	movui	r4,65518
		if (fatReadFATSecter(pVol, Secter)){
			if (pVol->Partition_Type == PARTITION_FAT32){
				NextCluster = *(alt_u32*)(pVol->FAT_Data + (ThisCluster%nFatEntryPerSecter)*nFatEntrySize);
				ClusterType = fat32ClusterType(NextCluster);
			}else{
				NextCluster = *(alt_u16 *)(pVol->FAT_Data + (ThisCluster%nFatEntryPerSecter)*nFatEntrySize);
21082d9c:	90c7c83a 	sub	r3,r18,r3
21082da0:	1f07383a 	mul	r3,r3,fp
21082da4:	b0c7883a 	add	r3,r22,r3
21082da8:	1880110b 	ldhu	r2,68(r3)
21082dac:	157fffcc 	andi	r21,r2,65535

CLUSTER_TYPE fat16ClusterType(alt_u32 Fat){
    CLUSTER_TYPE Type;
    Fat = Fat & 0xFFFF; // 16 bits
    
    if (Fat > 0 && Fat < 0xFFF0)
21082db0:	a8ffffc4 	addi	r3,r21,-1
21082db4:	20c01736 	bltu	r4,r3,21082e14 <fatNextCluster+0x11c>
			}
			if (ClusterType != CLUSTER_NEXT_INFILE && ClusterType != CLUSTER_LAST_INFILE)
				NextCluster = 0;  // invalid cluster
		}

		if(NextCluster <= 60607) break;
21082db8:	013b2fd4 	movui	r4,60607
21082dbc:	2540192e 	bgeu	r4,r21,21082e24 <fatNextCluster+0x12c>
		// reset the sector index to force reading it from SD Card
		pVol->FAT_Index = -1;
21082dc0:	00bfffc4 	movi	r2,-1
21082dc4:	b0809115 	stw	r2,580(r22)
21082dc8:	b8af883a 	add	r23,r23,r2
    alt_32 nFatEntryPerSecter;
    const alt_32 nFatEntrySize = (pVol->Partition_Type == PARTITION_FAT32)?4:2; // 2 byte for FAT16
    alt_u32 Secter;
    alt_u32 trials = 3;

    while (trials > 0) {
21082dcc:	b83fe11e 	bne	r23,zero,21082d54 <__flash_rwdata_start+0xfffe0b0c>
		pVol->FAT_Index = -1;
		trials--;
    }

    if(NextCluster > 60607) {
		printf("Error getting next cluster (%d)\n", NextCluster);
21082dd0:	01000034 	movhi	r4,0
21082dd4:	2100af04 	addi	r4,r4,700
21082dd8:	a80b883a 	mov	r5,r21
21082ddc:	108e3bc0 	call	2108e3bc <printf>
		return 0;
	}

    return NextCluster;
}
21082de0:	b805883a 	mov	r2,r23
21082de4:	dfc00a17 	ldw	ra,40(sp)
21082de8:	df000917 	ldw	fp,36(sp)
21082dec:	ddc00817 	ldw	r23,32(sp)
21082df0:	dd800717 	ldw	r22,28(sp)
21082df4:	dd400617 	ldw	r21,24(sp)
21082df8:	dd000517 	ldw	r20,20(sp)
21082dfc:	dcc00417 	ldw	r19,16(sp)
21082e00:	dc800317 	ldw	r18,12(sp)
21082e04:	dc400217 	ldw	r17,8(sp)
21082e08:	dc000117 	ldw	r16,4(sp)
21082e0c:	dec00b04 	addi	sp,sp,44
21082e10:	f800283a 	ret
    CLUSTER_TYPE Type;
    Fat = Fat & 0xFFFF; // 16 bits
    
    if (Fat > 0 && Fat < 0xFFF0)
        Type = CLUSTER_NEXT_INFILE;
    else if (Fat >= 0xFFF8) // && Fat <= (unsigned short)0xFFFF)
21082e14:	00fffdd4 	movui	r3,65527
21082e18:	1d7fe736 	bltu	r3,r21,21082db8 <__flash_rwdata_start+0xfffe0b70>
        Type = CLUSTER_LAST_INFILE;
    else if (Fat == (alt_u16)0x00)
21082e1c:	a8000126 	beq	r21,zero,21082e24 <fatNextCluster+0x12c>
21082e20:	002b883a 	mov	r21,zero
        Type = CLUSTER_NEXT_INFILE;
    else if (Fat >= 0xFFFFFF8) // && Fat <= (unsigned short)0xFFFF)
        Type = CLUSTER_LAST_INFILE;
    else if (Fat == (alt_u32)0x00)
        Type = CLUSTER_UNUSED;
    else if (Fat >= 0xFFFFFF0 && Fat <= 0xFFFFFF6)
21082e24:	a82f883a 	mov	r23,r21
21082e28:	003fed06 	br	21082de0 <__flash_rwdata_start+0xfffe0b98>
		nFatEntryPerSecter = pVol->BPB_BytsPerSec/nFatEntrySize;
		Secter = pVol->FatEntrySecter + (ThisCluster*nFatEntrySize)/pVol->BPB_BytsPerSec;

		if (fatReadFATSecter(pVol, Secter)){
			if (pVol->Partition_Type == PARTITION_FAT32){
				NextCluster = *(alt_u32*)(pVol->FAT_Data + (ThisCluster%nFatEntryPerSecter)*nFatEntrySize);
21082e2c:	9407203a 	divu	r3,r18,r16
21082e30:	1c07383a 	mul	r3,r3,r16
         
}

CLUSTER_TYPE fat32ClusterType(alt_u32 Fat){
    CLUSTER_TYPE Type;
    Fat = Fat & 0xFFFFFFF; // 28 bits
21082e34:	01040034 	movhi	r4,4096
21082e38:	213fffc4 	addi	r4,r4,-1
		nFatEntryPerSecter = pVol->BPB_BytsPerSec/nFatEntrySize;
		Secter = pVol->FatEntrySecter + (ThisCluster*nFatEntrySize)/pVol->BPB_BytsPerSec;

		if (fatReadFATSecter(pVol, Secter)){
			if (pVol->Partition_Type == PARTITION_FAT32){
				NextCluster = *(alt_u32*)(pVol->FAT_Data + (ThisCluster%nFatEntryPerSecter)*nFatEntrySize);
21082e3c:	90c7c83a 	sub	r3,r18,r3
21082e40:	1f07383a 	mul	r3,r3,fp
21082e44:	b0c7883a 	add	r3,r22,r3
21082e48:	1d401117 	ldw	r21,68(r3)
         
}

CLUSTER_TYPE fat32ClusterType(alt_u32 Fat){
    CLUSTER_TYPE Type;
    Fat = Fat & 0xFFFFFFF; // 28 bits
21082e4c:	a904703a 	and	r2,r21,r4
    
    if (Fat > 0 && Fat < 0xFFFFFF0)
21082e50:	01040034 	movhi	r4,4096
21082e54:	10ffffc4 	addi	r3,r2,-1
21082e58:	213ffb84 	addi	r4,r4,-18
21082e5c:	20ffd62e 	bgeu	r4,r3,21082db8 <__flash_rwdata_start+0xfffe0b70>
        Type = CLUSTER_NEXT_INFILE;
    else if (Fat >= 0xFFFFFF8) // && Fat <= (unsigned short)0xFFFF)
21082e60:	00c40034 	movhi	r3,4096
21082e64:	18fffdc4 	addi	r3,r3,-9
21082e68:	18bfd336 	bltu	r3,r2,21082db8 <__flash_rwdata_start+0xfffe0b70>
21082e6c:	003fec06 	br	21082e20 <__flash_rwdata_start+0xfffe0bd8>
21082e70:	07000104 	movi	fp,4
21082e74:	003fb106 	br	21082d3c <__flash_rwdata_start+0xfffe0af4>

21082e78 <fatFindUnusedCluster>:
alt_u32 fatFindUnusedCluster(VOLUME_INFO *pVol){
    CLUSTER_TYPE ClusterType;
    alt_u32 UnusedCluster=-1, ThisCluster = 2, ClusterEntryValue;
    void *pFatEntry;

    const alt_32 nFatEntrySize = (pVol->Partition_Type == PARTITION_FAT32)?4:2; // 2 byte for FAT16
21082e78:	21400417 	ldw	r5,16(r4)
	}

    return NextCluster;
}

alt_u32 fatFindUnusedCluster(VOLUME_INFO *pVol){
21082e7c:	defff604 	addi	sp,sp,-40
21082e80:	df000815 	stw	fp,32(sp)
21082e84:	dfc00915 	stw	ra,36(sp)
21082e88:	ddc00715 	stw	r23,28(sp)
21082e8c:	dd800615 	stw	r22,24(sp)
21082e90:	dd400515 	stw	r21,20(sp)
21082e94:	dd000415 	stw	r20,16(sp)
21082e98:	dcc00315 	stw	r19,12(sp)
21082e9c:	dc800215 	stw	r18,8(sp)
21082ea0:	dc400115 	stw	r17,4(sp)
21082ea4:	dc000015 	stw	r16,0(sp)
    CLUSTER_TYPE ClusterType;
    alt_u32 UnusedCluster=-1, ThisCluster = 2, ClusterEntryValue;
    void *pFatEntry;

    const alt_32 nFatEntrySize = (pVol->Partition_Type == PARTITION_FAT32)?4:2; // 2 byte for FAT16
21082ea8:	008002c4 	movi	r2,11
	}

    return NextCluster;
}

alt_u32 fatFindUnusedCluster(VOLUME_INFO *pVol){
21082eac:	2039883a 	mov	fp,r4
    CLUSTER_TYPE ClusterType;
    alt_u32 UnusedCluster=-1, ThisCluster = 2, ClusterEntryValue;
    void *pFatEntry;

    const alt_32 nFatEntrySize = (pVol->Partition_Type == PARTITION_FAT32)?4:2; // 2 byte for FAT16
21082eb0:	28805126 	beq	r5,r2,21082ff8 <fatFindUnusedCluster+0x180>
21082eb4:	04c00084 	movi	r19,2
    const alt_32 nFatEntryPerSecter = pVol->BPB_BytsPerSec/nFatEntrySize;
21082eb8:	e5c00717 	ldw	r23,28(fp)
21082ebc:	e1011217 	ldw	r4,1096(fp)
21082ec0:	9ceb883a 	add	r21,r19,r19
21082ec4:	bce9203a 	divu	r20,r23,r19
    return NextCluster;
}

alt_u32 fatFindUnusedCluster(VOLUME_INFO *pVol){
    CLUSTER_TYPE ClusterType;
    alt_u32 UnusedCluster=-1, ThisCluster = 2, ClusterEntryValue;
21082ec8:	05800084 	movi	r22,2
//// add in v2.0
bool fatReadSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;

    if (nSecter != pVol->Secter_Index){
        if (!pVol->ReadBlock512(pVol->DiskHandle, nSecter, pVol->Secter_Data)){
21082ecc:	e4409204 	addi	r17,fp,584

    while(!bDone){     
        Secter = pVol->FatEntrySecter + (ThisCluster*nFatEntrySize)/pVol->BPB_BytsPerSec;
        if (fatReadSecter(pVol, Secter)){
            pFatEntry = (pVol->Secter_Data + (ThisCluster%nFatEntryPerSecter)*nFatEntrySize);
            if (pVol->Partition_Type == PARTITION_FAT32){
21082ed0:	040002c4 	movi	r16,11

CLUSTER_TYPE fat16ClusterType(alt_u32 Fat){
    CLUSTER_TYPE Type;
    Fat = Fat & 0xFFFF; // 16 bits
    
    if (Fat > 0 && Fat < 0xFFF0)
21082ed4:	04bffb94 	movui	r18,65518
    const alt_32 nFatEntryPerSecter = pVol->BPB_BytsPerSec/nFatEntrySize;
    alt_u32 Secter;
    bool bDone = FALSE;

    while(!bDone){     
        Secter = pVol->FatEntrySecter + (ThisCluster*nFatEntrySize)/pVol->BPB_BytsPerSec;
21082ed8:	e0800e17 	ldw	r2,56(fp)
21082edc:	adef203a 	divu	r23,r21,r23
21082ee0:	b8af883a 	add	r23,r23,r2
//=================================================================================
//// add in v2.0
bool fatReadSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;

    if (nSecter != pVol->Secter_Index){
21082ee4:	b9000926 	beq	r23,r4,21082f0c <fatFindUnusedCluster+0x94>
        if (!pVol->ReadBlock512(pVol->DiskHandle, nSecter, pVol->Secter_Data)){
21082ee8:	e0800117 	ldw	r2,4(fp)
21082eec:	e1000017 	ldw	r4,0(fp)
21082ef0:	b80b883a 	mov	r5,r23
21082ef4:	880d883a 	mov	r6,r17
21082ef8:	103ee83a 	callr	r2
21082efc:	10003326 	beq	r2,zero,21082fcc <fatFindUnusedCluster+0x154>
21082f00:	e1400417 	ldw	r5,16(fp)
            pVol->Secter_Index = -1;
            bSuccess = FALSE;
        }else{
            pVol->Secter_Index = nSecter;
21082f04:	e5c11215 	stw	r23,1096(fp)
21082f08:	b809883a 	mov	r4,r23
    bool bDone = FALSE;

    while(!bDone){     
        Secter = pVol->FatEntrySecter + (ThisCluster*nFatEntrySize)/pVol->BPB_BytsPerSec;
        if (fatReadSecter(pVol, Secter)){
            pFatEntry = (pVol->Secter_Data + (ThisCluster%nFatEntryPerSecter)*nFatEntrySize);
21082f0c:	b507203a 	divu	r3,r22,r20
21082f10:	1d07383a 	mul	r3,r3,r20
21082f14:	b0c7c83a 	sub	r3,r22,r3
21082f18:	1cc7383a 	mul	r3,r3,r19
21082f1c:	18c09204 	addi	r3,r3,584
21082f20:	e0c7883a 	add	r3,fp,r3
            if (pVol->Partition_Type == PARTITION_FAT32){
21082f24:	2c001a26 	beq	r5,r16,21082f90 <fatFindUnusedCluster+0x118>
                ClusterEntryValue = *(alt_u32*)pFatEntry; 
                ClusterType = fat32ClusterType(ClusterEntryValue);
            }else{
                ClusterEntryValue = *(alt_u16 *)pFatEntry; 
21082f28:	18c0000b 	ldhu	r3,0(r3)

VOLUME_INFO vInfo;

CLUSTER_TYPE fat16ClusterType(alt_u32 Fat){
    CLUSTER_TYPE Type;
    Fat = Fat & 0xFFFF; // 16 bits
21082f2c:	18bfffcc 	andi	r2,r3,65535
    
    if (Fat > 0 && Fat < 0xFFF0)
21082f30:	11bfffc4 	addi	r6,r2,-1
21082f34:	9180212e 	bgeu	r18,r6,21082fbc <fatFindUnusedCluster+0x144>
        Type = CLUSTER_NEXT_INFILE;
    else if (Fat >= 0xFFF8) // && Fat <= (unsigned short)0xFFFF)
21082f38:	01bffdd4 	movui	r6,65527
21082f3c:	30801f36 	bltu	r6,r2,21082fbc <fatFindUnusedCluster+0x144>
        Type = CLUSTER_LAST_INFILE;
    else if (Fat == (alt_u16)0x00)
21082f40:	10000626 	beq	r2,zero,21082f5c <fatFindUnusedCluster+0xe4>
        Type = CLUSTER_UNUSED;
    else if (Fat >= 0xFFF0 && Fat <= 0xFFF6)
21082f44:	18c00404 	addi	r3,r3,16
21082f48:	18ffffcc 	andi	r3,r3,65535
21082f4c:	008001c4 	movi	r2,7
21082f50:	10c01a2e 	bgeu	r2,r3,21082fbc <fatFindUnusedCluster+0x144>
21082f54:	0005883a 	mov	r2,zero
                ClusterType = fat32ClusterType(ClusterEntryValue);
            }else{
                ClusterEntryValue = *(alt_u16 *)pFatEntry; 
                ClusterType = fat16ClusterType(ClusterEntryValue);
            }    
            if (ClusterType == CLUSTER_UNUSED){
21082f58:	1000181e 	bne	r2,zero,21082fbc <fatFindUnusedCluster+0x144>
        ThisCluster++;           
    }                
    
    return UnusedCluster;

}
21082f5c:	b005883a 	mov	r2,r22
21082f60:	dfc00917 	ldw	ra,36(sp)
21082f64:	df000817 	ldw	fp,32(sp)
21082f68:	ddc00717 	ldw	r23,28(sp)
21082f6c:	dd800617 	ldw	r22,24(sp)
21082f70:	dd400517 	ldw	r21,20(sp)
21082f74:	dd000417 	ldw	r20,16(sp)
21082f78:	dcc00317 	ldw	r19,12(sp)
21082f7c:	dc800217 	ldw	r18,8(sp)
21082f80:	dc400117 	ldw	r17,4(sp)
21082f84:	dc000017 	ldw	r16,0(sp)
21082f88:	dec00a04 	addi	sp,sp,40
21082f8c:	f800283a 	ret
         
}

CLUSTER_TYPE fat32ClusterType(alt_u32 Fat){
    CLUSTER_TYPE Type;
    Fat = Fat & 0xFFFFFFF; // 28 bits
21082f90:	18800017 	ldw	r2,0(r3)
21082f94:	00c40034 	movhi	r3,4096
21082f98:	18ffffc4 	addi	r3,r3,-1
21082f9c:	10c4703a 	and	r2,r2,r3
    
    if (Fat > 0 && Fat < 0xFFFFFF0)
21082fa0:	01840034 	movhi	r6,4096
21082fa4:	10ffffc4 	addi	r3,r2,-1
21082fa8:	31bffb84 	addi	r6,r6,-18
21082fac:	30c0032e 	bgeu	r6,r3,21082fbc <fatFindUnusedCluster+0x144>
        Type = CLUSTER_NEXT_INFILE;
    else if (Fat >= 0xFFFFFF8) // && Fat <= (unsigned short)0xFFFF)
21082fb0:	00c40034 	movhi	r3,4096
21082fb4:	18fffdc4 	addi	r3,r3,-9
21082fb8:	1880082e 	bgeu	r3,r2,21082fdc <fatFindUnusedCluster+0x164>
                bDone = TRUE;
            }    
        }else{
            bDone = TRUE;
        }     
        ThisCluster++;           
21082fbc:	b5800044 	addi	r22,r22,1
21082fc0:	e5c00717 	ldw	r23,28(fp)
21082fc4:	aceb883a 	add	r21,r21,r19
21082fc8:	003fc306 	br	21082ed8 <__flash_rwdata_start+0xfffe0c90>
bool fatReadSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;

    if (nSecter != pVol->Secter_Index){
        if (!pVol->ReadBlock512(pVol->DiskHandle, nSecter, pVol->Secter_Data)){
            pVol->Secter_Index = -1;
21082fcc:	01ffffc4 	movi	r7,-1
21082fd0:	e1c11215 	stw	r7,1096(fp)
21082fd4:	382d883a 	mov	r22,r7
21082fd8:	003fe006 	br	21082f5c <__flash_rwdata_start+0xfffe0d14>
    
    if (Fat > 0 && Fat < 0xFFFFFF0)
        Type = CLUSTER_NEXT_INFILE;
    else if (Fat >= 0xFFFFFF8) // && Fat <= (unsigned short)0xFFFF)
        Type = CLUSTER_LAST_INFILE;
    else if (Fat == (alt_u32)0x00)
21082fdc:	103fdf26 	beq	r2,zero,21082f5c <__flash_rwdata_start+0xfffe0d14>
        Type = CLUSTER_UNUSED;
    else if (Fat >= 0xFFFFFF0 && Fat <= 0xFFFFFF6)
21082fe0:	01bc0034 	movhi	r6,61440
21082fe4:	31800404 	addi	r6,r6,16
21082fe8:	1185883a 	add	r2,r2,r6
21082fec:	00c001c4 	movi	r3,7
21082ff0:	18bff22e 	bgeu	r3,r2,21082fbc <__flash_rwdata_start+0xfffe0d74>
21082ff4:	003fd706 	br	21082f54 <__flash_rwdata_start+0xfffe0d0c>
alt_u32 fatFindUnusedCluster(VOLUME_INFO *pVol){
    CLUSTER_TYPE ClusterType;
    alt_u32 UnusedCluster=-1, ThisCluster = 2, ClusterEntryValue;
    void *pFatEntry;

    const alt_32 nFatEntrySize = (pVol->Partition_Type == PARTITION_FAT32)?4:2; // 2 byte for FAT16
21082ff8:	04c00104 	movi	r19,4
21082ffc:	003fae06 	br	21082eb8 <__flash_rwdata_start+0xfffe0c70>

21083000 <fatDelClusterList>:
    return UnusedCluster;

}


bool fatDelClusterList(VOLUME_INFO *pVol, alt_u32 StartCluster){
21083000:	defff204 	addi	sp,sp,-56
21083004:	df000c15 	stw	fp,48(sp)
21083008:	2039883a 	mov	fp,r4
    bool bDone = FALSE;
    alt_u32 ClusterIndex, Secter, ClusterEntryValue;
    void *pFatEntryValue;
    
    
    const int nFatEntrySize = (pVol->Partition_Type == PARTITION_FAT32)?4:2; // 2 byte for FAT16
2108300c:	21000417 	ldw	r4,16(r4)
    return UnusedCluster;

}


bool fatDelClusterList(VOLUME_INFO *pVol, alt_u32 StartCluster){
21083010:	dd800a15 	stw	r22,40(sp)
21083014:	dfc00d15 	stw	ra,52(sp)
21083018:	ddc00b15 	stw	r23,44(sp)
2108301c:	dd400915 	stw	r21,36(sp)
21083020:	dd000815 	stw	r20,32(sp)
21083024:	dcc00715 	stw	r19,28(sp)
21083028:	dc800615 	stw	r18,24(sp)
2108302c:	dc400515 	stw	r17,20(sp)
21083030:	dc000415 	stw	r16,16(sp)
    bool bDone = FALSE;
    alt_u32 ClusterIndex, Secter, ClusterEntryValue;
    void *pFatEntryValue;
    
    
    const int nFatEntrySize = (pVol->Partition_Type == PARTITION_FAT32)?4:2; // 2 byte for FAT16
21083034:	008002c4 	movi	r2,11
    return UnusedCluster;

}


bool fatDelClusterList(VOLUME_INFO *pVol, alt_u32 StartCluster){
21083038:	282d883a 	mov	r22,r5
    bool bDone = FALSE;
    alt_u32 ClusterIndex, Secter, ClusterEntryValue;
    void *pFatEntryValue;
    
    
    const int nFatEntrySize = (pVol->Partition_Type == PARTITION_FAT32)?4:2; // 2 byte for FAT16
2108303c:	20806c26 	beq	r4,r2,210831f0 <fatDelClusterList+0x1f0>
21083040:	04400084 	movi	r17,2
    const int nFatEntryPerSecter = pVol->BPB_BytsPerSec/nFatEntrySize;
21083044:	e1c00717 	ldw	r7,28(fp)
            }else{
                ClusterEntryValue = *(alt_u16 *)pFatEntryValue; //(pVol->Secter_Data + (ThisCluster%nFatEntryPerSecter)*nFatEntrySize); 
                ClusterType = fat16ClusterType(ClusterEntryValue);
            }
                
            if (ClusterType != CLUSTER_NEXT_INFILE && ClusterType != CLUSTER_LAST_INFILE){
21083048:	0005883a 	mov	r2,zero
2108304c:	0009883a 	mov	r4,zero
21083050:	8da1383a 	mul	r16,r17,r22
21083054:	10ffff44 	addi	r3,r2,-3
                bDone = TRUE;
                bSuccess = FALSE;
            }else{
                if (ClusterType == CLUSTER_LAST_INFILE)
21083058:	210000e0 	cmpeqi	r4,r4,3
         
}

CLUSTER_TYPE fat32ClusterType(alt_u32 Fat){
    CLUSTER_TYPE Type;
    Fat = Fat & 0xFFFFFFF; // 28 bits
2108305c:	05040034 	movhi	r20,4096
    
    if (Fat > 0 && Fat < 0xFFFFFF0)
21083060:	04c40034 	movhi	r19,4096
         
}

CLUSTER_TYPE fat32ClusterType(alt_u32 Fat){
    CLUSTER_TYPE Type;
    Fat = Fat & 0xFFFFFFF; // 28 bits
21083064:	a53fffc4 	addi	r20,r20,-1
    
    if (Fat > 0 && Fat < 0xFFFFFF0)
21083068:	9cfffb84 	addi	r19,r19,-18
    alt_u32 ClusterIndex, Secter, ClusterEntryValue;
    void *pFatEntryValue;
    
    
    const int nFatEntrySize = (pVol->Partition_Type == PARTITION_FAT32)?4:2; // 2 byte for FAT16
    const int nFatEntryPerSecter = pVol->BPB_BytsPerSec/nFatEntrySize;
2108306c:	3c6f203a 	divu	r23,r7,r17
            }else{
                ClusterEntryValue = *(alt_u16 *)pFatEntryValue; //(pVol->Secter_Data + (ThisCluster%nFatEntryPerSecter)*nFatEntrySize); 
                ClusterType = fat16ClusterType(ClusterEntryValue);
            }
                
            if (ClusterType != CLUSTER_NEXT_INFILE && ClusterType != CLUSTER_LAST_INFILE){
21083070:	d8c00115 	stw	r3,4(sp)
21083074:	d8c00015 	stw	r3,0(sp)
//// add in v2.0
bool fatReadSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;

    if (nSecter != pVol->Secter_Index){
        if (!pVol->ReadBlock512(pVol->DiskHandle, nSecter, pVol->Secter_Data)){
21083078:	e4809204 	addi	r18,fp,584
                
            if (ClusterType != CLUSTER_NEXT_INFILE && ClusterType != CLUSTER_LAST_INFILE){
                bDone = TRUE;
                bSuccess = FALSE;
            }else{
                if (ClusterType == CLUSTER_LAST_INFILE)
2108307c:	d9000215 	stw	r4,8(sp)
21083080:	d9000315 	stw	r4,12(sp)
    const int nFatEntryPerSecter = pVol->BPB_BytsPerSec/nFatEntrySize;
     
    ClusterIndex = StartCluster;
    while(bSuccess && !bDone){
        // read FAT Table
        Secter = pVol->FatEntrySecter + (ClusterIndex*nFatEntrySize)/pVol->BPB_BytsPerSec;
21083084:	e0800e17 	ldw	r2,56(fp)
//=================================================================================
//// add in v2.0
bool fatReadSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;

    if (nSecter != pVol->Secter_Index){
21083088:	e1411217 	ldw	r5,1096(fp)
    const int nFatEntryPerSecter = pVol->BPB_BytsPerSec/nFatEntrySize;
     
    ClusterIndex = StartCluster;
    while(bSuccess && !bDone){
        // read FAT Table
        Secter = pVol->FatEntrySecter + (ClusterIndex*nFatEntrySize)/pVol->BPB_BytsPerSec;
2108308c:	81cf203a 	divu	r7,r16,r7
21083090:	38ab883a 	add	r21,r7,r2
//=================================================================================
//// add in v2.0
bool fatReadSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;

    if (nSecter != pVol->Secter_Index){
21083094:	a9400826 	beq	r21,r5,210830b8 <fatDelClusterList+0xb8>
        if (!pVol->ReadBlock512(pVol->DiskHandle, nSecter, pVol->Secter_Data)){
21083098:	e0800117 	ldw	r2,4(fp)
2108309c:	e1000017 	ldw	r4,0(fp)
210830a0:	a80b883a 	mov	r5,r21
210830a4:	900d883a 	mov	r6,r18
210830a8:	103ee83a 	callr	r2
210830ac:	10002026 	beq	r2,zero,21083130 <fatDelClusterList+0x130>
            pVol->Secter_Index = -1;
            bSuccess = FALSE;
        }else{
            pVol->Secter_Index = nSecter;
210830b0:	e5411215 	stw	r21,1096(fp)
210830b4:	a80b883a 	mov	r5,r21
        // read FAT Table
        Secter = pVol->FatEntrySecter + (ClusterIndex*nFatEntrySize)/pVol->BPB_BytsPerSec;
        bSuccess = fatReadSecter(pVol, Secter);
        if (bSuccess){
            // get the value of FAT entry
            pFatEntryValue = (pVol->Secter_Data + (ClusterIndex%nFatEntryPerSecter)*nFatEntrySize);
210830b8:	b5c5203a 	divu	r2,r22,r23
210830bc:	15c5383a 	mul	r2,r2,r23
            if (pVol->Partition_Type == PARTITION_FAT32){
210830c0:	e1800417 	ldw	r6,16(fp)
210830c4:	010002c4 	movi	r4,11
        // read FAT Table
        Secter = pVol->FatEntrySecter + (ClusterIndex*nFatEntrySize)/pVol->BPB_BytsPerSec;
        bSuccess = fatReadSecter(pVol, Secter);
        if (bSuccess){
            // get the value of FAT entry
            pFatEntryValue = (pVol->Secter_Data + (ClusterIndex%nFatEntryPerSecter)*nFatEntrySize);
210830c8:	b085c83a 	sub	r2,r22,r2
210830cc:	1445383a 	mul	r2,r2,r17
210830d0:	10809204 	addi	r2,r2,584
210830d4:	e085883a 	add	r2,fp,r2
            if (pVol->Partition_Type == PARTITION_FAT32){
210830d8:	31002226 	beq	r6,r4,21083164 <fatDelClusterList+0x164>
                ClusterEntryValue = *(alt_u32 *)pFatEntryValue; 
                ClusterType = fat32ClusterType(ClusterEntryValue);
            }else{
                ClusterEntryValue = *(alt_u16 *)pFatEntryValue; //(pVol->Secter_Data + (ThisCluster%nFatEntryPerSecter)*nFatEntrySize); 
210830dc:	1180000b 	ldhu	r6,0(r2)

CLUSTER_TYPE fat16ClusterType(alt_u32 Fat){
    CLUSTER_TYPE Type;
    Fat = Fat & 0xFFFF; // 16 bits
    
    if (Fat > 0 && Fat < 0xFFF0)
210830e0:	02bffb94 	movui	r10,65518

VOLUME_INFO vInfo;

CLUSTER_TYPE fat16ClusterType(alt_u32 Fat){
    CLUSTER_TYPE Type;
    Fat = Fat & 0xFFFF; // 16 bits
210830e4:	313fffcc 	andi	r4,r6,65535
    
    if (Fat > 0 && Fat < 0xFFF0)
210830e8:	21ffffc4 	addi	r7,r4,-1
210830ec:	51c0132e 	bgeu	r10,r7,2108313c <fatDelClusterList+0x13c>
        Type = CLUSTER_NEXT_INFILE;
    else if (Fat >= 0xFFF8) // && Fat <= (unsigned short)0xFFFF)
210830f0:	01fffdd4 	movui	r7,65527
210830f4:	39002436 	bltu	r7,r4,21083188 <fatDelClusterList+0x188>
        Type = CLUSTER_LAST_INFILE;
    else if (Fat == (alt_u16)0x00)
210830f8:	2000291e 	bne	r4,zero,210831a0 <fatDelClusterList+0x1a0>
    bool bDone = FALSE;
    alt_u32 ClusterIndex, Secter, ClusterEntryValue;
    void *pFatEntryValue;
    
    
    const int nFatEntrySize = (pVol->Partition_Type == PARTITION_FAT32)?4:2; // 2 byte for FAT16
210830fc:	0005883a 	mov	r2,zero
    }  // while                
    
    
    return bSuccess;

}
21083100:	dfc00d17 	ldw	ra,52(sp)
21083104:	df000c17 	ldw	fp,48(sp)
21083108:	ddc00b17 	ldw	r23,44(sp)
2108310c:	dd800a17 	ldw	r22,40(sp)
21083110:	dd400917 	ldw	r21,36(sp)
21083114:	dd000817 	ldw	r20,32(sp)
21083118:	dcc00717 	ldw	r19,28(sp)
2108311c:	dc800617 	ldw	r18,24(sp)
21083120:	dc400517 	ldw	r17,20(sp)
21083124:	dc000417 	ldw	r16,16(sp)
21083128:	dec00e04 	addi	sp,sp,56
2108312c:	f800283a 	ret
bool fatReadSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;

    if (nSecter != pVol->Secter_Index){
        if (!pVol->ReadBlock512(pVol->DiskHandle, nSecter, pVol->Secter_Data)){
            pVol->Secter_Index = -1;
21083130:	00bfffc4 	movi	r2,-1
21083134:	e0811215 	stw	r2,1096(fp)
21083138:	003ff006 	br	210830fc <__flash_rwdata_start+0xfffe0eb4>

CLUSTER_TYPE fat16ClusterType(alt_u32 Fat){
    CLUSTER_TYPE Type;
    Fat = Fat & 0xFFFF; // 16 bits
    
    if (Fat > 0 && Fat < 0xFFF0)
2108313c:	002b883a 	mov	r21,zero
                    bDone = TRUE; // the last cluster
                // update
                if (pVol->Partition_Type == PARTITION_FAT32)
                    *(alt_u32 *)pFatEntryValue = CLUSTER_UNUSED;
                else 
                    *(alt_u16 *)pFatEntryValue = CLUSTER_UNUSED;
21083140:	1000000d 	sth	zero,0(r2)
                //write back FAT Table
                bSuccess = pVol->WriteBlock512(pVol->DiskHandle, pVol->Secter_Index, pVol->Secter_Data);
21083144:	e0800217 	ldw	r2,8(fp)
21083148:	e1000017 	ldw	r4,0(fp)
2108314c:	900d883a 	mov	r6,r18
21083150:	103ee83a 	callr	r2
    
    const int nFatEntrySize = (pVol->Partition_Type == PARTITION_FAT32)?4:2; // 2 byte for FAT16
    const int nFatEntryPerSecter = pVol->BPB_BytsPerSec/nFatEntrySize;
     
    ClusterIndex = StartCluster;
    while(bSuccess && !bDone){
21083154:	103fea26 	beq	r2,zero,21083100 <__flash_rwdata_start+0xfffe0eb8>
21083158:	a83fe91e 	bne	r21,zero,21083100 <__flash_rwdata_start+0xfffe0eb8>
2108315c:	e1c00717 	ldw	r7,28(fp)
21083160:	003fc806 	br	21083084 <__flash_rwdata_start+0xfffe0e3c>
         
}

CLUSTER_TYPE fat32ClusterType(alt_u32 Fat){
    CLUSTER_TYPE Type;
    Fat = Fat & 0xFFFFFFF; // 28 bits
21083164:	11000017 	ldw	r4,0(r2)
21083168:	2508703a 	and	r4,r4,r20
    
    if (Fat > 0 && Fat < 0xFFFFFF0)
2108316c:	217fffc4 	addi	r5,r4,-1
21083170:	9940072e 	bgeu	r19,r5,21083190 <fatDelClusterList+0x190>
        Type = CLUSTER_NEXT_INFILE;
    else if (Fat >= 0xFFFFFF8) // && Fat <= (unsigned short)0xFFFF)
21083174:	00c40034 	movhi	r3,4096
21083178:	18fffdc4 	addi	r3,r3,-9
2108317c:	1900112e 	bgeu	r3,r4,210831c4 <fatDelClusterList+0x1c4>
21083180:	05400044 	movi	r21,1
21083184:	00000306 	br	21083194 <fatDelClusterList+0x194>
    CLUSTER_TYPE Type;
    Fat = Fat & 0xFFFF; // 16 bits
    
    if (Fat > 0 && Fat < 0xFFF0)
        Type = CLUSTER_NEXT_INFILE;
    else if (Fat >= 0xFFF8) // && Fat <= (unsigned short)0xFFFF)
21083188:	05400044 	movi	r21,1
2108318c:	003fec06 	br	21083140 <__flash_rwdata_start+0xfffe0ef8>

CLUSTER_TYPE fat32ClusterType(alt_u32 Fat){
    CLUSTER_TYPE Type;
    Fat = Fat & 0xFFFFFFF; // 28 bits
    
    if (Fat > 0 && Fat < 0xFFFFFF0)
21083190:	002b883a 	mov	r21,zero
            }else{
                if (ClusterType == CLUSTER_LAST_INFILE)
                    bDone = TRUE; // the last cluster
                // update
                if (pVol->Partition_Type == PARTITION_FAT32)
                    *(alt_u32 *)pFatEntryValue = CLUSTER_UNUSED;
21083194:	10000015 	stw	zero,0(r2)
21083198:	e1411217 	ldw	r5,1096(fp)
2108319c:	003fe906 	br	21083144 <__flash_rwdata_start+0xfffe0efc>
        Type = CLUSTER_NEXT_INFILE;
    else if (Fat >= 0xFFF8) // && Fat <= (unsigned short)0xFFFF)
        Type = CLUSTER_LAST_INFILE;
    else if (Fat == (alt_u16)0x00)
        Type = CLUSTER_UNUSED;
    else if (Fat >= 0xFFF0 && Fat <= 0xFFF6)
210831a0:	31800404 	addi	r6,r6,16
210831a4:	31bfffcc 	andi	r6,r6,65535
210831a8:	010001c4 	movi	r4,7
210831ac:	21bfd32e 	bgeu	r4,r6,210830fc <__flash_rwdata_start+0xfffe0eb4>
            }else{
                ClusterEntryValue = *(alt_u16 *)pFatEntryValue; //(pVol->Secter_Data + (ThisCluster%nFatEntryPerSecter)*nFatEntrySize); 
                ClusterType = fat16ClusterType(ClusterEntryValue);
            }
                
            if (ClusterType != CLUSTER_NEXT_INFILE && ClusterType != CLUSTER_LAST_INFILE){
210831b0:	d8c00017 	ldw	r3,0(sp)
210831b4:	01000044 	movi	r4,1
210831b8:	20ffd036 	bltu	r4,r3,210830fc <__flash_rwdata_start+0xfffe0eb4>
                bDone = TRUE;
                bSuccess = FALSE;
            }else{
                if (ClusterType == CLUSTER_LAST_INFILE)
210831bc:	dd400217 	ldw	r21,8(sp)
210831c0:	003fdf06 	br	21083140 <__flash_rwdata_start+0xfffe0ef8>
    
    if (Fat > 0 && Fat < 0xFFFFFF0)
        Type = CLUSTER_NEXT_INFILE;
    else if (Fat >= 0xFFFFFF8) // && Fat <= (unsigned short)0xFFFF)
        Type = CLUSTER_LAST_INFILE;
    else if (Fat == (alt_u32)0x00)
210831c4:	203fcd26 	beq	r4,zero,210830fc <__flash_rwdata_start+0xfffe0eb4>
        Type = CLUSTER_UNUSED;
    else if (Fat >= 0xFFFFFF0 && Fat <= 0xFFFFFF6)
210831c8:	00fc0034 	movhi	r3,61440
210831cc:	18c00404 	addi	r3,r3,16
210831d0:	20c9883a 	add	r4,r4,r3
210831d4:	014001c4 	movi	r5,7
210831d8:	293fc82e 	bgeu	r5,r4,210830fc <__flash_rwdata_start+0xfffe0eb4>
            }else{
                ClusterEntryValue = *(alt_u16 *)pFatEntryValue; //(pVol->Secter_Data + (ThisCluster%nFatEntryPerSecter)*nFatEntrySize); 
                ClusterType = fat16ClusterType(ClusterEntryValue);
            }
                
            if (ClusterType != CLUSTER_NEXT_INFILE && ClusterType != CLUSTER_LAST_INFILE){
210831dc:	d8c00117 	ldw	r3,4(sp)
210831e0:	01000044 	movi	r4,1
210831e4:	20ffc536 	bltu	r4,r3,210830fc <__flash_rwdata_start+0xfffe0eb4>
                bDone = TRUE;
                bSuccess = FALSE;
            }else{
                if (ClusterType == CLUSTER_LAST_INFILE)
210831e8:	dd400317 	ldw	r21,12(sp)
210831ec:	003fe906 	br	21083194 <__flash_rwdata_start+0xfffe0f4c>
210831f0:	04400104 	movi	r17,4
210831f4:	003f9306 	br	21083044 <__flash_rwdata_start+0xfffe0dfc>

210831f8 <fatDumpDate>:
    return bSuccess;

}


void fatDumpDate(unsigned short Date){
210831f8:	f800283a 	ret

210831fc <fatDumpTime>:
    Month = ((Date >> 5) & 0xF);
    Day = ((Date >> 0) & 0x1F);
    FAT_DEBUG(("%d,%d,%d", Year, Month, Day)); 
}

void fatDumpTime(unsigned short Date){
210831fc:	f800283a 	ret

21083200 <fatIsLastDir>:
    S = ((Date >> 0) & 0x1F)*2;
    FAT_DEBUG(("%d:%d:%d", H, M, S));     
}

bool fatIsLastDir(FAT_DIRECTORY *pDir){
    if (pDir->Name[0] == REMAINED_UNUSED_DIR_ENTRY)  // 0x00
21083200:	20800007 	ldb	r2,0(r4)
        return TRUE;
    return FALSE;        
}
21083204:	1005003a 	cmpeq	r2,r2,zero
21083208:	f800283a 	ret

2108320c <fatIsValidDir>:


bool fatIsValidDir(FAT_DIRECTORY *pDir){
2108320c:	defff904 	addi	sp,sp,-28
    char szTest[] = {0x00, 0xE5, 0x22, 0x2A, 0x2B, 0x2C, 0x2E, 0x2F, 0x3A, 0x3B, 0x3C, 0x3E, 0x3F, 0x5B, 0x5C, 0x5D, 0x7C};
21083210:	01400034 	movhi	r5,0
        return TRUE;
    return FALSE;        
}


bool fatIsValidDir(FAT_DIRECTORY *pDir){
21083214:	dc000515 	stw	r16,20(sp)
    char szTest[] = {0x00, 0xE5, 0x22, 0x2A, 0x2B, 0x2C, 0x2E, 0x2F, 0x3A, 0x3B, 0x3C, 0x3E, 0x3F, 0x5B, 0x5C, 0x5D, 0x7C};
21083218:	2940b744 	addi	r5,r5,733
        return TRUE;
    return FALSE;        
}


bool fatIsValidDir(FAT_DIRECTORY *pDir){
2108321c:	2021883a 	mov	r16,r4
    char szTest[] = {0x00, 0xE5, 0x22, 0x2A, 0x2B, 0x2C, 0x2E, 0x2F, 0x3A, 0x3B, 0x3C, 0x3E, 0x3F, 0x5B, 0x5C, 0x5D, 0x7C};
21083220:	01800444 	movi	r6,17
21083224:	d809883a 	mov	r4,sp
        return TRUE;
    return FALSE;        
}


bool fatIsValidDir(FAT_DIRECTORY *pDir){
21083228:	dfc00615 	stw	ra,24(sp)
    char szTest[] = {0x00, 0xE5, 0x22, 0x2A, 0x2B, 0x2C, 0x2E, 0x2F, 0x3A, 0x3B, 0x3C, 0x3E, 0x3F, 0x5B, 0x5C, 0x5D, 0x7C};
2108322c:	108e1340 	call	2108e134 <memcpy>
    int i;
    
    for(i=0;i<sizeof(szTest)/sizeof(szTest[0]);i++){
        if (pDir->Name[0] == szTest[i]){
21083230:	80800007 	ldb	r2,0(r16)
21083234:	d8c00007 	ldb	r3,0(sp)
21083238:	10c02426 	beq	r2,r3,210832cc <fatIsValidDir+0xc0>
2108323c:	d8c00047 	ldb	r3,1(sp)
21083240:	18802226 	beq	r3,r2,210832cc <fatIsValidDir+0xc0>
21083244:	d8c00087 	ldb	r3,2(sp)
21083248:	18802026 	beq	r3,r2,210832cc <fatIsValidDir+0xc0>
2108324c:	d8c000c7 	ldb	r3,3(sp)
21083250:	18801e26 	beq	r3,r2,210832cc <fatIsValidDir+0xc0>
21083254:	d8c00107 	ldb	r3,4(sp)
21083258:	18801c26 	beq	r3,r2,210832cc <fatIsValidDir+0xc0>
2108325c:	d8c00147 	ldb	r3,5(sp)
21083260:	18801a26 	beq	r3,r2,210832cc <fatIsValidDir+0xc0>
21083264:	d8c00187 	ldb	r3,6(sp)
21083268:	18801826 	beq	r3,r2,210832cc <fatIsValidDir+0xc0>
2108326c:	d8c001c7 	ldb	r3,7(sp)
21083270:	18801626 	beq	r3,r2,210832cc <fatIsValidDir+0xc0>
21083274:	d8c00207 	ldb	r3,8(sp)
21083278:	18801426 	beq	r3,r2,210832cc <fatIsValidDir+0xc0>
2108327c:	d8c00247 	ldb	r3,9(sp)
21083280:	18801226 	beq	r3,r2,210832cc <fatIsValidDir+0xc0>
21083284:	d8c00287 	ldb	r3,10(sp)
21083288:	18801026 	beq	r3,r2,210832cc <fatIsValidDir+0xc0>
2108328c:	d8c002c7 	ldb	r3,11(sp)
21083290:	18800e26 	beq	r3,r2,210832cc <fatIsValidDir+0xc0>
21083294:	d8c00307 	ldb	r3,12(sp)
21083298:	18800c26 	beq	r3,r2,210832cc <fatIsValidDir+0xc0>
2108329c:	d8c00347 	ldb	r3,13(sp)
210832a0:	18800a26 	beq	r3,r2,210832cc <fatIsValidDir+0xc0>
210832a4:	d8c00387 	ldb	r3,14(sp)
210832a8:	18800826 	beq	r3,r2,210832cc <fatIsValidDir+0xc0>
210832ac:	d8c003c7 	ldb	r3,15(sp)
210832b0:	18800626 	beq	r3,r2,210832cc <fatIsValidDir+0xc0>
210832b4:	d8c00407 	ldb	r3,16(sp)
210832b8:	1884c03a 	cmpne	r2,r3,r2
            return FALSE;
        }
    }    
    return TRUE;
    
}
210832bc:	dfc00617 	ldw	ra,24(sp)
210832c0:	dc000517 	ldw	r16,20(sp)
210832c4:	dec00704 	addi	sp,sp,28
210832c8:	f800283a 	ret
    char szTest[] = {0x00, 0xE5, 0x22, 0x2A, 0x2B, 0x2C, 0x2E, 0x2F, 0x3A, 0x3B, 0x3C, 0x3E, 0x3F, 0x5B, 0x5C, 0x5D, 0x7C};
    int i;
    
    for(i=0;i<sizeof(szTest)/sizeof(szTest[0]);i++){
        if (pDir->Name[0] == szTest[i]){
            return FALSE;
210832cc:	0005883a 	mov	r2,zero
        }
    }    
    return TRUE;
    
}
210832d0:	dfc00617 	ldw	ra,24(sp)
210832d4:	dc000517 	ldw	r16,20(sp)
210832d8:	dec00704 	addi	sp,sp,28
210832dc:	f800283a 	ret

210832e0 <fatIsUnusedDir>:

bool fatIsUnusedDir(FAT_DIRECTORY *pDir){
    if (pDir->Name[0] == (alt_8)UNUSED_DIR_ENTRY)
210832e0:	20800007 	ldb	r2,0(r4)
        return TRUE;
    return FALSE; 
}
210832e4:	10bff960 	cmpeqi	r2,r2,-27
210832e8:	f800283a 	ret

210832ec <fatDump>:

// debug
void fatDump(FAT_DIRECTORY *pDir){
210832ec:	defffb04 	addi	sp,sp,-20
    char szInvalidName[] = {0x22, 0x2A, 0x2B, 0x2C, 0x2E, 0x2F, 0x3A, 0x3B, 0x3C, 0x3E, 0x3F, 0x5B, 0x5C, 0x5D, 0x7C};
210832f0:	01400034 	movhi	r5,0
210832f4:	2940bb84 	addi	r5,r5,750
210832f8:	d809883a 	mov	r4,sp
210832fc:	018003c4 	movi	r6,15
        return TRUE;
    return FALSE; 
}

// debug
void fatDump(FAT_DIRECTORY *pDir){
21083300:	dfc00415 	stw	ra,16(sp)
    char szInvalidName[] = {0x22, 0x2A, 0x2B, 0x2C, 0x2E, 0x2F, 0x3A, 0x3B, 0x3C, 0x3E, 0x3F, 0x5B, 0x5C, 0x5D, 0x7C};
21083304:	108e1340 	call	2108e134 <memcpy>
    FAT_DEBUG(("ClusterHi:%04Xh\n", pDir->FirstLogicalClusterHi));
    FAT_DEBUG(("LastWriteTime:")); fatDumpTime(pDir->LastWriteTime);FAT_DEBUG(("\n"));
    FAT_DEBUG(("LastWriteDate:")); fatDumpDate(pDir->LastWriteDate);FAT_DEBUG(("\n"));
    FAT_DEBUG(("Cluster:%04Xh(%d)\n", pDir->FirstLogicalCluster,pDir->FirstLogicalCluster));
    FAT_DEBUG(("File Size:%08Xh(%ld)\n", pDir->FileSize, (long)pDir->FileSize));
}
21083308:	dfc00417 	ldw	ra,16(sp)
2108330c:	dec00504 	addi	sp,sp,20
21083310:	f800283a 	ret

21083314 <fatArray2Value>:


unsigned int fatArray2Value(unsigned char *pValue, unsigned int nNum){
    alt_u8 *pMSB = (pValue + nNum - 1);
21083314:	28ffffc4 	addi	r3,r5,-1
21083318:	20c9883a 	add	r4,r4,r3
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
2108331c:	28000626 	beq	r5,zero,21083338 <fatArray2Value+0x24>
21083320:	214bc83a 	sub	r5,r4,r5
        nValue <<= 8;
        nValue |= *pMSB--;
21083324:	20c00003 	ldbu	r3,0(r4)
unsigned int fatArray2Value(unsigned char *pValue, unsigned int nNum){
    alt_u8 *pMSB = (pValue + nNum - 1);
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
        nValue <<= 8;
21083328:	1004923a 	slli	r2,r2,8
2108332c:	213fffc4 	addi	r4,r4,-1
        nValue |= *pMSB--;
21083330:	1884b03a 	or	r2,r3,r2

unsigned int fatArray2Value(unsigned char *pValue, unsigned int nNum){
    alt_u8 *pMSB = (pValue + nNum - 1);
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
21083334:	217ffb1e 	bne	r4,r5,21083324 <__flash_rwdata_start+0xfffe10dc>
        nValue |= *pMSB--;
        
    }
    
    return nValue;
}
21083338:	f800283a 	ret

2108333c <fatReadFATSecter>:
//=================================================================================
//// add in v2.0
bool fatReadFATSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;

    if (nSecter != pVol->FAT_Index){
2108333c:	20c09117 	ldw	r3,580(r4)
21083340:	19401626 	beq	r3,r5,2108339c <fatReadFATSecter+0x60>
    
    return nValue;
}
//=================================================================================
//// add in v2.0
bool fatReadFATSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
21083344:	defffd04 	addi	sp,sp,-12
21083348:	dc000015 	stw	r16,0(sp)
    bool bSuccess = TRUE;

    if (nSecter != pVol->FAT_Index){
        if (!pVol->ReadBlock512(pVol->DiskHandle, nSecter, pVol->FAT_Data)){
2108334c:	20800117 	ldw	r2,4(r4)
21083350:	2021883a 	mov	r16,r4
21083354:	21000017 	ldw	r4,0(r4)
    
    return nValue;
}
//=================================================================================
//// add in v2.0
bool fatReadFATSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
21083358:	dc400115 	stw	r17,4(sp)
2108335c:	dfc00215 	stw	ra,8(sp)
    bool bSuccess = TRUE;

    if (nSecter != pVol->FAT_Index){
        if (!pVol->ReadBlock512(pVol->DiskHandle, nSecter, pVol->FAT_Data)){
21083360:	81801104 	addi	r6,r16,68
21083364:	2823883a 	mov	r17,r5
21083368:	103ee83a 	callr	r2
2108336c:	10000726 	beq	r2,zero,2108338c <fatReadFATSecter+0x50>
            pVol->FAT_Index = -1;
            bSuccess = FALSE;
        }else{
            pVol->FAT_Index = nSecter;
21083370:	84409115 	stw	r17,580(r16)
    return nValue;
}
//=================================================================================
//// add in v2.0
bool fatReadFATSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;
21083374:	00800044 	movi	r2,1
        }else{
            pVol->FAT_Index = nSecter;
        }
    }
    return bSuccess;
}
21083378:	dfc00217 	ldw	ra,8(sp)
2108337c:	dc400117 	ldw	r17,4(sp)
21083380:	dc000017 	ldw	r16,0(sp)
21083384:	dec00304 	addi	sp,sp,12
21083388:	f800283a 	ret
bool fatReadFATSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;

    if (nSecter != pVol->FAT_Index){
        if (!pVol->ReadBlock512(pVol->DiskHandle, nSecter, pVol->FAT_Data)){
            pVol->FAT_Index = -1;
2108338c:	00bfffc4 	movi	r2,-1
21083390:	80809115 	stw	r2,580(r16)
            bSuccess = FALSE;
21083394:	0005883a 	mov	r2,zero
21083398:	003ff706 	br	21083378 <__flash_rwdata_start+0xfffe1130>
    return nValue;
}
//=================================================================================
//// add in v2.0
bool fatReadFATSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;
2108339c:	00800044 	movi	r2,1
210833a0:	f800283a 	ret

210833a4 <fatReadSecter>:
//=================================================================================
//// add in v2.0
bool fatReadSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;

    if (nSecter != pVol->Secter_Index){
210833a4:	20c11217 	ldw	r3,1096(r4)
210833a8:	19401626 	beq	r3,r5,21083404 <fatReadSecter+0x60>
    }
    return bSuccess;
}
//=================================================================================
//// add in v2.0
bool fatReadSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
210833ac:	defffd04 	addi	sp,sp,-12
210833b0:	dc000015 	stw	r16,0(sp)
    bool bSuccess = TRUE;

    if (nSecter != pVol->Secter_Index){
        if (!pVol->ReadBlock512(pVol->DiskHandle, nSecter, pVol->Secter_Data)){
210833b4:	20800117 	ldw	r2,4(r4)
210833b8:	2021883a 	mov	r16,r4
210833bc:	21000017 	ldw	r4,0(r4)
    }
    return bSuccess;
}
//=================================================================================
//// add in v2.0
bool fatReadSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
210833c0:	dc400115 	stw	r17,4(sp)
210833c4:	dfc00215 	stw	ra,8(sp)
    bool bSuccess = TRUE;

    if (nSecter != pVol->Secter_Index){
        if (!pVol->ReadBlock512(pVol->DiskHandle, nSecter, pVol->Secter_Data)){
210833c8:	81809204 	addi	r6,r16,584
210833cc:	2823883a 	mov	r17,r5
210833d0:	103ee83a 	callr	r2
210833d4:	10000726 	beq	r2,zero,210833f4 <fatReadSecter+0x50>
            pVol->Secter_Index = -1;
            bSuccess = FALSE;
        }else{
            pVol->Secter_Index = nSecter;
210833d8:	84411215 	stw	r17,1096(r16)
    return bSuccess;
}
//=================================================================================
//// add in v2.0
bool fatReadSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;
210833dc:	00800044 	movi	r2,1
            pVol->Secter_Index = nSecter;
        }
    }

    return bSuccess;          
}     
210833e0:	dfc00217 	ldw	ra,8(sp)
210833e4:	dc400117 	ldw	r17,4(sp)
210833e8:	dc000017 	ldw	r16,0(sp)
210833ec:	dec00304 	addi	sp,sp,12
210833f0:	f800283a 	ret
bool fatReadSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;

    if (nSecter != pVol->Secter_Index){
        if (!pVol->ReadBlock512(pVol->DiskHandle, nSecter, pVol->Secter_Data)){
            pVol->Secter_Index = -1;
210833f4:	00bfffc4 	movi	r2,-1
210833f8:	80811215 	stw	r2,1096(r16)
            bSuccess = FALSE;
210833fc:	0005883a 	mov	r2,zero
21083400:	003ff706 	br	210833e0 <__flash_rwdata_start+0xfffe1198>
    return bSuccess;
}
//=================================================================================
//// add in v2.0
bool fatReadSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;
21083404:	00800044 	movi	r2,1
21083408:	f800283a 	ret

2108340c <fatReadMultiSecter>:
//=================================================================================
//// [ADDED]
bool fatReadMultiSecter(VOLUME_INFO *pVol, alt_u32 nSecter, alt_u32 n, char* buf){
    bool bSuccess = TRUE;

	if (!pVol->ReadBlocks(pVol->DiskHandle, nSecter, n, buf)){
2108340c:	20800317 	ldw	r2,12(r4)
21083410:	21000017 	ldw	r4,0(r4)

    return bSuccess;          
}     
//=================================================================================
//// [ADDED]
bool fatReadMultiSecter(VOLUME_INFO *pVol, alt_u32 nSecter, alt_u32 n, char* buf){
21083414:	deffff04 	addi	sp,sp,-4
21083418:	dfc00015 	stw	ra,0(sp)
    bool bSuccess = TRUE;

	if (!pVol->ReadBlocks(pVol->DiskHandle, nSecter, n, buf)){
2108341c:	103ee83a 	callr	r2
		bSuccess = FALSE;
	}
    return bSuccess;
}
21083420:	1004c03a 	cmpne	r2,r2,zero
21083424:	dfc00017 	ldw	ra,0(sp)
21083428:	dec00104 	addi	sp,sp,4
2108342c:	f800283a 	ret

21083430 <fatFindDirectory>:
//=================================================================================
//// add in v2.0
FAT_DIRECTORY* fatFindDirectory(VOLUME_INFO *pVol, alt_u32 nDirectoryIndex){
21083430:	defffc04 	addi	sp,sp,-16
    FAT_DIRECTORY *pDir=NULL;
    alt_u32 nSecterOffset, nSecter, nByteOffset;
             
    nSecterOffset = (sizeof(FAT_DIRECTORY)*nDirectoryIndex)/pVol->BPB_BytsPerSec;
21083434:	20800717 	ldw	r2,28(r4)
	}
    return bSuccess;
}
//=================================================================================
//// add in v2.0
FAT_DIRECTORY* fatFindDirectory(VOLUME_INFO *pVol, alt_u32 nDirectoryIndex){
21083438:	dc000015 	stw	r16,0(sp)
    FAT_DIRECTORY *pDir=NULL;
    alt_u32 nSecterOffset, nSecter, nByteOffset;
             
    nSecterOffset = (sizeof(FAT_DIRECTORY)*nDirectoryIndex)/pVol->BPB_BytsPerSec;
2108343c:	2820917a 	slli	r16,r5,5
	}
    return bSuccess;
}
//=================================================================================
//// add in v2.0
FAT_DIRECTORY* fatFindDirectory(VOLUME_INFO *pVol, alt_u32 nDirectoryIndex){
21083440:	dc800215 	stw	r18,8(sp)
    FAT_DIRECTORY *pDir=NULL;
    alt_u32 nSecterOffset, nSecter, nByteOffset;
             
    nSecterOffset = (sizeof(FAT_DIRECTORY)*nDirectoryIndex)/pVol->BPB_BytsPerSec;
    nSecter = pVol->RootDirectoryEntrySecter + nSecterOffset;
21083444:	24800f17 	ldw	r18,60(r4)
	}
    return bSuccess;
}
//=================================================================================
//// add in v2.0
FAT_DIRECTORY* fatFindDirectory(VOLUME_INFO *pVol, alt_u32 nDirectoryIndex){
21083448:	dc400115 	stw	r17,4(sp)
2108344c:	2023883a 	mov	r17,r4
//=================================================================================
//// add in v2.0
bool fatReadSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;

    if (nSecter != pVol->Secter_Index){
21083450:	21011217 	ldw	r4,1096(r4)
//// add in v2.0
FAT_DIRECTORY* fatFindDirectory(VOLUME_INFO *pVol, alt_u32 nDirectoryIndex){
    FAT_DIRECTORY *pDir=NULL;
    alt_u32 nSecterOffset, nSecter, nByteOffset;
             
    nSecterOffset = (sizeof(FAT_DIRECTORY)*nDirectoryIndex)/pVol->BPB_BytsPerSec;
21083454:	8087203a 	divu	r3,r16,r2
	}
    return bSuccess;
}
//=================================================================================
//// add in v2.0
FAT_DIRECTORY* fatFindDirectory(VOLUME_INFO *pVol, alt_u32 nDirectoryIndex){
21083458:	dfc00315 	stw	ra,12(sp)
    FAT_DIRECTORY *pDir=NULL;
    alt_u32 nSecterOffset, nSecter, nByteOffset;
             
    nSecterOffset = (sizeof(FAT_DIRECTORY)*nDirectoryIndex)/pVol->BPB_BytsPerSec;
    nSecter = pVol->RootDirectoryEntrySecter + nSecterOffset;
2108345c:	1ca5883a 	add	r18,r3,r18
//=================================================================================
//// add in v2.0
bool fatReadSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;

    if (nSecter != pVol->Secter_Index){
21083460:	91000926 	beq	r18,r4,21083488 <fatFindDirectory+0x58>
        if (!pVol->ReadBlock512(pVol->DiskHandle, nSecter, pVol->Secter_Data)){
21083464:	88800117 	ldw	r2,4(r17)
21083468:	89000017 	ldw	r4,0(r17)
2108346c:	900b883a 	mov	r5,r18
21083470:	89809204 	addi	r6,r17,584
21083474:	103ee83a 	callr	r2
21083478:	10000d26 	beq	r2,zero,210834b0 <fatFindDirectory+0x80>
2108347c:	88800717 	ldw	r2,28(r17)
            pVol->Secter_Index = -1;
            bSuccess = FALSE;
        }else{
            pVol->Secter_Index = nSecter;
21083480:	8c811215 	stw	r18,1096(r17)
21083484:	8087203a 	divu	r3,r16,r2
             
    nSecterOffset = (sizeof(FAT_DIRECTORY)*nDirectoryIndex)/pVol->BPB_BytsPerSec;
    nSecter = pVol->RootDirectoryEntrySecter + nSecterOffset;
        // read sector
    if (fatReadSecter(pVol, nSecter)){
        nByteOffset = (sizeof(FAT_DIRECTORY)*nDirectoryIndex)%pVol->BPB_BytsPerSec; 
21083488:	1885383a 	mul	r2,r3,r2
2108348c:	80a1c83a 	sub	r16,r16,r2
        pDir = (FAT_DIRECTORY *)(pVol->Secter_Data + nByteOffset);
21083490:	84009204 	addi	r16,r16,584
21083494:	8c05883a 	add	r2,r17,r16
    }        
        
    return pDir;        
}
21083498:	dfc00317 	ldw	ra,12(sp)
2108349c:	dc800217 	ldw	r18,8(sp)
210834a0:	dc400117 	ldw	r17,4(sp)
210834a4:	dc000017 	ldw	r16,0(sp)
210834a8:	dec00404 	addi	sp,sp,16
210834ac:	f800283a 	ret
bool fatReadSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;

    if (nSecter != pVol->Secter_Index){
        if (!pVol->ReadBlock512(pVol->DiskHandle, nSecter, pVol->Secter_Data)){
            pVol->Secter_Index = -1;
210834b0:	00bfffc4 	movi	r2,-1
210834b4:	88811215 	stw	r2,1096(r17)
    return bSuccess;
}
//=================================================================================
//// add in v2.0
FAT_DIRECTORY* fatFindDirectory(VOLUME_INFO *pVol, alt_u32 nDirectoryIndex){
    FAT_DIRECTORY *pDir=NULL;
210834b8:	0005883a 	mov	r2,zero
210834bc:	003ff606 	br	21083498 <__flash_rwdata_start+0xfffe1250>

210834c0 <fatFindUnusedDirectory>:
    return pDir;        
}

//=================================================================================
//// add in v2.0
alt_u32 fatFindUnusedDirectory(VOLUME_INFO *pVol){
210834c0:	defff804 	addi	sp,sp,-32
210834c4:	dd000415 	stw	r20,16(sp)
210834c8:	2029883a 	mov	r20,r4
210834cc:	a1c11217 	ldw	r7,1096(r20)
210834d0:	21000717 	ldw	r4,28(r4)
210834d4:	dd800615 	stw	r22,24(sp)
210834d8:	dd400515 	stw	r21,20(sp)
210834dc:	dcc00315 	stw	r19,12(sp)
210834e0:	dc800215 	stw	r18,8(sp)
210834e4:	dc400115 	stw	r17,4(sp)
210834e8:	dfc00715 	stw	ra,28(sp)
210834ec:	dc000015 	stw	r16,0(sp)
    alt_u32 Dir = -1;
    FAT_DIRECTORY *pDir=NULL;
    alt_u32 nSecterOffset, nSecter, nByteOffset;
    alt_u32 nDirectoryIndex = 2; //??? start from ?
210834f0:	05400084 	movi	r21,2
210834f4:	04401004 	movi	r17,64
    return TRUE;
    
}

bool fatIsUnusedDir(FAT_DIRECTORY *pDir){
    if (pDir->Name[0] == (alt_8)UNUSED_DIR_ENTRY)
210834f8:	04bff944 	movi	r18,-27
//// add in v2.0
bool fatReadSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;

    if (nSecter != pVol->Secter_Index){
        if (!pVol->ReadBlock512(pVol->DiskHandle, nSecter, pVol->Secter_Data)){
210834fc:	a5809204 	addi	r22,r20,584
            pVol->Secter_Index = -1;
21083500:	04ffffc4 	movi	r19,-1
    alt_u32 nDirectoryIndex = 2; //??? start from ?
    bool bDone = FALSE;
             
    while(!bDone){             
        nSecterOffset = (sizeof(FAT_DIRECTORY)*nDirectoryIndex)/pVol->BPB_BytsPerSec;
        nSecter = pVol->RootDirectoryEntrySecter + nSecterOffset;
21083504:	a4000f17 	ldw	r16,60(r20)
    alt_u32 nSecterOffset, nSecter, nByteOffset;
    alt_u32 nDirectoryIndex = 2; //??? start from ?
    bool bDone = FALSE;
             
    while(!bDone){             
        nSecterOffset = (sizeof(FAT_DIRECTORY)*nDirectoryIndex)/pVol->BPB_BytsPerSec;
21083508:	8907203a 	divu	r3,r17,r4
//// add in v2.0
bool fatReadSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;

    if (nSecter != pVol->Secter_Index){
        if (!pVol->ReadBlock512(pVol->DiskHandle, nSecter, pVol->Secter_Data)){
2108350c:	b00d883a 	mov	r6,r22
    alt_u32 nDirectoryIndex = 2; //??? start from ?
    bool bDone = FALSE;
             
    while(!bDone){             
        nSecterOffset = (sizeof(FAT_DIRECTORY)*nDirectoryIndex)/pVol->BPB_BytsPerSec;
        nSecter = pVol->RootDirectoryEntrySecter + nSecterOffset;
21083510:	1c21883a 	add	r16,r3,r16
//// add in v2.0
bool fatReadSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;

    if (nSecter != pVol->Secter_Index){
        if (!pVol->ReadBlock512(pVol->DiskHandle, nSecter, pVol->Secter_Data)){
21083514:	800b883a 	mov	r5,r16
//=================================================================================
//// add in v2.0
bool fatReadSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;

    if (nSecter != pVol->Secter_Index){
21083518:	81c00826 	beq	r16,r7,2108353c <fatFindUnusedDirectory+0x7c>
        if (!pVol->ReadBlock512(pVol->DiskHandle, nSecter, pVol->Secter_Data)){
2108351c:	a0800117 	ldw	r2,4(r20)
21083520:	a1000017 	ldw	r4,0(r20)
21083524:	103ee83a 	callr	r2
21083528:	10001926 	beq	r2,zero,21083590 <fatFindUnusedDirectory+0xd0>
2108352c:	a1000717 	ldw	r4,28(r20)
            pVol->Secter_Index = -1;
            bSuccess = FALSE;
        }else{
            pVol->Secter_Index = nSecter;
21083530:	a4011215 	stw	r16,1096(r20)
21083534:	800f883a 	mov	r7,r16
21083538:	8907203a 	divu	r3,r17,r4
    while(!bDone){             
        nSecterOffset = (sizeof(FAT_DIRECTORY)*nDirectoryIndex)/pVol->BPB_BytsPerSec;
        nSecter = pVol->RootDirectoryEntrySecter + nSecterOffset;
            // read sector
        if (fatReadSecter(pVol, nSecter)){
            nByteOffset = (sizeof(FAT_DIRECTORY)*nDirectoryIndex)%pVol->BPB_BytsPerSec; 
2108353c:	1907383a 	mul	r3,r3,r4
21083540:	88e3c83a 	sub	r17,r17,r3
    S = ((Date >> 0) & 0x1F)*2;
    FAT_DEBUG(("%d:%d:%d", H, M, S));     
}

bool fatIsLastDir(FAT_DIRECTORY *pDir){
    if (pDir->Name[0] == REMAINED_UNUSED_DIR_ENTRY)  // 0x00
21083544:	a463883a 	add	r17,r20,r17
21083548:	88c09207 	ldb	r3,584(r17)
2108354c:	18000426 	beq	r3,zero,21083560 <fatFindUnusedDirectory+0xa0>
    return TRUE;
    
}

bool fatIsUnusedDir(FAT_DIRECTORY *pDir){
    if (pDir->Name[0] == (alt_8)UNUSED_DIR_ENTRY)
21083550:	1c800426 	beq	r3,r18,21083564 <fatFindUnusedDirectory+0xa4>
            if (fatIsLastDir(pDir) || fatIsUnusedDir(pDir)){
                bDone = TRUE;
                if (fatIsUnusedDir(pDir))
                    Dir = nDirectoryIndex;
            }
            nDirectoryIndex++;        
21083554:	ad400044 	addi	r21,r21,1
21083558:	a822917a 	slli	r17,r21,5
2108355c:	003fe906 	br	21083504 <__flash_rwdata_start+0xfffe12bc>
    S = ((Date >> 0) & 0x1F)*2;
    FAT_DEBUG(("%d:%d:%d", H, M, S));     
}

bool fatIsLastDir(FAT_DIRECTORY *pDir){
    if (pDir->Name[0] == REMAINED_UNUSED_DIR_ENTRY)  // 0x00
21083560:	057fffc4 	movi	r21,-1
                bDone = FALSE;
        }
    }             
    
    return Dir;      
}
21083564:	a805883a 	mov	r2,r21
21083568:	dfc00717 	ldw	ra,28(sp)
2108356c:	dd800617 	ldw	r22,24(sp)
21083570:	dd400517 	ldw	r21,20(sp)
21083574:	dd000417 	ldw	r20,16(sp)
21083578:	dcc00317 	ldw	r19,12(sp)
2108357c:	dc800217 	ldw	r18,8(sp)
21083580:	dc400117 	ldw	r17,4(sp)
21083584:	dc000017 	ldw	r16,0(sp)
21083588:	dec00804 	addi	sp,sp,32
2108358c:	f800283a 	ret
bool fatReadSecter(VOLUME_INFO *pVol, alt_u32 nSecter){
    bool bSuccess = TRUE;

    if (nSecter != pVol->Secter_Index){
        if (!pVol->ReadBlock512(pVol->DiskHandle, nSecter, pVol->Secter_Data)){
            pVol->Secter_Index = -1;
21083590:	a4c11215 	stw	r19,1096(r20)
21083594:	a1000717 	ldw	r4,28(r20)
21083598:	01ffffc4 	movi	r7,-1
2108359c:	003fd906 	br	21083504 <__flash_rwdata_start+0xfffe12bc>

210835a0 <fatMount>:
    
    return Dir;      
}

//=================================================================================
bool fatMount(VOLUME_INFO *pVol){
210835a0:	defff604 	addi	sp,sp,-40
210835a4:	dc400115 	stw	r17,4(sp)
210835a8:	dc000015 	stw	r16,0(sp)
    // 1DEh( 16 bytes): 3nd Partition Entry
    // 1EEh( 16 bytes): 4nd Partition Entry
    // 1FEh(  2 bytes): Executable Maker (55h AAh)
    
    // read first block (secotor 0), BPB(BIOS Parameter Block) or called as boot sector or reserved sector
    if (!pVol->ReadBlock512(pVol->DiskHandle, 0, szBlock)){
210835ac:	04400034 	movhi	r17,0
    
    return Dir;      
}

//=================================================================================
bool fatMount(VOLUME_INFO *pVol){
210835b0:	2021883a 	mov	r16,r4
    // 1DEh( 16 bytes): 3nd Partition Entry
    // 1EEh( 16 bytes): 4nd Partition Entry
    // 1FEh(  2 bytes): Executable Maker (55h AAh)
    
    // read first block (secotor 0), BPB(BIOS Parameter Block) or called as boot sector or reserved sector
    if (!pVol->ReadBlock512(pVol->DiskHandle, 0, szBlock)){
210835b4:	20800117 	ldw	r2,4(r4)
210835b8:	21000017 	ldw	r4,0(r4)
210835bc:	8c57e204 	addi	r17,r17,24456
    
    return Dir;      
}

//=================================================================================
bool fatMount(VOLUME_INFO *pVol){
210835c0:	dfc00915 	stw	ra,36(sp)
210835c4:	df000815 	stw	fp,32(sp)
210835c8:	ddc00715 	stw	r23,28(sp)
210835cc:	dd800615 	stw	r22,24(sp)
210835d0:	dd400515 	stw	r21,20(sp)
210835d4:	dd000415 	stw	r20,16(sp)
210835d8:	dcc00315 	stw	r19,12(sp)
210835dc:	dc800215 	stw	r18,8(sp)
    // 1DEh( 16 bytes): 3nd Partition Entry
    // 1EEh( 16 bytes): 4nd Partition Entry
    // 1FEh(  2 bytes): Executable Maker (55h AAh)
    
    // read first block (secotor 0), BPB(BIOS Parameter Block) or called as boot sector or reserved sector
    if (!pVol->ReadBlock512(pVol->DiskHandle, 0, szBlock)){
210835e0:	000b883a 	mov	r5,zero
210835e4:	880d883a 	mov	r6,r17
210835e8:	103ee83a 	callr	r2
210835ec:	10000526 	beq	r2,zero,21083604 <fatMount+0x64>
    */
        
    // check file system 
    FirstPartitionEntry = 0x1BE;
    //PartitionType = szBlock[FirstPartitionEntry + 4];
    PartitionType = szBlock[0x01C2];
210835f0:	88807083 	ldbu	r2,450(r17)
    if (PartitionType == PARTITION_FAT16){
210835f4:	00c00184 	movi	r3,6
210835f8:	10c00f26 	beq	r2,r3,21083638 <fatMount+0x98>
        FAT_DEBUG(("FAT16\n"));
    }else if (PartitionType == PARTITION_FAT32){
210835fc:	00c002c4 	movi	r3,11
21083600:	10c00d26 	beq	r2,r3,21083638 <fatMount+0x98>
    // 1FEh(  2 bytes): Executable Maker (55h AAh)
    
    // read first block (secotor 0), BPB(BIOS Parameter Block) or called as boot sector or reserved sector
    if (!pVol->ReadBlock512(pVol->DiskHandle, 0, szBlock)){
        FAT_DEBUG(("Read section 0 error.\n"));
        return FALSE;
21083604:	0005883a 	mov	r2,zero
    }        
    pVol->bMount = bSuccess;
    return bSuccess;   
    

}
21083608:	dfc00917 	ldw	ra,36(sp)
2108360c:	df000817 	ldw	fp,32(sp)
21083610:	ddc00717 	ldw	r23,28(sp)
21083614:	dd800617 	ldw	r22,24(sp)
21083618:	dd400517 	ldw	r21,20(sp)
2108361c:	dd000417 	ldw	r20,16(sp)
21083620:	dcc00317 	ldw	r19,12(sp)
21083624:	dc800217 	ldw	r18,8(sp)
21083628:	dc400117 	ldw	r17,4(sp)
2108362c:	dc000017 	ldw	r16,0(sp)
21083630:	dec00a04 	addi	sp,sp,40
21083634:	f800283a 	ret
        FAT_DEBUG(("FAT32\n"));
    }else{        
        FAT_DEBUG(("the partition type(%d) is not supported.\n", PartitionType));
        return FALSE; // only support FAT16 in this example
    }       
    pVol->Partition_Type = PartitionType; 
21083638:	80800415 	stw	r2,16(r16)
    alt_u8 *pMSB = (pValue + nNum - 1);
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
        nValue <<= 8;
        nValue |= *pMSB--;
2108363c:	88807243 	ldbu	r2,457(r17)
21083640:	89007203 	ldbu	r4,456(r17)
21083644:	88c071c3 	ldbu	r3,455(r17)
unsigned int fatArray2Value(unsigned char *pValue, unsigned int nNum){
    alt_u8 *pMSB = (pValue + nNum - 1);
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
        nValue <<= 8;
21083648:	1004923a 	slli	r2,r2,8
        nValue |= *pMSB--;
2108364c:	8c807183 	ldbu	r18,454(r17)
                            //szBlock[FirstPartitionEntry + 8 + 1]*256 + 
                            //szBlock[FirstPartitionEntry + 8];        
    
    //3 Parsing the Volume Boot Record(BR)
    //3.1  Read the Volume Boot Record(BR)
    if (!pVol->ReadBlock512(pVol->DiskHandle, FirstSectionInVolume1, szBlock)){
21083650:	81c00117 	ldw	r7,4(r16)
    alt_u8 *pMSB = (pValue + nNum - 1);
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
        nValue <<= 8;
        nValue |= *pMSB--;
21083654:	1104b03a 	or	r2,r2,r4
unsigned int fatArray2Value(unsigned char *pValue, unsigned int nNum){
    alt_u8 *pMSB = (pValue + nNum - 1);
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
        nValue <<= 8;
21083658:	1004923a 	slli	r2,r2,8
        nValue |= *pMSB--;
2108365c:	04400034 	movhi	r17,0
                            //szBlock[FirstPartitionEntry + 8 + 1]*256 + 
                            //szBlock[FirstPartitionEntry + 8];        
    
    //3 Parsing the Volume Boot Record(BR)
    //3.1  Read the Volume Boot Record(BR)
    if (!pVol->ReadBlock512(pVol->DiskHandle, FirstSectionInVolume1, szBlock)){
21083660:	81000017 	ldw	r4,0(r16)
    alt_u8 *pMSB = (pValue + nNum - 1);
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
        nValue <<= 8;
        nValue |= *pMSB--;
21083664:	10c4b03a 	or	r2,r2,r3
unsigned int fatArray2Value(unsigned char *pValue, unsigned int nNum){
    alt_u8 *pMSB = (pValue + nNum - 1);
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
        nValue <<= 8;
21083668:	1004923a 	slli	r2,r2,8
        nValue |= *pMSB--;
2108366c:	8c57e204 	addi	r17,r17,24456
                            //szBlock[FirstPartitionEntry + 8 + 1]*256 + 
                            //szBlock[FirstPartitionEntry + 8];        
    
    //3 Parsing the Volume Boot Record(BR)
    //3.1  Read the Volume Boot Record(BR)
    if (!pVol->ReadBlock512(pVol->DiskHandle, FirstSectionInVolume1, szBlock)){
21083670:	880d883a 	mov	r6,r17
    alt_u8 *pMSB = (pValue + nNum - 1);
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
        nValue <<= 8;
        nValue |= *pMSB--;
21083674:	14a4b03a 	or	r18,r2,r18
                            //szBlock[FirstPartitionEntry + 8 + 1]*256 + 
                            //szBlock[FirstPartitionEntry + 8];        
    
    //3 Parsing the Volume Boot Record(BR)
    //3.1  Read the Volume Boot Record(BR)
    if (!pVol->ReadBlock512(pVol->DiskHandle, FirstSectionInVolume1, szBlock)){
21083678:	900b883a 	mov	r5,r18
2108367c:	383ee83a 	callr	r7
21083680:	103fe026 	beq	r2,zero,21083604 <__flash_rwdata_start+0xfffe13bc>
        FAT_DEBUG(("Read first sector in volume one fail.\n"));
        return FALSE;
    }        
    pVol->PartitionStartSecter = FirstSectionInVolume1;     
21083684:	84800615 	stw	r18,24(r16)
    pVol->BPB_BytsPerSec = szBlock[0x0B+1]*256 + szBlock[0x0B];
21083688:	88800303 	ldbu	r2,12(r17)
2108368c:	8f0002c3 	ldbu	fp,11(r17)
    pVol->BPB_NumFATs = szBlock[0x10];
    pVol->BPB_RootEntCnt = szBlock[0x11+1]*256 + szBlock[0x11]; 
    pVol->BPB_FATSz = szBlock[0x16+1]*256 + szBlock[0x16];
    
    // add for v2.0
    pVol->Secter_Index = -1;
21083690:	00ffffc4 	movi	r3,-1
    if (!pVol->ReadBlock512(pVol->DiskHandle, FirstSectionInVolume1, szBlock)){
        FAT_DEBUG(("Read first sector in volume one fail.\n"));
        return FALSE;
    }        
    pVol->PartitionStartSecter = FirstSectionInVolume1;     
    pVol->BPB_BytsPerSec = szBlock[0x0B+1]*256 + szBlock[0x0B];
21083694:	1004923a 	slli	r2,r2,8
    pVol->BPB_NumFATs = szBlock[0x10];
    pVol->BPB_RootEntCnt = szBlock[0x11+1]*256 + szBlock[0x11]; 
    pVol->BPB_FATSz = szBlock[0x16+1]*256 + szBlock[0x16];
    
    // add for v2.0
    pVol->Secter_Index = -1;
21083698:	80c11215 	stw	r3,1096(r16)
    memset(pVol->Secter_Data, 0, MY_SECTER_SIZE); // 512 bytes
2108369c:	81009204 	addi	r4,r16,584
    if (!pVol->ReadBlock512(pVol->DiskHandle, FirstSectionInVolume1, szBlock)){
        FAT_DEBUG(("Read first sector in volume one fail.\n"));
        return FALSE;
    }        
    pVol->PartitionStartSecter = FirstSectionInVolume1;     
    pVol->BPB_BytsPerSec = szBlock[0x0B+1]*256 + szBlock[0x0B];
210836a0:	1739883a 	add	fp,r2,fp
210836a4:	87000715 	stw	fp,28(r16)
    pVol->BPB_SecPerCluster = szBlock[0x0D];
210836a8:	8dc00343 	ldbu	r23,13(r17)
    pVol->BPB_RootEntCnt = szBlock[0x11+1]*256 + szBlock[0x11]; 
    pVol->BPB_FATSz = szBlock[0x16+1]*256 + szBlock[0x16];
    
    // add for v2.0
    pVol->Secter_Index = -1;
    memset(pVol->Secter_Data, 0, MY_SECTER_SIZE); // 512 bytes
210836ac:	000b883a 	mov	r5,zero
210836b0:	01808004 	movi	r6,512
        FAT_DEBUG(("Read first sector in volume one fail.\n"));
        return FALSE;
    }        
    pVol->PartitionStartSecter = FirstSectionInVolume1;     
    pVol->BPB_BytsPerSec = szBlock[0x0B+1]*256 + szBlock[0x0B];
    pVol->BPB_SecPerCluster = szBlock[0x0D];
210836b4:	85c00815 	stw	r23,32(r16)
    pVol->BPB_RsvdSecCnt = szBlock[0x0E + 1]*256 + szBlock[0x0E]; 
210836b8:	888003c3 	ldbu	r2,15(r17)
210836bc:	8d400383 	ldbu	r21,14(r17)
210836c0:	1004923a 	slli	r2,r2,8
210836c4:	156b883a 	add	r21,r2,r21
210836c8:	85400915 	stw	r21,36(r16)
    pVol->BPB_NumFATs = szBlock[0x10];
210836cc:	8d800403 	ldbu	r22,16(r17)
210836d0:	85800a15 	stw	r22,40(r16)
    pVol->BPB_RootEntCnt = szBlock[0x11+1]*256 + szBlock[0x11]; 
210836d4:	88800483 	ldbu	r2,18(r17)
210836d8:	8cc00443 	ldbu	r19,17(r17)
210836dc:	1004923a 	slli	r2,r2,8
210836e0:	14e7883a 	add	r19,r2,r19
210836e4:	84c00b15 	stw	r19,44(r16)
    pVol->BPB_FATSz = szBlock[0x16+1]*256 + szBlock[0x16];
210836e8:	8d0005c3 	ldbu	r20,23(r17)
210836ec:	88c00583 	ldbu	r3,22(r17)
210836f0:	a028923a 	slli	r20,r20,8
210836f4:	a0e9883a 	add	r20,r20,r3
210836f8:	85000c15 	stw	r20,48(r16)
    
    // add for v2.0
    pVol->Secter_Index = -1;
    memset(pVol->Secter_Data, 0, MY_SECTER_SIZE); // 512 bytes
210836fc:	108e26c0 	call	2108e26c <memset>
    
    if (pVol->Partition_Type == PARTITION_FAT32){
21083700:	80c00417 	ldw	r3,16(r16)
21083704:	008002c4 	movi	r2,11
21083708:	18801126 	beq	r3,r2,21083750 <fatMount+0x1b0>
        pVol->BPB_FATSz = fatArray2Value(&szBlock[0x24], 4);  // BPB_FATSz32
        //pVol->BPB_RootEntCnt = fatArray2Value(&szBlock[0x2C], 4);  // BPB_RootClus            
    }
    
    if (pVol->BPB_BytsPerSec != MY_SECTER_SIZE){
2108370c:	00808004 	movi	r2,512
21083710:	e0bfbc1e 	bne	fp,r2,21083604 <__flash_rwdata_start+0xfffe13bc>
    FAT_DEBUG(("Sectors Per FAT: %04Xh(%d)\n", pVol->BPB_FATSz, pVol->BPB_FATSz));
#endif    
    //
    pVol->FatEntrySecter = pVol->PartitionStartSecter + pVol->BPB_RsvdSecCnt;
    pVol->RootDirectoryEntrySecter = pVol->FatEntrySecter + pVol->BPB_NumFATs * pVol->BPB_FATSz;
    pVol->DataEntrySecter = pVol->RootDirectoryEntrySecter + ((pVol->BPB_RootEntCnt*32)+(pVol->BPB_BytsPerSec-1))/pVol->BPB_BytsPerSec;
21083714:	9806917a 	slli	r3,r19,5
    FAT_DEBUG(("Maximum Root Directory Entries: %04Xh(%d)\n", pVol->BPB_RootEntCnt, pVol->BPB_RootEntCnt));
    FAT_DEBUG(("Sectors Per FAT: %04Xh(%d)\n", pVol->BPB_FATSz, pVol->BPB_FATSz));
#endif    
    //
    pVol->FatEntrySecter = pVol->PartitionStartSecter + pVol->BPB_RsvdSecCnt;
    pVol->RootDirectoryEntrySecter = pVol->FatEntrySecter + pVol->BPB_NumFATs * pVol->BPB_FATSz;
21083718:	a5a9383a 	mul	r20,r20,r22
    FAT_DEBUG(("Number of Copies of FAT: %02Xh(%d)\n", pVol->BPB_NumFATs, pVol->BPB_NumFATs));
    FAT_DEBUG(("Maximum Root Directory Entries: %04Xh(%d)\n", pVol->BPB_RootEntCnt, pVol->BPB_RootEntCnt));
    FAT_DEBUG(("Sectors Per FAT: %04Xh(%d)\n", pVol->BPB_FATSz, pVol->BPB_FATSz));
#endif    
    //
    pVol->FatEntrySecter = pVol->PartitionStartSecter + pVol->BPB_RsvdSecCnt;
2108371c:	9565883a 	add	r18,r18,r21
    pVol->RootDirectoryEntrySecter = pVol->FatEntrySecter + pVol->BPB_NumFATs * pVol->BPB_FATSz;
    pVol->DataEntrySecter = pVol->RootDirectoryEntrySecter + ((pVol->BPB_RootEntCnt*32)+(pVol->BPB_BytsPerSec-1))/pVol->BPB_BytsPerSec;
21083720:	18c07fc4 	addi	r3,r3,511
21083724:	1806d27a 	srli	r3,r3,9
    
    // read FAT table into memory
    pVol->nBytesPerCluster = pVol->BPB_BytsPerSec * pVol->BPB_SecPerCluster;
21083728:	b82e927a 	slli	r23,r23,9
    FAT_DEBUG(("Maximum Root Directory Entries: %04Xh(%d)\n", pVol->BPB_RootEntCnt, pVol->BPB_RootEntCnt));
    FAT_DEBUG(("Sectors Per FAT: %04Xh(%d)\n", pVol->BPB_FATSz, pVol->BPB_FATSz));
#endif    
    //
    pVol->FatEntrySecter = pVol->PartitionStartSecter + pVol->BPB_RsvdSecCnt;
    pVol->RootDirectoryEntrySecter = pVol->FatEntrySecter + pVol->BPB_NumFATs * pVol->BPB_FATSz;
2108372c:	a4a9883a 	add	r20,r20,r18
    if (bSuccess){
        FAT_DEBUG(("Fat_Mount success\n"));
    }else{        
        FAT_DEBUG(("Fat_Mount fail\n"));
    }        
    pVol->bMount = bSuccess;
21083730:	00800044 	movi	r2,1
    FAT_DEBUG(("Sectors Per FAT: %04Xh(%d)\n", pVol->BPB_FATSz, pVol->BPB_FATSz));
#endif    
    //
    pVol->FatEntrySecter = pVol->PartitionStartSecter + pVol->BPB_RsvdSecCnt;
    pVol->RootDirectoryEntrySecter = pVol->FatEntrySecter + pVol->BPB_NumFATs * pVol->BPB_FATSz;
    pVol->DataEntrySecter = pVol->RootDirectoryEntrySecter + ((pVol->BPB_RootEntCnt*32)+(pVol->BPB_BytsPerSec-1))/pVol->BPB_BytsPerSec;
21083734:	a0c7883a 	add	r3,r20,r3
    FAT_DEBUG(("Number of Copies of FAT: %02Xh(%d)\n", pVol->BPB_NumFATs, pVol->BPB_NumFATs));
    FAT_DEBUG(("Maximum Root Directory Entries: %04Xh(%d)\n", pVol->BPB_RootEntCnt, pVol->BPB_RootEntCnt));
    FAT_DEBUG(("Sectors Per FAT: %04Xh(%d)\n", pVol->BPB_FATSz, pVol->BPB_FATSz));
#endif    
    //
    pVol->FatEntrySecter = pVol->PartitionStartSecter + pVol->BPB_RsvdSecCnt;
21083738:	84800e15 	stw	r18,56(r16)
    pVol->RootDirectoryEntrySecter = pVol->FatEntrySecter + pVol->BPB_NumFATs * pVol->BPB_FATSz;
2108373c:	85000f15 	stw	r20,60(r16)
    pVol->DataEntrySecter = pVol->RootDirectoryEntrySecter + ((pVol->BPB_RootEntCnt*32)+(pVol->BPB_BytsPerSec-1))/pVol->BPB_BytsPerSec;
21083740:	80c01015 	stw	r3,64(r16)
    
    // read FAT table into memory
    pVol->nBytesPerCluster = pVol->BPB_BytsPerSec * pVol->BPB_SecPerCluster;
21083744:	85c00d15 	stw	r23,52(r16)
    if (bSuccess){
        FAT_DEBUG(("Fat_Mount success\n"));
    }else{        
        FAT_DEBUG(("Fat_Mount fail\n"));
    }        
    pVol->bMount = bSuccess;
21083748:	80800515 	stw	r2,20(r16)
    return bSuccess;   
2108374c:	003fae06 	br	21083608 <__flash_rwdata_start+0xfffe13c0>
    alt_u8 *pMSB = (pValue + nNum - 1);
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
        nValue <<= 8;
        nValue |= *pMSB--;
21083750:	8d0009c3 	ldbu	r20,39(r17)
21083754:	89000983 	ldbu	r4,38(r17)
21083758:	88800943 	ldbu	r2,37(r17)
unsigned int fatArray2Value(unsigned char *pValue, unsigned int nNum){
    alt_u8 *pMSB = (pValue + nNum - 1);
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
        nValue <<= 8;
2108375c:	a028923a 	slli	r20,r20,8
        nValue |= *pMSB--;
21083760:	88c00903 	ldbu	r3,36(r17)
21083764:	a128b03a 	or	r20,r20,r4
unsigned int fatArray2Value(unsigned char *pValue, unsigned int nNum){
    alt_u8 *pMSB = (pValue + nNum - 1);
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
        nValue <<= 8;
21083768:	a028923a 	slli	r20,r20,8
        nValue |= *pMSB--;
2108376c:	a0a8b03a 	or	r20,r20,r2
unsigned int fatArray2Value(unsigned char *pValue, unsigned int nNum){
    alt_u8 *pMSB = (pValue + nNum - 1);
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
        nValue <<= 8;
21083770:	a028923a 	slli	r20,r20,8
        nValue |= *pMSB--;
21083774:	a0e8b03a 	or	r20,r20,r3
    // add for v2.0
    pVol->Secter_Index = -1;
    memset(pVol->Secter_Data, 0, MY_SECTER_SIZE); // 512 bytes
    
    if (pVol->Partition_Type == PARTITION_FAT32){
        pVol->BPB_FATSz = fatArray2Value(&szBlock[0x24], 4);  // BPB_FATSz32
21083778:	85000c15 	stw	r20,48(r16)
2108377c:	003fe306 	br	2108370c <__flash_rwdata_start+0xfffe14c4>

21083780 <fatMountSdcard>:

bool SD_ReadBlocks(DISK_HANDLE DiskHandle, alt_u32 PysicalSelector, alt_u32 n, alt_u8* szBuf){
    return SDLIB_ReadBlocks(PysicalSelector, n, szBuf);
}

FAT_HANDLE fatMountSdcard(void){
21083780:	defff504 	addi	sp,sp,-44
21083784:	dc000115 	stw	r16,4(sp)
21083788:	dfc00a15 	stw	ra,40(sp)
2108378c:	df000915 	stw	fp,36(sp)
21083790:	ddc00815 	stw	r23,32(sp)
21083794:	dd800715 	stw	r22,28(sp)
21083798:	dd400615 	stw	r21,24(sp)
2108379c:	dd000515 	stw	r20,20(sp)
210837a0:	dcc00415 	stw	r19,16(sp)
210837a4:	dc800315 	stw	r18,12(sp)
210837a8:	dc400215 	stw	r17,8(sp)
210837ac:	040002c4 	movi	r16,11
210837b0:	843fffc4 	addi	r16,r16,-1
    int nTry=0;
    bool bSuccess = TRUE;
        
    //1. chek whether SD Card existed. Init SD card if it is present.
    while(!bFind && nTry++ < nMaxTry){
        bFind = SDLIB_Init(SD_CONT_BASE);
210837b4:	01080034 	movhi	r4,8192
    bool bFind = FALSE;
    int nTry=0;
    bool bSuccess = TRUE;
        
    //1. chek whether SD Card existed. Init SD card if it is present.
    while(!bFind && nTry++ < nMaxTry){
210837b8:	80001526 	beq	r16,zero,21083810 <fatMountSdcard+0x90>
        bFind = SDLIB_Init(SD_CONT_BASE);
210837bc:	10852b80 	call	210852b8 <SDLIB_Init>
        if (!bFind)
210837c0:	10002026 	beq	r2,zero,21083844 <fatMountSdcard+0xc4>
    }    
    
    //hFat = malloc(sizeof(VOLUME_INFO));
    hFat = &vInfo;
    pVol = (VOLUME_INFO *)hFat;
    pVol->ReadBlock512 = SD_ReadBlock512;
210837c4:	04000034 	movhi	r16,0
210837c8:	00884234 	movhi	r2,8456
210837cc:	84188304 	addi	r16,r16,25100
210837d0:	108b0304 	addi	r2,r2,11276

//===================== SUPPORT_SD_CARD =================================================
#ifdef SUPPORT_SD_CARD

bool SD_ReadBlock512(DISK_HANDLE DiskHandle, alt_u32 PysicalSelector, alt_u8 szBuf[512]){
    return SDLIB_ReadBlock512(PysicalSelector, szBuf);
210837d4:	04400034 	movhi	r17,0
210837d8:	8c57e204 	addi	r17,r17,24456
    }    
    
    //hFat = malloc(sizeof(VOLUME_INFO));
    hFat = &vInfo;
    pVol = (VOLUME_INFO *)hFat;
    pVol->ReadBlock512 = SD_ReadBlock512;
210837dc:	80800115 	stw	r2,4(r16)
    pVol->ReadBlocks = SD_ReadBlocks;
210837e0:	00884234 	movhi	r2,8456
210837e4:	108b0604 	addi	r2,r2,11288

//===================== SUPPORT_SD_CARD =================================================
#ifdef SUPPORT_SD_CARD

bool SD_ReadBlock512(DISK_HANDLE DiskHandle, alt_u32 PysicalSelector, alt_u8 szBuf[512]){
    return SDLIB_ReadBlock512(PysicalSelector, szBuf);
210837e8:	0009883a 	mov	r4,zero
210837ec:	880b883a 	mov	r5,r17
    
    //hFat = malloc(sizeof(VOLUME_INFO));
    hFat = &vInfo;
    pVol = (VOLUME_INFO *)hFat;
    pVol->ReadBlock512 = SD_ReadBlock512;
    pVol->ReadBlocks = SD_ReadBlocks;
210837f0:	80800315 	stw	r2,12(r16)

//===================== SUPPORT_SD_CARD =================================================
#ifdef SUPPORT_SD_CARD

bool SD_ReadBlock512(DISK_HANDLE DiskHandle, alt_u32 PysicalSelector, alt_u8 szBuf[512]){
    return SDLIB_ReadBlock512(PysicalSelector, szBuf);
210837f4:	10853280 	call	21085328 <SDLIB_ReadBlock512>
    // 1DEh( 16 bytes): 3nd Partition Entry
    // 1EEh( 16 bytes): 4nd Partition Entry
    // 1FEh(  2 bytes): Executable Maker (55h AAh)
    
    // read first block (secotor 0), BPB(BIOS Parameter Block) or called as boot sector or reserved sector
    if (!pVol->ReadBlock512(pVol->DiskHandle, 0, szBlock)){
210837f8:	10000526 	beq	r2,zero,21083810 <fatMountSdcard+0x90>
    */
        
    // check file system 
    FirstPartitionEntry = 0x1BE;
    //PartitionType = szBlock[FirstPartitionEntry + 4];
    PartitionType = szBlock[0x01C2];
210837fc:	88807083 	ldbu	r2,450(r17)
    if (PartitionType == PARTITION_FAT16){
21083800:	00c00184 	movi	r3,6
21083804:	10c01326 	beq	r2,r3,21083854 <fatMountSdcard+0xd4>
        FAT_DEBUG(("FAT16\n"));
    }else if (PartitionType == PARTITION_FAT32){
21083808:	00c002c4 	movi	r3,11
2108380c:	10c01126 	beq	r2,r3,21083854 <fatMountSdcard+0xd4>
        FAT_DEBUG(("Fat_Mount success\n"));
        pVol->bMount = TRUE;
    }else{        
        FAT_DEBUG(("Fat_Mount fail\n"));
        //free((void *)hFat);
        hFat = 0;
21083810:	0005883a 	mov	r2,zero
    }        

    return hFat;   
}
21083814:	dfc00a17 	ldw	ra,40(sp)
21083818:	df000917 	ldw	fp,36(sp)
2108381c:	ddc00817 	ldw	r23,32(sp)
21083820:	dd800717 	ldw	r22,28(sp)
21083824:	dd400617 	ldw	r21,24(sp)
21083828:	dd000517 	ldw	r20,20(sp)
2108382c:	dcc00417 	ldw	r19,16(sp)
21083830:	dc800317 	ldw	r18,12(sp)
21083834:	dc400217 	ldw	r17,8(sp)
21083838:	dc000117 	ldw	r16,4(sp)
2108383c:	dec00b04 	addi	sp,sp,44
21083840:	f800283a 	ret
        
    //1. chek whether SD Card existed. Init SD card if it is present.
    while(!bFind && nTry++ < nMaxTry){
        bFind = SDLIB_Init(SD_CONT_BASE);
        if (!bFind)
            usleep(100*1000);
21083844:	010000b4 	movhi	r4,2
21083848:	2121a804 	addi	r4,r4,-31072
2108384c:	109b8500 	call	2109b850 <usleep>
21083850:	003fd706 	br	210837b0 <__flash_rwdata_start+0xfffe1568>
    alt_u8 *pMSB = (pValue + nNum - 1);
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
        nValue <<= 8;
        nValue |= *pMSB--;
21083854:	88c07243 	ldbu	r3,457(r17)
21083858:	89007203 	ldbu	r4,456(r17)
2108385c:	894071c3 	ldbu	r5,455(r17)
unsigned int fatArray2Value(unsigned char *pValue, unsigned int nNum){
    alt_u8 *pMSB = (pValue + nNum - 1);
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
        nValue <<= 8;
21083860:	1806923a 	slli	r3,r3,8
        nValue |= *pMSB--;
21083864:	8cc07183 	ldbu	r19,454(r17)
                            //szBlock[FirstPartitionEntry + 8 + 1]*256 + 
                            //szBlock[FirstPartitionEntry + 8];        
    
    //3 Parsing the Volume Boot Record(BR)
    //3.1  Read the Volume Boot Record(BR)
    if (!pVol->ReadBlock512(pVol->DiskHandle, FirstSectionInVolume1, szBlock)){
21083868:	81c00117 	ldw	r7,4(r16)
    alt_u8 *pMSB = (pValue + nNum - 1);
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
        nValue <<= 8;
        nValue |= *pMSB--;
2108386c:	1906b03a 	or	r3,r3,r4
unsigned int fatArray2Value(unsigned char *pValue, unsigned int nNum){
    alt_u8 *pMSB = (pValue + nNum - 1);
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
        nValue <<= 8;
21083870:	1806923a 	slli	r3,r3,8
        nValue |= *pMSB--;
21083874:	04400034 	movhi	r17,0
                            //szBlock[FirstPartitionEntry + 8 + 1]*256 + 
                            //szBlock[FirstPartitionEntry + 8];        
    
    //3 Parsing the Volume Boot Record(BR)
    //3.1  Read the Volume Boot Record(BR)
    if (!pVol->ReadBlock512(pVol->DiskHandle, FirstSectionInVolume1, szBlock)){
21083878:	81000017 	ldw	r4,0(r16)
    alt_u8 *pMSB = (pValue + nNum - 1);
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
        nValue <<= 8;
        nValue |= *pMSB--;
2108387c:	1946b03a 	or	r3,r3,r5
unsigned int fatArray2Value(unsigned char *pValue, unsigned int nNum){
    alt_u8 *pMSB = (pValue + nNum - 1);
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
        nValue <<= 8;
21083880:	1806923a 	slli	r3,r3,8
        nValue |= *pMSB--;
21083884:	8c57e204 	addi	r17,r17,24456
        FAT_DEBUG(("FAT32\n"));
    }else{        
        FAT_DEBUG(("the partition type(%d) is not supported.\n", PartitionType));
        return FALSE; // only support FAT16 in this example
    }       
    pVol->Partition_Type = PartitionType; 
21083888:	04800034 	movhi	r18,0
    alt_u8 *pMSB = (pValue + nNum - 1);
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
        nValue <<= 8;
        nValue |= *pMSB--;
2108388c:	1ce6b03a 	or	r19,r3,r19
        FAT_DEBUG(("FAT32\n"));
    }else{        
        FAT_DEBUG(("the partition type(%d) is not supported.\n", PartitionType));
        return FALSE; // only support FAT16 in this example
    }       
    pVol->Partition_Type = PartitionType; 
21083890:	80800415 	stw	r2,16(r16)
                            //szBlock[FirstPartitionEntry + 8 + 1]*256 + 
                            //szBlock[FirstPartitionEntry + 8];        
    
    //3 Parsing the Volume Boot Record(BR)
    //3.1  Read the Volume Boot Record(BR)
    if (!pVol->ReadBlock512(pVol->DiskHandle, FirstSectionInVolume1, szBlock)){
21083894:	880d883a 	mov	r6,r17
21083898:	980b883a 	mov	r5,r19
        FAT_DEBUG(("FAT32\n"));
    }else{        
        FAT_DEBUG(("the partition type(%d) is not supported.\n", PartitionType));
        return FALSE; // only support FAT16 in this example
    }       
    pVol->Partition_Type = PartitionType; 
2108389c:	94988304 	addi	r18,r18,25100
                            //szBlock[FirstPartitionEntry + 8 + 1]*256 + 
                            //szBlock[FirstPartitionEntry + 8];        
    
    //3 Parsing the Volume Boot Record(BR)
    //3.1  Read the Volume Boot Record(BR)
    if (!pVol->ReadBlock512(pVol->DiskHandle, FirstSectionInVolume1, szBlock)){
210838a0:	383ee83a 	callr	r7
210838a4:	103fda26 	beq	r2,zero,21083810 <__flash_rwdata_start+0xfffe15c8>
        FAT_DEBUG(("Read first sector in volume one fail.\n"));
        return FALSE;
    }        
    pVol->PartitionStartSecter = FirstSectionInVolume1;     
    pVol->BPB_BytsPerSec = szBlock[0x0B+1]*256 + szBlock[0x0B];
210838a8:	89c00303 	ldbu	r7,12(r17)
    pVol->BPB_SecPerCluster = szBlock[0x0D];
    pVol->BPB_RsvdSecCnt = szBlock[0x0E + 1]*256 + szBlock[0x0E]; 
210838ac:	898003c3 	ldbu	r6,15(r17)
    pVol->BPB_NumFATs = szBlock[0x10];
    pVol->BPB_RootEntCnt = szBlock[0x11+1]*256 + szBlock[0x11]; 
210838b0:	89400483 	ldbu	r5,18(r17)
    pVol->BPB_FATSz = szBlock[0x16+1]*256 + szBlock[0x16];
210838b4:	88c005c3 	ldbu	r3,23(r17)
210838b8:	88800583 	ldbu	r2,22(r17)
    if (!pVol->ReadBlock512(pVol->DiskHandle, FirstSectionInVolume1, szBlock)){
        FAT_DEBUG(("Read first sector in volume one fail.\n"));
        return FALSE;
    }        
    pVol->PartitionStartSecter = FirstSectionInVolume1;     
    pVol->BPB_BytsPerSec = szBlock[0x0B+1]*256 + szBlock[0x0B];
210838bc:	380e923a 	slli	r7,r7,8
    pVol->BPB_SecPerCluster = szBlock[0x0D];
    pVol->BPB_RsvdSecCnt = szBlock[0x0E + 1]*256 + szBlock[0x0E]; 
    pVol->BPB_NumFATs = szBlock[0x10];
    pVol->BPB_RootEntCnt = szBlock[0x11+1]*256 + szBlock[0x11]; 
    pVol->BPB_FATSz = szBlock[0x16+1]*256 + szBlock[0x16];
210838c0:	1806923a 	slli	r3,r3,8
    if (!pVol->ReadBlock512(pVol->DiskHandle, FirstSectionInVolume1, szBlock)){
        FAT_DEBUG(("Read first sector in volume one fail.\n"));
        return FALSE;
    }        
    pVol->PartitionStartSecter = FirstSectionInVolume1;     
    pVol->BPB_BytsPerSec = szBlock[0x0B+1]*256 + szBlock[0x0B];
210838c4:	8dc002c3 	ldbu	r23,11(r17)
    pVol->BPB_SecPerCluster = szBlock[0x0D];
    pVol->BPB_RsvdSecCnt = szBlock[0x0E + 1]*256 + szBlock[0x0E]; 
210838c8:	300c923a 	slli	r6,r6,8
210838cc:	8d800383 	ldbu	r22,14(r17)
    pVol->BPB_NumFATs = szBlock[0x10];
    pVol->BPB_RootEntCnt = szBlock[0x11+1]*256 + szBlock[0x11]; 
210838d0:	280a923a 	slli	r5,r5,8
210838d4:	8d000443 	ldbu	r20,17(r17)
    }        
    pVol->PartitionStartSecter = FirstSectionInVolume1;     
    pVol->BPB_BytsPerSec = szBlock[0x0B+1]*256 + szBlock[0x0B];
    pVol->BPB_SecPerCluster = szBlock[0x0D];
    pVol->BPB_RsvdSecCnt = szBlock[0x0E + 1]*256 + szBlock[0x0E]; 
    pVol->BPB_NumFATs = szBlock[0x10];
210838d8:	8a000403 	ldbu	r8,16(r17)
        FAT_DEBUG(("Read first sector in volume one fail.\n"));
        return FALSE;
    }        
    pVol->PartitionStartSecter = FirstSectionInVolume1;     
    pVol->BPB_BytsPerSec = szBlock[0x0B+1]*256 + szBlock[0x0B];
    pVol->BPB_SecPerCluster = szBlock[0x0D];
210838dc:	8f000343 	ldbu	fp,13(r17)
    pVol->BPB_RsvdSecCnt = szBlock[0x0E + 1]*256 + szBlock[0x0E]; 
    pVol->BPB_NumFATs = szBlock[0x10];
    pVol->BPB_RootEntCnt = szBlock[0x11+1]*256 + szBlock[0x11]; 
    pVol->BPB_FATSz = szBlock[0x16+1]*256 + szBlock[0x16];
210838e0:	18ab883a 	add	r21,r3,r2
    if (!pVol->ReadBlock512(pVol->DiskHandle, FirstSectionInVolume1, szBlock)){
        FAT_DEBUG(("Read first sector in volume one fail.\n"));
        return FALSE;
    }        
    pVol->PartitionStartSecter = FirstSectionInVolume1;     
    pVol->BPB_BytsPerSec = szBlock[0x0B+1]*256 + szBlock[0x0B];
210838e4:	3def883a 	add	r23,r7,r23
    pVol->BPB_SecPerCluster = szBlock[0x0D];
    pVol->BPB_RsvdSecCnt = szBlock[0x0E + 1]*256 + szBlock[0x0E]; 
210838e8:	35ad883a 	add	r22,r6,r22
    pVol->BPB_NumFATs = szBlock[0x10];
    pVol->BPB_RootEntCnt = szBlock[0x11+1]*256 + szBlock[0x11]; 
210838ec:	2d29883a 	add	r20,r5,r20
    pVol->BPB_FATSz = szBlock[0x16+1]*256 + szBlock[0x16];
    
    // add for v2.0
    pVol->Secter_Index = -1;
210838f0:	00bfffc4 	movi	r2,-1
    memset(pVol->Secter_Data, 0, MY_SECTER_SIZE); // 512 bytes
210838f4:	91009204 	addi	r4,r18,584
210838f8:	000b883a 	mov	r5,zero
210838fc:	01808004 	movi	r6,512
    }        
    pVol->PartitionStartSecter = FirstSectionInVolume1;     
    pVol->BPB_BytsPerSec = szBlock[0x0B+1]*256 + szBlock[0x0B];
    pVol->BPB_SecPerCluster = szBlock[0x0D];
    pVol->BPB_RsvdSecCnt = szBlock[0x0E + 1]*256 + szBlock[0x0E]; 
    pVol->BPB_NumFATs = szBlock[0x10];
21083900:	92000a15 	stw	r8,40(r18)
    pVol->BPB_RootEntCnt = szBlock[0x11+1]*256 + szBlock[0x11]; 
    pVol->BPB_FATSz = szBlock[0x16+1]*256 + szBlock[0x16];
    
    // add for v2.0
    pVol->Secter_Index = -1;
    memset(pVol->Secter_Data, 0, MY_SECTER_SIZE); // 512 bytes
21083904:	da000015 	stw	r8,0(sp)
    //3.1  Read the Volume Boot Record(BR)
    if (!pVol->ReadBlock512(pVol->DiskHandle, FirstSectionInVolume1, szBlock)){
        FAT_DEBUG(("Read first sector in volume one fail.\n"));
        return FALSE;
    }        
    pVol->PartitionStartSecter = FirstSectionInVolume1;     
21083908:	94c00615 	stw	r19,24(r18)
    pVol->BPB_BytsPerSec = szBlock[0x0B+1]*256 + szBlock[0x0B];
2108390c:	95c00715 	stw	r23,28(r18)
    pVol->BPB_SecPerCluster = szBlock[0x0D];
21083910:	97000815 	stw	fp,32(r18)
    pVol->BPB_RsvdSecCnt = szBlock[0x0E + 1]*256 + szBlock[0x0E]; 
21083914:	95800915 	stw	r22,36(r18)
    pVol->BPB_NumFATs = szBlock[0x10];
    pVol->BPB_RootEntCnt = szBlock[0x11+1]*256 + szBlock[0x11]; 
21083918:	95000b15 	stw	r20,44(r18)
    pVol->BPB_FATSz = szBlock[0x16+1]*256 + szBlock[0x16];
2108391c:	95400c15 	stw	r21,48(r18)
    
    // add for v2.0
    pVol->Secter_Index = -1;
21083920:	90811215 	stw	r2,1096(r18)
    memset(pVol->Secter_Data, 0, MY_SECTER_SIZE); // 512 bytes
21083924:	108e26c0 	call	2108e26c <memset>
    
    if (pVol->Partition_Type == PARTITION_FAT32){
21083928:	90c00417 	ldw	r3,16(r18)
2108392c:	008002c4 	movi	r2,11
21083930:	da000017 	ldw	r8,0(sp)
21083934:	18801326 	beq	r3,r2,21083984 <fatMountSdcard+0x204>
        pVol->BPB_FATSz = fatArray2Value(&szBlock[0x24], 4);  // BPB_FATSz32
        //pVol->BPB_RootEntCnt = fatArray2Value(&szBlock[0x2C], 4);  // BPB_RootClus            
    }
    
    if (pVol->BPB_BytsPerSec != MY_SECTER_SIZE){
21083938:	00808004 	movi	r2,512
2108393c:	b8bfb41e 	bne	r23,r2,21083810 <__flash_rwdata_start+0xfffe15c8>
    FAT_DEBUG(("Sectors Per FAT: %04Xh(%d)\n", pVol->BPB_FATSz, pVol->BPB_FATSz));
#endif    
    //
    pVol->FatEntrySecter = pVol->PartitionStartSecter + pVol->BPB_RsvdSecCnt;
    pVol->RootDirectoryEntrySecter = pVol->FatEntrySecter + pVol->BPB_NumFATs * pVol->BPB_FATSz;
    pVol->DataEntrySecter = pVol->RootDirectoryEntrySecter + ((pVol->BPB_RootEntCnt*32)+(pVol->BPB_BytsPerSec-1))/pVol->BPB_BytsPerSec;
21083940:	a004917a 	slli	r2,r20,5
    FAT_DEBUG(("Maximum Root Directory Entries: %04Xh(%d)\n", pVol->BPB_RootEntCnt, pVol->BPB_RootEntCnt));
    FAT_DEBUG(("Sectors Per FAT: %04Xh(%d)\n", pVol->BPB_FATSz, pVol->BPB_FATSz));
#endif    
    //
    pVol->FatEntrySecter = pVol->PartitionStartSecter + pVol->BPB_RsvdSecCnt;
    pVol->RootDirectoryEntrySecter = pVol->FatEntrySecter + pVol->BPB_NumFATs * pVol->BPB_FATSz;
21083944:	aa09383a 	mul	r4,r21,r8
    FAT_DEBUG(("Number of Copies of FAT: %02Xh(%d)\n", pVol->BPB_NumFATs, pVol->BPB_NumFATs));
    FAT_DEBUG(("Maximum Root Directory Entries: %04Xh(%d)\n", pVol->BPB_RootEntCnt, pVol->BPB_RootEntCnt));
    FAT_DEBUG(("Sectors Per FAT: %04Xh(%d)\n", pVol->BPB_FATSz, pVol->BPB_FATSz));
#endif    
    //
    pVol->FatEntrySecter = pVol->PartitionStartSecter + pVol->BPB_RsvdSecCnt;
21083948:	9d87883a 	add	r3,r19,r22
    pVol->RootDirectoryEntrySecter = pVol->FatEntrySecter + pVol->BPB_NumFATs * pVol->BPB_FATSz;
    pVol->DataEntrySecter = pVol->RootDirectoryEntrySecter + ((pVol->BPB_RootEntCnt*32)+(pVol->BPB_BytsPerSec-1))/pVol->BPB_BytsPerSec;
2108394c:	10807fc4 	addi	r2,r2,511
21083950:	1004d27a 	srli	r2,r2,9
    FAT_DEBUG(("Maximum Root Directory Entries: %04Xh(%d)\n", pVol->BPB_RootEntCnt, pVol->BPB_RootEntCnt));
    FAT_DEBUG(("Sectors Per FAT: %04Xh(%d)\n", pVol->BPB_FATSz, pVol->BPB_FATSz));
#endif    
    //
    pVol->FatEntrySecter = pVol->PartitionStartSecter + pVol->BPB_RsvdSecCnt;
    pVol->RootDirectoryEntrySecter = pVol->FatEntrySecter + pVol->BPB_NumFATs * pVol->BPB_FATSz;
21083954:	20c9883a 	add	r4,r4,r3
    pVol->DataEntrySecter = pVol->RootDirectoryEntrySecter + ((pVol->BPB_RootEntCnt*32)+(pVol->BPB_BytsPerSec-1))/pVol->BPB_BytsPerSec;
    
    // read FAT table into memory
    pVol->nBytesPerCluster = pVol->BPB_BytsPerSec * pVol->BPB_SecPerCluster;
21083958:	e038927a 	slli	fp,fp,9
    FAT_DEBUG(("Sectors Per FAT: %04Xh(%d)\n", pVol->BPB_FATSz, pVol->BPB_FATSz));
#endif    
    //
    pVol->FatEntrySecter = pVol->PartitionStartSecter + pVol->BPB_RsvdSecCnt;
    pVol->RootDirectoryEntrySecter = pVol->FatEntrySecter + pVol->BPB_NumFATs * pVol->BPB_FATSz;
    pVol->DataEntrySecter = pVol->RootDirectoryEntrySecter + ((pVol->BPB_RootEntCnt*32)+(pVol->BPB_BytsPerSec-1))/pVol->BPB_BytsPerSec;
2108395c:	2085883a 	add	r2,r4,r2
21083960:	80801015 	stw	r2,64(r16)
    if (bSuccess){
        FAT_DEBUG(("Fat_Mount success\n"));
    }else{        
        FAT_DEBUG(("Fat_Mount fail\n"));
    }        
    pVol->bMount = bSuccess;
21083964:	00800044 	movi	r2,1
21083968:	80800515 	stw	r2,20(r16)
        FAT_DEBUG(("Cannot find SD card.\n"));
        return hFat;
    }    
    
    //hFat = malloc(sizeof(VOLUME_INFO));
    hFat = &vInfo;
2108396c:	00800034 	movhi	r2,0
    FAT_DEBUG(("Number of Copies of FAT: %02Xh(%d)\n", pVol->BPB_NumFATs, pVol->BPB_NumFATs));
    FAT_DEBUG(("Maximum Root Directory Entries: %04Xh(%d)\n", pVol->BPB_RootEntCnt, pVol->BPB_RootEntCnt));
    FAT_DEBUG(("Sectors Per FAT: %04Xh(%d)\n", pVol->BPB_FATSz, pVol->BPB_FATSz));
#endif    
    //
    pVol->FatEntrySecter = pVol->PartitionStartSecter + pVol->BPB_RsvdSecCnt;
21083970:	80c00e15 	stw	r3,56(r16)
    pVol->RootDirectoryEntrySecter = pVol->FatEntrySecter + pVol->BPB_NumFATs * pVol->BPB_FATSz;
21083974:	81000f15 	stw	r4,60(r16)
    pVol->DataEntrySecter = pVol->RootDirectoryEntrySecter + ((pVol->BPB_RootEntCnt*32)+(pVol->BPB_BytsPerSec-1))/pVol->BPB_BytsPerSec;
    
    // read FAT table into memory
    pVol->nBytesPerCluster = pVol->BPB_BytsPerSec * pVol->BPB_SecPerCluster;
21083978:	87000d15 	stw	fp,52(r16)
        FAT_DEBUG(("Cannot find SD card.\n"));
        return hFat;
    }    
    
    //hFat = malloc(sizeof(VOLUME_INFO));
    hFat = &vInfo;
2108397c:	10988304 	addi	r2,r2,25100
21083980:	003fa406 	br	21083814 <__flash_rwdata_start+0xfffe15cc>
    alt_u8 *pMSB = (pValue + nNum - 1);
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
        nValue <<= 8;
        nValue |= *pMSB--;
21083984:	8d4009c3 	ldbu	r21,39(r17)
21083988:	89000983 	ldbu	r4,38(r17)
2108398c:	88c00943 	ldbu	r3,37(r17)
unsigned int fatArray2Value(unsigned char *pValue, unsigned int nNum){
    alt_u8 *pMSB = (pValue + nNum - 1);
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
        nValue <<= 8;
21083990:	a82a923a 	slli	r21,r21,8
        nValue |= *pMSB--;
21083994:	88800903 	ldbu	r2,36(r17)
21083998:	a92ab03a 	or	r21,r21,r4
unsigned int fatArray2Value(unsigned char *pValue, unsigned int nNum){
    alt_u8 *pMSB = (pValue + nNum - 1);
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
        nValue <<= 8;
2108399c:	a82a923a 	slli	r21,r21,8
        nValue |= *pMSB--;
210839a0:	a8eab03a 	or	r21,r21,r3
unsigned int fatArray2Value(unsigned char *pValue, unsigned int nNum){
    alt_u8 *pMSB = (pValue + nNum - 1);
    alt_u32 nValue;
    int i;
    for(i=0;i<nNum;i++){
        nValue <<= 8;
210839a4:	a82a923a 	slli	r21,r21,8
        nValue |= *pMSB--;
210839a8:	a8aab03a 	or	r21,r21,r2
    // add for v2.0
    pVol->Secter_Index = -1;
    memset(pVol->Secter_Data, 0, MY_SECTER_SIZE); // 512 bytes
    
    if (pVol->Partition_Type == PARTITION_FAT32){
        pVol->BPB_FATSz = fatArray2Value(&szBlock[0x24], 4);  // BPB_FATSz32
210839ac:	95400c15 	stw	r21,48(r18)
210839b0:	003fe106 	br	21083938 <__flash_rwdata_start+0xfffe16f0>

210839b4 <debug_output>:
#include "debug.h"


void debug_output(char *pMessage){
    
    printf(pMessage);
210839b4:	108e3bc1 	jmpi	2108e3bc <printf>

210839b8 <myprintf>:
}

int myprintf(char *format, ...){
210839b8:	deff7b04 	addi	sp,sp,-532
210839bc:	dfc08115 	stw	ra,516(sp)
210839c0:	dc008015 	stw	r16,512(sp)
210839c4:	d9408215 	stw	r5,520(sp)
210839c8:	d9808315 	stw	r6,524(sp)
210839cc:	d9c08415 	stw	r7,528(sp)
    int rc;
    char szText[512];
    
    va_list paramList;
    va_start(paramList, format);
    rc = vsnprintf(szText, 512, format, paramList);
210839d0:	01408004 	movi	r5,512
210839d4:	200d883a 	mov	r6,r4
210839d8:	d9c08204 	addi	r7,sp,520
210839dc:	d809883a 	mov	r4,sp
210839e0:	10928d00 	call	210928d0 <vsnprintf>
#include "debug.h"


void debug_output(char *pMessage){
    
    printf(pMessage);
210839e4:	d809883a 	mov	r4,sp
    int rc;
    char szText[512];
    
    va_list paramList;
    va_start(paramList, format);
    rc = vsnprintf(szText, 512, format, paramList);
210839e8:	1021883a 	mov	r16,r2
#include "debug.h"


void debug_output(char *pMessage){
    
    printf(pMessage);
210839ec:	108e3bc0 	call	2108e3bc <printf>
    va_end(paramList);
    
    debug_output(szText);

    return rc;    
}
210839f0:	8005883a 	mov	r2,r16
210839f4:	dfc08117 	ldw	ra,516(sp)
210839f8:	dc008017 	ldw	r16,512(sp)
210839fc:	dec08504 	addi	sp,sp,532
21083a00:	f800283a 	ret

21083a04 <myprintf_hexarray>:


int myprintf_hexarray(unsigned char *pHex, int len){
21083a04:	defff804 	addi	sp,sp,-32
21083a08:	dc800615 	stw	r18,24(sp)
21083a0c:	dfc00715 	stw	ra,28(sp)
21083a10:	dc400515 	stw	r17,20(sp)
21083a14:	dc000415 	stw	r16,16(sp)
21083a18:	2825883a 	mov	r18,r5
    int i;
    unsigned char szText[16];
    for(i=0;i<len;i++){
21083a1c:	01400b0e 	bge	zero,r5,21083a4c <myprintf_hexarray+0x48>
21083a20:	2021883a 	mov	r16,r4
21083a24:	2163883a 	add	r17,r4,r5
        sprintf(szText, "[%02X]", *(pHex+i));
21083a28:	81800003 	ldbu	r6,0(r16)
21083a2c:	01400034 	movhi	r5,0
21083a30:	d809883a 	mov	r4,sp
21083a34:	2940c004 	addi	r5,r5,768
21083a38:	108e5800 	call	2108e580 <sprintf>
21083a3c:	84000044 	addi	r16,r16,1
        DEBUG((szText));
21083a40:	d809883a 	mov	r4,sp
21083a44:	10839b80 	call	210839b8 <myprintf>


int myprintf_hexarray(unsigned char *pHex, int len){
    int i;
    unsigned char szText[16];
    for(i=0;i<len;i++){
21083a48:	847ff71e 	bne	r16,r17,21083a28 <__flash_rwdata_start+0xfffe17e0>
        sprintf(szText, "[%02X]", *(pHex+i));
        DEBUG((szText));
    }
    return len;
}
21083a4c:	9005883a 	mov	r2,r18
21083a50:	dfc00717 	ldw	ra,28(sp)
21083a54:	dc800617 	ldw	r18,24(sp)
21083a58:	dc400517 	ldw	r17,20(sp)
21083a5c:	dc000417 	ldw	r16,16(sp)
21083a60:	dec00804 	addi	sp,sp,32
21083a64:	f800283a 	ret

21083a68 <myprintf_dwordarray>:

int  myprintf_dwordarray(unsigned int *pArray, int nElementCount){
21083a68:	defff804 	addi	sp,sp,-32
21083a6c:	dc800615 	stw	r18,24(sp)
21083a70:	dfc00715 	stw	ra,28(sp)
21083a74:	dc400515 	stw	r17,20(sp)
21083a78:	dc000415 	stw	r16,16(sp)
21083a7c:	2825883a 	mov	r18,r5
    int i;
    char szText[16];
    for(i=0;i<nElementCount;i++){
21083a80:	01400c0e 	bge	zero,r5,21083ab4 <myprintf_dwordarray+0x4c>
21083a84:	2021883a 	mov	r16,r4
21083a88:	0023883a 	mov	r17,zero
        sprintf(szText, "[%08X]", *(pArray+i));
21083a8c:	81800017 	ldw	r6,0(r16)
21083a90:	01400034 	movhi	r5,0
21083a94:	2940c204 	addi	r5,r5,776
21083a98:	d809883a 	mov	r4,sp
21083a9c:	108e5800 	call	2108e580 <sprintf>
        DEBUG((szText));
21083aa0:	d809883a 	mov	r4,sp
}

int  myprintf_dwordarray(unsigned int *pArray, int nElementCount){
    int i;
    char szText[16];
    for(i=0;i<nElementCount;i++){
21083aa4:	8c400044 	addi	r17,r17,1
        sprintf(szText, "[%08X]", *(pArray+i));
        DEBUG((szText));
21083aa8:	10839b80 	call	210839b8 <myprintf>
21083aac:	84000104 	addi	r16,r16,4
}

int  myprintf_dwordarray(unsigned int *pArray, int nElementCount){
    int i;
    char szText[16];
    for(i=0;i<nElementCount;i++){
21083ab0:	8cbff61e 	bne	r17,r18,21083a8c <__flash_rwdata_start+0xfffe1844>
        sprintf(szText, "[%08X]", *(pArray+i));
        DEBUG((szText));
    }
    return nElementCount;
}
21083ab4:	9005883a 	mov	r2,r18
21083ab8:	dfc00717 	ldw	ra,28(sp)
21083abc:	dc800617 	ldw	r18,24(sp)
21083ac0:	dc400517 	ldw	r17,20(sp)
21083ac4:	dc000417 	ldw	r16,16(sp)
21083ac8:	dec00804 	addi	sp,sp,32
21083acc:	f800283a 	ret

21083ad0 <mmc_send_status.constprop.4>:
	struct mmc_cmd cmd;
	int err, retries = 5;

	cmd.cmdidx = MMC_CMD_SEND_STATUS;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = mmc->rca << 16;
21083ad0:	20801e0b 	ldhu	r2,120(r4)
	mmc->rca = 0;

	return 0;
}

static int mmc_send_status(struct mmc *mmc, int timeout) {
21083ad4:	defff004 	addi	sp,sp,-64
	struct mmc_cmd cmd;
	int err, retries = 5;

	cmd.cmdidx = MMC_CMD_SEND_STATUS;
21083ad8:	00c00344 	movi	r3,13
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = mmc->rca << 16;
21083adc:	1004943a 	slli	r2,r2,16
	mmc->rca = 0;

	return 0;
}

static int mmc_send_status(struct mmc *mmc, int timeout) {
21083ae0:	dd800e15 	stw	r22,56(sp)
	struct mmc_cmd cmd;
	int err, retries = 5;

	cmd.cmdidx = MMC_CMD_SEND_STATUS;
21083ae4:	d8c0000d 	sth	r3,0(sp)
		if (!err) {
			if ((cmd.response[0] & MMC_STATUS_RDY_FOR_DATA)
					&& (cmd.response[0] & MMC_STATUS_CURR_STATE) !=
					MMC_STATE_PRG)
				break;
			else if (cmd.response[0] & MMC_STATUS_MASK) {
21083ae8:	05bf7e74 	movhi	r22,65017
static int mmc_send_status(struct mmc *mmc, int timeout) {
	struct mmc_cmd cmd;
	int err, retries = 5;

	cmd.cmdidx = MMC_CMD_SEND_STATUS;
	cmd.resp_type = MMC_RSP_R1;
21083aec:	00c00544 	movi	r3,21
	mmc->rca = 0;

	return 0;
}

static int mmc_send_status(struct mmc *mmc, int timeout) {
21083af0:	dd400d15 	stw	r21,52(sp)
21083af4:	dd000c15 	stw	r20,48(sp)
21083af8:	dcc00b15 	stw	r19,44(sp)
21083afc:	dc800a15 	stw	r18,40(sp)
21083b00:	dc400915 	stw	r17,36(sp)
21083b04:	dc000815 	stw	r16,32(sp)
21083b08:	dfc00f15 	stw	ra,60(sp)
21083b0c:	2027883a 	mov	r19,r4
		if (!err) {
			if ((cmd.response[0] & MMC_STATUS_RDY_FOR_DATA)
					&& (cmd.response[0] & MMC_STATUS_CURR_STATE) !=
					MMC_STATE_PRG)
				break;
			else if (cmd.response[0] & MMC_STATUS_MASK) {
21083b10:	b5902004 	addi	r22,r22,16512
static int mmc_send_status(struct mmc *mmc, int timeout) {
	struct mmc_cmd cmd;
	int err, retries = 5;

	cmd.cmdidx = MMC_CMD_SEND_STATUS;
	cmd.resp_type = MMC_RSP_R1;
21083b14:	d8c00115 	stw	r3,4(sp)
	cmd.cmdarg = mmc->rca << 16;
21083b18:	d8800215 	stw	r2,8(sp)
	return 0;
}

static int mmc_send_status(struct mmc *mmc, int timeout) {
	struct mmc_cmd cmd;
	int err, retries = 5;
21083b1c:	04800144 	movi	r18,5

	cmd.cmdidx = MMC_CMD_SEND_STATUS;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = mmc->rca << 16;
21083b20:	0440fa04 	movi	r17,1000

	do {
		err = mmc_send_cmd(mmc, &cmd, NULL);
		if (!err) {
			if ((cmd.response[0] & MMC_STATUS_RDY_FOR_DATA)
					&& (cmd.response[0] & MMC_STATUS_CURR_STATE) !=
21083b24:	05438004 	movi	r21,3584
#define MMC_PRINT(x)
#endif

void udelay(int t) {
#define US_DELAY 100
	volatile int us = US_DELAY;
21083b28:	04001904 	movi	r16,100
		} else if (--retries < 0)
			return err;

		udelay(1000);

	} while (timeout--);
21083b2c:	053fffc4 	movi	r20,-1

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21083b30:	98802417 	ldw	r2,144(r19)
21083b34:	9809883a 	mov	r4,r19
21083b38:	d80b883a 	mov	r5,sp
21083b3c:	000d883a 	mov	r6,zero
21083b40:	103ee83a 	callr	r2
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = mmc->rca << 16;

	do {
		err = mmc_send_cmd(mmc, &cmd, NULL);
		if (!err) {
21083b44:	1000171e 	bne	r2,zero,21083ba4 <mmc_send_status.constprop.4+0xd4>
			if ((cmd.response[0] & MMC_STATUS_RDY_FOR_DATA)
21083b48:	d9400317 	ldw	r5,12(sp)
21083b4c:	2880400c 	andi	r2,r5,256
21083b50:	10000226 	beq	r2,zero,21083b5c <mmc_send_status.constprop.4+0x8c>
					&& (cmd.response[0] & MMC_STATUS_CURR_STATE) !=
21083b54:	2887800c 	andi	r2,r5,7680
21083b58:	1540231e 	bne	r2,r21,21083be8 <mmc_send_status.constprop.4+0x118>
					MMC_STATE_PRG)
				break;
			else if (cmd.response[0] & MMC_STATUS_MASK) {
21083b5c:	2d84703a 	and	r2,r5,r22
21083b60:	1000131e 	bne	r2,zero,21083bb0 <mmc_send_status.constprop.4+0xe0>
#define MMC_PRINT(x)
#endif

void udelay(int t) {
#define US_DELAY 100
	volatile int us = US_DELAY;
21083b64:	dc000715 	stw	r16,28(sp)
21083b68:	0140fa04 	movi	r5,1000
	while (t--) {
		us = US_DELAY;
21083b6c:	dc000715 	stw	r16,28(sp)
		while (us--)
21083b70:	d8800717 	ldw	r2,28(sp)
21083b74:	10ffffc4 	addi	r3,r2,-1
21083b78:	d8c00715 	stw	r3,28(sp)
21083b7c:	103ffc1e 	bne	r2,zero,21083b70 <__flash_rwdata_start+0xfffe1928>
21083b80:	297fffc4 	addi	r5,r5,-1
#endif

void udelay(int t) {
#define US_DELAY 100
	volatile int us = US_DELAY;
	while (t--) {
21083b84:	283ff91e 	bne	r5,zero,21083b6c <__flash_rwdata_start+0xfffe1924>
		} else if (--retries < 0)
			return err;

		udelay(1000);

	} while (timeout--);
21083b88:	8c7fffc4 	addi	r17,r17,-1
21083b8c:	8d3fe81e 	bne	r17,r20,21083b30 <__flash_rwdata_start+0xfffe18e8>

	if (timeout <= 0) {
		printf("Timeout waiting card ready\n\r");
21083b90:	01000034 	movhi	r4,0
21083b94:	2100ca04 	addi	r4,r4,808
21083b98:	108e3bc0 	call	2108e3bc <printf>
		return TIMEOUT;
21083b9c:	00bffb44 	movi	r2,-19
21083ba0:	00000706 	br	21083bc0 <mmc_send_status.constprop.4+0xf0>
				break;
			else if (cmd.response[0] & MMC_STATUS_MASK) {
				printf("Status Error: 0x%08X\n\r", cmd.response[0]);
				return COMM_ERR;
			}
		} else if (--retries < 0)
21083ba4:	94bfffc4 	addi	r18,r18,-1
21083ba8:	903fee0e 	bge	r18,zero,21083b64 <__flash_rwdata_start+0xfffe191c>
21083bac:	00000406 	br	21083bc0 <mmc_send_status.constprop.4+0xf0>
			if ((cmd.response[0] & MMC_STATUS_RDY_FOR_DATA)
					&& (cmd.response[0] & MMC_STATUS_CURR_STATE) !=
					MMC_STATE_PRG)
				break;
			else if (cmd.response[0] & MMC_STATUS_MASK) {
				printf("Status Error: 0x%08X\n\r", cmd.response[0]);
21083bb0:	01000034 	movhi	r4,0
21083bb4:	2100c404 	addi	r4,r4,784
21083bb8:	108e3bc0 	call	2108e3bc <printf>
				return COMM_ERR;
21083bbc:	00bffb84 	movi	r2,-18
		printf("Timeout waiting card ready\n\r");
		return TIMEOUT;
	}

	return 0;
}
21083bc0:	dfc00f17 	ldw	ra,60(sp)
21083bc4:	dd800e17 	ldw	r22,56(sp)
21083bc8:	dd400d17 	ldw	r21,52(sp)
21083bcc:	dd000c17 	ldw	r20,48(sp)
21083bd0:	dcc00b17 	ldw	r19,44(sp)
21083bd4:	dc800a17 	ldw	r18,40(sp)
21083bd8:	dc400917 	ldw	r17,36(sp)
21083bdc:	dc000817 	ldw	r16,32(sp)
21083be0:	dec01004 	addi	sp,sp,64
21083be4:	f800283a 	ret

		udelay(1000);

	} while (timeout--);

	if (timeout <= 0) {
21083be8:	883fe926 	beq	r17,zero,21083b90 <__flash_rwdata_start+0xfffe1948>
		printf("Timeout waiting card ready\n\r");
		return TIMEOUT;
	}

	return 0;
21083bec:	0005883a 	mov	r2,zero
21083bf0:	003ff306 	br	21083bc0 <__flash_rwdata_start+0xfffe1978>

21083bf4 <mmc_startup>:
		mmc->card_caps |= MMC_MODE_HS;

	return 0;
}

static int mmc_startup(struct mmc *mmc) {
21083bf4:	defedf04 	addi	sp,sp,-1156
	char ext_csd[512];
	char test_csd[512];
	int timeout = 1000;

	/* Put the Card in Identify Mode */
	cmd.cmdidx = MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
21083bf8:	00c00084 	movi	r3,2

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21083bfc:	20802417 	ldw	r2,144(r4)
	char ext_csd[512];
	char test_csd[512];
	int timeout = 1000;

	/* Put the Card in Identify Mode */
	cmd.cmdidx = MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
21083c00:	d8c1070d 	sth	r3,1052(sp)
	cmd.resp_type = MMC_RSP_R2;
21083c04:	00c001c4 	movi	r3,7
		mmc->card_caps |= MMC_MODE_HS;

	return 0;
}

static int mmc_startup(struct mmc *mmc) {
21083c08:	dc011715 	stw	r16,1116(sp)
21083c0c:	dfc12015 	stw	ra,1152(sp)
21083c10:	df011f15 	stw	fp,1148(sp)
21083c14:	ddc11e15 	stw	r23,1144(sp)
21083c18:	dd811d15 	stw	r22,1140(sp)
21083c1c:	dd411c15 	stw	r21,1136(sp)
21083c20:	dd011b15 	stw	r20,1132(sp)
21083c24:	dcc11a15 	stw	r19,1128(sp)
21083c28:	dc811915 	stw	r18,1124(sp)
21083c2c:	dc411815 	stw	r17,1120(sp)
	char test_csd[512];
	int timeout = 1000;

	/* Put the Card in Identify Mode */
	cmd.cmdidx = MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
	cmd.resp_type = MMC_RSP_R2;
21083c30:	d8c10815 	stw	r3,1056(sp)
	cmd.cmdarg = 0;
21083c34:	d8010915 	stw	zero,1060(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21083c38:	d9410704 	addi	r5,sp,1052
21083c3c:	000d883a 	mov	r6,zero
		mmc->card_caps |= MMC_MODE_HS;

	return 0;
}

static int mmc_startup(struct mmc *mmc) {
21083c40:	2021883a 	mov	r16,r4

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21083c44:	103ee83a 	callr	r2
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = 0;

	err = mmc_send_cmd(mmc, &cmd, NULL);

	if (err)
21083c48:	10000c26 	beq	r2,zero,21083c7c <mmc_startup+0x88>
	}

	mmc_set_clock(mmc, mmc->tran_speed);

	return 0;
}
21083c4c:	dfc12017 	ldw	ra,1152(sp)
21083c50:	df011f17 	ldw	fp,1148(sp)
21083c54:	ddc11e17 	ldw	r23,1144(sp)
21083c58:	dd811d17 	ldw	r22,1140(sp)
21083c5c:	dd411c17 	ldw	r21,1136(sp)
21083c60:	dd011b17 	ldw	r20,1132(sp)
21083c64:	dcc11a17 	ldw	r19,1128(sp)
21083c68:	dc811917 	ldw	r18,1124(sp)
21083c6c:	dc411817 	ldw	r17,1120(sp)
21083c70:	dc011717 	ldw	r16,1116(sp)
21083c74:	dec12104 	addi	sp,sp,1156
21083c78:	f800283a 	ret
	err = mmc_send_cmd(mmc, &cmd, NULL);

	if (err)
		return err;

	memcpy(mmc->cid, cmd.response, 16);
21083c7c:	81001a04 	addi	r4,r16,104
21083c80:	d9410a04 	addi	r5,sp,1064
21083c84:	01800404 	movi	r6,16
21083c88:	108e1340 	call	2108e134 <memcpy>
	 * For MMC cards, set the Relative Address.
	 * For SD cards, get the Relatvie Address.
	 * This also puts the cards into Standby State
	 */
	cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
	cmd.cmdarg = mmc->rca << 16;
21083c8c:	80801e0b 	ldhu	r2,120(r16)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21083c90:	80c02417 	ldw	r3,144(r16)
	/*
	 * For MMC cards, set the Relative Address.
	 * For SD cards, get the Relatvie Address.
	 * This also puts the cards into Standby State
	 */
	cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
21083c94:	010000c4 	movi	r4,3
	cmd.cmdarg = mmc->rca << 16;
21083c98:	1004943a 	slli	r2,r2,16
	/*
	 * For MMC cards, set the Relative Address.
	 * For SD cards, get the Relatvie Address.
	 * This also puts the cards into Standby State
	 */
	cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
21083c9c:	d901070d 	sth	r4,1052(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21083ca0:	d9410704 	addi	r5,sp,1052
	 * For MMC cards, set the Relative Address.
	 * For SD cards, get the Relatvie Address.
	 * This also puts the cards into Standby State
	 */
	cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
	cmd.cmdarg = mmc->rca << 16;
21083ca4:	d8810915 	stw	r2,1060(sp)
	cmd.resp_type = MMC_RSP_R6;
21083ca8:	00800544 	movi	r2,21
21083cac:	d8810815 	stw	r2,1056(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21083cb0:	8009883a 	mov	r4,r16
21083cb4:	000d883a 	mov	r6,zero
21083cb8:	183ee83a 	callr	r3
	cmd.cmdarg = mmc->rca << 16;
	cmd.resp_type = MMC_RSP_R6;

	err = mmc_send_cmd(mmc, &cmd, NULL);

	if (err)
21083cbc:	103fe31e 	bne	r2,zero,21083c4c <__flash_rwdata_start+0xfffe1a04>
		return err;

	if (IS_SD(mmc))
21083cc0:	80800a17 	ldw	r2,40(r16)
21083cc4:	108000ac 	andhi	r2,r2,2
21083cc8:	1000751e 	bne	r2,zero,21083ea0 <mmc_startup+0x2ac>
21083ccc:	80801e0b 	ldhu	r2,120(r16)
		mmc->rca = (cmd.response[0] >> 16) & 0xffff;

	/* Get the Card-Specific Data */
	cmd.cmdidx = MMC_CMD_SEND_CSD;
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = mmc->rca << 16;
21083cd0:	1004943a 	slli	r2,r2,16

	if (IS_SD(mmc))
		mmc->rca = (cmd.response[0] >> 16) & 0xffff;

	/* Get the Card-Specific Data */
	cmd.cmdidx = MMC_CMD_SEND_CSD;
21083cd4:	01000244 	movi	r4,9

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21083cd8:	80c02417 	ldw	r3,144(r16)

	if (IS_SD(mmc))
		mmc->rca = (cmd.response[0] >> 16) & 0xffff;

	/* Get the Card-Specific Data */
	cmd.cmdidx = MMC_CMD_SEND_CSD;
21083cdc:	d901070d 	sth	r4,1052(sp)
	cmd.resp_type = MMC_RSP_R2;
21083ce0:	010001c4 	movi	r4,7
21083ce4:	d9010815 	stw	r4,1056(sp)
	cmd.cmdarg = mmc->rca << 16;
21083ce8:	d8810915 	stw	r2,1060(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21083cec:	8009883a 	mov	r4,r16
21083cf0:	d9410704 	addi	r5,sp,1052
21083cf4:	000d883a 	mov	r6,zero
21083cf8:	183ee83a 	callr	r3
21083cfc:	1023883a 	mov	r17,r2
	cmd.cmdarg = mmc->rca << 16;

	err = mmc_send_cmd(mmc, &cmd, NULL);

	/* Waiting for the ready status */
	mmc_send_status(mmc, timeout);
21083d00:	8009883a 	mov	r4,r16
21083d04:	1083ad00 	call	21083ad0 <mmc_send_status.constprop.4>

	if (err)
21083d08:	8800691e 	bne	r17,zero,21083eb0 <mmc_startup+0x2bc>
		return err;

	mmc->csd[0] = cmd.response[0];
21083d0c:	d8810a17 	ldw	r2,1064(sp)
	mmc->csd[1] = cmd.response[1];
21083d10:	d9810b17 	ldw	r6,1068(sp)
	mmc->csd[2] = cmd.response[2];
21083d14:	d8c10c17 	ldw	r3,1072(sp)
	mmc->csd[3] = cmd.response[3];
21083d18:	d9c10d17 	ldw	r7,1076(sp)

	if (mmc->version == MMC_VERSION_UNKNOWN) {
21083d1c:	81000a17 	ldw	r4,40(r16)
	mmc_send_status(mmc, timeout);

	if (err)
		return err;

	mmc->csd[0] = cmd.response[0];
21083d20:	80801615 	stw	r2,88(r16)
	mmc->csd[1] = cmd.response[1];
21083d24:	81801715 	stw	r6,92(r16)
	mmc->csd[2] = cmd.response[2];
21083d28:	80c01815 	stw	r3,96(r16)
	mmc->csd[3] = cmd.response[3];
21083d2c:	81c01915 	stw	r7,100(r16)

	if (mmc->version == MMC_VERSION_UNKNOWN) {
21083d30:	01400074 	movhi	r5,1
21083d34:	21409726 	beq	r4,r5,21083f94 <mmc_startup+0x3a0>
21083d38:	220000ac 	andhi	r8,r4,2
		}
	}

	/* divide frequency by 10, since the mults are 10x bigger */
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];
21083d3c:	1008d07a 	srli	r4,r2,1
21083d40:	01400034 	movhi	r5,0
21083d44:	29412604 	addi	r5,r5,1176
			break;
		}
	}

	/* divide frequency by 10, since the mults are 10x bigger */
	freq = fbase[(cmd.response[0] & 0x7)];
21083d48:	108001cc 	andi	r2,r2,7
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];
21083d4c:	21000f0c 	andi	r4,r4,60
21083d50:	2909883a 	add	r4,r5,r4
			break;
		}
	}

	/* divide frequency by 10, since the mults are 10x bigger */
	freq = fbase[(cmd.response[0] & 0x7)];
21083d54:	1085883a 	add	r2,r2,r2
21083d58:	01400034 	movhi	r5,0
21083d5c:	29413604 	addi	r5,r5,1240
21083d60:	1085883a 	add	r2,r2,r2
21083d64:	2885883a 	add	r2,r5,r2
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
21083d68:	300ad43a 	srli	r5,r6,16

	/* divide frequency by 10, since the mults are 10x bigger */
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;
21083d6c:	22400017 	ldw	r9,0(r4)
21083d70:	11000017 	ldw	r4,0(r2)

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
21083d74:	294003cc 	andi	r5,r5,15
21083d78:	00800044 	movi	r2,1

	/* divide frequency by 10, since the mults are 10x bigger */
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;
21083d7c:	4909383a 	mul	r4,r9,r4

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
21083d80:	114a983a 	sll	r5,r2,r5

	/* divide frequency by 10, since the mults are 10x bigger */
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;
21083d84:	81001f15 	stw	r4,124(r16)

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
21083d88:	81402015 	stw	r5,128(r16)

	if (IS_SD(mmc))
21083d8c:	40005326 	beq	r8,zero,21083edc <mmc_startup+0x2e8>
		mmc->write_bl_len = mmc->read_bl_len;
21083d90:	81402115 	stw	r5,132(r16)
21083d94:	280f883a 	mov	r7,r5
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);

	if (mmc->high_capacity) {
21083d98:	80800e17 	ldw	r2,56(r16)
21083d9c:	10004626 	beq	r2,zero,21083eb8 <mmc_startup+0x2c4>
		csize = (mmc->csd[1] & 0x3f) << 16 | (mmc->csd[2] & 0xffff0000) >> 16;
21083da0:	31800fcc 	andi	r6,r6,63
21083da4:	300c943a 	slli	r6,r6,16
21083da8:	1806d43a 	srli	r3,r3,16
21083dac:	00800284 	movi	r2,10
21083db0:	30c6b03a 	or	r3,r6,r3
	} else {
		csize = (mmc->csd[1] & 0x3ff) << 2 | (mmc->csd[2] & 0xc0000000) >> 30;
		cmult = (mmc->csd[2] & 0x00038000) >> 15;
	}

	mmc->capacity = (csize + 1) << (cmult + 2);
21083db4:	18c00044 	addi	r3,r3,1
21083db8:	1884983a 	sll	r2,r3,r2
	mmc->capacity *= mmc->read_bl_len;

	if (mmc->read_bl_len > 512)
21083dbc:	00c08004 	movi	r3,512
		csize = (mmc->csd[1] & 0x3ff) << 2 | (mmc->csd[2] & 0xc0000000) >> 30;
		cmult = (mmc->csd[2] & 0x00038000) >> 15;
	}

	mmc->capacity = (csize + 1) << (cmult + 2);
	mmc->capacity *= mmc->read_bl_len;
21083dc0:	1145383a 	mul	r2,r2,r5
21083dc4:	80802315 	stw	r2,140(r16)

	if (mmc->read_bl_len > 512)
21083dc8:	1940010e 	bge	r3,r5,21083dd0 <mmc_startup+0x1dc>
		mmc->read_bl_len = 512;
21083dcc:	80c02015 	stw	r3,128(r16)

	if (mmc->write_bl_len > 512)
21083dd0:	00808004 	movi	r2,512
21083dd4:	11c0012e 	bgeu	r2,r7,21083ddc <mmc_startup+0x1e8>
		mmc->write_bl_len = 512;
21083dd8:	80802115 	stw	r2,132(r16)

	/* Select the card, and put it into Transfer Mode */
	cmd.cmdidx = MMC_CMD_SELECT_CARD;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = mmc->rca << 16;
21083ddc:	80801e0b 	ldhu	r2,120(r16)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21083de0:	80c02417 	ldw	r3,144(r16)

	if (mmc->write_bl_len > 512)
		mmc->write_bl_len = 512;

	/* Select the card, and put it into Transfer Mode */
	cmd.cmdidx = MMC_CMD_SELECT_CARD;
21083de4:	010001c4 	movi	r4,7
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = mmc->rca << 16;
21083de8:	1004943a 	slli	r2,r2,16
	if (mmc->write_bl_len > 512)
		mmc->write_bl_len = 512;

	/* Select the card, and put it into Transfer Mode */
	cmd.cmdidx = MMC_CMD_SELECT_CARD;
	cmd.resp_type = MMC_RSP_R1;
21083dec:	04400544 	movi	r17,21

	if (mmc->write_bl_len > 512)
		mmc->write_bl_len = 512;

	/* Select the card, and put it into Transfer Mode */
	cmd.cmdidx = MMC_CMD_SELECT_CARD;
21083df0:	d901070d 	sth	r4,1052(sp)
	cmd.resp_type = MMC_RSP_R1;
21083df4:	dc410815 	stw	r17,1056(sp)
	cmd.cmdarg = mmc->rca << 16;
21083df8:	d8810915 	stw	r2,1060(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21083dfc:	8009883a 	mov	r4,r16
21083e00:	d9410704 	addi	r5,sp,1052
21083e04:	000d883a 	mov	r6,zero
21083e08:	183ee83a 	callr	r3
	cmd.cmdidx = MMC_CMD_SELECT_CARD;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = mmc->rca << 16;
	err = mmc_send_cmd(mmc, &cmd, NULL);

	if (err)
21083e0c:	103f8f1e 	bne	r2,zero,21083c4c <__flash_rwdata_start+0xfffe1a04>
	/*
	 * For SD, its erase group is always one sector
	 */
	mmc->erase_grp_size = 1;
	mmc->part_config = MMCPART_NOAVAILABLE;
	if (!IS_SD(mmc) && (mmc->version >= MMC_VERSION_4)) {
21083e10:	80800a17 	ldw	r2,40(r16)

	/*
	 * For SD, its erase group is always one sector
	 */
	mmc->erase_grp_size = 1;
	mmc->part_config = MMCPART_NOAVAILABLE;
21083e14:	013fffc4 	movi	r4,-1
		return err;

	/*
	 * For SD, its erase group is always one sector
	 */
	mmc->erase_grp_size = 1;
21083e18:	00c00044 	movi	r3,1
	mmc->part_config = MMCPART_NOAVAILABLE;
21083e1c:	81001e85 	stb	r4,122(r16)
		return err;

	/*
	 * For SD, its erase group is always one sector
	 */
	mmc->erase_grp_size = 1;
21083e20:	80c02215 	stw	r3,136(r16)
	mmc->part_config = MMCPART_NOAVAILABLE;
	if (!IS_SD(mmc) && (mmc->version >= MMC_VERSION_4)) {
21083e24:	110000ac 	andhi	r4,r2,2
21083e28:	2000311e 	bne	r4,zero,21083ef0 <mmc_startup+0x2fc>
21083e2c:	01000074 	movhi	r4,1
21083e30:	21000fc4 	addi	r4,r4,63
21083e34:	2080cb36 	bltu	r4,r2,21084164 <mmc_startup+0x570>
static int mmc_change_freq(struct mmc *mmc) {
	char ext_csd[512];
	char cardtype;
	int err;

	mmc->card_caps = 0;
21083e38:	80001115 	stw	zero,68(r16)
21083e3c:	0007883a 	mov	r3,zero

	if (err)
		return err;

	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;
21083e40:	85c01217 	ldw	r23,72(r16)

	if (IS_SD(mmc)) {
21083e44:	108000ac 	andhi	r2,r2,2

	if (err)
		return err;

	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;
21083e48:	b8c6703a 	and	r3,r23,r3
21083e4c:	80c01115 	stw	r3,68(r16)

	if (IS_SD(mmc)) {
21083e50:	10007426 	beq	r2,zero,21084024 <mmc_startup+0x430>
		if (mmc->card_caps & MMC_MODE_4BIT) {
21083e54:	1880400c 	andi	r2,r3,256
21083e58:	1001371e 	bne	r2,zero,21084338 <mmc_startup+0x744>
				return err;

			mmc_set_bus_width(mmc, 4);
		}

		if (mmc->card_caps & MMC_MODE_HS)
21083e5c:	18c0004c 	andi	r3,r3,1
21083e60:	18012b26 	beq	r3,zero,21084310 <mmc_startup+0x71c>
			mmc->tran_speed = 50000000;
21083e64:	0080bef4 	movhi	r2,763
21083e68:	10bc2004 	addi	r2,r2,-3968
21083e6c:	80801f15 	stw	r2,124(r16)

	mmc_set_ios(mmc);
}

static void mmc_set_clock(struct mmc *mmc, uint clock) {
	if (clock > mmc->f_max)
21083e70:	80c00d17 	ldw	r3,52(r16)
21083e74:	1880012e 	bgeu	r3,r2,21083e7c <mmc_startup+0x288>
21083e78:	1805883a 	mov	r2,r3
		clock = mmc->f_max;

	if (clock < mmc->f_min)
21083e7c:	80c00c17 	ldw	r3,48(r16)
21083e80:	10c0012e 	bgeu	r2,r3,21083e88 <mmc_startup+0x294>
21083e84:	1805883a 	mov	r2,r3
 */
static const int multipliers[] = { 0, /* reserved */
10, 12, 13, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 70, 80, };

static void mmc_set_ios(struct mmc *mmc) {
	mmc->set_ios(mmc);
21083e88:	80c02517 	ldw	r3,148(r16)
		clock = mmc->f_max;

	if (clock < mmc->f_min)
		clock = mmc->f_min;

	mmc->clock = clock;
21083e8c:	80801015 	stw	r2,64(r16)
 */
static const int multipliers[] = { 0, /* reserved */
10, 12, 13, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 70, 80, };

static void mmc_set_ios(struct mmc *mmc) {
	mmc->set_ios(mmc);
21083e90:	8009883a 	mov	r4,r16
21083e94:	183ee83a 	callr	r3
		}
	}

	mmc_set_clock(mmc, mmc->tran_speed);

	return 0;
21083e98:	0005883a 	mov	r2,zero
21083e9c:	003f6b06 	br	21083c4c <__flash_rwdata_start+0xfffe1a04>

	if (err)
		return err;

	if (IS_SD(mmc))
		mmc->rca = (cmd.response[0] >> 16) & 0xffff;
21083ea0:	d8c10a8b 	ldhu	r3,1066(sp)
21083ea4:	1805883a 	mov	r2,r3
21083ea8:	80c01e0d 	sth	r3,120(r16)
21083eac:	003f8806 	br	21083cd0 <__flash_rwdata_start+0xfffe1a88>
21083eb0:	8805883a 	mov	r2,r17
21083eb4:	003f6506 	br	21083c4c <__flash_rwdata_start+0xfffe1a04>
	if (mmc->high_capacity) {
		csize = (mmc->csd[1] & 0x3f) << 16 | (mmc->csd[2] & 0xffff0000) >> 16;
		cmult = 8;
	} else {
		csize = (mmc->csd[1] & 0x3ff) << 2 | (mmc->csd[2] & 0xc0000000) >> 30;
		cmult = (mmc->csd[2] & 0x00038000) >> 15;
21083eb8:	1804d3fa 	srli	r2,r3,15

	if (mmc->high_capacity) {
		csize = (mmc->csd[1] & 0x3f) << 16 | (mmc->csd[2] & 0xffff0000) >> 16;
		cmult = 8;
	} else {
		csize = (mmc->csd[1] & 0x3ff) << 2 | (mmc->csd[2] & 0xc0000000) >> 30;
21083ebc:	1808d7ba 	srli	r4,r3,30
21083ec0:	3180ffcc 	andi	r6,r6,1023
21083ec4:	3187883a 	add	r3,r6,r6
21083ec8:	18c7883a 	add	r3,r3,r3
		cmult = (mmc->csd[2] & 0x00038000) >> 15;
21083ecc:	108001cc 	andi	r2,r2,7

	if (mmc->high_capacity) {
		csize = (mmc->csd[1] & 0x3f) << 16 | (mmc->csd[2] & 0xffff0000) >> 16;
		cmult = 8;
	} else {
		csize = (mmc->csd[1] & 0x3ff) << 2 | (mmc->csd[2] & 0xc0000000) >> 30;
21083ed0:	1906b03a 	or	r3,r3,r4
21083ed4:	10800084 	addi	r2,r2,2
21083ed8:	003fb606 	br	21083db4 <__flash_rwdata_start+0xfffe1b6c>
	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);

	if (IS_SD(mmc))
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);
21083edc:	380ed5ba 	srli	r7,r7,22
21083ee0:	39c003cc 	andi	r7,r7,15
21083ee4:	11ce983a 	sll	r7,r2,r7
21083ee8:	81c02115 	stw	r7,132(r16)
21083eec:	003faa06 	br	21083d98 <__flash_rwdata_start+0xfffe1b50>
21083ef0:	dc810004 	addi	r18,sp,1024
	struct mmc_cmd cmd;
	static uint switch_status[16];
	struct mmc_data data;
	int timeout;

	uint* scr = alt_uncached_malloc(8);
21083ef4:	01000204 	movi	r4,8
21083ef8:	109b7f40 	call	2109b7f4 <alt_uncached_malloc>
	mmc->card_caps = 0;

	/* Read the SCR to find out if this card supports higher speeds */
	cmd.cmdidx = MMC_CMD_APP_CMD;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = mmc->rca << 16;
21083efc:	80c01e0b 	ldhu	r3,120(r16)
	struct mmc_cmd cmd;
	static uint switch_status[16];
	struct mmc_data data;
	int timeout;

	uint* scr = alt_uncached_malloc(8);
21083f00:	1029883a 	mov	r20,r2

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21083f04:	80802417 	ldw	r2,144(r16)
	mmc->card_caps = 0;

	/* Read the SCR to find out if this card supports higher speeds */
	cmd.cmdidx = MMC_CMD_APP_CMD;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = mmc->rca << 16;
21083f08:	1806943a 	slli	r3,r3,16

	uint* scr = alt_uncached_malloc(8);
	mmc->card_caps = 0;

	/* Read the SCR to find out if this card supports higher speeds */
	cmd.cmdidx = MMC_CMD_APP_CMD;
21083f0c:	01000dc4 	movi	r4,55
	cmd.resp_type = MMC_RSP_R1;
21083f10:	04400544 	movi	r17,21

	uint* scr = alt_uncached_malloc(8);
	mmc->card_caps = 0;

	/* Read the SCR to find out if this card supports higher speeds */
	cmd.cmdidx = MMC_CMD_APP_CMD;
21083f14:	d901000d 	sth	r4,1024(sp)
	static uint switch_status[16];
	struct mmc_data data;
	int timeout;

	uint* scr = alt_uncached_malloc(8);
	mmc->card_caps = 0;
21083f18:	80001115 	stw	zero,68(r16)

	/* Read the SCR to find out if this card supports higher speeds */
	cmd.cmdidx = MMC_CMD_APP_CMD;
	cmd.resp_type = MMC_RSP_R1;
21083f1c:	dc410115 	stw	r17,1028(sp)
	cmd.cmdarg = mmc->rca << 16;
21083f20:	d8c10215 	stw	r3,1032(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21083f24:	8009883a 	mov	r4,r16
21083f28:	900b883a 	mov	r5,r18
21083f2c:	000d883a 	mov	r6,zero
21083f30:	103ee83a 	callr	r2
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = mmc->rca << 16;

	err = mmc_send_cmd(mmc, &cmd, NULL);

	if (err)
21083f34:	103f451e 	bne	r2,zero,21083c4c <__flash_rwdata_start+0xfffe1a04>
		return err;

	cmd.cmdidx = SD_CMD_APP_SEND_SCR;
21083f38:	00800cc4 	movi	r2,51
	cmd.resp_type = MMC_RSP_R1;
21083f3c:	dc410115 	stw	r17,1028(sp)
	err = mmc_send_cmd(mmc, &cmd, NULL);

	if (err)
		return err;

	cmd.cmdidx = SD_CMD_APP_SEND_SCR;
21083f40:	d881000d 	sth	r2,1024(sp)
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = 0;
21083f44:	d8010215 	stw	zero,1032(sp)
21083f48:	04400104 	movi	r17,4

	timeout = 3;

	retry_scr: data.dest = (char *) scr;
	data.blocksize = 8;
21083f4c:	05400204 	movi	r21,8
	data.blocks = 1;
21083f50:	04c00044 	movi	r19,1

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21083f54:	80c02417 	ldw	r3,144(r16)
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = 0;

	timeout = 3;

	retry_scr: data.dest = (char *) scr;
21083f58:	dd011215 	stw	r20,1096(sp)
	data.blocksize = 8;
21083f5c:	dd411515 	stw	r21,1108(sp)
	data.blocks = 1;
21083f60:	dcc11415 	stw	r19,1104(sp)
	data.flags = MMC_DATA_READ;
21083f64:	dcc11315 	stw	r19,1100(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21083f68:	8009883a 	mov	r4,r16
21083f6c:	900b883a 	mov	r5,r18
21083f70:	d9811204 	addi	r6,sp,1096
21083f74:	183ee83a 	callr	r3
	data.blocks = 1;
	data.flags = MMC_DATA_READ;

	err = mmc_send_cmd(mmc, &cmd, &data);

	if (err) {
21083f78:	10012026 	beq	r2,zero,210843fc <mmc_startup+0x808>
21083f7c:	8c7fffc4 	addi	r17,r17,-1
		if (timeout--)
21083f80:	883ff41e 	bne	r17,zero,21083f54 <__flash_rwdata_start+0xfffe1d0c>
	if (IS_SD(mmc))
		err = sd_change_freq(mmc);
	else
		err = mmc_change_freq(mmc);

	if (err)
21083f84:	103f311e 	bne	r2,zero,21083c4c <__flash_rwdata_start+0xfffe1a04>
21083f88:	80800a17 	ldw	r2,40(r16)
21083f8c:	80c01117 	ldw	r3,68(r16)
21083f90:	003fab06 	br	21083e40 <__flash_rwdata_start+0xfffe1bf8>
	mmc->csd[1] = cmd.response[1];
	mmc->csd[2] = cmd.response[2];
	mmc->csd[3] = cmd.response[3];

	if (mmc->version == MMC_VERSION_UNKNOWN) {
		int version = (cmd.response[0] >> 26) & 0xf;
21083f94:	100ad6ba 	srli	r5,r2,26

		switch (version) {
21083f98:	02000104 	movi	r8,4
	mmc->csd[1] = cmd.response[1];
	mmc->csd[2] = cmd.response[2];
	mmc->csd[3] = cmd.response[3];

	if (mmc->version == MMC_VERSION_UNKNOWN) {
		int version = (cmd.response[0] >> 26) & 0xf;
21083f9c:	294003cc 	andi	r5,r5,15

		switch (version) {
21083fa0:	41410436 	bltu	r8,r5,210843b4 <mmc_startup+0x7c0>
21083fa4:	280a90ba 	slli	r5,r5,2
21083fa8:	01084234 	movhi	r4,8456
21083fac:	210ff004 	addi	r4,r4,16320
21083fb0:	290b883a 	add	r5,r5,r4
21083fb4:	29000017 	ldw	r4,0(r5)
		case 3:
			mmc->version = MMC_VERSION_3;
			break;
		case 4:
			mmc->version = MMC_VERSION_4;
			break;
21083fb8:	0011883a 	mov	r8,zero
	mmc->csd[3] = cmd.response[3];

	if (mmc->version == MMC_VERSION_UNKNOWN) {
		int version = (cmd.response[0] >> 26) & 0xf;

		switch (version) {
21083fbc:	2000683a 	jmp	r4
21083fc0:	21084004 	addi	r4,r4,8448
21083fc4:	21083ff4 	orhi	r4,r4,8447
21083fc8:	21083fe4 	muli	r4,r4,8447
21083fcc:	21083fd4 	ori	r4,r4,8447
21083fd0:	21084014 	ori	r4,r4,8448
			break;
		case 2:
			mmc->version = MMC_VERSION_2_2;
			break;
		case 3:
			mmc->version = MMC_VERSION_3;
21083fd4:	01000074 	movhi	r4,1
21083fd8:	21000c04 	addi	r4,r4,48
21083fdc:	81000a15 	stw	r4,40(r16)
			break;
21083fe0:	003f5606 	br	21083d3c <__flash_rwdata_start+0xfffe1af4>
			break;
		case 1:
			mmc->version = MMC_VERSION_1_4;
			break;
		case 2:
			mmc->version = MMC_VERSION_2_2;
21083fe4:	01000074 	movhi	r4,1
21083fe8:	21000884 	addi	r4,r4,34
21083fec:	81000a15 	stw	r4,40(r16)
			break;
21083ff0:	003f5206 	br	21083d3c <__flash_rwdata_start+0xfffe1af4>
		switch (version) {
		case 0:
			mmc->version = MMC_VERSION_1_2;
			break;
		case 1:
			mmc->version = MMC_VERSION_1_4;
21083ff4:	01000074 	movhi	r4,1
21083ff8:	21000504 	addi	r4,r4,20
21083ffc:	81000a15 	stw	r4,40(r16)
			break;
21084000:	003f4e06 	br	21083d3c <__flash_rwdata_start+0xfffe1af4>
	if (mmc->version == MMC_VERSION_UNKNOWN) {
		int version = (cmd.response[0] >> 26) & 0xf;

		switch (version) {
		case 0:
			mmc->version = MMC_VERSION_1_2;
21084004:	01000074 	movhi	r4,1
21084008:	21000484 	addi	r4,r4,18
2108400c:	81000a15 	stw	r4,40(r16)
			break;
21084010:	003f4a06 	br	21083d3c <__flash_rwdata_start+0xfffe1af4>
			break;
		case 3:
			mmc->version = MMC_VERSION_3;
			break;
		case 4:
			mmc->version = MMC_VERSION_4;
21084014:	01000074 	movhi	r4,1
21084018:	21001004 	addi	r4,r4,64
2108401c:	81000a15 	stw	r4,40(r16)
			break;
21084020:	003f4606 	br	21083d3c <__flash_rwdata_start+0xfffe1af4>
		if (mmc->card_caps & MMC_MODE_HS)
			mmc->tran_speed = 50000000;
		else
			mmc->tran_speed = 25000000;
	} else {
		width = ((mmc->host_caps & MMC_MODE_MASK_WIDTH_BITS) >>
21084024:	bdc0c00c 	andi	r23,r23,768
21084028:	b82ed23a 	srli	r23,r23,8
2108402c:	dc810004 	addi	r18,sp,1024
static int mmc_switch(struct mmc *mmc, char set, char index, char value) {
	struct mmc_cmd cmd;
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
21084030:	05000184 	movi	r20,6
21084034:	bde3883a 	add	r17,r23,r23
21084038:	8c63883a 	add	r17,r17,r17
	cmd.resp_type = MMC_RSP_R1b;
2108403c:	04c00744 	movi	r19,29
	struct mmc_cmd cmd;
	struct mmc_data data;
	int err;

	/* Get the Card Status Register */
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
21084040:	05800204 	movi	r22,8
	cmd.resp_type = MMC_RSP_R1;
21084044:	05400544 	movi	r21,21
21084048:	00000406 	br	2108405c <mmc_startup+0x468>
		else
			mmc->tran_speed = 25000000;
	} else {
		width = ((mmc->host_caps & MMC_MODE_MASK_WIDTH_BITS) >>
		MMC_MODE_WIDTH_BITS_SHIFT);
		for (; width >= 0; width--) {
2108404c:	bdffffc4 	addi	r23,r23,-1
21084050:	00bfffc4 	movi	r2,-1
21084054:	8c7fff04 	addi	r17,r17,-4
21084058:	b8803a26 	beq	r23,r2,21084144 <mmc_startup+0x550>
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
	cmd.resp_type = MMC_RSP_R1b;
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) | (index << 16)
			| (value << 8);
2108405c:	b804923a 	slli	r2,r23,8

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084060:	80c02417 	ldw	r3,144(r16)
static int mmc_switch(struct mmc *mmc, char set, char index, char value) {
	struct mmc_cmd cmd;
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
21084064:	dd01000d 	sth	r20,1024(sp)
	cmd.resp_type = MMC_RSP_R1b;
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) | (index << 16)
			| (value << 8);
21084068:	10bfedf4 	orhi	r2,r2,65463
	struct mmc_cmd cmd;
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
	cmd.resp_type = MMC_RSP_R1b;
2108406c:	dcc10115 	stw	r19,1028(sp)
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) | (index << 16)
21084070:	d8810215 	stw	r2,1032(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084074:	8009883a 	mov	r4,r16
21084078:	900b883a 	mov	r5,r18
2108407c:	000d883a 	mov	r6,zero
21084080:	183ee83a 	callr	r3
			| (value << 8);

	ret = mmc_send_cmd(mmc, &cmd, NULL);

	/* Waiting for the ready status */
	if (!ret)
21084084:	103ff11e 	bne	r2,zero,2108404c <__flash_rwdata_start+0xfffe1e04>
		ret = mmc_send_status(mmc, timeout);
21084088:	8009883a 	mov	r4,r16
2108408c:	1083ad00 	call	21083ad0 <mmc_send_status.constprop.4>
		for (; width >= 0; width--) {
			/* Set the card to use 4 bit*/
			err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
			EXT_CSD_BUS_WIDTH, width);

			if (err)
21084090:	103fee1e 	bne	r2,zero,2108404c <__flash_rwdata_start+0xfffe1e04>
 */
static const int multipliers[] = { 0, /* reserved */
10, 12, 13, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 70, 80, };

static void mmc_set_ios(struct mmc *mmc) {
	mmc->set_ios(mmc);
21084094:	80802517 	ldw	r2,148(r16)
			EXT_CSD_BUS_WIDTH, width);

			if (err)
				continue;

			if (!width) {
21084098:	b800a126 	beq	r23,zero,21084320 <mmc_startup+0x72c>
 */
static const int multipliers[] = { 0, /* reserved */
10, 12, 13, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 70, 80, };

static void mmc_set_ios(struct mmc *mmc) {
	mmc->set_ios(mmc);
2108409c:	8009883a 	mov	r4,r16
}

static void mmc_set_bus_width(struct mmc *mmc, uint width) {
	mmc->bus_width = width;
210840a0:	84400f15 	stw	r17,60(r16)
 */
static const int multipliers[] = { 0, /* reserved */
10, 12, 13, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 70, 80, };

static void mmc_set_ios(struct mmc *mmc) {
	mmc->set_ios(mmc);
210840a4:	103ee83a 	callr	r2

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
210840a8:	80c02417 	ldw	r3,144(r16)
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = 0;

	data.dest = (char *) ext_csd;
	data.blocks = 1;
210840ac:	00800044 	movi	r2,1
	data.blocksize = 512;
210840b0:	01008004 	movi	r4,512
210840b4:	d9011115 	stw	r4,1092(sp)
	struct mmc_cmd cmd;
	struct mmc_data data;
	int err;

	/* Get the Card Status Register */
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
210840b8:	dd81000d 	sth	r22,1024(sp)
	cmd.resp_type = MMC_RSP_R1;
210840bc:	dd410115 	stw	r21,1028(sp)
	cmd.cmdarg = 0;
210840c0:	d8010215 	stw	zero,1032(sp)

	data.dest = (char *) ext_csd;
210840c4:	dec10e15 	stw	sp,1080(sp)
	data.blocks = 1;
210840c8:	d8811015 	stw	r2,1088(sp)
	data.blocksize = 512;
	data.flags = MMC_DATA_READ;
210840cc:	d8810f15 	stw	r2,1084(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
210840d0:	8009883a 	mov	r4,r16
210840d4:	900b883a 	mov	r5,r18
210840d8:	d9810e04 	addi	r6,sp,1080
210840dc:	183ee83a 	callr	r3
				break;
			} else
				mmc_set_bus_width(mmc, 4 * width);

			err = mmc_send_ext_csd(mmc, test_csd);
			if (!err
210840e0:	103fda1e 	bne	r2,zero,2108404c <__flash_rwdata_start+0xfffe1e04>
					&& ext_csd[EXT_CSD_PARTITIONING_SUPPORT]
210840e4:	d8c0a807 	ldb	r3,672(sp)
210840e8:	d8802807 	ldb	r2,160(sp)
210840ec:	18bfd71e 	bne	r3,r2,2108404c <__flash_rwdata_start+0xfffe1e04>
							== test_csd[EXT_CSD_PARTITIONING_SUPPORT]
					&& ext_csd[EXT_CSD_ERASE_GROUP_DEF]
210840f0:	d8c0abc7 	ldb	r3,687(sp)
210840f4:	d8802bc7 	ldb	r2,175(sp)
210840f8:	18bfd41e 	bne	r3,r2,2108404c <__flash_rwdata_start+0xfffe1e04>
							== test_csd[EXT_CSD_ERASE_GROUP_DEF]
					&& ext_csd[EXT_CSD_REV] == test_csd[EXT_CSD_REV]
210840fc:	d8c0b007 	ldb	r3,704(sp)
21084100:	d8803007 	ldb	r2,192(sp)
21084104:	18bfd11e 	bne	r3,r2,2108404c <__flash_rwdata_start+0xfffe1e04>
					&& ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
21084108:	d8c0b807 	ldb	r3,736(sp)
2108410c:	d8803807 	ldb	r2,224(sp)
21084110:	18bfce1e 	bne	r3,r2,2108404c <__flash_rwdata_start+0xfffe1e04>
							== test_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
					&& memcmp(&ext_csd[EXT_CSD_SEC_CNT],
21084114:	d900b504 	addi	r4,sp,724
21084118:	d9403504 	addi	r5,sp,212
2108411c:	01800104 	movi	r6,4
21084120:	108e0b80 	call	2108e0b8 <memcmp>
21084124:	103fc91e 	bne	r2,zero,2108404c <__flash_rwdata_start+0xfffe1e04>
							&test_csd[EXT_CSD_SEC_CNT], 4) == 0) {

				mmc->card_caps |= width;
21084128:	80c01117 	ldw	r3,68(r16)
2108412c:	1dc6b03a 	or	r3,r3,r23
21084130:	80c01115 	stw	r3,68(r16)
				break;
			}
		}

		if (mmc->card_caps & MMC_MODE_HS) {
21084134:	1880004c 	andi	r2,r3,1
21084138:	1000041e 	bne	r2,zero,2108414c <mmc_startup+0x558>
2108413c:	80801f17 	ldw	r2,124(r16)
21084140:	003f4b06 	br	21083e70 <__flash_rwdata_start+0xfffe1c28>
21084144:	80c01117 	ldw	r3,68(r16)
21084148:	003ffa06 	br	21084134 <__flash_rwdata_start+0xfffe1eec>
			if (mmc->card_caps & MMC_MODE_HS_52MHz)
2108414c:	18c0040c 	andi	r3,r3,16
21084150:	18009c26 	beq	r3,zero,210843c4 <mmc_startup+0x7d0>
				mmc->tran_speed = 52000000;
21084154:	0080c674 	movhi	r2,793
21084158:	109d4004 	addi	r2,r2,29952
2108415c:	80801f15 	stw	r2,124(r16)
21084160:	003f4306 	br	21083e70 <__flash_rwdata_start+0xfffe1c28>
	struct mmc_cmd cmd;
	struct mmc_data data;
	int err;

	/* Get the Card Status Register */
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
21084164:	01000204 	movi	r4,8
21084168:	d900000d 	sth	r4,0(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
2108416c:	80802417 	ldw	r2,144(r16)
	/* Get the Card Status Register */
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = 0;

	data.dest = (char *) ext_csd;
21084170:	d9008004 	addi	r4,sp,512

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084174:	dc810004 	addi	r18,sp,1024
	/* Get the Card Status Register */
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = 0;

	data.dest = (char *) ext_csd;
21084178:	d9010015 	stw	r4,1024(sp)
	data.blocks = 1;
	data.blocksize = 512;
2108417c:	01008004 	movi	r4,512
21084180:	d9010315 	stw	r4,1036(sp)
	struct mmc_data data;
	int err;

	/* Get the Card Status Register */
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
	cmd.resp_type = MMC_RSP_R1;
21084184:	dc400115 	stw	r17,4(sp)
	cmd.cmdarg = 0;
21084188:	d8000215 	stw	zero,8(sp)

	data.dest = (char *) ext_csd;
	data.blocks = 1;
2108418c:	d8c10215 	stw	r3,1032(sp)
	data.blocksize = 512;
	data.flags = MMC_DATA_READ;
21084190:	d8c10115 	stw	r3,1028(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084194:	8009883a 	mov	r4,r16
21084198:	d80b883a 	mov	r5,sp
2108419c:	900d883a 	mov	r6,r18
210841a0:	103ee83a 	callr	r2
	mmc->erase_grp_size = 1;
	mmc->part_config = MMCPART_NOAVAILABLE;
	if (!IS_SD(mmc) && (mmc->version >= MMC_VERSION_4)) {
		/* check  ext_csd version and capacity */
		err = mmc_send_ext_csd(mmc, ext_csd);
		if (!err & (ext_csd[EXT_CSD_REV] >= 2)) {
210841a4:	10000f1e 	bne	r2,zero,210841e4 <mmc_startup+0x5f0>
210841a8:	d880b007 	ldb	r2,704(sp)
210841ac:	10800088 	cmpgei	r2,r2,2
210841b0:	10000c26 	beq	r2,zero,210841e4 <mmc_startup+0x5f0>
			 * According to the JEDEC Standard, the value of
			 * ext_csd's capacity is valid if the value is more
			 * than 2GB
			 */
			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
210841b4:	d900b547 	ldb	r4,725(sp)
					| ext_csd[EXT_CSD_SEC_CNT + 2] << 16
210841b8:	d8c0b587 	ldb	r3,726(sp)
			/*
			 * According to the JEDEC Standard, the value of
			 * ext_csd's capacity is valid if the value is more
			 * than 2GB
			 */
			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
210841bc:	d880b507 	ldb	r2,724(sp)
					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
210841c0:	2008923a 	slli	r4,r4,8
					| ext_csd[EXT_CSD_SEC_CNT + 2] << 16
210841c4:	1806943a 	slli	r3,r3,16
210841c8:	20c6b03a 	or	r3,r4,r3
210841cc:	1884b03a 	or	r2,r3,r2
					| ext_csd[EXT_CSD_SEC_CNT + 3] << 24;
			capacity *= 512;
210841d0:	1004927a 	slli	r2,r2,9
			if ((capacity >> 20) > 2 * 1024)
210841d4:	01020004 	movi	r4,2048
210841d8:	1006d53a 	srli	r3,r2,20
210841dc:	20c0012e 	bgeu	r4,r3,210841e4 <mmc_startup+0x5f0>
				mmc->capacity = capacity;
210841e0:	80802315 	stw	r2,140(r16)
		/*
		 * Check whether GROUP_DEF is set, if yes, read out
		 * group size from ext_csd directly, or calculate
		 * the group size from the csd value.
		 */
		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF])
210841e4:	d880abc7 	ldb	r2,687(sp)
210841e8:	10007a26 	beq	r2,zero,210843d4 <mmc_startup+0x7e0>
			mmc->erase_grp_size = ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512
					* 1024;
210841ec:	d880b807 	ldb	r2,736(sp)
210841f0:	100494fa 	slli	r2,r2,19
		 * Check whether GROUP_DEF is set, if yes, read out
		 * group size from ext_csd directly, or calculate
		 * the group size from the csd value.
		 */
		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF])
			mmc->erase_grp_size = ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512
210841f4:	80802215 	stw	r2,136(r16)
			erase_gmul = (mmc->csd[2] & 0x000003e0) >> 5;
			mmc->erase_grp_size = (erase_gsz + 1) * (erase_gmul + 1);
		}

		/* store the partition info of emmc */
		if ((ext_csd[EXT_CSD_PARTITIONING_SUPPORT] & PART_SUPPORT)
210841f8:	d880a803 	ldbu	r2,672(sp)
210841fc:	1080004c 	andi	r2,r2,1
21084200:	1000021e 	bne	r2,zero,2108420c <mmc_startup+0x618>
				|| ext_csd[EXT_CSD_BOOT_MULT])
21084204:	d880b887 	ldb	r2,738(sp)
21084208:	10000226 	beq	r2,zero,21084214 <mmc_startup+0x620>
			mmc->part_config = ext_csd[EXT_CSD_PART_CONF];
2108420c:	d880acc3 	ldbu	r2,691(sp)
21084210:	80801e85 	stb	r2,122(r16)
	}

	if (IS_SD(mmc))
21084214:	80800a17 	ldw	r2,40(r16)
21084218:	10c000ac 	andhi	r3,r2,2
2108421c:	183f351e 	bne	r3,zero,21083ef4 <__flash_rwdata_start+0xfffe1cac>
	int err;

	mmc->card_caps = 0;

	/* Only version 4 supports high-speed */
	if (mmc->version < MMC_VERSION_4)
21084220:	00c00074 	movhi	r3,1
static int mmc_change_freq(struct mmc *mmc) {
	char ext_csd[512];
	char cardtype;
	int err;

	mmc->card_caps = 0;
21084224:	80001115 	stw	zero,68(r16)

	/* Only version 4 supports high-speed */
	if (mmc->version < MMC_VERSION_4)
21084228:	18c00fc4 	addi	r3,r3,63
2108422c:	18bf032e 	bgeu	r3,r2,21083e3c <__flash_rwdata_start+0xfffe1bf4>

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084230:	80802417 	ldw	r2,144(r16)
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = 0;

	data.dest = (char *) ext_csd;
	data.blocks = 1;
21084234:	05800044 	movi	r22,1
	struct mmc_cmd cmd;
	struct mmc_data data;
	int err;

	/* Get the Card Status Register */
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
21084238:	05000204 	movi	r20,8
	cmd.resp_type = MMC_RSP_R1;
2108423c:	04c00544 	movi	r19,21
	cmd.cmdarg = 0;

	data.dest = (char *) ext_csd;
	data.blocks = 1;
	data.blocksize = 512;
21084240:	04408004 	movi	r17,512
	struct mmc_cmd cmd;
	struct mmc_data data;
	int err;

	/* Get the Card Status Register */
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
21084244:	dd01000d 	sth	r20,1024(sp)
	cmd.resp_type = MMC_RSP_R1;
21084248:	dcc10115 	stw	r19,1028(sp)
	cmd.cmdarg = 0;
2108424c:	d8010215 	stw	zero,1032(sp)

	data.dest = (char *) ext_csd;
21084250:	dec10e15 	stw	sp,1080(sp)
	data.blocks = 1;
21084254:	dd811015 	stw	r22,1088(sp)
	data.blocksize = 512;
21084258:	dc411115 	stw	r17,1092(sp)
	data.flags = MMC_DATA_READ;
2108425c:	dd810f15 	stw	r22,1084(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084260:	8009883a 	mov	r4,r16
21084264:	900b883a 	mov	r5,r18
21084268:	d9810e04 	addi	r6,sp,1080
2108426c:	103ee83a 	callr	r2
	if (mmc->version < MMC_VERSION_4)
		return 0;

	err = mmc_send_ext_csd(mmc, ext_csd);

	if (err)
21084270:	103f441e 	bne	r2,zero,21083f84 <__flash_rwdata_start+0xfffe1d3c>
static int mmc_switch(struct mmc *mmc, char set, char index, char value) {
	struct mmc_cmd cmd;
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
21084274:	00c00184 	movi	r3,6
21084278:	d8c1000d 	sth	r3,1024(sp)
	cmd.resp_type = MMC_RSP_R1b;
2108427c:	00c00744 	movi	r3,29
21084280:	d8c10115 	stw	r3,1028(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084284:	80802417 	ldw	r2,144(r16)
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
	cmd.resp_type = MMC_RSP_R1b;
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) | (index << 16)
21084288:	00ffee74 	movhi	r3,65465
2108428c:	18c04004 	addi	r3,r3,256
21084290:	d8c10215 	stw	r3,1032(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084294:	8009883a 	mov	r4,r16
21084298:	900b883a 	mov	r5,r18
2108429c:	000d883a 	mov	r6,zero
	err = mmc_send_ext_csd(mmc, ext_csd);

	if (err)
		return err;

	cardtype = ext_csd[EXT_CSD_CARD_TYPE] & 0xf;
210842a0:	dd403103 	ldbu	r21,196(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
210842a4:	103ee83a 	callr	r2
			| (value << 8);

	ret = mmc_send_cmd(mmc, &cmd, NULL);

	/* Waiting for the ready status */
	if (!ret)
210842a8:	103f361e 	bne	r2,zero,21083f84 <__flash_rwdata_start+0xfffe1d3c>
		ret = mmc_send_status(mmc, timeout);
210842ac:	8009883a 	mov	r4,r16
210842b0:	1083ad00 	call	21083ad0 <mmc_send_status.constprop.4>

	cardtype = ext_csd[EXT_CSD_CARD_TYPE] & 0xf;

	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING, 1);

	if (err)
210842b4:	103f331e 	bne	r2,zero,21083f84 <__flash_rwdata_start+0xfffe1d3c>

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
210842b8:	80802417 	ldw	r2,144(r16)
	struct mmc_cmd cmd;
	struct mmc_data data;
	int err;

	/* Get the Card Status Register */
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
210842bc:	dd01000d 	sth	r20,1024(sp)
	cmd.resp_type = MMC_RSP_R1;
210842c0:	dcc10115 	stw	r19,1028(sp)
	cmd.cmdarg = 0;
210842c4:	d8010215 	stw	zero,1032(sp)

	data.dest = (char *) ext_csd;
210842c8:	dec10e15 	stw	sp,1080(sp)
	data.blocks = 1;
210842cc:	dd811015 	stw	r22,1088(sp)
	data.blocksize = 512;
210842d0:	dc411115 	stw	r17,1092(sp)
	data.flags = MMC_DATA_READ;
210842d4:	dd810f15 	stw	r22,1084(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
210842d8:	8009883a 	mov	r4,r16
210842dc:	900b883a 	mov	r5,r18
210842e0:	d9810e04 	addi	r6,sp,1080
210842e4:	103ee83a 	callr	r2
		return err;

	/* Now check to see that it worked */
	err = mmc_send_ext_csd(mmc, ext_csd);

	if (err)
210842e8:	103f261e 	bne	r2,zero,21083f84 <__flash_rwdata_start+0xfffe1d3c>
		return err;

	/* No high-speed support */
	if (!ext_csd[EXT_CSD_HS_TIMING])
210842ec:	d8802e47 	ldb	r2,185(sp)
210842f0:	103f2526 	beq	r2,zero,21083f88 <__flash_rwdata_start+0xfffe1d40>
		return 0;

	/* High Speed is set, there are two types: 52MHz and 26MHz */
	if (cardtype & MMC_HS_52MHZ)
210842f4:	ad40008c 	andi	r21,r21,2
		mmc->card_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
210842f8:	80c01117 	ldw	r3,68(r16)
210842fc:	80800a17 	ldw	r2,40(r16)
	/* No high-speed support */
	if (!ext_csd[EXT_CSD_HS_TIMING])
		return 0;

	/* High Speed is set, there are two types: 52MHz and 26MHz */
	if (cardtype & MMC_HS_52MHZ)
21084300:	a800d61e 	bne	r21,zero,2108465c <mmc_startup+0xa68>
		mmc->card_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
	else
		mmc->card_caps |= MMC_MODE_HS;
21084304:	18c00054 	ori	r3,r3,1
21084308:	80c01115 	stw	r3,68(r16)
2108430c:	003ecc06 	br	21083e40 <__flash_rwdata_start+0xfffe1bf8>
		}

		if (mmc->card_caps & MMC_MODE_HS)
			mmc->tran_speed = 50000000;
		else
			mmc->tran_speed = 25000000;
21084310:	00805f74 	movhi	r2,381
21084314:	109e1004 	addi	r2,r2,30784
21084318:	80801f15 	stw	r2,124(r16)
2108431c:	003ed406 	br	21083e70 <__flash_rwdata_start+0xfffe1c28>
static void mmc_set_ios(struct mmc *mmc) {
	mmc->set_ios(mmc);
}

static void mmc_set_bus_width(struct mmc *mmc, uint width) {
	mmc->bus_width = width;
21084320:	00c00044 	movi	r3,1
21084324:	80c00f15 	stw	r3,60(r16)
 */
static const int multipliers[] = { 0, /* reserved */
10, 12, 13, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 70, 80, };

static void mmc_set_ios(struct mmc *mmc) {
	mmc->set_ios(mmc);
21084328:	8009883a 	mov	r4,r16
2108432c:	103ee83a 	callr	r2
21084330:	80c01117 	ldw	r3,68(r16)
21084334:	003f7f06 	br	21084134 <__flash_rwdata_start+0xfffe1eec>

	if (IS_SD(mmc)) {
		if (mmc->card_caps & MMC_MODE_4BIT) {
			cmd.cmdidx = MMC_CMD_APP_CMD;
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = mmc->rca << 16;
21084338:	80801e0b 	ldhu	r2,120(r16)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
2108433c:	80c02417 	ldw	r3,144(r16)
	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;

	if (IS_SD(mmc)) {
		if (mmc->card_caps & MMC_MODE_4BIT) {
			cmd.cmdidx = MMC_CMD_APP_CMD;
21084340:	01000dc4 	movi	r4,55
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = mmc->rca << 16;
21084344:	1004943a 	slli	r2,r2,16
	mmc->card_caps &= mmc->host_caps;

	if (IS_SD(mmc)) {
		if (mmc->card_caps & MMC_MODE_4BIT) {
			cmd.cmdidx = MMC_CMD_APP_CMD;
			cmd.resp_type = MMC_RSP_R1;
21084348:	04400544 	movi	r17,21
	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;

	if (IS_SD(mmc)) {
		if (mmc->card_caps & MMC_MODE_4BIT) {
			cmd.cmdidx = MMC_CMD_APP_CMD;
2108434c:	d901070d 	sth	r4,1052(sp)
			cmd.resp_type = MMC_RSP_R1;
21084350:	dc410815 	stw	r17,1056(sp)
			cmd.cmdarg = mmc->rca << 16;
21084354:	d8810915 	stw	r2,1060(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084358:	8009883a 	mov	r4,r16
2108435c:	d9410704 	addi	r5,sp,1052
21084360:	000d883a 	mov	r6,zero
21084364:	183ee83a 	callr	r3
			cmd.cmdidx = MMC_CMD_APP_CMD;
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = mmc->rca << 16;

			err = mmc_send_cmd(mmc, &cmd, NULL);
			if (err)
21084368:	103e381e 	bne	r2,zero,21083c4c <__flash_rwdata_start+0xfffe1a04>
				return err;

			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
2108436c:	00c00184 	movi	r3,6

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084370:	80802417 	ldw	r2,144(r16)

			err = mmc_send_cmd(mmc, &cmd, NULL);
			if (err)
				return err;

			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
21084374:	d8c1070d 	sth	r3,1052(sp)
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = 2;
21084378:	00c00084 	movi	r3,2
			err = mmc_send_cmd(mmc, &cmd, NULL);
			if (err)
				return err;

			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
			cmd.resp_type = MMC_RSP_R1;
2108437c:	dc410815 	stw	r17,1056(sp)
			cmd.cmdarg = 2;
21084380:	d8c10915 	stw	r3,1060(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084384:	8009883a 	mov	r4,r16
21084388:	d9410704 	addi	r5,sp,1052
2108438c:	000d883a 	mov	r6,zero
21084390:	103ee83a 	callr	r2

			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = 2;
			err = mmc_send_cmd(mmc, &cmd, NULL);
			if (err)
21084394:	103e2d1e 	bne	r2,zero,21083c4c <__flash_rwdata_start+0xfffe1a04>
 */
static const int multipliers[] = { 0, /* reserved */
10, 12, 13, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 70, 80, };

static void mmc_set_ios(struct mmc *mmc) {
	mmc->set_ios(mmc);
21084398:	80802517 	ldw	r2,148(r16)
}

static void mmc_set_bus_width(struct mmc *mmc, uint width) {
	mmc->bus_width = width;
2108439c:	00c00104 	movi	r3,4
210843a0:	80c00f15 	stw	r3,60(r16)
 */
static const int multipliers[] = { 0, /* reserved */
10, 12, 13, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 70, 80, };

static void mmc_set_ios(struct mmc *mmc) {
	mmc->set_ios(mmc);
210843a4:	8009883a 	mov	r4,r16
210843a8:	103ee83a 	callr	r2
210843ac:	80c01117 	ldw	r3,68(r16)
210843b0:	003eaa06 	br	21083e5c <__flash_rwdata_start+0xfffe1c14>
			break;
		case 4:
			mmc->version = MMC_VERSION_4;
			break;
		default:
			mmc->version = MMC_VERSION_1_2;
210843b4:	21000484 	addi	r4,r4,18
210843b8:	81000a15 	stw	r4,40(r16)
			break;
210843bc:	0011883a 	mov	r8,zero
210843c0:	003e5e06 	br	21083d3c <__flash_rwdata_start+0xfffe1af4>

		if (mmc->card_caps & MMC_MODE_HS) {
			if (mmc->card_caps & MMC_MODE_HS_52MHz)
				mmc->tran_speed = 52000000;
			else
				mmc->tran_speed = 26000000;
210843c4:	00806374 	movhi	r2,397
210843c8:	10aea004 	addi	r2,r2,-17792
210843cc:	80801f15 	stw	r2,124(r16)
210843d0:	003ea706 	br	21083e70 <__flash_rwdata_start+0xfffe1c28>
		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF])
			mmc->erase_grp_size = ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512
					* 1024;
		else {
			int erase_gsz, erase_gmul;
			erase_gsz = (mmc->csd[2] & 0x00007c00) >> 10;
210843d4:	80801817 	ldw	r2,96(r16)
210843d8:	10df000c 	andi	r3,r2,31744
			erase_gmul = (mmc->csd[2] & 0x000003e0) >> 5;
210843dc:	1080f80c 	andi	r2,r2,992
		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF])
			mmc->erase_grp_size = ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512
					* 1024;
		else {
			int erase_gsz, erase_gmul;
			erase_gsz = (mmc->csd[2] & 0x00007c00) >> 10;
210843e0:	1806d2ba 	srli	r3,r3,10
			erase_gmul = (mmc->csd[2] & 0x000003e0) >> 5;
210843e4:	1004d17a 	srli	r2,r2,5
			mmc->erase_grp_size = (erase_gsz + 1) * (erase_gmul + 1);
210843e8:	18c00044 	addi	r3,r3,1
210843ec:	10800044 	addi	r2,r2,1
210843f0:	1885383a 	mul	r2,r3,r2
210843f4:	80802215 	stw	r2,136(r16)
210843f8:	003f7f06 	br	210841f8 <__flash_rwdata_start+0xfffe1fb0>
		return err;
	}

	uint b0, b1, b2, b3;

	b0 = (scr[0] & 0x000000ff) << 24;
210843fc:	a0800017 	ldw	r2,0(r20)
	b2 = (scr[1] & 0x00ff0000) >> 8;
	b3 = (scr[1] & 0xff000000) >> 24;

	mmc->scr[1] = b0 | b1 | b2 | b3;

	alt_uncached_free(scr);
21084400:	a009883a 	mov	r4,r20
	uint b0, b1, b2, b3;

	b0 = (scr[0] & 0x000000ff) << 24;
	b1 = (scr[0] & 0x0000ff00) << 8;
	b2 = (scr[0] & 0x00ff0000) >> 8;
	b3 = (scr[0] & 0xff000000) >> 24;
21084404:	100cd63a 	srli	r6,r2,24
		return err;
	}

	uint b0, b1, b2, b3;

	b0 = (scr[0] & 0x000000ff) << 24;
21084408:	100a963a 	slli	r5,r2,24
	b1 = (scr[0] & 0x0000ff00) << 8;
2108440c:	10ffc00c 	andi	r3,r2,65280
21084410:	1806923a 	slli	r3,r3,8
	b2 = (scr[0] & 0x00ff0000) >> 8;
21084414:	10803fec 	andhi	r2,r2,255
21084418:	1004d23a 	srli	r2,r2,8
2108441c:	314ab03a 	or	r5,r6,r5
21084420:	28c6b03a 	or	r3,r5,r3
	b3 = (scr[0] & 0xff000000) >> 24;

	mmc->scr[0] = b0 | b1 | b2 | b3;
21084424:	1884b03a 	or	r2,r3,r2
21084428:	80801415 	stw	r2,80(r16)

	b0 = (scr[1] & 0x000000ff) << 24;
2108442c:	a0800117 	ldw	r2,4(r20)
	b1 = (scr[1] & 0x0000ff00) << 8;
	b2 = (scr[1] & 0x00ff0000) >> 8;
	b3 = (scr[1] & 0xff000000) >> 24;
21084430:	100cd63a 	srli	r6,r2,24
	b2 = (scr[0] & 0x00ff0000) >> 8;
	b3 = (scr[0] & 0xff000000) >> 24;

	mmc->scr[0] = b0 | b1 | b2 | b3;

	b0 = (scr[1] & 0x000000ff) << 24;
21084434:	100a963a 	slli	r5,r2,24
	b1 = (scr[1] & 0x0000ff00) << 8;
21084438:	10ffc00c 	andi	r3,r2,65280
2108443c:	1806923a 	slli	r3,r3,8
	b2 = (scr[1] & 0x00ff0000) >> 8;
21084440:	10803fec 	andhi	r2,r2,255
21084444:	1004d23a 	srli	r2,r2,8
21084448:	314ab03a 	or	r5,r6,r5
2108444c:	28c6b03a 	or	r3,r5,r3
	b3 = (scr[1] & 0xff000000) >> 24;

	mmc->scr[1] = b0 | b1 | b2 | b3;
21084450:	1884b03a 	or	r2,r3,r2
21084454:	80801515 	stw	r2,84(r16)

	alt_uncached_free(scr);
21084458:	109b7e40 	call	2109b7e4 <alt_uncached_free>

	MMC_PRINT(("SCR: %08x\n\r", mmc->scr[0]));
	MMC_PRINT(("     %08x\n\r", mmc->scr[1]));

	switch ((mmc->scr[0] >> 24) & 0xf) {
2108445c:	80c01417 	ldw	r3,80(r16)
21084460:	01000044 	movi	r4,1
21084464:	1804d63a 	srli	r2,r3,24
21084468:	108003cc 	andi	r2,r2,15
2108446c:	11007726 	beq	r2,r4,2108464c <mmc_startup+0xa58>
21084470:	10006c26 	beq	r2,zero,21084624 <mmc_startup+0xa30>
21084474:	01000084 	movi	r4,2
21084478:	11006a1e 	bne	r2,r4,21084624 <mmc_startup+0xa30>
		break;
	case 1:
		mmc->version = SD_VERSION_1_10;
		break;
	case 2:
		mmc->version = SD_VERSION_2;
2108447c:	008000b4 	movhi	r2,2
21084480:	10800804 	addi	r2,r2,32
21084484:	80800a15 	stw	r2,40(r16)
	default:
		mmc->version = SD_VERSION_1_0;
		break;
	}

	if (mmc->scr[0] & SD_DATA_4BIT)
21084488:	18c0012c 	andhi	r3,r3,4
2108448c:	18000326 	beq	r3,zero,2108449c <mmc_startup+0x8a8>
		mmc->card_caps |= MMC_MODE_4BIT;
21084490:	80801117 	ldw	r2,68(r16)
21084494:	10804014 	ori	r2,r2,256
21084498:	80801115 	stw	r2,68(r16)
2108449c:	05c00034 	movhi	r23,0
210844a0:	bdd86204 	addi	r23,r23,24968
	/* Switch the frequency */
	cmd.cmdidx = SD_CMD_SWITCH_FUNC;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = (mode << 31) | 0xffffff;
	cmd.cmdarg &= ~(0xf << (group * 4));
	cmd.cmdarg |= value << (group * 4);
210844a4:	04804034 	movhi	r18,256
	if (err)
		return err;

	cmd.cmdidx = SD_CMD_APP_SEND_SCR;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = 0;
210844a8:	07000104 	movi	fp,4
		char *resp) {
	struct mmc_cmd cmd;
	struct mmc_data data;

	/* Switch the frequency */
	cmd.cmdidx = SD_CMD_SWITCH_FUNC;
210844ac:	05000184 	movi	r20,6
	cmd.resp_type = MMC_RSP_R1;
210844b0:	04c00544 	movi	r19,21
	cmd.cmdarg = (mode << 31) | 0xffffff;
	cmd.cmdarg &= ~(0xf << (group * 4));
	cmd.cmdarg |= value << (group * 4);
210844b4:	94bffc44 	addi	r18,r18,-15

	data.dest = (char *) resp;
	data.blocksize = 64;
	data.blocks = 1;
210844b8:	04400044 	movi	r17,1
210844bc:	bd401004 	addi	r21,r23,64

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
210844c0:	80802417 	ldw	r2,144(r16)
	cmd.cmdarg = (mode << 31) | 0xffffff;
	cmd.cmdarg &= ~(0xf << (group * 4));
	cmd.cmdarg |= value << (group * 4);

	data.dest = (char *) resp;
	data.blocksize = 64;
210844c4:	00c01004 	movi	r3,64
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = (mode << 31) | 0xffffff;
	cmd.cmdarg &= ~(0xf << (group * 4));
	cmd.cmdarg |= value << (group * 4);

	data.dest = (char *) resp;
210844c8:	ddc10e15 	stw	r23,1080(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
210844cc:	d9810e04 	addi	r6,sp,1080
210844d0:	05800034 	movhi	r22,0
		char *resp) {
	struct mmc_cmd cmd;
	struct mmc_data data;

	/* Switch the frequency */
	cmd.cmdidx = SD_CMD_SWITCH_FUNC;
210844d4:	dd00000d 	sth	r20,0(sp)
	cmd.resp_type = MMC_RSP_R1;
210844d8:	dcc00115 	stw	r19,4(sp)
	cmd.cmdarg = (mode << 31) | 0xffffff;
	cmd.cmdarg &= ~(0xf << (group * 4));
	cmd.cmdarg |= value << (group * 4);
210844dc:	dc800215 	stw	r18,8(sp)

	data.dest = (char *) resp;
	data.blocksize = 64;
210844e0:	d8c11115 	stw	r3,1092(sp)
	data.blocks = 1;
210844e4:	dc411015 	stw	r17,1088(sp)
	data.flags = MMC_DATA_READ;
210844e8:	dc410f15 	stw	r17,1084(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
210844ec:	8009883a 	mov	r4,r16
210844f0:	d80b883a 	mov	r5,sp
210844f4:	b5986204 	addi	r22,r22,24968
210844f8:	103ee83a 	callr	r2
210844fc:	b02f883a 	mov	r23,r22
21084500:	b1c01004 	addi	r7,r22,64
21084504:	b00d883a 	mov	r6,r22

	int i;
	uint* s = resp;
	for(i = 0; (i < 16); i++){
		uint b0, b1, b2, b3;
		b0 = (s[i] & 0x000000ff) << 24;
21084508:	30c00017 	ldw	r3,0(r6)
2108450c:	31800104 	addi	r6,r6,4
		b1 = (s[i] & 0x0000ff00) << 8;
		b2 = (s[i] & 0x00ff0000) >> 8;
		b3 = (s[i] & 0xff000000) >> 24;
21084510:	1814d63a 	srli	r10,r3,24

	int i;
	uint* s = resp;
	for(i = 0; (i < 16); i++){
		uint b0, b1, b2, b3;
		b0 = (s[i] & 0x000000ff) << 24;
21084514:	1812963a 	slli	r9,r3,24
		b1 = (s[i] & 0x0000ff00) << 8;
21084518:	197fc00c 	andi	r5,r3,65280
2108451c:	280a923a 	slli	r5,r5,8
		b2 = (s[i] & 0x00ff0000) >> 8;
21084520:	18c03fec 	andhi	r3,r3,255
21084524:	1808d23a 	srli	r4,r3,8
21084528:	5246b03a 	or	r3,r10,r9
2108452c:	1946b03a 	or	r3,r3,r5
		b3 = (s[i] & 0xff000000) >> 24;
		s[i] = b0 | b1 | b2 | b3;
21084530:	1906b03a 	or	r3,r3,r4
21084534:	30ffff15 	stw	r3,-4(r6)

	bool ret = mmc_send_cmd(mmc, &cmd, &data);

	int i;
	uint* s = resp;
	for(i = 0; (i < 16); i++){
21084538:	357ff31e 	bne	r6,r21,21084508 <__flash_rwdata_start+0xfffe22c0>

	timeout = 4;
	while (timeout--) {
		err = sd_switch(mmc, SD_SWITCH_CHECK, 0, 1, (char *) switch_status);

		if (err)
2108453c:	103e911e 	bne	r2,zero,21083f84 <__flash_rwdata_start+0xfffe1d3c>

		MMC_PRINT(("switch status 7 %08x\n\r", switch_status[7]));
		MMC_PRINT(("switch status 3 %08x\n\r", switch_status[3]));
		MMC_PRINT(("switch status 4 %08x\n\r", switch_status[4]));
		/* The high-speed function is busy.  Try again */
		if (!(switch_status[7] & SD_HIGHSPEED_BUSY))
21084540:	b8800717 	ldw	r2,28(r23)
21084544:	108000ac 	andhi	r2,r2,2
21084548:	10000226 	beq	r2,zero,21084554 <mmc_startup+0x960>
2108454c:	e73fffc4 	addi	fp,fp,-1
	/* Version 1.0 doesn't support switching */
	if (mmc->version == SD_VERSION_1_0)
		return 0;

	timeout = 4;
	while (timeout--) {
21084550:	e03fdb1e 	bne	fp,zero,210844c0 <__flash_rwdata_start+0xfffe2278>
		if (!(switch_status[7] & SD_HIGHSPEED_BUSY))
			break;
	}

	/* If high-speed isn't supported, we return */
	if (!(switch_status[3] & SD_HIGHSPEED_SUPPORTED)){
21084554:	b8800317 	ldw	r2,12(r23)
21084558:	108000ac 	andhi	r2,r2,2
2108455c:	103e8a26 	beq	r2,zero,21083f88 <__flash_rwdata_start+0xfffe1d40>
	 * If the host doesn't support SD_HIGHSPEED, do not switch card to
	 * HIGHSPEED mode even if the card support SD_HIGHSPPED.
	 * This can avoid furthur problem when the card runs in different
	 * mode between the host.
	 */
	if (!((mmc->host_caps & MMC_MODE_HS_52MHz) && (mmc->host_caps & MMC_MODE_HS)))
21084560:	80801217 	ldw	r2,72(r16)
21084564:	00c00444 	movi	r3,17
21084568:	1080044c 	andi	r2,r2,17
2108456c:	10fe861e 	bne	r2,r3,21083f88 <__flash_rwdata_start+0xfffe1d40>
		char *resp) {
	struct mmc_cmd cmd;
	struct mmc_data data;

	/* Switch the frequency */
	cmd.cmdidx = SD_CMD_SWITCH_FUNC;
21084570:	01000184 	movi	r4,6
21084574:	d900000d 	sth	r4,0(sp)
	cmd.resp_type = MMC_RSP_R1;
21084578:	01000544 	movi	r4,21
2108457c:	d9000115 	stw	r4,4(sp)
	cmd.cmdarg = (mode << 31) | 0xffffff;
	cmd.cmdarg &= ~(0xf << (group * 4));
	cmd.cmdarg |= value << (group * 4);
21084580:	01204034 	movhi	r4,33024
21084584:	213ffc44 	addi	r4,r4,-15
21084588:	d9000215 	stw	r4,8(sp)

	data.dest = (char *) resp;
2108458c:	01000034 	movhi	r4,0

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084590:	80c02417 	ldw	r3,144(r16)
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = (mode << 31) | 0xffffff;
	cmd.cmdarg &= ~(0xf << (group * 4));
	cmd.cmdarg |= value << (group * 4);

	data.dest = (char *) resp;
21084594:	21186204 	addi	r4,r4,24968
	data.blocksize = 64;
	data.blocks = 1;
21084598:	00800044 	movi	r2,1
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = (mode << 31) | 0xffffff;
	cmd.cmdarg &= ~(0xf << (group * 4));
	cmd.cmdarg |= value << (group * 4);

	data.dest = (char *) resp;
2108459c:	d9010e15 	stw	r4,1080(sp)
	data.blocksize = 64;
210845a0:	01001004 	movi	r4,64
210845a4:	d9011115 	stw	r4,1092(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
210845a8:	d9c11615 	stw	r7,1112(sp)
	cmd.cmdarg &= ~(0xf << (group * 4));
	cmd.cmdarg |= value << (group * 4);

	data.dest = (char *) resp;
	data.blocksize = 64;
	data.blocks = 1;
210845ac:	d8811015 	stw	r2,1088(sp)
	data.flags = MMC_DATA_READ;
210845b0:	d8810f15 	stw	r2,1084(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
210845b4:	8009883a 	mov	r4,r16
210845b8:	d80b883a 	mov	r5,sp
210845bc:	d9810e04 	addi	r6,sp,1080
210845c0:	183ee83a 	callr	r3
210845c4:	d9c11617 	ldw	r7,1112(sp)

	int i;
	uint* s = resp;
	for(i = 0; (i < 16); i++){
		uint b0, b1, b2, b3;
		b0 = (s[i] & 0x000000ff) << 24;
210845c8:	b0c00017 	ldw	r3,0(r22)
210845cc:	b5800104 	addi	r22,r22,4
		b1 = (s[i] & 0x0000ff00) << 8;
		b2 = (s[i] & 0x00ff0000) >> 8;
		b3 = (s[i] & 0xff000000) >> 24;
210845d0:	180cd63a 	srli	r6,r3,24

	int i;
	uint* s = resp;
	for(i = 0; (i < 16); i++){
		uint b0, b1, b2, b3;
		b0 = (s[i] & 0x000000ff) << 24;
210845d4:	180a963a 	slli	r5,r3,24
		b1 = (s[i] & 0x0000ff00) << 8;
210845d8:	193fc00c 	andi	r4,r3,65280
210845dc:	2008923a 	slli	r4,r4,8
		b2 = (s[i] & 0x00ff0000) >> 8;
210845e0:	18c03fec 	andhi	r3,r3,255
210845e4:	1806d23a 	srli	r3,r3,8
210845e8:	314ab03a 	or	r5,r6,r5
210845ec:	2908b03a 	or	r4,r5,r4
		b3 = (s[i] & 0xff000000) >> 24;
		s[i] = b0 | b1 | b2 | b3;
210845f0:	20c6b03a 	or	r3,r4,r3
210845f4:	b0ffff15 	stw	r3,-4(r22)

	bool ret = mmc_send_cmd(mmc, &cmd, &data);

	int i;
	uint* s = resp;
	for(i = 0; (i < 16); i++){
210845f8:	b1fff31e 	bne	r22,r7,210845c8 <__flash_rwdata_start+0xfffe2380>
	if (!((mmc->host_caps & MMC_MODE_HS_52MHz) && (mmc->host_caps & MMC_MODE_HS)))
		return 0;

	err = sd_switch(mmc, SD_SWITCH_SWITCH, 0, 1, (char *) switch_status);
	MMC_PRINT(("switch status 4 %08x\n\r", switch_status[4]));
	if (err)
210845fc:	103e611e 	bne	r2,zero,21083f84 <__flash_rwdata_start+0xfffe1d3c>
		return err;

	if ((switch_status[4] & 0x0f000000) == 0x01000000){
21084600:	b8800417 	ldw	r2,16(r23)
21084604:	00c04034 	movhi	r3,256
21084608:	1083c02c 	andhi	r2,r2,3840
2108460c:	10fe5e1e 	bne	r2,r3,21083f88 <__flash_rwdata_start+0xfffe1d40>
		MMC_PRINT(("High speed supported!\n"));
		mmc->card_caps |= MMC_MODE_HS;
21084610:	80c01117 	ldw	r3,68(r16)
21084614:	80800a17 	ldw	r2,40(r16)
21084618:	18c00054 	ori	r3,r3,1
2108461c:	80c01115 	stw	r3,68(r16)
21084620:	003e0706 	br	21083e40 <__flash_rwdata_start+0xfffe1bf8>
		break;
	case 2:
		mmc->version = SD_VERSION_2;
		break;
	default:
		mmc->version = SD_VERSION_1_0;
21084624:	008000b4 	movhi	r2,2
21084628:	10800404 	addi	r2,r2,16
2108462c:	80800a15 	stw	r2,40(r16)
		break;
	}

	if (mmc->scr[0] & SD_DATA_4BIT)
21084630:	18c0012c 	andhi	r3,r3,4
21084634:	183e5426 	beq	r3,zero,21083f88 <__flash_rwdata_start+0xfffe1d40>
		mmc->card_caps |= MMC_MODE_4BIT;
21084638:	80c01117 	ldw	r3,68(r16)
2108463c:	80800a17 	ldw	r2,40(r16)
21084640:	18c04014 	ori	r3,r3,256
21084644:	80c01115 	stw	r3,68(r16)
21084648:	003dfd06 	br	21083e40 <__flash_rwdata_start+0xfffe1bf8>
	switch ((mmc->scr[0] >> 24) & 0xf) {
	case 0:
		mmc->version = SD_VERSION_1_0;
		break;
	case 1:
		mmc->version = SD_VERSION_1_10;
2108464c:	008000b4 	movhi	r2,2
21084650:	10800684 	addi	r2,r2,26
21084654:	80800a15 	stw	r2,40(r16)
21084658:	003f8b06 	br	21084488 <__flash_rwdata_start+0xfffe2240>
	if (!ext_csd[EXT_CSD_HS_TIMING])
		return 0;

	/* High Speed is set, there are two types: 52MHz and 26MHz */
	if (cardtype & MMC_HS_52MHZ)
		mmc->card_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
2108465c:	18c00454 	ori	r3,r3,17
21084660:	80c01115 	stw	r3,68(r16)
21084664:	003df606 	br	21083e40 <__flash_rwdata_start+0xfffe1bf8>

21084668 <udelay>:
#define MMC_PRINT(x)	DEBUG(x)
#else
#define MMC_PRINT(x)
#endif

void udelay(int t) {
21084668:	deffff04 	addi	sp,sp,-4
#define US_DELAY 100
	volatile int us = US_DELAY;
2108466c:	01401904 	movi	r5,100
21084670:	d9400015 	stw	r5,0(sp)
	while (t--) {
21084674:	01bfffc4 	movi	r6,-1
21084678:	213fffc4 	addi	r4,r4,-1
2108467c:	21800726 	beq	r4,r6,2108469c <udelay+0x34>
		us = US_DELAY;
21084680:	d9400015 	stw	r5,0(sp)
		while (us--)
21084684:	d8800017 	ldw	r2,0(sp)
21084688:	10ffffc4 	addi	r3,r2,-1
2108468c:	d8c00015 	stw	r3,0(sp)
21084690:	103ffc1e 	bne	r2,zero,21084684 <__flash_rwdata_start+0xfffe243c>
#endif

void udelay(int t) {
#define US_DELAY 100
	volatile int us = US_DELAY;
	while (t--) {
21084694:	213fffc4 	addi	r4,r4,-1
21084698:	21bff91e 	bne	r4,r6,21084680 <__flash_rwdata_start+0xfffe2438>
		us = US_DELAY;
		while (us--)
			;
	}
}
2108469c:	dec00104 	addi	sp,sp,4
210846a0:	f800283a 	ret

210846a4 <mmc_init>:
}

int mmc_init(struct mmc *mmc) {
	int err;

	if (mmc->has_init)
210846a4:	20800b17 	ldw	r2,44(r4)
	}

	return blkcnt;
}

int mmc_init(struct mmc *mmc) {
210846a8:	deffe804 	addi	sp,sp,-96
210846ac:	df001615 	stw	fp,88(sp)
210846b0:	dfc01715 	stw	ra,92(sp)
210846b4:	ddc01515 	stw	r23,84(sp)
210846b8:	dd801415 	stw	r22,80(sp)
210846bc:	dd401315 	stw	r21,76(sp)
210846c0:	dd001215 	stw	r20,72(sp)
210846c4:	dcc01115 	stw	r19,68(sp)
210846c8:	dc801015 	stw	r18,64(sp)
210846cc:	dc400f15 	stw	r17,60(sp)
210846d0:	dc000e15 	stw	r16,56(sp)
210846d4:	2039883a 	mov	fp,r4
	int err;

	if (mmc->has_init)
210846d8:	10000e26 	beq	r2,zero,21084714 <mmc_init+0x70>
		return 0;
210846dc:	0021883a 	mov	r16,zero
	if (err)
		mmc->has_init = 0;
	else
		mmc->has_init = 1;
	return err;
}
210846e0:	8005883a 	mov	r2,r16
210846e4:	dfc01717 	ldw	ra,92(sp)
210846e8:	df001617 	ldw	fp,88(sp)
210846ec:	ddc01517 	ldw	r23,84(sp)
210846f0:	dd801417 	ldw	r22,80(sp)
210846f4:	dd401317 	ldw	r21,76(sp)
210846f8:	dd001217 	ldw	r20,72(sp)
210846fc:	dcc01117 	ldw	r19,68(sp)
21084700:	dc801017 	ldw	r18,64(sp)
21084704:	dc400f17 	ldw	r17,60(sp)
21084708:	dc000e17 	ldw	r16,56(sp)
2108470c:	dec01804 	addi	sp,sp,96
21084710:	f800283a 	ret
	int err;

	if (mmc->has_init)
		return 0;

	err = mmc->init(mmc);
21084714:	20802617 	ldw	r2,152(r4)
21084718:	103ee83a 	callr	r2

	if (err)
2108471c:	10000226 	beq	r2,zero,21084728 <mmc_init+0x84>
21084720:	1021883a 	mov	r16,r2
21084724:	003fee06 	br	210846e0 <__flash_rwdata_start+0xfffe2498>
 */
static const int multipliers[] = { 0, /* reserved */
10, 12, 13, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 70, 80, };

static void mmc_set_ios(struct mmc *mmc) {
	mmc->set_ios(mmc);
21084728:	e0802517 	ldw	r2,148(fp)
}

static void mmc_set_bus_width(struct mmc *mmc, uint width) {
	mmc->bus_width = width;
2108472c:	00c00044 	movi	r3,1
21084730:	e0c00f15 	stw	r3,60(fp)
 */
static const int multipliers[] = { 0, /* reserved */
10, 12, 13, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 70, 80, };

static void mmc_set_ios(struct mmc *mmc) {
	mmc->set_ios(mmc);
21084734:	e009883a 	mov	r4,fp
21084738:	103ee83a 	callr	r2

	mmc_set_ios(mmc);
}

static void mmc_set_clock(struct mmc *mmc, uint clock) {
	if (clock > mmc->f_max)
2108473c:	e0800d17 	ldw	r2,52(fp)
		clock = mmc->f_max;

	if (clock < mmc->f_min)
21084740:	e0c00c17 	ldw	r3,48(fp)
21084744:	1004c03a 	cmpne	r2,r2,zero
21084748:	10c06a36 	bltu	r2,r3,210848f4 <mmc_init+0x250>
 */
static const int multipliers[] = { 0, /* reserved */
10, 12, 13, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 70, 80, };

static void mmc_set_ios(struct mmc *mmc) {
	mmc->set_ios(mmc);
2108474c:	e0c02517 	ldw	r3,148(fp)
21084750:	e009883a 	mov	r4,fp
		clock = mmc->f_max;

	if (clock < mmc->f_min)
		clock = mmc->f_min;

	mmc->clock = clock;
21084754:	e0801015 	stw	r2,64(fp)
 */
static const int multipliers[] = { 0, /* reserved */
10, 12, 13, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 70, 80, };

static void mmc_set_ios(struct mmc *mmc) {
	mmc->set_ios(mmc);
21084758:	183ee83a 	callr	r3
#define MMC_PRINT(x)
#endif

void udelay(int t) {
#define US_DELAY 100
	volatile int us = US_DELAY;
2108475c:	01001904 	movi	r4,100
21084760:	d9000d15 	stw	r4,52(sp)
21084764:	0140fa04 	movi	r5,1000
	while (t--) {
		us = US_DELAY;
21084768:	d9000d15 	stw	r4,52(sp)
		while (us--)
2108476c:	d8800d17 	ldw	r2,52(sp)
21084770:	10ffffc4 	addi	r3,r2,-1
21084774:	d8c00d15 	stw	r3,52(sp)
21084778:	103ffc1e 	bne	r2,zero,2108476c <__flash_rwdata_start+0xfffe2524>
2108477c:	297fffc4 	addi	r5,r5,-1
#endif

void udelay(int t) {
#define US_DELAY 100
	volatile int us = US_DELAY;
	while (t--) {
21084780:	283ff91e 	bne	r5,zero,21084768 <__flash_rwdata_start+0xfffe2520>

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084784:	e0802417 	ldw	r2,144(fp)
	struct mmc_cmd cmd;
	int err;

	udelay(1000);

	cmd.cmdidx = MMC_CMD_GO_IDLE_STATE;
21084788:	d800000d 	sth	zero,0(sp)
	cmd.cmdarg = 0;
2108478c:	d8000215 	stw	zero,8(sp)
	cmd.resp_type = MMC_RSP_NONE;
21084790:	d8000115 	stw	zero,4(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084794:	e009883a 	mov	r4,fp
21084798:	d80b883a 	mov	r5,sp
2108479c:	000d883a 	mov	r6,zero
210847a0:	103ee83a 	callr	r2
	cmd.cmdarg = 0;
	cmd.resp_type = MMC_RSP_NONE;

	err = mmc_send_cmd(mmc, &cmd, NULL);

	if (err)
210847a4:	103fde1e 	bne	r2,zero,21084720 <__flash_rwdata_start+0xfffe24d8>
#define MMC_PRINT(x)
#endif

void udelay(int t) {
#define US_DELAY 100
	volatile int us = US_DELAY;
210847a8:	01001904 	movi	r4,100
210847ac:	d9000c15 	stw	r4,48(sp)
210847b0:	00c1f404 	movi	r3,2000
	while (t--) {
		us = US_DELAY;
210847b4:	d9000c15 	stw	r4,48(sp)
		while (us--)
210847b8:	dc000c17 	ldw	r16,48(sp)
210847bc:	80bfffc4 	addi	r2,r16,-1
210847c0:	d8800c15 	stw	r2,48(sp)
210847c4:	803ffc1e 	bne	r16,zero,210847b8 <__flash_rwdata_start+0xfffe2570>
210847c8:	18ffffc4 	addi	r3,r3,-1
#endif

void udelay(int t) {
#define US_DELAY 100
	volatile int us = US_DELAY;
	while (t--) {
210847cc:	183ff91e 	bne	r3,zero,210847b4 <__flash_rwdata_start+0xfffe256c>

static int mmc_send_if_cond(struct mmc *mmc) {
	struct mmc_cmd cmd;
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
210847d0:	00800204 	movi	r2,8
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
210847d4:	e0c00917 	ldw	r3,36(fp)

static int mmc_send_if_cond(struct mmc *mmc) {
	struct mmc_cmd cmd;
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
210847d8:	d880000d 	sth	r2,0(sp)
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
210847dc:	00804034 	movhi	r2,256
210847e0:	10a00004 	addi	r2,r2,-32768

	if (err)
		return err;

	/* The internal partition reset to user partition(0) at every CMD0*/
	mmc->part_num = 0;
210847e4:	e0001ec5 	stb	zero,123(fp)
	struct mmc_cmd cmd;
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
210847e8:	1884703a 	and	r2,r3,r2
210847ec:	10004b26 	beq	r2,zero,2108491c <mmc_init+0x278>
210847f0:	00806a84 	movi	r2,426

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
210847f4:	e0c02417 	ldw	r3,144(fp)
	struct mmc_cmd cmd;
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
210847f8:	d8800215 	stw	r2,8(sp)
	cmd.resp_type = MMC_RSP_R7;
210847fc:	00800544 	movi	r2,21
21084800:	d8800115 	stw	r2,4(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084804:	e009883a 	mov	r4,fp
21084808:	d80b883a 	mov	r5,sp
2108480c:	000d883a 	mov	r6,zero
21084810:	183ee83a 	callr	r3
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
	cmd.resp_type = MMC_RSP_R7;

	err = mmc_send_cmd(mmc, &cmd, NULL);

	if (err)
21084814:	1000061e 	bne	r2,zero,21084830 <mmc_init+0x18c>
		return err;

	if ((cmd.response[0] & 0xff) != 0xaa)
21084818:	d8c00303 	ldbu	r3,12(sp)
2108481c:	00802a84 	movi	r2,170
21084820:	1880031e 	bne	r3,r2,21084830 <mmc_init+0x18c>
		return UNUSABLE_ERR;
	else
		mmc->version = SD_VERSION_2;
21084824:	008000b4 	movhi	r2,2
21084828:	10800804 	addi	r2,r2,32
2108482c:	e0800a15 	stw	r2,40(fp)
		 * in the ocr are set. However, Some controller
		 * can set bit 7 (reserved for low voltages), but
		 * how to manage low voltages SD card is not yet
		 * specified.
		 */
		cmd.cmdarg = (mmc->voltages & 0xff8000);
21084830:	05804034 	movhi	r22,256

		if (mmc->version == SD_VERSION_2)
21084834:	054000b4 	movhi	r21,2
		 * in the ocr are set. However, Some controller
		 * can set bit 7 (reserved for low voltages), but
		 * how to manage low voltages SD card is not yet
		 * specified.
		 */
		cmd.cmdarg = (mmc->voltages & 0xff8000);
21084838:	b5a00004 	addi	r22,r22,-32768

		if (mmc->version == SD_VERSION_2)
2108483c:	ad400804 	addi	r21,r21,32

	return 0;
}

static int sd_send_op_cond(struct mmc *mmc) {
	int timeout = 1000;
21084840:	0440fa04 	movi	r17,1000
	int err;
	struct mmc_cmd cmd;

	do {
		cmd.cmdidx = MMC_CMD_APP_CMD;
21084844:	05000dc4 	movi	r20,55
		cmd.resp_type = MMC_RSP_R1;
21084848:	04c00544 	movi	r19,21
		err = mmc_send_cmd(mmc, &cmd, NULL);

		if (err)
			return err;

		cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
2108484c:	04800a44 	movi	r18,41
#define MMC_PRINT(x)
#endif

void udelay(int t) {
#define US_DELAY 100
	volatile int us = US_DELAY;
21084850:	05c01904 	movi	r23,100

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084854:	e0802417 	ldw	r2,144(fp)
	int timeout = 1000;
	int err;
	struct mmc_cmd cmd;

	do {
		cmd.cmdidx = MMC_CMD_APP_CMD;
21084858:	dd00000d 	sth	r20,0(sp)
		cmd.resp_type = MMC_RSP_R1;
2108485c:	dcc00115 	stw	r19,4(sp)
		cmd.cmdarg = 0;
21084860:	d8000215 	stw	zero,8(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084864:	e009883a 	mov	r4,fp
21084868:	d80b883a 	mov	r5,sp
2108486c:	000d883a 	mov	r6,zero
21084870:	103ee83a 	callr	r2
		cmd.resp_type = MMC_RSP_R1;
		cmd.cmdarg = 0;

		err = mmc_send_cmd(mmc, &cmd, NULL);

		if (err)
21084874:	1000211e 	bne	r2,zero,210848fc <mmc_init+0x258>
		 * in the ocr are set. However, Some controller
		 * can set bit 7 (reserved for low voltages), but
		 * how to manage low voltages SD card is not yet
		 * specified.
		 */
		cmd.cmdarg = (mmc->voltages & 0xff8000);
21084878:	e0800917 	ldw	r2,36(fp)

		if (mmc->version == SD_VERSION_2)
2108487c:	e0c00a17 	ldw	r3,40(fp)

		if (err)
			return err;

		cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
21084880:	01000044 	movi	r4,1
		 * in the ocr are set. However, Some controller
		 * can set bit 7 (reserved for low voltages), but
		 * how to manage low voltages SD card is not yet
		 * specified.
		 */
		cmd.cmdarg = (mmc->voltages & 0xff8000);
21084884:	1584703a 	and	r2,r2,r22
		err = mmc_send_cmd(mmc, &cmd, NULL);

		if (err)
			return err;

		cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
21084888:	dc80000d 	sth	r18,0(sp)
		cmd.resp_type = MMC_RSP_R3;
2108488c:	d9000115 	stw	r4,4(sp)
		 * in the ocr are set. However, Some controller
		 * can set bit 7 (reserved for low voltages), but
		 * how to manage low voltages SD card is not yet
		 * specified.
		 */
		cmd.cmdarg = (mmc->voltages & 0xff8000);
21084890:	d8800215 	stw	r2,8(sp)

		if (mmc->version == SD_VERSION_2)
21084894:	1d40021e 	bne	r3,r21,210848a0 <mmc_init+0x1fc>
			cmd.cmdarg |= OCR_HCS;
21084898:	10900034 	orhi	r2,r2,16384
2108489c:	d8800215 	stw	r2,8(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
210848a0:	e0802417 	ldw	r2,144(fp)
210848a4:	e009883a 	mov	r4,fp
210848a8:	d80b883a 	mov	r5,sp
210848ac:	000d883a 	mov	r6,zero
210848b0:	103ee83a 	callr	r2
		if (mmc->version == SD_VERSION_2)
			cmd.cmdarg |= OCR_HCS;

		err = mmc_send_cmd(mmc, &cmd, NULL);

		if (err)
210848b4:	1000111e 	bne	r2,zero,210848fc <mmc_init+0x258>
#define MMC_PRINT(x)
#endif

void udelay(int t) {
#define US_DELAY 100
	volatile int us = US_DELAY;
210848b8:	ddc00b15 	stw	r23,44(sp)
210848bc:	0080fa04 	movi	r2,1000
	while (t--) {
		us = US_DELAY;
210848c0:	ddc00b15 	stw	r23,44(sp)
		while (us--)
210848c4:	d8c00b17 	ldw	r3,44(sp)
210848c8:	197fffc4 	addi	r5,r3,-1
210848cc:	d9400b15 	stw	r5,44(sp)
210848d0:	183ffc1e 	bne	r3,zero,210848c4 <__flash_rwdata_start+0xfffe267c>
210848d4:	10bfffc4 	addi	r2,r2,-1
#endif

void udelay(int t) {
#define US_DELAY 100
	volatile int us = US_DELAY;
	while (t--) {
210848d8:	103ff91e 	bne	r2,zero,210848c0 <__flash_rwdata_start+0xfffe2678>

		if (err)
			return err;

		udelay(1000);
	} while ((!(cmd.response[0] & OCR_BUSY)) && timeout--);
210848dc:	d8c00317 	ldw	r3,12(sp)
210848e0:	18001316 	blt	r3,zero,21084930 <mmc_init+0x28c>
210848e4:	8c7fffc4 	addi	r17,r17,-1
210848e8:	00bfffc4 	movi	r2,-1
210848ec:	88bfd91e 	bne	r17,r2,21084854 <__flash_rwdata_start+0xfffe260c>
210848f0:	00000406 	br	21084904 <mmc_init+0x260>
210848f4:	1805883a 	mov	r2,r3
210848f8:	003f9406 	br	2108474c <__flash_rwdata_start+0xfffe2504>

	/* Now try to get the SD card's operating condition */
	err = sd_send_op_cond(mmc);

	/* If the command timed out, we check for an MMC card */
	if (err == TIMEOUT) {
210848fc:	00fffb44 	movi	r3,-19
21084900:	10c01926 	beq	r2,r3,21084968 <mmc_init+0x2c4>
			printf("Card did not respond to voltage select!\n\r");
			return UNUSABLE_ERR;
		}
	}

	err = mmc_startup(mmc);
21084904:	e009883a 	mov	r4,fp
21084908:	1083bf40 	call	21083bf4 <mmc_startup>
	if (err)
2108490c:	10000526 	beq	r2,zero,21084924 <mmc_init+0x280>
		mmc->has_init = 0;
21084910:	e0000b15 	stw	zero,44(fp)
21084914:	1021883a 	mov	r16,r2
21084918:	003f7106 	br	210846e0 <__flash_rwdata_start+0xfffe2498>
	struct mmc_cmd cmd;
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
2108491c:	00802a84 	movi	r2,170
21084920:	003fb406 	br	210847f4 <__flash_rwdata_start+0xfffe25ac>

	err = mmc_startup(mmc);
	if (err)
		mmc->has_init = 0;
	else
		mmc->has_init = 1;
21084924:	00800044 	movi	r2,1
21084928:	e0800b15 	stw	r2,44(fp)
2108492c:	003f6c06 	br	210846e0 <__flash_rwdata_start+0xfffe2498>
			return err;

		udelay(1000);
	} while ((!(cmd.response[0] & OCR_BUSY)) && timeout--);

	if (timeout <= 0)
21084930:	883ff426 	beq	r17,zero,21084904 <__flash_rwdata_start+0xfffe26bc>
		return UNUSABLE_ERR;

	if (mmc->version != SD_VERSION_2)
21084934:	e1000a17 	ldw	r4,40(fp)
21084938:	008000b4 	movhi	r2,2
2108493c:	10800804 	addi	r2,r2,32
21084940:	20800326 	beq	r4,r2,21084950 <mmc_init+0x2ac>
		mmc->version = SD_VERSION_1_0;
21084944:	008000b4 	movhi	r2,2
21084948:	10800404 	addi	r2,r2,16
2108494c:	e0800a15 	stw	r2,40(fp)

	mmc->ocr = cmd.response[0];

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
21084950:	1804d7ba 	srli	r2,r3,30
		return UNUSABLE_ERR;

	if (mmc->version != SD_VERSION_2)
		mmc->version = SD_VERSION_1_0;

	mmc->ocr = cmd.response[0];
21084954:	e0c01315 	stw	r3,76(fp)

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
	mmc->rca = 0;
21084958:	e0001e0d 	sth	zero,120(fp)
	if (mmc->version != SD_VERSION_2)
		mmc->version = SD_VERSION_1_0;

	mmc->ocr = cmd.response[0];

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
2108495c:	1080004c 	andi	r2,r2,1
21084960:	e0800e15 	stw	r2,56(fp)
21084964:	003fe706 	br	21084904 <__flash_rwdata_start+0xfffe26bc>
#define MMC_PRINT(x)
#endif

void udelay(int t) {
#define US_DELAY 100
	volatile int us = US_DELAY;
21084968:	01401904 	movi	r5,100
2108496c:	d9400815 	stw	r5,32(sp)
21084970:	0100fa04 	movi	r4,1000
	while (t--) {
		us = US_DELAY;
21084974:	d9400815 	stw	r5,32(sp)
		while (us--)
21084978:	d8800817 	ldw	r2,32(sp)
2108497c:	10ffffc4 	addi	r3,r2,-1
21084980:	d8c00815 	stw	r3,32(sp)
21084984:	103ffc1e 	bne	r2,zero,21084978 <__flash_rwdata_start+0xfffe2730>
21084988:	213fffc4 	addi	r4,r4,-1
#endif

void udelay(int t) {
#define US_DELAY 100
	volatile int us = US_DELAY;
	while (t--) {
2108498c:	203ff91e 	bne	r4,zero,21084974 <__flash_rwdata_start+0xfffe272c>

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084990:	e0802417 	ldw	r2,144(fp)
	struct mmc_cmd cmd;
	int err;

	udelay(1000);

	cmd.cmdidx = MMC_CMD_GO_IDLE_STATE;
21084994:	d800000d 	sth	zero,0(sp)
	cmd.cmdarg = 0;
21084998:	d8000215 	stw	zero,8(sp)
	cmd.resp_type = MMC_RSP_NONE;
2108499c:	d8000115 	stw	zero,4(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
210849a0:	e009883a 	mov	r4,fp
210849a4:	d80b883a 	mov	r5,sp
210849a8:	000d883a 	mov	r6,zero
210849ac:	103ee83a 	callr	r2
	cmd.cmdarg = 0;
	cmd.resp_type = MMC_RSP_NONE;

	err = mmc_send_cmd(mmc, &cmd, NULL);

	if (err)
210849b0:	10000b1e 	bne	r2,zero,210849e0 <mmc_init+0x33c>
#define MMC_PRINT(x)
#endif

void udelay(int t) {
#define US_DELAY 100
	volatile int us = US_DELAY;
210849b4:	00801904 	movi	r2,100
210849b8:	d8800715 	stw	r2,28(sp)
210849bc:	0141f404 	movi	r5,2000
	while (t--) {
		us = US_DELAY;
210849c0:	1009883a 	mov	r4,r2
210849c4:	d9000715 	stw	r4,28(sp)
		while (us--)
210849c8:	d8800717 	ldw	r2,28(sp)
210849cc:	10ffffc4 	addi	r3,r2,-1
210849d0:	d8c00715 	stw	r3,28(sp)
210849d4:	103ffc1e 	bne	r2,zero,210849c8 <__flash_rwdata_start+0xfffe2780>
210849d8:	297fffc4 	addi	r5,r5,-1
#endif

void udelay(int t) {
#define US_DELAY 100
	volatile int us = US_DELAY;
	while (t--) {
210849dc:	283ff91e 	bne	r5,zero,210849c4 <__flash_rwdata_start+0xfffe277c>

	/* Some cards seem to need this */
	mmc_go_idle(mmc);

	/* Asking to the card its capabilities */
	cmd.cmdidx = MMC_CMD_SEND_OP_COND;
210849e0:	00c00044 	movi	r3,1

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
210849e4:	e0802417 	ldw	r2,144(fp)

	/* Some cards seem to need this */
	mmc_go_idle(mmc);

	/* Asking to the card its capabilities */
	cmd.cmdidx = MMC_CMD_SEND_OP_COND;
210849e8:	d8c0000d 	sth	r3,0(sp)
	cmd.resp_type = MMC_RSP_R3;
210849ec:	00c00044 	movi	r3,1
210849f0:	d8c00115 	stw	r3,4(sp)
	cmd.cmdarg = 0;
210849f4:	d8000215 	stw	zero,8(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
210849f8:	e009883a 	mov	r4,fp
210849fc:	d80b883a 	mov	r5,sp
21084a00:	000d883a 	mov	r6,zero
21084a04:	103ee83a 	callr	r2
	cmd.resp_type = MMC_RSP_R3;
	cmd.cmdarg = 0;

	err = mmc_send_cmd(mmc, &cmd, NULL);

	if (err)
21084a08:	1000321e 	bne	r2,zero,21084ad4 <mmc_init+0x430>
#define MMC_PRINT(x)
#endif

void udelay(int t) {
#define US_DELAY 100
	volatile int us = US_DELAY;
21084a0c:	00801904 	movi	r2,100
21084a10:	d8800915 	stw	r2,36(sp)
21084a14:	0140fa04 	movi	r5,1000
	while (t--) {
		us = US_DELAY;
21084a18:	1009883a 	mov	r4,r2
21084a1c:	d9000915 	stw	r4,36(sp)
		while (us--)
21084a20:	d8800917 	ldw	r2,36(sp)
21084a24:	10ffffc4 	addi	r3,r2,-1
21084a28:	d8c00915 	stw	r3,36(sp)
21084a2c:	103ffc1e 	bne	r2,zero,21084a20 <__flash_rwdata_start+0xfffe27d8>
21084a30:	297fffc4 	addi	r5,r5,-1
#endif

void udelay(int t) {
#define US_DELAY 100
	volatile int us = US_DELAY;
	while (t--) {
21084a34:	283ff91e 	bne	r5,zero,21084a1c <__flash_rwdata_start+0xfffe27d4>
21084a38:	d8800317 	ldw	r2,12(sp)
21084a3c:	05802034 	movhi	r22,128
21084a40:	b5bfe004 	addi	r22,r22,-128
21084a44:	0489c404 	movi	r18,10000
		return err;

	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
21084a48:	05400044 	movi	r21,1
		cmd.resp_type = MMC_RSP_R3;
21084a4c:	05000044 	movi	r20,1
#define MMC_PRINT(x)
#endif

void udelay(int t) {
#define US_DELAY 100
	volatile int us = US_DELAY;
21084a50:	04401904 	movi	r17,100

		if (err)
			return err;

		udelay(1000);
	} while (!(cmd.response[0] & OCR_BUSY) && timeout--);
21084a54:	04ffffc4 	movi	r19,-1
21084a58:	e0c00917 	ldw	r3,36(fp)
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc->voltages & (cmd.response[0] & OCR_VOLTAGE_MASK))
				| (cmd.response[0] & OCR_ACCESS_MODE);

		if (mmc->host_caps & MMC_MODE_HC)
21084a5c:	e1001217 	ldw	r4,72(fp)
		return err;

	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
21084a60:	dd40000d 	sth	r21,0(sp)
21084a64:	1d86703a 	and	r3,r3,r22
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc->voltages & (cmd.response[0] & OCR_VOLTAGE_MASK))
				| (cmd.response[0] & OCR_ACCESS_MODE);
21084a68:	18d80034 	orhi	r3,r3,24576
21084a6c:	1884703a 	and	r2,r3,r2

	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
21084a70:	dd000115 	stw	r20,4(sp)
		cmd.cmdarg = (mmc->voltages & (cmd.response[0] & OCR_VOLTAGE_MASK))
21084a74:	d8800215 	stw	r2,8(sp)
				| (cmd.response[0] & OCR_ACCESS_MODE);

		if (mmc->host_caps & MMC_MODE_HC)
21084a78:	20c2000c 	andi	r3,r4,2048
21084a7c:	18000226 	beq	r3,zero,21084a88 <mmc_init+0x3e4>
			cmd.cmdarg |= OCR_HCS;
21084a80:	10900034 	orhi	r2,r2,16384
21084a84:	d8800215 	stw	r2,8(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084a88:	e0802417 	ldw	r2,144(fp)
21084a8c:	e009883a 	mov	r4,fp
21084a90:	d80b883a 	mov	r5,sp
21084a94:	000d883a 	mov	r6,zero
21084a98:	103ee83a 	callr	r2
		if (mmc->host_caps & MMC_MODE_HC)
			cmd.cmdarg |= OCR_HCS;

		err = mmc_send_cmd(mmc, &cmd, NULL);

		if (err)
21084a9c:	10000d1e 	bne	r2,zero,21084ad4 <mmc_init+0x430>
#define MMC_PRINT(x)
#endif

void udelay(int t) {
#define US_DELAY 100
	volatile int us = US_DELAY;
21084aa0:	dc400a15 	stw	r17,40(sp)
21084aa4:	0100fa04 	movi	r4,1000
	while (t--) {
		us = US_DELAY;
21084aa8:	dc400a15 	stw	r17,40(sp)
		while (us--)
21084aac:	d8c00a17 	ldw	r3,40(sp)
21084ab0:	18bfffc4 	addi	r2,r3,-1
21084ab4:	d8800a15 	stw	r2,40(sp)
21084ab8:	183ffc1e 	bne	r3,zero,21084aac <__flash_rwdata_start+0xfffe2864>
21084abc:	213fffc4 	addi	r4,r4,-1
#endif

void udelay(int t) {
#define US_DELAY 100
	volatile int us = US_DELAY;
	while (t--) {
21084ac0:	203ff91e 	bne	r4,zero,21084aa8 <__flash_rwdata_start+0xfffe2860>

		if (err)
			return err;

		udelay(1000);
	} while (!(cmd.response[0] & OCR_BUSY) && timeout--);
21084ac4:	d8800317 	ldw	r2,12(sp)
21084ac8:	10000716 	blt	r2,zero,21084ae8 <mmc_init+0x444>
21084acc:	94bfffc4 	addi	r18,r18,-1
21084ad0:	94ffe11e 	bne	r18,r19,21084a58 <__flash_rwdata_start+0xfffe2810>
	/* If the command timed out, we check for an MMC card */
	if (err == TIMEOUT) {
		err = mmc_send_op_cond(mmc);

		if (err) {
			printf("Card did not respond to voltage select!\n\r");
21084ad4:	01000034 	movhi	r4,0
21084ad8:	2100d204 	addi	r4,r4,840
			return UNUSABLE_ERR;
21084adc:	043ffbc4 	movi	r16,-17
	/* If the command timed out, we check for an MMC card */
	if (err == TIMEOUT) {
		err = mmc_send_op_cond(mmc);

		if (err) {
			printf("Card did not respond to voltage select!\n\r");
21084ae0:	108e3bc0 	call	2108e3bc <printf>
			return UNUSABLE_ERR;
21084ae4:	003efe06 	br	210846e0 <__flash_rwdata_start+0xfffe2498>
			return err;

		udelay(1000);
	} while (!(cmd.response[0] & OCR_BUSY) && timeout--);

	if (timeout <= 0)
21084ae8:	903ffa26 	beq	r18,zero,21084ad4 <__flash_rwdata_start+0xfffe288c>
		return UNUSABLE_ERR;

	mmc->version = MMC_VERSION_UNKNOWN;
	mmc->ocr = cmd.response[0];

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
21084aec:	1006d7ba 	srli	r3,r2,30
	} while (!(cmd.response[0] & OCR_BUSY) && timeout--);

	if (timeout <= 0)
		return UNUSABLE_ERR;

	mmc->version = MMC_VERSION_UNKNOWN;
21084af0:	01000074 	movhi	r4,1
21084af4:	e1000a15 	stw	r4,40(fp)
	mmc->ocr = cmd.response[0];

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
21084af8:	18c0004c 	andi	r3,r3,1

	if (timeout <= 0)
		return UNUSABLE_ERR;

	mmc->version = MMC_VERSION_UNKNOWN;
	mmc->ocr = cmd.response[0];
21084afc:	e0801315 	stw	r2,76(fp)

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
21084b00:	e0c00e15 	stw	r3,56(fp)
	mmc->rca = 0;
21084b04:	e0001e0d 	sth	zero,120(fp)
21084b08:	003f7e06 	br	21084904 <__flash_rwdata_start+0xfffe26bc>

21084b0c <mmc_bread>:
	else
		mmc->has_init = 1;
	return err;
}

size_t mmc_bread(struct mmc *mmc, size_t start, size_t blkcnt, void *dst) {
21084b0c:	deffea04 	addi	sp,sp,-88
21084b10:	dc800e15 	stw	r18,56(sp)
21084b14:	dfc01515 	stw	ra,84(sp)
21084b18:	df001415 	stw	fp,80(sp)
21084b1c:	ddc01315 	stw	r23,76(sp)
21084b20:	dd801215 	stw	r22,72(sp)
21084b24:	dd401115 	stw	r21,68(sp)
21084b28:	dd001015 	stw	r20,64(sp)
21084b2c:	dcc00f15 	stw	r19,60(sp)
21084b30:	dc400d15 	stw	r17,52(sp)
21084b34:	dc000c15 	stw	r16,48(sp)
21084b38:	3025883a 	mov	r18,r6
	size_t cur, blocks_todo = blkcnt;

	if (blkcnt == 0)
21084b3c:	30004426 	beq	r6,zero,21084c50 <mmc_bread+0x144>
21084b40:	382d883a 	mov	r22,r7
		return 0;

	if ((start + blkcnt) > mmc->capacity / mmc->read_bl_len) {
21084b44:	20802017 	ldw	r2,128(r4)
21084b48:	21c02317 	ldw	r7,140(r4)
21084b4c:	282b883a 	mov	r21,r5
21084b50:	314b883a 	add	r5,r6,r5
21084b54:	388d203a 	divu	r6,r7,r2
21084b58:	2023883a 	mov	r17,r4
21084b5c:	31403836 	bltu	r6,r5,21084c40 <mmc_bread+0x134>

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084b60:	22002417 	ldw	r8,144(r4)
}

static int mmc_set_blocklen(struct mmc *mmc, int len) {
	struct mmc_cmd cmd;

	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
21084b64:	01400404 	movi	r5,16
	cmd.resp_type = MMC_RSP_R1;
21084b68:	04c00544 	movi	r19,21
}

static int mmc_set_blocklen(struct mmc *mmc, int len) {
	struct mmc_cmd cmd;

	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
21084b6c:	d940010d 	sth	r5,4(sp)
	cmd.resp_type = MMC_RSP_R1;
21084b70:	dcc00215 	stw	r19,8(sp)
	cmd.cmdarg = len;
21084b74:	d8800315 	stw	r2,12(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084b78:	d9400104 	addi	r5,sp,4
21084b7c:	000d883a 	mov	r6,zero
21084b80:	403ee83a 	callr	r8
		printf("MMC: block number 0x%lx exceeds max(0x%lx) (%x, %x)\n", start + blkcnt,
				mmc->capacity / mmc->read_bl_len, mmc->capacity, mmc->read_bl_len);
		return 0;
	}

	if (mmc_set_blocklen(mmc, mmc->read_bl_len))
21084b84:	1000321e 	bne	r2,zero,21084c50 <mmc_bread+0x144>
21084b88:	88802017 	ldw	r2,128(r17)
21084b8c:	9039883a 	mov	fp,r18
static int mmc_read_blocks(struct mmc *mmc, void *dst, size_t start,
		size_t blkcnt) {
	struct mmc_cmd cmd;
	struct mmc_data data;

	if (blkcnt > 1)
21084b90:	05c00044 	movi	r23,1
		cmd.cmdidx = MMC_CMD_READ_MULTIPLE_BLOCK;
21084b94:	05000484 	movi	r20,18

	if (mmc_set_blocklen(mmc, mmc->read_bl_len))
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ? mmc->b_max : blocks_todo;
21084b98:	89002817 	ldw	r4,160(r17)
21084b9c:	e021883a 	mov	r16,fp
21084ba0:	2700012e 	bgeu	r4,fp,21084ba8 <mmc_bread+0x9c>
21084ba4:	2021883a 	mov	r16,r4
static int mmc_read_blocks(struct mmc *mmc, void *dst, size_t start,
		size_t blkcnt) {
	struct mmc_cmd cmd;
	struct mmc_data data;

	if (blkcnt > 1)
21084ba8:	bc003b2e 	bgeu	r23,r16,21084c98 <mmc_bread+0x18c>
		cmd.cmdidx = MMC_CMD_READ_MULTIPLE_BLOCK;
21084bac:	dd00010d 	sth	r20,4(sp)
	else
		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;

	if (mmc->high_capacity)
21084bb0:	89000e17 	ldw	r4,56(r17)
21084bb4:	20003326 	beq	r4,zero,21084c84 <mmc_bread+0x178>
		cmd.cmdarg = start;
21084bb8:	dd400315 	stw	r21,12(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084bbc:	8a402417 	ldw	r9,144(r17)
	if (mmc->high_capacity)
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->read_bl_len;

	cmd.resp_type = MMC_RSP_R1;
21084bc0:	dcc00215 	stw	r19,8(sp)

	data.dest = dst;
21084bc4:	dd800815 	stw	r22,32(sp)
	data.blocks = blkcnt;
21084bc8:	dc000a15 	stw	r16,40(sp)
	data.blocksize = mmc->read_bl_len;
21084bcc:	d8800b15 	stw	r2,44(sp)
	data.flags = MMC_DATA_READ;
21084bd0:	ddc00915 	stw	r23,36(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084bd4:	8809883a 	mov	r4,r17
21084bd8:	d9400104 	addi	r5,sp,4
21084bdc:	d9800804 	addi	r6,sp,32
21084be0:	483ee83a 	callr	r9
	data.dest = dst;
	data.blocks = blkcnt;
	data.blocksize = mmc->read_bl_len;
	data.flags = MMC_DATA_READ;

	if (mmc_send_cmd(mmc, &cmd, &data))
21084be4:	10002a1e 	bne	r2,zero,21084c90 <mmc_bread+0x184>
		return 0;

	if (blkcnt > 1) {
21084be8:	bc000b2e 	bgeu	r23,r16,21084c18 <mmc_bread+0x10c>
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
21084bec:	00c00304 	movi	r3,12

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084bf0:	88802417 	ldw	r2,144(r17)

	if (mmc_send_cmd(mmc, &cmd, &data))
		return 0;

	if (blkcnt > 1) {
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
21084bf4:	d8c0010d 	sth	r3,4(sp)
		cmd.cmdarg = 0;
		cmd.resp_type = MMC_RSP_R1b;
21084bf8:	00c00744 	movi	r3,29
	if (mmc_send_cmd(mmc, &cmd, &data))
		return 0;

	if (blkcnt > 1) {
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
		cmd.cmdarg = 0;
21084bfc:	d8000315 	stw	zero,12(sp)
		cmd.resp_type = MMC_RSP_R1b;
21084c00:	d8c00215 	stw	r3,8(sp)

static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
		struct mmc_data *data) {
	int ret;

	ret = mmc->send_cmd(mmc, cmd, data);
21084c04:	8809883a 	mov	r4,r17
21084c08:	d9400104 	addi	r5,sp,4
21084c0c:	000d883a 	mov	r6,zero
21084c10:	103ee83a 	callr	r2

	if (blkcnt > 1) {
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
		cmd.cmdarg = 0;
		cmd.resp_type = MMC_RSP_R1b;
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
21084c14:	1000231e 	bne	r2,zero,21084ca4 <mmc_bread+0x198>
	data.dest = dst;
	data.blocks = blkcnt;
	data.blocksize = mmc->read_bl_len;
	data.flags = MMC_DATA_READ;

	if (mmc_send_cmd(mmc, &cmd, &data))
21084c18:	8005883a 	mov	r2,r16
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ? mmc->b_max : blocks_todo;

		if (mmc_read_blocks(mmc, dst, start, cur) != cur)
21084c1c:	80800c1e 	bne	r16,r2,21084c50 <mmc_bread+0x144>
			return 0;

		blocks_todo -= cur;
		start += cur;
		dst += cur * mmc->read_bl_len;
21084c20:	88802017 	ldw	r2,128(r17)
		cur = (blocks_todo > mmc->b_max) ? mmc->b_max : blocks_todo;

		if (mmc_read_blocks(mmc, dst, start, cur) != cur)
			return 0;

		blocks_todo -= cur;
21084c24:	e439c83a 	sub	fp,fp,r16
		start += cur;
21084c28:	ac2b883a 	add	r21,r21,r16
		dst += cur * mmc->read_bl_len;
21084c2c:	80a1383a 	mul	r16,r16,r2
21084c30:	b42d883a 	add	r22,r22,r16
	} while (blocks_todo > 0);
21084c34:	e03fd81e 	bne	fp,zero,21084b98 <__flash_rwdata_start+0xfffe2950>
21084c38:	9005883a 	mov	r2,r18
21084c3c:	00000506 	br	21084c54 <mmc_bread+0x148>

	if (blkcnt == 0)
		return 0;

	if ((start + blkcnt) > mmc->capacity / mmc->read_bl_len) {
		printf("MMC: block number 0x%lx exceeds max(0x%lx) (%x, %x)\n", start + blkcnt,
21084c40:	01000034 	movhi	r4,0
21084c44:	2100dd04 	addi	r4,r4,884
21084c48:	d8800015 	stw	r2,0(sp)
21084c4c:	108e3bc0 	call	2108e3bc <printf>
				mmc->capacity / mmc->read_bl_len, mmc->capacity, mmc->read_bl_len);
		return 0;
21084c50:	0005883a 	mov	r2,zero
		start += cur;
		dst += cur * mmc->read_bl_len;
	} while (blocks_todo > 0);

	return blkcnt;
}
21084c54:	dfc01517 	ldw	ra,84(sp)
21084c58:	df001417 	ldw	fp,80(sp)
21084c5c:	ddc01317 	ldw	r23,76(sp)
21084c60:	dd801217 	ldw	r22,72(sp)
21084c64:	dd401117 	ldw	r21,68(sp)
21084c68:	dd001017 	ldw	r20,64(sp)
21084c6c:	dcc00f17 	ldw	r19,60(sp)
21084c70:	dc800e17 	ldw	r18,56(sp)
21084c74:	dc400d17 	ldw	r17,52(sp)
21084c78:	dc000c17 	ldw	r16,48(sp)
21084c7c:	dec01604 	addi	sp,sp,88
21084c80:	f800283a 	ret
		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;

	if (mmc->high_capacity)
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->read_bl_len;
21084c84:	1549383a 	mul	r4,r2,r21
21084c88:	d9000315 	stw	r4,12(sp)
21084c8c:	003fcb06 	br	21084bbc <__flash_rwdata_start+0xfffe2974>
	data.dest = dst;
	data.blocks = blkcnt;
	data.blocksize = mmc->read_bl_len;
	data.flags = MMC_DATA_READ;

	if (mmc_send_cmd(mmc, &cmd, &data))
21084c90:	0005883a 	mov	r2,zero
21084c94:	003fe106 	br	21084c1c <__flash_rwdata_start+0xfffe29d4>
	struct mmc_data data;

	if (blkcnt > 1)
		cmd.cmdidx = MMC_CMD_READ_MULTIPLE_BLOCK;
	else
		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;
21084c98:	00c00444 	movi	r3,17
21084c9c:	d8c0010d 	sth	r3,4(sp)
21084ca0:	003fc306 	br	21084bb0 <__flash_rwdata_start+0xfffe2968>
	if (blkcnt > 1) {
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
		cmd.cmdarg = 0;
		cmd.resp_type = MMC_RSP_R1b;
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
			printf("mmc fail to send stop cmd\n");
21084ca4:	01000034 	movhi	r4,0
21084ca8:	2100eb04 	addi	r4,r4,940
21084cac:	108e4c00 	call	2108e4c0 <puts>

	do {
		cur = (blocks_todo > mmc->b_max) ? mmc->b_max : blocks_todo;

		if (mmc_read_blocks(mmc, dst, start, cur) != cur)
			return 0;
21084cb0:	0005883a 	mov	r2,zero
21084cb4:	003fe706 	br	21084c54 <__flash_rwdata_start+0xfffe2a0c>

21084cb8 <print_mmcinfo>:
	} while (blocks_todo > 0);

	return blkcnt;
}

void print_mmcinfo(struct mmc *mmc) {
21084cb8:	defffc04 	addi	sp,sp,-16
21084cbc:	dc000215 	stw	r16,8(sp)
21084cc0:	2021883a 	mov	r16,r4
	printf("Device: %s\n\r", mmc->name);
21084cc4:	01000034 	movhi	r4,0
21084cc8:	2100f604 	addi	r4,r4,984
21084ccc:	800b883a 	mov	r5,r16
	} while (blocks_todo > 0);

	return blkcnt;
}

void print_mmcinfo(struct mmc *mmc) {
21084cd0:	dfc00315 	stw	ra,12(sp)
	printf("Device: %s\n\r", mmc->name);
21084cd4:	108e3bc0 	call	2108e3bc <printf>
	printf("Manufacturer ID: %x\n\r", mmc->cid[0] >> 24);
21084cd8:	81401ac3 	ldbu	r5,107(r16)
21084cdc:	01000034 	movhi	r4,0
21084ce0:	2100fa04 	addi	r4,r4,1000
21084ce4:	108e3bc0 	call	2108e3bc <printf>
	printf("OEM: %x\n\r", (mmc->cid[0] >> 8) & 0xffff);
21084ce8:	81401a17 	ldw	r5,104(r16)
21084cec:	01000034 	movhi	r4,0
21084cf0:	21010004 	addi	r4,r4,1024
21084cf4:	280ad23a 	srli	r5,r5,8
21084cf8:	297fffcc 	andi	r5,r5,65535
21084cfc:	108e3bc0 	call	2108e3bc <printf>
	printf("Name: %c%c%c%c%c \n\r", mmc->cid[0] & 0xff, (mmc->cid[1] >> 24),
21084d00:	80801b17 	ldw	r2,108(r16)
21084d04:	81401a03 	ldbu	r5,104(r16)
21084d08:	01000034 	movhi	r4,0
			(mmc->cid[1] >> 16) & 0xff, (mmc->cid[1] >> 8) & 0xff,
21084d0c:	1006d23a 	srli	r3,r2,8
21084d10:	100ed43a 	srli	r7,r2,16

void print_mmcinfo(struct mmc *mmc) {
	printf("Device: %s\n\r", mmc->name);
	printf("Manufacturer ID: %x\n\r", mmc->cid[0] >> 24);
	printf("OEM: %x\n\r", (mmc->cid[0] >> 8) & 0xffff);
	printf("Name: %c%c%c%c%c \n\r", mmc->cid[0] & 0xff, (mmc->cid[1] >> 24),
21084d14:	100cd63a 	srli	r6,r2,24
21084d18:	18c03fcc 	andi	r3,r3,255
21084d1c:	10803fcc 	andi	r2,r2,255
21084d20:	39c03fcc 	andi	r7,r7,255
21084d24:	d8c00015 	stw	r3,0(sp)
21084d28:	21010304 	addi	r4,r4,1036
21084d2c:	d8800115 	stw	r2,4(sp)
21084d30:	108e3bc0 	call	2108e3bc <printf>
			(mmc->cid[1] >> 16) & 0xff, (mmc->cid[1] >> 8) & 0xff,
			mmc->cid[1] & 0xff);

	printf("Tran Speed: %d\n\r", mmc->tran_speed);
21084d34:	81401f17 	ldw	r5,124(r16)
21084d38:	01000034 	movhi	r4,0
21084d3c:	21010804 	addi	r4,r4,1056
21084d40:	108e3bc0 	call	2108e3bc <printf>
	printf("Rd Block Len: %d\n\r", mmc->read_bl_len);
21084d44:	81402017 	ldw	r5,128(r16)
21084d48:	01000034 	movhi	r4,0
21084d4c:	21010d04 	addi	r4,r4,1076
21084d50:	108e3bc0 	call	2108e3bc <printf>

	printf("%s version %d.%d\n\r", IS_SD(mmc) ? "SD" : "MMC",
21084d54:	81c00a17 	ldw	r7,40(r16)
21084d58:	388000ac 	andhi	r2,r7,2
21084d5c:	10001b1e 	bne	r2,zero,21084dcc <print_mmcinfo+0x114>
21084d60:	01400034 	movhi	r5,0
21084d64:	2940f304 	addi	r5,r5,972
			(mmc->version >> 4) & 0xf, mmc->version & 0xf);
21084d68:	380cd13a 	srli	r6,r7,4
			mmc->cid[1] & 0xff);

	printf("Tran Speed: %d\n\r", mmc->tran_speed);
	printf("Rd Block Len: %d\n\r", mmc->read_bl_len);

	printf("%s version %d.%d\n\r", IS_SD(mmc) ? "SD" : "MMC",
21084d6c:	01000034 	movhi	r4,0
21084d70:	21011204 	addi	r4,r4,1096
21084d74:	318003cc 	andi	r6,r6,15
21084d78:	39c003cc 	andi	r7,r7,15
21084d7c:	108e3bc0 	call	2108e3bc <printf>
			(mmc->version >> 4) & 0xf, mmc->version & 0xf);

	printf("High Capacity: %s\n\r", mmc->high_capacity ? "Yes" : "No");
21084d80:	80800e17 	ldw	r2,56(r16)
21084d84:	1000141e 	bne	r2,zero,21084dd8 <print_mmcinfo+0x120>
21084d88:	01400034 	movhi	r5,0
21084d8c:	2940f504 	addi	r5,r5,980
21084d90:	01000034 	movhi	r4,0
21084d94:	21011704 	addi	r4,r4,1116
21084d98:	108e3bc0 	call	2108e3bc <printf>
	printf("Capacity: %lu MB\n\r", mmc->capacity / 1024 / 1024);
21084d9c:	81402317 	ldw	r5,140(r16)
21084da0:	01000034 	movhi	r4,0
21084da4:	21011c04 	addi	r4,r4,1136
21084da8:	280ad53a 	srli	r5,r5,20
21084dac:	108e3bc0 	call	2108e3bc <printf>

	printf("Bus Width: %d-bit\n\r", mmc->bus_width);
21084db0:	81400f17 	ldw	r5,60(r16)
21084db4:	01000034 	movhi	r4,0
21084db8:	21012104 	addi	r4,r4,1156
}
21084dbc:	dfc00317 	ldw	ra,12(sp)
21084dc0:	dc000217 	ldw	r16,8(sp)
21084dc4:	dec00404 	addi	sp,sp,16
			(mmc->version >> 4) & 0xf, mmc->version & 0xf);

	printf("High Capacity: %s\n\r", mmc->high_capacity ? "Yes" : "No");
	printf("Capacity: %lu MB\n\r", mmc->capacity / 1024 / 1024);

	printf("Bus Width: %d-bit\n\r", mmc->bus_width);
21084dc8:	108e3bc1 	jmpi	2108e3bc <printf>
			mmc->cid[1] & 0xff);

	printf("Tran Speed: %d\n\r", mmc->tran_speed);
	printf("Rd Block Len: %d\n\r", mmc->read_bl_len);

	printf("%s version %d.%d\n\r", IS_SD(mmc) ? "SD" : "MMC",
21084dcc:	01400034 	movhi	r5,0
21084dd0:	2940f204 	addi	r5,r5,968
21084dd4:	003fe406 	br	21084d68 <__flash_rwdata_start+0xfffe2b20>
			(mmc->version >> 4) & 0xf, mmc->version & 0xf);

	printf("High Capacity: %s\n\r", mmc->high_capacity ? "Yes" : "No");
21084dd8:	01400034 	movhi	r5,0
21084ddc:	2940f404 	addi	r5,r5,976
21084de0:	003feb06 	br	21084d90 <__flash_rwdata_start+0xfffe2b48>

21084de4 <ocsdc_set_ios>:
}

static void ocsdc_set_ios(struct mmc *mmc)
{
	/* Support only 4 bit if */
	ocsdc_set_buswidth(mmc->priv, mmc->bus_width);
21084de4:	20800f17 	ldw	r2,60(r4)

	return 0;
}

static void ocsdc_set_ios(struct mmc *mmc)
{
21084de8:	defffb04 	addi	sp,sp,-20
21084dec:	dfc00415 	stw	ra,16(sp)
21084df0:	dcc00315 	stw	r19,12(sp)
21084df4:	dc800215 	stw	r18,8(sp)
21084df8:	dc400115 	stw	r17,4(sp)
21084dfc:	dc000015 	stw	r16,0(sp)
{
	IOWR(dev->iobase, offset, data);
}

static void ocsdc_set_buswidth(struct ocsdc * dev, uint width) {
	if (width == 4)
21084e00:	00c00104 	movi	r3,4
}

static void ocsdc_set_ios(struct mmc *mmc)
{
	/* Support only 4 bit if */
	ocsdc_set_buswidth(mmc->priv, mmc->bus_width);
21084e04:	21400817 	ldw	r5,32(r4)
{
	IOWR(dev->iobase, offset, data);
}

static void ocsdc_set_buswidth(struct ocsdc * dev, uint width) {
	if (width == 4)
21084e08:	10c02d26 	beq	r2,r3,21084ec0 <ocsdc_set_ios+0xdc>
		ocsdc_write(dev, OCSDC_CONTROL, 1);
	else if (width == 1)
21084e0c:	00c00044 	movi	r3,1
21084e10:	10c02f26 	beq	r2,r3,21084ed0 <ocsdc_set_ios+0xec>
{
	/* Support only 4 bit if */
	ocsdc_set_buswidth(mmc->priv, mmc->bus_width);

	/* Set clock speed */
	if (mmc->clock)
21084e14:	24001017 	ldw	r16,64(r4)
21084e18:	8000071e 	bne	r16,zero,21084e38 <ocsdc_set_ios+0x54>
		ocsdc_set_clock(mmc->priv, mmc->clock);
}
21084e1c:	dfc00417 	ldw	ra,16(sp)
21084e20:	dcc00317 	ldw	r19,12(sp)
21084e24:	dc800217 	ldw	r18,8(sp)
21084e28:	dc400117 	ldw	r17,4(sp)
21084e2c:	dc000017 	ldw	r16,0(sp)
21084e30:	dec00504 	addi	sp,sp,20
21084e34:	f800283a 	ret
	/* Support only 4 bit if */
	ocsdc_set_buswidth(mmc->priv, mmc->bus_width);

	/* Set clock speed */
	if (mmc->clock)
		ocsdc_set_clock(mmc->priv, mmc->clock);
21084e38:	24400817 	ldw	r17,32(r4)
}

/* Set clock prescalar value based on the required clock in HZ */
static void ocsdc_set_clock(struct ocsdc * dev, uint clock)
{
	int clk_div = (clock == dev->clk_freq)? 0x00000080 : dev->clk_freq / (2.0 * clock) - 1;
21084e3c:	89000117 	ldw	r4,4(r17)
21084e40:	81002626 	beq	r16,r4,21084edc <ocsdc_set_ios+0xf8>
21084e44:	108cfdc0 	call	2108cfdc <__floatsidf>
21084e48:	8009883a 	mov	r4,r16
21084e4c:	1027883a 	mov	r19,r2
21084e50:	1825883a 	mov	r18,r3
21084e54:	108d0ac0 	call	2108d0ac <__floatunsidf>
21084e58:	1009883a 	mov	r4,r2
21084e5c:	180b883a 	mov	r5,r3
21084e60:	100d883a 	mov	r6,r2
21084e64:	180f883a 	mov	r7,r3
21084e68:	108ad180 	call	2108ad18 <__adddf3>
21084e6c:	9809883a 	mov	r4,r19
21084e70:	900b883a 	mov	r5,r18
21084e74:	100d883a 	mov	r6,r2
21084e78:	180f883a 	mov	r7,r3
21084e7c:	108b5b40 	call	2108b5b4 <__divdf3>
21084e80:	1009883a 	mov	r4,r2
21084e84:	180b883a 	mov	r5,r3
21084e88:	000d883a 	mov	r6,zero
21084e8c:	01cffc34 	movhi	r7,16368
21084e90:	108c6840 	call	2108c684 <__subdf3>
21084e94:	1009883a 	mov	r4,r2
21084e98:	180b883a 	mov	r5,r3
21084e9c:	108cf540 	call	2108cf54 <__fixdfsi>
	return IORD(dev->iobase, offset);
}

static inline void ocsdc_write(struct ocsdc *dev, int offset, uint32_t data)
{
	IOWR(dev->iobase, offset, data);
21084ea0:	88c00017 	ldw	r3,0(r17)
21084ea4:	01000044 	movi	r4,1
21084ea8:	19002835 	stwio	r4,160(r3)
21084eac:	88c00017 	ldw	r3,0(r17)
21084eb0:	18802435 	stwio	r2,144(r3)
21084eb4:	88800017 	ldw	r2,0(r17)
21084eb8:	10002835 	stwio	zero,160(r2)
21084ebc:	003fd706 	br	21084e1c <__flash_rwdata_start+0xfffe2bd4>
21084ec0:	28800017 	ldw	r2,0(r5)
21084ec4:	00c00044 	movi	r3,1
21084ec8:	10c01c35 	stwio	r3,112(r2)
21084ecc:	003fd106 	br	21084e14 <__flash_rwdata_start+0xfffe2bcc>
21084ed0:	28800017 	ldw	r2,0(r5)
21084ed4:	10001c35 	stwio	zero,112(r2)
21084ed8:	003fce06 	br	21084e14 <__flash_rwdata_start+0xfffe2bcc>
}

/* Set clock prescalar value based on the required clock in HZ */
static void ocsdc_set_clock(struct ocsdc * dev, uint clock)
{
	int clk_div = (clock == dev->clk_freq)? 0x00000080 : dev->clk_freq / (2.0 * clock) - 1;
21084edc:	00802004 	movi	r2,128
21084ee0:	003fef06 	br	21084ea0 <__flash_rwdata_start+0xfffe2c58>

21084ee4 <ocsdc_send_cmd>:
	//printf("ocsdc_setup_read: addr: %x\n", (uint32_t)data->dest);

}

static int ocsdc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
{
21084ee4:	defffa04 	addi	sp,sp,-24
	struct ocsdc * dev = mmc->priv;

	int command = (cmd->cmdidx << 8);
	if (cmd->resp_type & MMC_RSP_PRESENT) {
21084ee8:	28800117 	ldw	r2,4(r5)
	//printf("ocsdc_setup_read: addr: %x\n", (uint32_t)data->dest);

}

static int ocsdc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
{
21084eec:	dc000115 	stw	r16,4(sp)
	struct ocsdc * dev = mmc->priv;

	int command = (cmd->cmdidx << 8);
21084ef0:	2c00000b 	ldhu	r16,0(r5)
	//printf("ocsdc_setup_read: addr: %x\n", (uint32_t)data->dest);

}

static int ocsdc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
{
21084ef4:	dc800315 	stw	r18,12(sp)
21084ef8:	dc400215 	stw	r17,8(sp)
21084efc:	dfc00515 	stw	ra,20(sp)
21084f00:	dcc00415 	stw	r19,16(sp)
	struct ocsdc * dev = mmc->priv;

	int command = (cmd->cmdidx << 8);
	if (cmd->resp_type & MMC_RSP_PRESENT) {
21084f04:	10c0004c 	andi	r3,r2,1
	//printf("ocsdc_setup_read: addr: %x\n", (uint32_t)data->dest);

}

static int ocsdc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
{
21084f08:	2825883a 	mov	r18,r5
	struct ocsdc * dev = mmc->priv;
21084f0c:	24400817 	ldw	r17,32(r4)

	int command = (cmd->cmdidx << 8);
21084f10:	8020923a 	slli	r16,r16,8
	if (cmd->resp_type & MMC_RSP_PRESENT) {
21084f14:	18000326 	beq	r3,zero,21084f24 <ocsdc_send_cmd+0x40>
		if (cmd->resp_type & MMC_RSP_136)
21084f18:	10c0008c 	andi	r3,r2,2
21084f1c:	18003c26 	beq	r3,zero,21085010 <ocsdc_send_cmd+0x12c>
			command |= 2;
21084f20:	84000094 	ori	r16,r16,2
		else {
			command |= 1;
		}
	}
	if (cmd->resp_type & MMC_RSP_BUSY)
21084f24:	10c0020c 	andi	r3,r2,8
21084f28:	18000126 	beq	r3,zero,21084f30 <ocsdc_send_cmd+0x4c>
		command |= (1 << 2);
21084f2c:	84000114 	ori	r16,r16,4
	if (cmd->resp_type & MMC_RSP_CRC)
21084f30:	10c0010c 	andi	r3,r2,4
21084f34:	18000126 	beq	r3,zero,21084f3c <ocsdc_send_cmd+0x58>
		command |= (1 << 3);
21084f38:	84000214 	ori	r16,r16,8
	if (cmd->resp_type & MMC_RSP_OPCODE)
21084f3c:	1080040c 	andi	r2,r2,16
21084f40:	10000126 	beq	r2,zero,21084f48 <ocsdc_send_cmd+0x64>
		command |= (1 << 4);
21084f44:	84000414 	ori	r16,r16,16

	if (data && ((data->flags & MMC_DATA_READ) || ((data->flags & MMC_DATA_WRITE))) && data->blocks) {
21084f48:	30000326 	beq	r6,zero,21084f58 <ocsdc_send_cmd+0x74>
21084f4c:	30800117 	ldw	r2,4(r6)
21084f50:	10c000cc 	andi	r3,r2,3
21084f54:	1800161e 	bne	r3,zero,21084fb0 <ocsdc_send_cmd+0xcc>
	return IORD(dev->iobase, offset);
}

static inline void ocsdc_write(struct ocsdc *dev, int offset, uint32_t data)
{
	IOWR(dev->iobase, offset, data);
21084f58:	88800017 	ldw	r2,0(r17)
21084f5c:	14000435 	stwio	r16,16(r2)
21084f60:	88800017 	ldw	r2,0(r17)
21084f64:	90c00217 	ldw	r3,8(r18)
21084f68:	10c00035 	stwio	r3,0(r2)
21084f6c:	89000017 	ldw	r4,0(r17)
	alt_dcache_flush(start, end-start);
}

static inline uint32_t ocsdc_read(struct ocsdc *dev, int offset)
{
	return IORD(dev->iobase, offset);
21084f70:	21003404 	addi	r4,r4,208
21084f74:	00000106 	br	21084f7c <ocsdc_send_cmd+0x98>
			ocsdc_write(dev, OCSDC_CMD_INT_STATUS, 0);
			OCSDC_PRINT(("ocsdc_finish: cmd %d, status %x\n\r", cmd->cmdidx, r2));
			retval = -1;
			break;
		}
		else if (r2 & OCSDC_CMD_INT_STATUS_CC) {
21084f78:	1800271e 	bne	r3,zero,21085018 <ocsdc_send_cmd+0x134>
	alt_dcache_flush(start, end-start);
}

static inline uint32_t ocsdc_read(struct ocsdc *dev, int offset)
{
	return IORD(dev->iobase, offset);
21084f7c:	20c00037 	ldwio	r3,0(r4)

	int retval = 0;
	while (1) {
		int r2 = ocsdc_read(dev, OCSDC_CMD_INT_STATUS);
		//printf("ocsdc_finish: cmd %d, status %x\n", cmd->cmdidx, r2);
		if (r2 & OCSDC_CMD_INT_STATUS_EI) {
21084f80:	1880008c 	andi	r2,r3,2
			ocsdc_write(dev, OCSDC_CMD_INT_STATUS, 0);
			OCSDC_PRINT(("ocsdc_finish: cmd %d, status %x\n\r", cmd->cmdidx, r2));
			retval = -1;
			break;
		}
		else if (r2 & OCSDC_CMD_INT_STATUS_CC) {
21084f84:	18c0004c 	andi	r3,r3,1

	int retval = 0;
	while (1) {
		int r2 = ocsdc_read(dev, OCSDC_CMD_INT_STATUS);
		//printf("ocsdc_finish: cmd %d, status %x\n", cmd->cmdidx, r2);
		if (r2 & OCSDC_CMD_INT_STATUS_EI) {
21084f88:	103ffb26 	beq	r2,zero,21084f78 <__flash_rwdata_start+0xfffe2d30>
	return IORD(dev->iobase, offset);
}

static inline void ocsdc_write(struct ocsdc *dev, int offset, uint32_t data)
{
	IOWR(dev->iobase, offset, data);
21084f8c:	20000035 	stwio	zero,0(r4)
	OCSDC_PRINT(("ocsdc_send_cmd %04x\n\r", command));

	ocsdc_write(dev, OCSDC_COMMAND, command);
	ocsdc_write(dev, OCSDC_ARGUMENT, cmd->cmdarg);

	if (ocsdc_finish(dev, cmd) < 0) return -1;
21084f90:	00bfffc4 	movi	r2,-1
		bool ret = ocsdc_data_finish(dev);

		return ret;
	}
	else return 0;
}
21084f94:	dfc00517 	ldw	ra,20(sp)
21084f98:	dcc00417 	ldw	r19,16(sp)
21084f9c:	dc800317 	ldw	r18,12(sp)
21084fa0:	dc400217 	ldw	r17,8(sp)
21084fa4:	dc000117 	ldw	r16,4(sp)
21084fa8:	dec00604 	addi	sp,sp,24
21084fac:	f800283a 	ret
	if (cmd->resp_type & MMC_RSP_CRC)
		command |= (1 << 3);
	if (cmd->resp_type & MMC_RSP_OPCODE)
		command |= (1 << 4);

	if (data && ((data->flags & MMC_DATA_READ) || ((data->flags & MMC_DATA_WRITE))) && data->blocks) {
21084fb0:	30c00217 	ldw	r3,8(r6)
21084fb4:	183fe826 	beq	r3,zero,21084f58 <__flash_rwdata_start+0xfffe2d10>
		if (data->flags & MMC_DATA_READ)
21084fb8:	1100004c 	andi	r4,r2,1
			command |= (1 << 5);
		if (data->flags & MMC_DATA_WRITE)
21084fbc:	1080008c 	andi	r2,r2,2
		command |= (1 << 3);
	if (cmd->resp_type & MMC_RSP_OPCODE)
		command |= (1 << 4);

	if (data && ((data->flags & MMC_DATA_READ) || ((data->flags & MMC_DATA_WRITE))) && data->blocks) {
		if (data->flags & MMC_DATA_READ)
21084fc0:	2000321e 	bne	r4,zero,2108508c <ocsdc_send_cmd+0x1a8>
			command |= (1 << 5);
		if (data->flags & MMC_DATA_WRITE)
21084fc4:	10000126 	beq	r2,zero,21084fcc <ocsdc_send_cmd+0xe8>
			command |= (1 << 6);
21084fc8:	84001014 	ori	r16,r16,64
	if (data->flags & MMC_DATA_READ) {
		flush_dcache_range(data->dest, data->dest+data->blocksize*data->blocks);
		ocsdc_write(dev, OCSDC_DST_SRC_ADDR, (uint32_t)data->dest);
	}
	else {
		flush_dcache_range((void *)data->src, (void *)data->src+data->blocksize*data->blocks);
21084fcc:	31400317 	ldw	r5,12(r6)
	int iobase;
	int clk_freq;
};

void flush_dcache_range(void * start, void * end) {
	alt_dcache_flush(start, end-start);
21084fd0:	31000017 	ldw	r4,0(r6)
21084fd4:	d9800015 	stw	r6,0(sp)
21084fd8:	194b383a 	mul	r5,r3,r5
21084fdc:	109b15c0 	call	2109b15c <alt_dcache_flush>
	return IORD(dev->iobase, offset);
}

static inline void ocsdc_write(struct ocsdc *dev, int offset, uint32_t data)
{
	IOWR(dev->iobase, offset, data);
21084fe0:	d9800017 	ldw	r6,0(sp)
21084fe4:	88800017 	ldw	r2,0(r17)
21084fe8:	30c00017 	ldw	r3,0(r6)
21084fec:	10c06035 	stwio	r3,384(r2)
21084ff0:	88800017 	ldw	r2,0(r17)
21084ff4:	30c00317 	ldw	r3,12(r6)
21084ff8:	10c04435 	stwio	r3,272(r2)
	else {
		flush_dcache_range((void *)data->src, (void *)data->src+data->blocksize*data->blocks);
		ocsdc_write(dev, OCSDC_DST_SRC_ADDR, (uint32_t)data->src);
	}
	ocsdc_write(dev, OCSDC_BLOCK_SIZE, data->blocksize);
	ocsdc_write(dev, OCSDC_BLOCK_COUNT, data->blocks-1);
21084ffc:	30800217 	ldw	r2,8(r6)
	return IORD(dev->iobase, offset);
}

static inline void ocsdc_write(struct ocsdc *dev, int offset, uint32_t data)
{
	IOWR(dev->iobase, offset, data);
21085000:	88c00017 	ldw	r3,0(r17)
	else {
		flush_dcache_range((void *)data->src, (void *)data->src+data->blocksize*data->blocks);
		ocsdc_write(dev, OCSDC_DST_SRC_ADDR, (uint32_t)data->src);
	}
	ocsdc_write(dev, OCSDC_BLOCK_SIZE, data->blocksize);
	ocsdc_write(dev, OCSDC_BLOCK_COUNT, data->blocks-1);
21085004:	10bfffc4 	addi	r2,r2,-1
	return IORD(dev->iobase, offset);
}

static inline void ocsdc_write(struct ocsdc *dev, int offset, uint32_t data)
{
	IOWR(dev->iobase, offset, data);
21085008:	18804835 	stwio	r2,288(r3)
2108500c:	003fd206 	br	21084f58 <__flash_rwdata_start+0xfffe2d10>
	int command = (cmd->cmdidx << 8);
	if (cmd->resp_type & MMC_RSP_PRESENT) {
		if (cmd->resp_type & MMC_RSP_136)
			command |= 2;
		else {
			command |= 1;
21085010:	84000054 	ori	r16,r16,1
21085014:	003fc306 	br	21084f24 <__flash_rwdata_start+0xfffe2cdc>
	return IORD(dev->iobase, offset);
}

static inline void ocsdc_write(struct ocsdc *dev, int offset, uint32_t data)
{
	IOWR(dev->iobase, offset, data);
21085018:	20000035 	stwio	zero,0(r4)
	alt_dcache_flush(start, end-start);
}

static inline uint32_t ocsdc_read(struct ocsdc *dev, int offset)
{
	return IORD(dev->iobase, offset);
2108501c:	88c00017 	ldw	r3,0(r17)
21085020:	19000837 	ldwio	r4,32(r3)
		else if (r2 & OCSDC_CMD_INT_STATUS_CC) {
			//clear interrupts
			ocsdc_write(dev, OCSDC_CMD_INT_STATUS, 0);
			//get response
			cmd->response[0] = ocsdc_read(dev, OCSDC_RESPONSE_1);
			if (cmd->resp_type & MMC_RSP_136) {
21085024:	90c00117 	ldw	r3,4(r18)
		}
		else if (r2 & OCSDC_CMD_INT_STATUS_CC) {
			//clear interrupts
			ocsdc_write(dev, OCSDC_CMD_INT_STATUS, 0);
			//get response
			cmd->response[0] = ocsdc_read(dev, OCSDC_RESPONSE_1);
21085028:	91000315 	stw	r4,12(r18)
			if (cmd->resp_type & MMC_RSP_136) {
2108502c:	18c0008c 	andi	r3,r3,2
21085030:	18000c1e 	bne	r3,zero,21085064 <ocsdc_send_cmd+0x180>

	ocsdc_write(dev, OCSDC_COMMAND, command);
	ocsdc_write(dev, OCSDC_ARGUMENT, cmd->cmdarg);

	if (ocsdc_finish(dev, cmd) < 0) return -1;
	if (data && data->blocks) {
21085034:	303fd726 	beq	r6,zero,21084f94 <__flash_rwdata_start+0xfffe2d4c>
21085038:	30c00217 	ldw	r3,8(r6)
2108503c:	183fd526 	beq	r3,zero,21084f94 <__flash_rwdata_start+0xfffe2d4c>
21085040:	89000017 	ldw	r4,0(r17)
	alt_dcache_flush(start, end-start);
}

static inline uint32_t ocsdc_read(struct ocsdc *dev, int offset)
{
	return IORD(dev->iobase, offset);
21085044:	21003c04 	addi	r4,r4,240
21085048:	20800037 	ldwio	r2,0(r4)
}

static int ocsdc_data_finish(struct ocsdc * dev) {
	int status;

    while ((status = ocsdc_read(dev, OCSDC_DAT_INT_STATUS)) == 0);
2108504c:	103ffe26 	beq	r2,zero,21085048 <__flash_rwdata_start+0xfffe2e00>
	return IORD(dev->iobase, offset);
}

static inline void ocsdc_write(struct ocsdc *dev, int offset, uint32_t data)
{
	IOWR(dev->iobase, offset, data);
21085050:	20000035 	stwio	zero,0(r4)
	int status;

    while ((status = ocsdc_read(dev, OCSDC_DAT_INT_STATUS)) == 0);
    ocsdc_write(dev, OCSDC_DAT_INT_STATUS, 0);

    if (status & SDCMSC_DAT_INT_STATUS_TRS) {
21085054:	1080004c 	andi	r2,r2,1
21085058:	1080005c 	xori	r2,r2,1
2108505c:	0085c83a 	sub	r2,zero,r2
21085060:	003fcc06 	br	21084f94 <__flash_rwdata_start+0xfffe2d4c>
	alt_dcache_flush(start, end-start);
}

static inline uint32_t ocsdc_read(struct ocsdc *dev, int offset)
{
	return IORD(dev->iobase, offset);
21085064:	88c00017 	ldw	r3,0(r17)
21085068:	18c00c37 	ldwio	r3,48(r3)
			//clear interrupts
			ocsdc_write(dev, OCSDC_CMD_INT_STATUS, 0);
			//get response
			cmd->response[0] = ocsdc_read(dev, OCSDC_RESPONSE_1);
			if (cmd->resp_type & MMC_RSP_136) {
				cmd->response[1] = ocsdc_read(dev, OCSDC_RESPONSE_2);
2108506c:	90c00415 	stw	r3,16(r18)
	alt_dcache_flush(start, end-start);
}

static inline uint32_t ocsdc_read(struct ocsdc *dev, int offset)
{
	return IORD(dev->iobase, offset);
21085070:	88c00017 	ldw	r3,0(r17)
21085074:	18c01037 	ldwio	r3,64(r3)
			ocsdc_write(dev, OCSDC_CMD_INT_STATUS, 0);
			//get response
			cmd->response[0] = ocsdc_read(dev, OCSDC_RESPONSE_1);
			if (cmd->resp_type & MMC_RSP_136) {
				cmd->response[1] = ocsdc_read(dev, OCSDC_RESPONSE_2);
				cmd->response[2] = ocsdc_read(dev, OCSDC_RESPONSE_3);
21085078:	90c00515 	stw	r3,20(r18)
	alt_dcache_flush(start, end-start);
}

static inline uint32_t ocsdc_read(struct ocsdc *dev, int offset)
{
	return IORD(dev->iobase, offset);
2108507c:	88c00017 	ldw	r3,0(r17)
21085080:	18c01437 	ldwio	r3,80(r3)
			//get response
			cmd->response[0] = ocsdc_read(dev, OCSDC_RESPONSE_1);
			if (cmd->resp_type & MMC_RSP_136) {
				cmd->response[1] = ocsdc_read(dev, OCSDC_RESPONSE_2);
				cmd->response[2] = ocsdc_read(dev, OCSDC_RESPONSE_3);
				cmd->response[3] = ocsdc_read(dev, OCSDC_RESPONSE_4);
21085084:	90c00615 	stw	r3,24(r18)
21085088:	003fea06 	br	21085034 <__flash_rwdata_start+0xfffe2dec>
	if (cmd->resp_type & MMC_RSP_OPCODE)
		command |= (1 << 4);

	if (data && ((data->flags & MMC_DATA_READ) || ((data->flags & MMC_DATA_WRITE))) && data->blocks) {
		if (data->flags & MMC_DATA_READ)
			command |= (1 << 5);
2108508c:	84c00814 	ori	r19,r16,32
		if (data->flags & MMC_DATA_WRITE)
21085090:	10000126 	beq	r2,zero,21085098 <ocsdc_send_cmd+0x1b4>
			command |= (1 << 6);
21085094:	84c01814 	ori	r19,r16,96

static void ocsdc_setup_data_xfer(struct ocsdc * dev, struct mmc_cmd *cmd, struct mmc_data *data) {

	//invalidate cache
	if (data->flags & MMC_DATA_READ) {
		flush_dcache_range(data->dest, data->dest+data->blocksize*data->blocks);
21085098:	31400317 	ldw	r5,12(r6)
	int iobase;
	int clk_freq;
};

void flush_dcache_range(void * start, void * end) {
	alt_dcache_flush(start, end-start);
2108509c:	31000017 	ldw	r4,0(r6)
210850a0:	d9800015 	stw	r6,0(sp)
210850a4:	194b383a 	mul	r5,r3,r5
210850a8:	109b15c0 	call	2109b15c <alt_dcache_flush>
	return IORD(dev->iobase, offset);
}

static inline void ocsdc_write(struct ocsdc *dev, int offset, uint32_t data)
{
	IOWR(dev->iobase, offset, data);
210850ac:	d9800017 	ldw	r6,0(sp)
210850b0:	88800017 	ldw	r2,0(r17)
210850b4:	30c00017 	ldw	r3,0(r6)
210850b8:	10c06035 	stwio	r3,384(r2)
210850bc:	9821883a 	mov	r16,r19
210850c0:	003fcb06 	br	21084ff0 <__flash_rwdata_start+0xfffe2da8>

210850c4 <ocsdc_init>:
	else return 0;
}

/* Initialize ocsdc controller */
static int ocsdc_init(struct mmc *mmc)
{
210850c4:	defffb04 	addi	sp,sp,-20
210850c8:	dc000015 	stw	r16,0(sp)
	struct ocsdc * dev = mmc->priv;
210850cc:	24000817 	ldw	r16,32(r4)
	else return 0;
}

/* Initialize ocsdc controller */
static int ocsdc_init(struct mmc *mmc)
{
210850d0:	dfc00415 	stw	ra,16(sp)
210850d4:	dcc00315 	stw	r19,12(sp)
	return IORD(dev->iobase, offset);
}

static inline void ocsdc_write(struct ocsdc *dev, int offset, uint32_t data)
{
	IOWR(dev->iobase, offset, data);
210850d8:	80800017 	ldw	r2,0(r16)
	else return 0;
}

/* Initialize ocsdc controller */
static int ocsdc_init(struct mmc *mmc)
{
210850dc:	dc800215 	stw	r18,8(sp)
210850e0:	dc400115 	stw	r17,4(sp)
	return IORD(dev->iobase, offset);
}

static inline void ocsdc_write(struct ocsdc *dev, int offset, uint32_t data)
{
	IOWR(dev->iobase, offset, data);
210850e4:	00dfffc4 	movi	r3,32767
210850e8:	10c02035 	stwio	r3,128(r2)
210850ec:	80800017 	ldw	r2,0(r16)
210850f0:	10003835 	stwio	zero,224(r2)
210850f4:	80800017 	ldw	r2,0(r16)
210850f8:	10004035 	stwio	zero,256(r2)
210850fc:	80800017 	ldw	r2,0(r16)
21085100:	10003435 	stwio	zero,208(r2)
21085104:	80800017 	ldw	r2,0(r16)
21085108:	10003c35 	stwio	zero,240(r2)
	ocsdc_write(dev, OCSDC_DAT_INT_ENABLE, 0);
	//clear all interrupts
	ocsdc_write(dev, OCSDC_CMD_INT_STATUS, 0);
	ocsdc_write(dev, OCSDC_DAT_INT_STATUS, 0);
	//set clock to maximum (devide by 2)
	ocsdc_set_clock(dev, dev->clk_freq/2);
2108510c:	81000117 	ldw	r4,4(r16)
21085110:	2022d7fa 	srli	r17,r4,31
21085114:	8923883a 	add	r17,r17,r4
21085118:	8823d07a 	srai	r17,r17,1
}

/* Set clock prescalar value based on the required clock in HZ */
static void ocsdc_set_clock(struct ocsdc * dev, uint clock)
{
	int clk_div = (clock == dev->clk_freq)? 0x00000080 : dev->clk_freq / (2.0 * clock) - 1;
2108511c:	89002626 	beq	r17,r4,210851b8 <ocsdc_init+0xf4>
21085120:	108cfdc0 	call	2108cfdc <__floatsidf>
21085124:	8809883a 	mov	r4,r17
21085128:	1027883a 	mov	r19,r2
2108512c:	1825883a 	mov	r18,r3
21085130:	108d0ac0 	call	2108d0ac <__floatunsidf>
21085134:	1009883a 	mov	r4,r2
21085138:	180b883a 	mov	r5,r3
2108513c:	100d883a 	mov	r6,r2
21085140:	180f883a 	mov	r7,r3
21085144:	108ad180 	call	2108ad18 <__adddf3>
21085148:	9809883a 	mov	r4,r19
2108514c:	900b883a 	mov	r5,r18
21085150:	100d883a 	mov	r6,r2
21085154:	180f883a 	mov	r7,r3
21085158:	108b5b40 	call	2108b5b4 <__divdf3>
2108515c:	1009883a 	mov	r4,r2
21085160:	180b883a 	mov	r5,r3
21085164:	000d883a 	mov	r6,zero
21085168:	01cffc34 	movhi	r7,16368
2108516c:	108c6840 	call	2108c684 <__subdf3>
21085170:	1009883a 	mov	r4,r2
21085174:	180b883a 	mov	r5,r3
21085178:	108cf540 	call	2108cf54 <__fixdfsi>
	return IORD(dev->iobase, offset);
}

static inline void ocsdc_write(struct ocsdc *dev, int offset, uint32_t data)
{
	IOWR(dev->iobase, offset, data);
2108517c:	80c00017 	ldw	r3,0(r16)
21085180:	01000044 	movi	r4,1
21085184:	19002835 	stwio	r4,160(r3)
21085188:	80c00017 	ldw	r3,0(r16)
2108518c:	18802435 	stwio	r2,144(r3)
21085190:	80800017 	ldw	r2,0(r16)
21085194:	10002835 	stwio	zero,160(r2)
	ocsdc_write(dev, OCSDC_DAT_INT_STATUS, 0);
	//set clock to maximum (devide by 2)
	ocsdc_set_clock(dev, dev->clk_freq/2);

	return 0;
}
21085198:	0005883a 	mov	r2,zero
2108519c:	dfc00417 	ldw	ra,16(sp)
210851a0:	dcc00317 	ldw	r19,12(sp)
210851a4:	dc800217 	ldw	r18,8(sp)
210851a8:	dc400117 	ldw	r17,4(sp)
210851ac:	dc000017 	ldw	r16,0(sp)
210851b0:	dec00504 	addi	sp,sp,20
210851b4:	f800283a 	ret
}

/* Set clock prescalar value based on the required clock in HZ */
static void ocsdc_set_clock(struct ocsdc * dev, uint clock)
{
	int clk_div = (clock == dev->clk_freq)? 0x00000080 : dev->clk_freq / (2.0 * clock) - 1;
210851b8:	00802004 	movi	r2,128
210851bc:	003fef06 	br	2108517c <__flash_rwdata_start+0xfffe2f34>

210851c0 <flush_dcache_range>:
	int iobase;
	int clk_freq;
};

void flush_dcache_range(void * start, void * end) {
	alt_dcache_flush(start, end-start);
210851c0:	290bc83a 	sub	r5,r5,r4
210851c4:	109b15c1 	jmpi	2109b15c <alt_dcache_flush>

210851c8 <ocsdc_mmc_init>:
	if (mmc->clock)
		ocsdc_set_clock(mmc->priv, mmc->clock);
}

struct mmc * ocsdc_mmc_init(int base_addr, int clk_freq)
{
210851c8:	defffb04 	addi	sp,sp,-20
210851cc:	dcc00315 	stw	r19,12(sp)
210851d0:	2027883a 	mov	r19,r4
	struct mmc *mmc;
	struct ocsdc *priv;

	mmc = malloc(sizeof(struct mmc));
210851d4:	01002904 	movi	r4,164
	if (mmc->clock)
		ocsdc_set_clock(mmc->priv, mmc->clock);
}

struct mmc * ocsdc_mmc_init(int base_addr, int clk_freq)
{
210851d8:	dc800215 	stw	r18,8(sp)
210851dc:	dc000015 	stw	r16,0(sp)
210851e0:	dfc00415 	stw	ra,16(sp)
210851e4:	dc400115 	stw	r17,4(sp)
210851e8:	2825883a 	mov	r18,r5
	struct mmc *mmc;
	struct ocsdc *priv;

	mmc = malloc(sizeof(struct mmc));
210851ec:	108d8e80 	call	2108d8e8 <malloc>
210851f0:	1021883a 	mov	r16,r2
	if (!mmc) goto MMC_ALLOC;
210851f4:	10002b26 	beq	r2,zero,210852a4 <ocsdc_mmc_init+0xdc>
	priv = malloc(sizeof(struct ocsdc));
210851f8:	01000204 	movi	r4,8
210851fc:	108d8e80 	call	2108d8e8 <malloc>
21085200:	1023883a 	mov	r17,r2
	mmc->b_max = 256;

	return mmc;

OCSDC_ALLOC:
	free(mmc);
21085204:	8009883a 	mov	r4,r16
	struct ocsdc *priv;

	mmc = malloc(sizeof(struct mmc));
	if (!mmc) goto MMC_ALLOC;
	priv = malloc(sizeof(struct ocsdc));
	if (!priv) goto OCSDC_ALLOC;
21085208:	10002826 	beq	r2,zero,210852ac <ocsdc_mmc_init+0xe4>

	memset(mmc, 0, sizeof(struct mmc));
2108520c:	000b883a 	mov	r5,zero
21085210:	01802904 	movi	r6,164
21085214:	108e26c0 	call	2108e26c <memset>
	memset(priv, 0, sizeof(struct ocsdc));

	priv->iobase = base_addr;
	priv->clk_freq = clk_freq;

	sprintf(mmc->name, "ocsdc");
21085218:	00d91cf4 	movhi	r3,25715
2108521c:	18d8dbc4 	addi	r3,r3,25455
21085220:	80c00015 	stw	r3,0(r16)
21085224:	00c018c4 	movi	r3,99
21085228:	80c0010d 	sth	r3,4(r16)
	mmc->priv = priv;
	mmc->send_cmd = ocsdc_send_cmd;
2108522c:	00c84234 	movhi	r3,8456
21085230:	18d3b904 	addi	r3,r3,20196
	mmc->set_ios = ocsdc_set_ios;
	mmc->init = ocsdc_init;
	mmc->getcd = NULL;

	mmc->f_min = priv->clk_freq/6; /*maximum clock division 64 */
21085234:	00800184 	movi	r2,6
21085238:	9085283a 	div	r2,r18,r2
	priv->iobase = base_addr;
	priv->clk_freq = clk_freq;

	sprintf(mmc->name, "ocsdc");
	mmc->priv = priv;
	mmc->send_cmd = ocsdc_send_cmd;
2108523c:	80c02415 	stw	r3,144(r16)
	mmc->set_ios = ocsdc_set_ios;
21085240:	00c84234 	movhi	r3,8456
21085244:	18d37904 	addi	r3,r3,19940
	mmc->init = ocsdc_init;
	mmc->getcd = NULL;

	mmc->f_min = priv->clk_freq/6; /*maximum clock division 64 */
21085248:	80800c15 	stw	r2,48(r16)
	mmc->f_max = priv->clk_freq;
	mmc->voltages = MMC_VDD_32_33 | MMC_VDD_33_34;
2108524c:	00800c34 	movhi	r2,48
	priv->clk_freq = clk_freq;

	sprintf(mmc->name, "ocsdc");
	mmc->priv = priv;
	mmc->send_cmd = ocsdc_send_cmd;
	mmc->set_ios = ocsdc_set_ios;
21085250:	80c02515 	stw	r3,148(r16)
	mmc->init = ocsdc_init;
	mmc->getcd = NULL;

	mmc->f_min = priv->clk_freq/6; /*maximum clock division 64 */
	mmc->f_max = priv->clk_freq;
	mmc->voltages = MMC_VDD_32_33 | MMC_VDD_33_34;
21085254:	80800915 	stw	r2,36(r16)

	sprintf(mmc->name, "ocsdc");
	mmc->priv = priv;
	mmc->send_cmd = ocsdc_send_cmd;
	mmc->set_ios = ocsdc_set_ios;
	mmc->init = ocsdc_init;
21085258:	00c84234 	movhi	r3,8456

	mmc->f_min = priv->clk_freq/6; /*maximum clock division 64 */
	mmc->f_max = priv->clk_freq;
	mmc->voltages = MMC_VDD_32_33 | MMC_VDD_33_34;
	mmc->host_caps = MMC_MODE_4BIT;
	mmc->host_caps = MMC_MODE_HS | MMC_MODE_HS_52MHz | MMC_MODE_4BIT;
2108525c:	00804444 	movi	r2,273

	sprintf(mmc->name, "ocsdc");
	mmc->priv = priv;
	mmc->send_cmd = ocsdc_send_cmd;
	mmc->set_ios = ocsdc_set_ios;
	mmc->init = ocsdc_init;
21085260:	18d43104 	addi	r3,r3,20676

	mmc->f_min = priv->clk_freq/6; /*maximum clock division 64 */
	mmc->f_max = priv->clk_freq;
	mmc->voltages = MMC_VDD_32_33 | MMC_VDD_33_34;
	mmc->host_caps = MMC_MODE_4BIT;
	mmc->host_caps = MMC_MODE_HS | MMC_MODE_HS_52MHz | MMC_MODE_4BIT;
21085264:	80801215 	stw	r2,72(r16)

	mmc->b_max = 256;
21085268:	00804004 	movi	r2,256
2108526c:	80802815 	stw	r2,160(r16)
	if (!priv) goto OCSDC_ALLOC;

	memset(mmc, 0, sizeof(struct mmc));
	memset(priv, 0, sizeof(struct ocsdc));

	priv->iobase = base_addr;
21085270:	8cc00015 	stw	r19,0(r17)
	priv->clk_freq = clk_freq;
21085274:	8c800115 	stw	r18,4(r17)

	sprintf(mmc->name, "ocsdc");
	mmc->priv = priv;
21085278:	84400815 	stw	r17,32(r16)
	mmc->send_cmd = ocsdc_send_cmd;
	mmc->set_ios = ocsdc_set_ios;
	mmc->init = ocsdc_init;
2108527c:	80c02615 	stw	r3,152(r16)
	mmc->getcd = NULL;

	mmc->f_min = priv->clk_freq/6; /*maximum clock division 64 */
	mmc->f_max = priv->clk_freq;
21085280:	84800d15 	stw	r18,52(r16)
	mmc->host_caps = MMC_MODE_4BIT;
	mmc->host_caps = MMC_MODE_HS | MMC_MODE_HS_52MHz | MMC_MODE_4BIT;

	mmc->b_max = 256;

	return mmc;
21085284:	8005883a 	mov	r2,r16

OCSDC_ALLOC:
	free(mmc);
MMC_ALLOC:
	return NULL;
}
21085288:	dfc00417 	ldw	ra,16(sp)
2108528c:	dcc00317 	ldw	r19,12(sp)
21085290:	dc800217 	ldw	r18,8(sp)
21085294:	dc400117 	ldw	r17,4(sp)
21085298:	dc000017 	ldw	r16,0(sp)
2108529c:	dec00504 	addi	sp,sp,20
210852a0:	f800283a 	ret
	return mmc;

OCSDC_ALLOC:
	free(mmc);
MMC_ALLOC:
	return NULL;
210852a4:	0005883a 	mov	r2,zero
210852a8:	003ff706 	br	21085288 <__flash_rwdata_start+0xfffe3040>
	mmc->b_max = 256;

	return mmc;

OCSDC_ALLOC:
	free(mmc);
210852ac:	108d8fc0 	call	2108d8fc <free>
MMC_ALLOC:
	return NULL;
210852b0:	0005883a 	mov	r2,zero
210852b4:	003ff406 	br	21085288 <__flash_rwdata_start+0xfffe3040>

210852b8 <SDLIB_Init>:
struct mmc * sd_drv;
//-------------------------------------------------------------------------
bool SDLIB_Init(int base_addr) {
	//---------------------------------
	//init ocsdc driver
	if (!sd_drv) {
210852b8:	d0a01c17 	ldw	r2,-32656(gp)

#define DEBUG_SDCARD_HEX //DEBUG_HEX_PRINTF

struct mmc * sd_drv;
//-------------------------------------------------------------------------
bool SDLIB_Init(int base_addr) {
210852bc:	deffff04 	addi	sp,sp,-4
210852c0:	dfc00015 	stw	ra,0(sp)
	//---------------------------------
	//init ocsdc driver
	if (!sd_drv) {
210852c4:	10000f26 	beq	r2,zero,21085304 <SDLIB_Init+0x4c>
			return FALSE;
		}
		SDCARD_DEBUG(("ocsdc_mmc_init success\n\r"));
	}

	if (sd_drv->has_init)
210852c8:	10c00b17 	ldw	r3,44(r2)
210852cc:	18000426 	beq	r3,zero,210852e0 <SDLIB_Init+0x28>
		return TRUE;
210852d0:	00800044 	movi	r2,1
#ifdef DEBUG_SDCARD
	print_mmcinfo(sd_drv);
#endif

	return TRUE;
}
210852d4:	dfc00017 	ldw	ra,0(sp)
210852d8:	dec00104 	addi	sp,sp,4
210852dc:	f800283a 	ret
		SDCARD_DEBUG(("ocsdc_mmc_init success\n\r"));
	}

	if (sd_drv->has_init)
		return TRUE;
	int err = mmc_init(sd_drv);
210852e0:	1009883a 	mov	r4,r2
210852e4:	10846a40 	call	210846a4 <mmc_init>
	if (err != 0 || sd_drv->has_init == 0) {
210852e8:	10000b1e 	bne	r2,zero,21085318 <SDLIB_Init+0x60>
210852ec:	d0a01c17 	ldw	r2,-32656(gp)
210852f0:	10800b17 	ldw	r2,44(r2)
210852f4:	1004c03a 	cmpne	r2,r2,zero
#ifdef DEBUG_SDCARD
	print_mmcinfo(sd_drv);
#endif

	return TRUE;
}
210852f8:	dfc00017 	ldw	ra,0(sp)
210852fc:	dec00104 	addi	sp,sp,4
21085300:	f800283a 	ret
//-------------------------------------------------------------------------
bool SDLIB_Init(int base_addr) {
	//---------------------------------
	//init ocsdc driver
	if (!sd_drv) {
		sd_drv = ocsdc_mmc_init(base_addr, 50000000);
21085304:	0140bef4 	movhi	r5,763
21085308:	297c2004 	addi	r5,r5,-3968
2108530c:	10851c80 	call	210851c8 <ocsdc_mmc_init>
21085310:	d0a01c15 	stw	r2,-32656(gp)
		if(!sd_drv){
21085314:	103fec1e 	bne	r2,zero,210852c8 <__flash_rwdata_start+0xfffe3080>
			SDCARD_DEBUG(("ocsdc_mmc_init failed\n\r"));
			return FALSE;
21085318:	0005883a 	mov	r2,zero
#ifdef DEBUG_SDCARD
	print_mmcinfo(sd_drv);
#endif

	return TRUE;
}
2108531c:	dfc00017 	ldw	ra,0(sp)
21085320:	dec00104 	addi	sp,sp,4
21085324:	f800283a 	ret

21085328 <SDLIB_ReadBlock512>:

bool SDLIB_ReadBlock512(alt_u32 block_number, alt_u8 *buff) {
21085328:	2005883a 	mov	r2,r4
	//SDCARD_DEBUG(("%d\n", block_number));
	if (mmc_bread(sd_drv, block_number, 1, buff) == 0) {
2108532c:	d1201c17 	ldw	r4,-32656(gp)
#endif

	return TRUE;
}

bool SDLIB_ReadBlock512(alt_u32 block_number, alt_u8 *buff) {
21085330:	deffff04 	addi	sp,sp,-4
21085334:	280f883a 	mov	r7,r5
	//SDCARD_DEBUG(("%d\n", block_number));
	if (mmc_bread(sd_drv, block_number, 1, buff) == 0) {
21085338:	01800044 	movi	r6,1
2108533c:	100b883a 	mov	r5,r2
#endif

	return TRUE;
}

bool SDLIB_ReadBlock512(alt_u32 block_number, alt_u8 *buff) {
21085340:	dfc00015 	stw	ra,0(sp)
	//SDCARD_DEBUG(("%d\n", block_number));
	if (mmc_bread(sd_drv, block_number, 1, buff) == 0) {
21085344:	1084b0c0 	call	21084b0c <mmc_bread>
		SDCARD_DEBUG(("mmc_bread failed\n\r"));
		return FALSE;
	}

	return TRUE;
}
21085348:	1004c03a 	cmpne	r2,r2,zero
2108534c:	dfc00017 	ldw	ra,0(sp)
21085350:	dec00104 	addi	sp,sp,4
21085354:	f800283a 	ret

21085358 <SDLIB_ReadBlocks>:

bool SDLIB_ReadBlocks(alt_u32 block_number, alt_u32 n, alt_u8 *buff) {
21085358:	2007883a 	mov	r3,r4
	//SDCARD_DEBUG(("%d\n", block_number));
	if (mmc_bread(sd_drv, block_number, n, buff) == 0) {
2108535c:	d1201c17 	ldw	r4,-32656(gp)
	}

	return TRUE;
}

bool SDLIB_ReadBlocks(alt_u32 block_number, alt_u32 n, alt_u8 *buff) {
21085360:	2805883a 	mov	r2,r5
21085364:	deffff04 	addi	sp,sp,-4
21085368:	300f883a 	mov	r7,r6
	//SDCARD_DEBUG(("%d\n", block_number));
	if (mmc_bread(sd_drv, block_number, n, buff) == 0) {
2108536c:	180b883a 	mov	r5,r3
21085370:	100d883a 	mov	r6,r2
	}

	return TRUE;
}

bool SDLIB_ReadBlocks(alt_u32 block_number, alt_u32 n, alt_u8 *buff) {
21085374:	dfc00015 	stw	ra,0(sp)
	//SDCARD_DEBUG(("%d\n", block_number));
	if (mmc_bread(sd_drv, block_number, n, buff) == 0) {
21085378:	1084b0c0 	call	21084b0c <mmc_bread>
		SDCARD_DEBUG(("mmc_bread failed\n\r"));
		return FALSE;
	}

	return TRUE;
}
2108537c:	1004c03a 	cmpne	r2,r2,zero
21085380:	dfc00017 	ldw	ra,0(sp)
21085384:	dec00104 	addi	sp,sp,4
21085388:	f800283a 	ret

2108538c <ece423_video_display_add_text.constprop.2>:
 *  Purpose: Add a string to the screen
 *
 ******************************************************************/
void ece423_video_display_add_text(ece423_video_display* display, char* text, int x, int y, uint rgb_color, int scale) {

	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
2108538c:	20802717 	ldw	r2,156(r4)
	int spacing = 0;
	uint color = rgb2ycbcr(rgb_color);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
21085390:	00c00034 	movhi	r3,0
21085394:	18d76304 	addi	r3,r3,23948
 *  Purpose: Add a string to the screen
 *
 ******************************************************************/
void ece423_video_display_add_text(ece423_video_display* display, char* text, int x, int y, uint rgb_color, int scale) {

	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
21085398:	10800044 	addi	r2,r2,1
2108539c:	1085883a 	add	r2,r2,r2
210853a0:	1085883a 	add	r2,r2,r2
210853a4:	2085883a 	add	r2,r4,r2
	int spacing = 0;
	uint color = rgb2ycbcr(rgb_color);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
210853a8:	18c00017 	ldw	r3,0(r3)
 *  Purpose: Add a string to the screen
 *
 ******************************************************************/
void ece423_video_display_add_text(ece423_video_display* display, char* text, int x, int y, uint rgb_color, int scale) {

	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
210853ac:	10800017 	ldw	r2,0(r2)
 *  Function: ece423_video_display_add_text
 *
 *  Purpose: Add a string to the screen
 *
 ******************************************************************/
void ece423_video_display_add_text(ece423_video_display* display, char* text, int x, int y, uint rgb_color, int scale) {
210853b0:	deffef04 	addi	sp,sp,-68
210853b4:	dc400815 	stw	r17,32(sp)
210853b8:	2023883a 	mov	r17,r4
210853bc:	2809883a 	mov	r4,r5
210853c0:	df000f15 	stw	fp,60(sp)
210853c4:	ddc00e15 	stw	r23,56(sp)
210853c8:	dd800d15 	stw	r22,52(sp)
210853cc:	dd400c15 	stw	r21,48(sp)
210853d0:	dd000b15 	stw	r20,44(sp)
210853d4:	dcc00a15 	stw	r19,40(sp)
210853d8:	3029883a 	mov	r20,r6
210853dc:	dc000715 	stw	r16,28(sp)
210853e0:	2827883a 	mov	r19,r5
	int spacing = 0;
	uint color = rgb2ycbcr(rgb_color);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
210853e4:	d8c00015 	stw	r3,0(sp)
 *  Function: ece423_video_display_add_text
 *
 *  Purpose: Add a string to the screen
 *
 ******************************************************************/
void ece423_video_display_add_text(ece423_video_display* display, char* text, int x, int y, uint rgb_color, int scale) {
210853e8:	dfc01015 	stw	ra,64(sp)
210853ec:	dc800915 	stw	r18,36(sp)

	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
210853f0:	15400117 	ldw	r21,4(r2)
210853f4:	108e7200 	call	2108e720 <strlen>
210853f8:	00c00034 	movhi	r3,0
210853fc:	18d78004 	addi	r3,r3,24064
21085400:	1d800017 	ldw	r22,0(r3)
21085404:	d8c00017 	ldw	r3,0(sp)
	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {

		int c_offset = text[i] - 32;

		int c_width = font_glyph_dsc[c_offset].w_px;
21085408:	02c00034 	movhi	r11,0
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;

						if(b & mask) {
							frame[frame_offset] = color;
2108540c:	07002034 	movhi	fp,128
							p_color += 0x00005000;
							if(p_color > 0x0000FF00)
								p_color = 0x0000FF00;
							else if(p_color < 0x0000CC00)
								p_color = 0x0000CC00;
							frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
21085410:	027ffff4 	movhi	r9,65535
	uint color = rgb2ycbcr(rgb_color);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {
21085414:	000d883a 	mov	r6,zero

	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;

	int spacing = 0;
	uint color = rgb2ycbcr(rgb_color);
	int x_offset = x;
21085418:	04000284 	movi	r16,10
	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {

		int c_offset = text[i] - 32;

		int c_width = font_glyph_dsc[c_offset].w_px;
2108541c:	5ac19004 	addi	r11,r11,1600
21085420:	1d1b883a 	add	r13,r3,r20
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;

						if(b & mask) {
							frame[frame_offset] = color;
21085424:	e7002004 	addi	fp,fp,128
							continue;
						}
						unsigned int bg_color = frame[frame_offset];
						unsigned int p_color = bg_color & 0x0000FF00;
						if(p_color < 0x0000DD00) {
21085428:	05f73fd4 	movui	r23,56575
							p_color += 0x00005000;
							if(p_color > 0x0000FF00)
2108542c:	02bfc014 	movui	r10,65280
								p_color = 0x0000FF00;
							else if(p_color < 0x0000CC00)
								p_color = 0x0000CC00;
							frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
21085430:	4a403fc4 	addi	r9,r9,255
						unsigned int p_color = bg_color & 0x0000FF00;
						if(p_color < 0x0000DD00) {
							p_color += 0x00005000;
							if(p_color > 0x0000FF00)
								p_color = 0x0000FF00;
							else if(p_color < 0x0000CC00)
21085434:	0172ffd4 	movui	r5,52223
	uint color = rgb2ycbcr(rgb_color);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {
21085438:	3080492e 	bgeu	r6,r2,21085560 <ece423_video_display_add_text.constprop.2+0x1d4>
2108543c:	9987883a 	add	r3,r19,r6

		int c_offset = text[i] - 32;
21085440:	18c00007 	ldb	r3,0(r3)
21085444:	18fff804 	addi	r3,r3,-32

		int c_width = font_glyph_dsc[c_offset].w_px;
21085448:	180690fa 	slli	r3,r3,3
2108544c:	58c9883a 	add	r4,r11,r3
		int c_index = font_glyph_dsc[c_offset].glyph_index;

		for (int j = 0; j < c_height; j++) {
21085450:	d8c00017 	ldw	r3,0(sp)
	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {

		int c_offset = text[i] - 32;

		int c_width = font_glyph_dsc[c_offset].w_px;
21085454:	24800017 	ldw	r18,0(r4)
		int c_index = font_glyph_dsc[c_offset].glyph_index;
21085458:	21000117 	ldw	r4,4(r4)

		for (int j = 0; j < c_height; j++) {
2108545c:	00c03d0e 	bge	zero,r3,21085554 <ece423_video_display_add_text.constprop.2+0x1c8>
21085460:	b105883a 	add	r2,r22,r4
21085464:	10800003 	ldbu	r2,0(r2)
21085468:	a01f883a 	mov	r15,r20
			int k = 0;
			unsigned char mask = 0x80;
			unsigned char b = font_glyph_bitmap[c_index];
2108546c:	101d883a 	mov	r14,r2
			while(k < c_width) {
21085470:	0480280e 	bge	zero,r18,21085514 <ece423_video_display_add_text.constprop.2+0x188>
21085474:	023fe004 	movi	r8,-128
21085478:	0007883a 	mov	r3,zero

				for(int l = 0; l < scale; l++)
					for(int m = 0; m < scale; m++) {
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;
2108547c:	88802817 	ldw	r2,160(r17)

						if(b & mask) {
21085480:	720e703a 	and	r7,r14,r8
21085484:	39c03fcc 	andi	r7,r7,255

				for(int l = 0; l < scale; l++)
					for(int m = 0; m < scale; m++) {
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;
21085488:	7885383a 	mul	r2,r15,r2
2108548c:	1405883a 	add	r2,r2,r16
21085490:	1885883a 	add	r2,r3,r2

						if(b & mask) {
							frame[frame_offset] = color;
21085494:	1085883a 	add	r2,r2,r2
21085498:	1085883a 	add	r2,r2,r2
2108549c:	a885883a 	add	r2,r21,r2
					for(int m = 0; m < scale; m++) {
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;

						if(b & mask) {
210854a0:	3800161e 	bne	r7,zero,210854fc <ece423_video_display_add_text.constprop.2+0x170>
							frame[frame_offset] = color;
							continue;
						}
						unsigned int bg_color = frame[frame_offset];
210854a4:	17c00017 	ldw	ra,0(r2)
						unsigned int p_color = bg_color & 0x0000FF00;
210854a8:	f9ffc00c 	andi	r7,ra,65280
						if(p_color < 0x0000DD00) {
210854ac:	b9c00736 	bltu	r23,r7,210854cc <ece423_video_display_add_text.constprop.2+0x140>
							p_color += 0x00005000;
210854b0:	39d40004 	addi	r7,r7,20480
							if(p_color > 0x0000FF00)
210854b4:	51c03636 	bltu	r10,r7,21085590 <ece423_video_display_add_text.constprop.2+0x204>
								p_color = 0x0000FF00;
							else if(p_color < 0x0000CC00)
210854b8:	29c00136 	bltu	r5,r7,210854c0 <ece423_video_display_add_text.constprop.2+0x134>
								p_color = 0x0000CC00;
210854bc:	01f30014 	movui	r7,52224
							frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
210854c0:	fa7e703a 	and	ra,ra,r9
210854c4:	3fceb03a 	or	r7,r7,ra
210854c8:	11c00015 	stw	r7,0(r2)
						}
					}

				k++;
				mask = mask >> 1;
210854cc:	40803fcc 	andi	r2,r8,255
210854d0:	1004d07a 	srli	r2,r2,1
								p_color = 0x0000CC00;
							frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
						}
					}

				k++;
210854d4:	18c00044 	addi	r3,r3,1
				mask = mask >> 1;
210854d8:	1011883a 	mov	r8,r2

				if (mask == 0 || k >= c_width) {
210854dc:	1000091e 	bne	r2,zero,21085504 <ece423_video_display_add_text.constprop.2+0x178>
					c_index++;
210854e0:	21000044 	addi	r4,r4,1
					b = font_glyph_bitmap[c_index];
210854e4:	b105883a 	add	r2,r22,r4
210854e8:	13800003 	ldbu	r14,0(r2)
210854ec:	7005883a 	mov	r2,r14

		for (int j = 0; j < c_height; j++) {
			int k = 0;
			unsigned char mask = 0x80;
			unsigned char b = font_glyph_bitmap[c_index];
			while(k < c_width) {
210854f0:	1c80080e 	bge	r3,r18,21085514 <ece423_video_display_add_text.constprop.2+0x188>
				mask = mask >> 1;

				if (mask == 0 || k >= c_width) {
					c_index++;
					b = font_glyph_bitmap[c_index];
					mask = 0x80;
210854f4:	023fe004 	movi	r8,-128
210854f8:	003fe006 	br	2108547c <__flash_rwdata_start+0xfffe3234>
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;

						if(b & mask) {
							frame[frame_offset] = color;
210854fc:	17000015 	stw	fp,0(r2)
21085500:	003ff206 	br	210854cc <__flash_rwdata_start+0xfffe3284>
					}

				k++;
				mask = mask >> 1;

				if (mask == 0 || k >= c_width) {
21085504:	1cbfdd16 	blt	r3,r18,2108547c <__flash_rwdata_start+0xfffe3234>
					c_index++;
21085508:	21000044 	addi	r4,r4,1
					b = font_glyph_bitmap[c_index];
2108550c:	b105883a 	add	r2,r22,r4
21085510:	10800003 	ldbu	r2,0(r2)
21085514:	7bc00044 	addi	r15,r15,1
		int c_offset = text[i] - 32;

		int c_width = font_glyph_dsc[c_offset].w_px;
		int c_index = font_glyph_dsc[c_offset].glyph_index;

		for (int j = 0; j < c_height; j++) {
21085518:	7b7fd41e 	bne	r15,r13,2108546c <__flash_rwdata_start+0xfffe3224>
2108551c:	9809883a 	mov	r4,r19
21085520:	d9400615 	stw	r5,24(sp)
21085524:	d9800115 	stw	r6,4(sp)
21085528:	da400515 	stw	r9,20(sp)
2108552c:	da800415 	stw	r10,16(sp)
21085530:	dac00215 	stw	r11,8(sp)
21085534:	db400315 	stw	r13,12(sp)
21085538:	108e7200 	call	2108e720 <strlen>
2108553c:	db400317 	ldw	r13,12(sp)
21085540:	dac00217 	ldw	r11,8(sp)
21085544:	da800417 	ldw	r10,16(sp)
21085548:	da400517 	ldw	r9,20(sp)
2108554c:	d9800117 	ldw	r6,4(sp)
21085550:	d9400617 	ldw	r5,24(sp)
	uint color = rgb2ycbcr(rgb_color);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {
21085554:	31800044 	addi	r6,r6,1
					b = font_glyph_bitmap[c_index];
					mask = 0x80;
				}
			}
		}
		x_offset += scale*c_width + spacing;
21085558:	84a1883a 	add	r16,r16,r18
	uint color = rgb2ycbcr(rgb_color);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {
2108555c:	30bfb736 	bltu	r6,r2,2108543c <__flash_rwdata_start+0xfffe31f4>
			}
		}
		x_offset += scale*c_width + spacing;
	}

}
21085560:	dfc01017 	ldw	ra,64(sp)
21085564:	df000f17 	ldw	fp,60(sp)
21085568:	ddc00e17 	ldw	r23,56(sp)
2108556c:	dd800d17 	ldw	r22,52(sp)
21085570:	dd400c17 	ldw	r21,48(sp)
21085574:	dd000b17 	ldw	r20,44(sp)
21085578:	dcc00a17 	ldw	r19,40(sp)
2108557c:	dc800917 	ldw	r18,36(sp)
21085580:	dc400817 	ldw	r17,32(sp)
21085584:	dc000717 	ldw	r16,28(sp)
21085588:	dec01104 	addi	sp,sp,68
2108558c:	f800283a 	ret
						unsigned int bg_color = frame[frame_offset];
						unsigned int p_color = bg_color & 0x0000FF00;
						if(p_color < 0x0000DD00) {
							p_color += 0x00005000;
							if(p_color > 0x0000FF00)
								p_color = 0x0000FF00;
21085590:	01ffc014 	movui	r7,65280
21085594:	003fca06 	br	210854c0 <__flash_rwdata_start+0xfffe3278>

21085598 <ece423_video_display_buffer_is_available>:
 ******************************************************************/

int ece423_video_display_buffer_is_available(ece423_video_display* display) {


	if (display->num_frame_buffers > 1) {
21085598:	21402c17 	ldw	r5,176(r4)
2108559c:	00800044 	movi	r2,1
210855a0:	11400a0e 	bge	r2,r5,210855cc <ece423_video_display_buffer_is_available+0x34>
		int iNext_Rd_Buf = ((display->buffer_being_displayed - 1 + display->num_frame_buffers)
210855a4:	20c02617 	ldw	r3,152(r4)
			% display->num_frame_buffers);
		if (iNext_Rd_Buf == display->buffer_being_written) // If Frame Buf free to write to
210855a8:	20802717 	ldw	r2,156(r4)

int ece423_video_display_buffer_is_available(ece423_video_display* display) {


	if (display->num_frame_buffers > 1) {
		int iNext_Rd_Buf = ((display->buffer_being_displayed - 1 + display->num_frame_buffers)
210855ac:	193fffc4 	addi	r4,r3,-1
210855b0:	2907883a 	add	r3,r5,r4
210855b4:	1949283a 	div	r4,r3,r5
210855b8:	214b383a 	mul	r5,r4,r5
210855bc:	1947c83a 	sub	r3,r3,r5
			% display->num_frame_buffers);
		if (iNext_Rd_Buf == display->buffer_being_written) // If Frame Buf free to write to
210855c0:	1887003a 	cmpeq	r3,r3,r2
210855c4:	00c5c83a 	sub	r2,zero,r3
210855c8:	f800283a 	ret
			return -1; // Free Buf not yet available

	} // END if(display->num_frame_buffers > 1)
	// Else Only one display Buf so HAVE TO Overwrite LIVE Buf
	return 0;
210855cc:	0005883a 	mov	r2,zero
}
210855d0:	f800283a 	ret

210855d4 <ece423_video_display_get_buffer>:
 *           -1 - No new frame available, so no switch
 *
 ******************************************************************/
alt_u32* ece423_video_display_get_buffer(ece423_video_display* display) {

	return (display->buffer_ptrs[display->buffer_being_written]->buffer);
210855d4:	20802717 	ldw	r2,156(r4)
210855d8:	10800044 	addi	r2,r2,1
210855dc:	1085883a 	add	r2,r2,r2
210855e0:	1085883a 	add	r2,r2,r2
210855e4:	2089883a 	add	r4,r4,r2
210855e8:	20800017 	ldw	r2,0(r4)
}
210855ec:	10800117 	ldw	r2,4(r2)
210855f0:	f800283a 	ret

210855f4 <ece423_video_display_register_written_buffer>:
	 * Note: The new buffer_being_written may NOT Yet be FREE
	 * So Call
	 * ece423_video_display_buffer_is_available
	 * to Check Before Drawing in it
	 */
	if(display->video_name)
210855f4:	21402e17 	ldw	r5,184(r4)
 *                 -----------------------------------------
 *
 *  This Registers Buf pointed to by buffer_being_written
 *
 ******************************************************************/
void ece423_video_display_register_written_buffer(ece423_video_display* display) {
210855f8:	defffe04 	addi	sp,sp,-8
210855fc:	dc000015 	stw	r16,0(sp)
21085600:	dfc00115 	stw	ra,4(sp)
21085604:	2021883a 	mov	r16,r4
	 * Note: The new buffer_being_written may NOT Yet be FREE
	 * So Call
	 * ece423_video_display_buffer_is_available
	 * to Check Before Drawing in it
	 */
	if(display->video_name)
21085608:	28000226 	beq	r5,zero,21085614 <ece423_video_display_register_written_buffer+0x20>
		ece423_video_display_add_text(display, display->video_name, 10, 10, RGB_BLACK, 1);
2108560c:	01800284 	movi	r6,10
21085610:	108538c0 	call	2108538c <ece423_video_display_add_text.constprop.2>
	display->buffer_being_written = (display->buffer_being_written + 1)
21085614:	80802717 	ldw	r2,156(r16)
			% display->num_frame_buffers;
21085618:	80c02c17 	ldw	r3,176(r16)
	 * ece423_video_display_buffer_is_available
	 * to Check Before Drawing in it
	 */
	if(display->video_name)
		ece423_video_display_add_text(display, display->video_name, 10, 10, RGB_BLACK, 1);
	display->buffer_being_written = (display->buffer_being_written + 1)
2108561c:	10800044 	addi	r2,r2,1
			% display->num_frame_buffers;
21085620:	10c9283a 	div	r4,r2,r3
21085624:	20c7383a 	mul	r3,r4,r3
21085628:	10c5c83a 	sub	r2,r2,r3
	 * ece423_video_display_buffer_is_available
	 * to Check Before Drawing in it
	 */
	if(display->video_name)
		ece423_video_display_add_text(display, display->video_name, 10, 10, RGB_BLACK, 1);
	display->buffer_being_written = (display->buffer_being_written + 1)
2108562c:	80802715 	stw	r2,156(r16)
			% display->num_frame_buffers;


}
21085630:	dfc00117 	ldw	ra,4(sp)
21085634:	dc000017 	ldw	r16,0(sp)
21085638:	dec00204 	addi	sp,sp,8
2108563c:	f800283a 	ret

21085640 <ece423_video_display_switch_frames>:
 *
 *           -1 - No new frame available, so no switch
 *
 ******************************************************************/

int ece423_video_display_switch_frames(ece423_video_display* display) {
21085640:	defffc04 	addi	sp,sp,-16
21085644:	dc800215 	stw	r18,8(sp)
	int iNext_Rd_Buf;

	alt_u32 RD_Desc_Fifo_Level;

	iNext_Rd_Buf = ((display->buffer_being_displayed + 1)
21085648:	24802617 	ldw	r18,152(r4)
2108564c:	20802c17 	ldw	r2,176(r4)
			% display->num_frame_buffers);

	// Check if there is a new buffer to display
	if ((iNext_Rd_Buf != display->buffer_being_written)) {
21085650:	21402717 	ldw	r5,156(r4)
int ece423_video_display_switch_frames(ece423_video_display* display) {
	int iNext_Rd_Buf;

	alt_u32 RD_Desc_Fifo_Level;

	iNext_Rd_Buf = ((display->buffer_being_displayed + 1)
21085654:	90c00044 	addi	r3,r18,1
21085658:	18a5283a 	div	r18,r3,r2
2108565c:	9085383a 	mul	r2,r18,r2
 *
 *           -1 - No new frame available, so no switch
 *
 ******************************************************************/

int ece423_video_display_switch_frames(ece423_video_display* display) {
21085660:	dfc00315 	stw	ra,12(sp)
21085664:	dc400115 	stw	r17,4(sp)
21085668:	dc000015 	stw	r16,0(sp)
	int iNext_Rd_Buf;

	alt_u32 RD_Desc_Fifo_Level;

	iNext_Rd_Buf = ((display->buffer_being_displayed + 1)
2108566c:	18a5c83a 	sub	r18,r3,r2
			% display->num_frame_buffers);

	// Check if there is a new buffer to display
	if ((iNext_Rd_Buf != display->buffer_being_written)) {
21085670:	2c801726 	beq	r5,r18,210856d0 <ece423_video_display_switch_frames+0x90>
21085674:	94400044 	addi	r17,r18,1

		// Transfer Descriptor for Frame to mSGDMA
		while (alt_msgdma_standard_descriptor_async_transfer(display->mSGDMA,
				display->buffer_ptrs[iNext_Rd_Buf]->desc_base) != 0) {
21085678:	8c63883a 	add	r17,r17,r17
2108567c:	8c63883a 	add	r17,r17,r17
21085680:	2021883a 	mov	r16,r4
21085684:	2463883a 	add	r17,r4,r17

	// Check if there is a new buffer to display
	if ((iNext_Rd_Buf != display->buffer_being_written)) {

		// Transfer Descriptor for Frame to mSGDMA
		while (alt_msgdma_standard_descriptor_async_transfer(display->mSGDMA,
21085688:	88800017 	ldw	r2,0(r17)
2108568c:	81000017 	ldw	r4,0(r16)
21085690:	11400017 	ldw	r5,0(r2)
21085694:	109d1400 	call	2109d140 <alt_msgdma_standard_descriptor_async_transfer>
21085698:	103ffb1e 	bne	r2,zero,21085688 <__flash_rwdata_start+0xfffe3440>
2108569c:	81400017 	ldw	r5,0(r16)
		do {
			RD_Desc_Fifo_Level = (IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(
					display->mSGDMA->csr_base)
					& ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK)
					>> ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		} while (RD_Desc_Fifo_Level > 1);
210856a0:	01000044 	movi	r4,1
				display->buffer_ptrs[iNext_Rd_Buf]->desc_base) != 0) {
		}  // Keep Trying until there is room to Transfer another Frame

		// Wait if there is another frame waiting in the list
		do {
			RD_Desc_Fifo_Level = (IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(
210856a4:	28c00317 	ldw	r3,12(r5)
210856a8:	18c00237 	ldwio	r3,8(r3)
210856ac:	18ffffcc 	andi	r3,r3,65535
					display->mSGDMA->csr_base)
					& ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK)
					>> ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		} while (RD_Desc_Fifo_Level > 1);
210856b0:	20fffc36 	bltu	r4,r3,210856a4 <__flash_rwdata_start+0xfffe345c>

		display->buffer_being_displayed = iNext_Rd_Buf;
210856b4:	84802615 	stw	r18,152(r16)
		return 0;
	} else {
		return -1;
	}

}
210856b8:	dfc00317 	ldw	ra,12(sp)
210856bc:	dc800217 	ldw	r18,8(sp)
210856c0:	dc400117 	ldw	r17,4(sp)
210856c4:	dc000017 	ldw	r16,0(sp)
210856c8:	dec00404 	addi	sp,sp,16
210856cc:	f800283a 	ret

		display->buffer_being_displayed = iNext_Rd_Buf;
//		 	printf("Displayed %d - Written %d\n", display->buffer_being_displayed, display->buffer_being_written);
		return 0;
	} else {
		return -1;
210856d0:	00bfffc4 	movi	r2,-1
210856d4:	003ff806 	br	210856b8 <__flash_rwdata_start+0xfffe3470>

210856d8 <ece423_video_display_discard_buffered_frames>:
 *
 ******************************************************************/
void ece423_video_display_discard_buffered_frames(ece423_video_display* display) {

	// Reset the buffer to be written to the next buffer after the one being displayed
	display->buffer_being_written = ((display->buffer_being_displayed + 1)
210856d8:	20802617 	ldw	r2,152(r4)
		% display->num_frame_buffers);
210856dc:	20c02c17 	ldw	r3,176(r4)
 *
 ******************************************************************/
void ece423_video_display_discard_buffered_frames(ece423_video_display* display) {

	// Reset the buffer to be written to the next buffer after the one being displayed
	display->buffer_being_written = ((display->buffer_being_displayed + 1)
210856e0:	10800044 	addi	r2,r2,1
		% display->num_frame_buffers);
210856e4:	10cb283a 	div	r5,r2,r3
210856e8:	28c7383a 	mul	r3,r5,r3
210856ec:	10c5c83a 	sub	r2,r2,r3
 *
 ******************************************************************/
void ece423_video_display_discard_buffered_frames(ece423_video_display* display) {

	// Reset the buffer to be written to the next buffer after the one being displayed
	display->buffer_being_written = ((display->buffer_being_displayed + 1)
210856f0:	20802715 	stw	r2,156(r4)
210856f4:	f800283a 	ret

210856f8 <ece423_video_display_is_empty>:
 *           -1 - No new frame available, so no switch
 *
 ******************************************************************/

int ece423_video_display_is_empty(ece423_video_display* display) {
	int Next_Buf = ((display->buffer_being_displayed + 1)
210856f8:	20c02617 	ldw	r3,152(r4)
210856fc:	21402c17 	ldw	r5,176(r4)
					% display->num_frame_buffers);
	return (Next_Buf == display->buffer_being_written);
21085700:	20802717 	ldw	r2,156(r4)
 *           -1 - No new frame available, so no switch
 *
 ******************************************************************/

int ece423_video_display_is_empty(ece423_video_display* display) {
	int Next_Buf = ((display->buffer_being_displayed + 1)
21085704:	18c00044 	addi	r3,r3,1
21085708:	1949283a 	div	r4,r3,r5
2108570c:	214b383a 	mul	r5,r4,r5
21085710:	1947c83a 	sub	r3,r3,r5
					% display->num_frame_buffers);
	return (Next_Buf == display->buffer_being_written);
}
21085714:	10c5003a 	cmpeq	r2,r2,r3
21085718:	f800283a 	ret

2108571c <ece423_video_display_clear_screen>:
 *
 ******************************************************************/
void ece423_video_display_color_screen(ece423_video_display* display,
		uint rgb_color) {
	uint color = rgb2ycbcr(rgb_color);
	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
2108571c:	20802717 	ldw	r2,156(r4)
	for (int i = 0; i < display->bytes_per_frame / 4; i += 1)
21085720:	21402b17 	ldw	r5,172(r4)
 *
 ******************************************************************/
void ece423_video_display_color_screen(ece423_video_display* display,
		uint rgb_color) {
	uint color = rgb2ycbcr(rgb_color);
	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
21085724:	10800044 	addi	r2,r2,1
21085728:	1085883a 	add	r2,r2,r2
2108572c:	1085883a 	add	r2,r2,r2
21085730:	2085883a 	add	r2,r4,r2
21085734:	10800017 	ldw	r2,0(r2)
21085738:	10c00117 	ldw	r3,4(r2)
	for (int i = 0; i < display->bytes_per_frame / 4; i += 1)
2108573c:	008000c4 	movi	r2,3
21085740:	11400e0e 	bge	r2,r5,2108577c <ece423_video_display_clear_screen+0x60>
		frame[i] = color;
21085744:	01802074 	movhi	r6,129
21085748:	31bfe004 	addi	r6,r6,-128
 ******************************************************************/
void ece423_video_display_color_screen(ece423_video_display* display,
		uint rgb_color) {
	uint color = rgb2ycbcr(rgb_color);
	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
	for (int i = 0; i < display->bytes_per_frame / 4; i += 1)
2108574c:	000b883a 	mov	r5,zero
21085750:	00000206 	br	2108575c <ece423_video_display_clear_screen+0x40>
21085754:	1005d0ba 	srai	r2,r2,2
21085758:	2880080e 	bge	r5,r2,2108577c <ece423_video_display_clear_screen+0x60>
		frame[i] = color;
2108575c:	19800015 	stw	r6,0(r3)
 ******************************************************************/
void ece423_video_display_color_screen(ece423_video_display* display,
		uint rgb_color) {
	uint color = rgb2ycbcr(rgb_color);
	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
	for (int i = 0; i < display->bytes_per_frame / 4; i += 1)
21085760:	20802b17 	ldw	r2,172(r4)
21085764:	29400044 	addi	r5,r5,1
21085768:	18c00104 	addi	r3,r3,4
2108576c:	103ff90e 	bge	r2,zero,21085754 <__flash_rwdata_start+0xfffe350c>
21085770:	108000c4 	addi	r2,r2,3
21085774:	1005d0ba 	srai	r2,r2,2
21085778:	28bff816 	blt	r5,r2,2108575c <__flash_rwdata_start+0xfffe3514>
2108577c:	f800283a 	ret

21085780 <ece423_video_display_color_screen>:

uint rgb2ycbcr(uint rgb) {
	unsigned char r, g, b;
	b = rgb & 0xff;
	g = (rgb >> 8) & 0xff;
	r = (rgb >> 16) & 0xff;
21085780:	2804d43a 	srli	r2,r5,16
 *
 *  Purpose: Clear entire Frame Buf
 *
 ******************************************************************/
void ece423_video_display_color_screen(ece423_video_display* display,
		uint rgb_color) {
21085784:	defff504 	addi	sp,sp,-44
21085788:	dc000115 	stw	r16,4(sp)
2108578c:	2021883a 	mov	r16,r4
	b = rgb & 0xff;
	g = (rgb >> 8) & 0xff;
	r = (rgb >> 16) & 0xff;

	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
21085790:	11003fcc 	andi	r4,r2,255
 *
 *  Purpose: Clear entire Frame Buf
 *
 ******************************************************************/
void ece423_video_display_color_screen(ece423_video_display* display,
		uint rgb_color) {
21085794:	dfc00a15 	stw	ra,40(sp)
21085798:	df000915 	stw	fp,36(sp)
2108579c:	ddc00815 	stw	r23,32(sp)
210857a0:	dd800715 	stw	r22,28(sp)
210857a4:	dd400615 	stw	r21,24(sp)
210857a8:	dd000515 	stw	r20,20(sp)
210857ac:	dcc00415 	stw	r19,16(sp)
210857b0:	dc800315 	stw	r18,12(sp)
210857b4:	dc400215 	stw	r17,8(sp)
210857b8:	2823883a 	mov	r17,r5
	b = rgb & 0xff;
	g = (rgb >> 8) & 0xff;
	r = (rgb >> 16) & 0xff;

	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
210857bc:	108cfdc0 	call	2108cfdc <__floatsidf>
}

uint rgb2ycbcr(uint rgb) {
	unsigned char r, g, b;
	b = rgb & 0xff;
	g = (rgb >> 8) & 0xff;
210857c0:	8808d23a 	srli	r4,r17,8
	r = (rgb >> 16) & 0xff;

	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
210857c4:	102f883a 	mov	r23,r2
210857c8:	182d883a 	mov	r22,r3
210857cc:	21003fcc 	andi	r4,r4,255
210857d0:	108cfdc0 	call	2108cfdc <__floatsidf>
210857d4:	89003fcc 	andi	r4,r17,255
210857d8:	102b883a 	mov	r21,r2
210857dc:	1829883a 	mov	r20,r3
210857e0:	108cfdc0 	call	2108cfdc <__floatsidf>
	cb = -0.168736 * r - 0.331264 * g + 0.5 * b + 128;
210857e4:	018a3534 	movhi	r6,10452
210857e8:	01eff1b4 	movhi	r7,49094
210857ec:	b809883a 	mov	r4,r23
210857f0:	b00b883a 	mov	r5,r22
210857f4:	318d2804 	addi	r6,r6,13472
210857f8:	39e64904 	addi	r7,r7,-26332
	b = rgb & 0xff;
	g = (rgb >> 8) & 0xff;
	r = (rgb >> 16) & 0xff;

	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
210857fc:	1027883a 	mov	r19,r2
21085800:	1825883a 	mov	r18,r3
	cb = -0.168736 * r - 0.331264 * g + 0.5 * b + 128;
21085804:	108bf600 	call	2108bf60 <__muldf3>
21085808:	01bae5b4 	movhi	r6,60310
2108580c:	01cff574 	movhi	r7,16341
21085810:	a809883a 	mov	r4,r21
21085814:	a00b883a 	mov	r5,r20
21085818:	31b96c04 	addi	r6,r6,-6736
2108581c:	39ccdb44 	addi	r7,r7,13165
21085820:	1039883a 	mov	fp,r2
21085824:	1823883a 	mov	r17,r3
21085828:	108bf600 	call	2108bf60 <__muldf3>
2108582c:	e009883a 	mov	r4,fp
21085830:	880b883a 	mov	r5,r17
21085834:	100d883a 	mov	r6,r2
21085838:	180f883a 	mov	r7,r3
2108583c:	108c6840 	call	2108c684 <__subdf3>
21085840:	9809883a 	mov	r4,r19
21085844:	900b883a 	mov	r5,r18
21085848:	000d883a 	mov	r6,zero
2108584c:	01cff834 	movhi	r7,16352
21085850:	1039883a 	mov	fp,r2
21085854:	1823883a 	mov	r17,r3
21085858:	108bf600 	call	2108bf60 <__muldf3>
2108585c:	e009883a 	mov	r4,fp
21085860:	880b883a 	mov	r5,r17
21085864:	100d883a 	mov	r6,r2
21085868:	180f883a 	mov	r7,r3
2108586c:	108ad180 	call	2108ad18 <__adddf3>
21085870:	000d883a 	mov	r6,zero
21085874:	01d01834 	movhi	r7,16480
21085878:	1009883a 	mov	r4,r2
2108587c:	180b883a 	mov	r5,r3
21085880:	108ad180 	call	2108ad18 <__adddf3>
21085884:	180b883a 	mov	r5,r3
21085888:	1009883a 	mov	r4,r2
2108588c:	108a3200 	call	2108a320 <__fixunsdfsi>
	b = rgb & 0xff;
	g = (rgb >> 8) & 0xff;
	r = (rgb >> 16) & 0xff;

	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
21085890:	01b95834 	movhi	r6,58720
21085894:	01cff4f4 	movhi	r7,16339
21085898:	b809883a 	mov	r4,r23
2108589c:	b00b883a 	mov	r5,r22
210858a0:	31906244 	addi	r6,r6,16777
210858a4:	39c8b404 	addi	r7,r7,8912
	cb = -0.168736 * r - 0.331264 * g + 0.5 * b + 128;
	cr = 0.5 * r - 0.418688 * g - 0.081312 * b + 128;

	uint ycbcr = (cr << 16) | (y << 8) | (cb);
210858a8:	14403fcc 	andi	r17,r2,255
	b = rgb & 0xff;
	g = (rgb >> 8) & 0xff;
	r = (rgb >> 16) & 0xff;

	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
210858ac:	108bf600 	call	2108bf60 <__muldf3>
210858b0:	018e5634 	movhi	r6,14680
210858b4:	01cff8f4 	movhi	r7,16355
210858b8:	a809883a 	mov	r4,r21
210858bc:	a00b883a 	mov	r5,r20
210858c0:	31841884 	addi	r6,r6,4194
210858c4:	39f22d04 	addi	r7,r7,-14156
210858c8:	1839883a 	mov	fp,r3
210858cc:	d8800015 	stw	r2,0(sp)
210858d0:	108bf600 	call	2108bf60 <__muldf3>
210858d4:	da000017 	ldw	r8,0(sp)
210858d8:	e00b883a 	mov	r5,fp
210858dc:	100d883a 	mov	r6,r2
210858e0:	4009883a 	mov	r4,r8
210858e4:	180f883a 	mov	r7,r3
210858e8:	108ad180 	call	2108ad18 <__adddf3>
210858ec:	01a7efb4 	movhi	r6,40894
210858f0:	01cfef74 	movhi	r7,16317
210858f4:	9809883a 	mov	r4,r19
210858f8:	900b883a 	mov	r5,r18
210858fc:	319db244 	addi	r6,r6,30409
21085900:	39cbc684 	addi	r7,r7,12058
21085904:	1839883a 	mov	fp,r3
21085908:	d8800015 	stw	r2,0(sp)
2108590c:	108bf600 	call	2108bf60 <__muldf3>
21085910:	da000017 	ldw	r8,0(sp)
21085914:	100d883a 	mov	r6,r2
21085918:	180f883a 	mov	r7,r3
2108591c:	4009883a 	mov	r4,r8
21085920:	e00b883a 	mov	r5,fp
21085924:	108ad180 	call	2108ad18 <__adddf3>
21085928:	180b883a 	mov	r5,r3
2108592c:	1009883a 	mov	r4,r2
21085930:	108a3200 	call	2108a320 <__fixunsdfsi>
	cb = -0.168736 * r - 0.331264 * g + 0.5 * b + 128;
	cr = 0.5 * r - 0.418688 * g - 0.081312 * b + 128;

	uint ycbcr = (cr << 16) | (y << 8) | (cb);
21085934:	10803fcc 	andi	r2,r2,255
21085938:	1010923a 	slli	r8,r2,8
	r = (rgb >> 16) & 0xff;

	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
	cb = -0.168736 * r - 0.331264 * g + 0.5 * b + 128;
	cr = 0.5 * r - 0.418688 * g - 0.081312 * b + 128;
2108593c:	b809883a 	mov	r4,r23
21085940:	b00b883a 	mov	r5,r22
21085944:	000d883a 	mov	r6,zero
21085948:	01cff834 	movhi	r7,16352
2108594c:	8a22b03a 	or	r17,r17,r8
21085950:	108bf600 	call	2108bf60 <__muldf3>
21085954:	01b033f4 	movhi	r6,49359
21085958:	01cff6f4 	movhi	r7,16347
2108595c:	a809883a 	mov	r4,r21
21085960:	a00b883a 	mov	r5,r20
21085964:	31a47244 	addi	r6,r6,-28215
21085968:	39f2f204 	addi	r7,r7,-13368
2108596c:	102f883a 	mov	r23,r2
21085970:	182d883a 	mov	r22,r3
21085974:	108bf600 	call	2108bf60 <__muldf3>
21085978:	b809883a 	mov	r4,r23
2108597c:	b00b883a 	mov	r5,r22
21085980:	100d883a 	mov	r6,r2
21085984:	180f883a 	mov	r7,r3
21085988:	108c6840 	call	2108c684 <__subdf3>
2108598c:	01bf31b4 	movhi	r6,64710
21085990:	01cfed74 	movhi	r7,16309
21085994:	9809883a 	mov	r4,r19
21085998:	900b883a 	mov	r5,r18
2108599c:	31ae3704 	addi	r6,r6,-18212
210859a0:	39f43704 	addi	r7,r7,-12068
210859a4:	102b883a 	mov	r21,r2
210859a8:	1829883a 	mov	r20,r3
210859ac:	108bf600 	call	2108bf60 <__muldf3>
210859b0:	a809883a 	mov	r4,r21
210859b4:	a00b883a 	mov	r5,r20
210859b8:	100d883a 	mov	r6,r2
210859bc:	180f883a 	mov	r7,r3
210859c0:	108c6840 	call	2108c684 <__subdf3>
210859c4:	1009883a 	mov	r4,r2
210859c8:	180b883a 	mov	r5,r3
210859cc:	000d883a 	mov	r6,zero
210859d0:	01d01834 	movhi	r7,16480
210859d4:	108ad180 	call	2108ad18 <__adddf3>
210859d8:	180b883a 	mov	r5,r3
210859dc:	1009883a 	mov	r4,r2
210859e0:	108a3200 	call	2108a320 <__fixunsdfsi>
 *
 ******************************************************************/
void ece423_video_display_color_screen(ece423_video_display* display,
		uint rgb_color) {
	uint color = rgb2ycbcr(rgb_color);
	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
210859e4:	80c02717 	ldw	r3,156(r16)
	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
	cb = -0.168736 * r - 0.331264 * g + 0.5 * b + 128;
	cr = 0.5 * r - 0.418688 * g - 0.081312 * b + 128;

	uint ycbcr = (cr << 16) | (y << 8) | (cb);
210859e8:	10803fcc 	andi	r2,r2,255
210859ec:	1004943a 	slli	r2,r2,16
 *
 ******************************************************************/
void ece423_video_display_color_screen(ece423_video_display* display,
		uint rgb_color) {
	uint color = rgb2ycbcr(rgb_color);
	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
210859f0:	18c00044 	addi	r3,r3,1
210859f4:	18c7883a 	add	r3,r3,r3
210859f8:	18c7883a 	add	r3,r3,r3
210859fc:	80c7883a 	add	r3,r16,r3
21085a00:	19000017 	ldw	r4,0(r3)
	for (int i = 0; i < display->bytes_per_frame / 4; i += 1)
21085a04:	80c02b17 	ldw	r3,172(r16)
	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
	cb = -0.168736 * r - 0.331264 * g + 0.5 * b + 128;
	cr = 0.5 * r - 0.418688 * g - 0.081312 * b + 128;

	uint ycbcr = (cr << 16) | (y << 8) | (cb);
21085a08:	8884b03a 	or	r2,r17,r2
 *
 ******************************************************************/
void ece423_video_display_color_screen(ece423_video_display* display,
		uint rgb_color) {
	uint color = rgb2ycbcr(rgb_color);
	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
21085a0c:	21400117 	ldw	r5,4(r4)
	for (int i = 0; i < display->bytes_per_frame / 4; i += 1)
21085a10:	010000c4 	movi	r4,3
21085a14:	20c00c0e 	bge	r4,r3,21085a48 <ece423_video_display_color_screen+0x2c8>
21085a18:	000d883a 	mov	r6,zero
21085a1c:	00000206 	br	21085a28 <ece423_video_display_color_screen+0x2a8>
21085a20:	1807d0ba 	srai	r3,r3,2
21085a24:	30c0080e 	bge	r6,r3,21085a48 <ece423_video_display_color_screen+0x2c8>
		frame[i] = color;
21085a28:	28800015 	stw	r2,0(r5)
 ******************************************************************/
void ece423_video_display_color_screen(ece423_video_display* display,
		uint rgb_color) {
	uint color = rgb2ycbcr(rgb_color);
	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
	for (int i = 0; i < display->bytes_per_frame / 4; i += 1)
21085a2c:	80c02b17 	ldw	r3,172(r16)
21085a30:	31800044 	addi	r6,r6,1
21085a34:	29400104 	addi	r5,r5,4
21085a38:	183ff90e 	bge	r3,zero,21085a20 <__flash_rwdata_start+0xfffe37d8>
21085a3c:	18c000c4 	addi	r3,r3,3
21085a40:	1807d0ba 	srai	r3,r3,2
21085a44:	30fff816 	blt	r6,r3,21085a28 <__flash_rwdata_start+0xfffe37e0>
		frame[i] = color;
}
21085a48:	dfc00a17 	ldw	ra,40(sp)
21085a4c:	df000917 	ldw	fp,36(sp)
21085a50:	ddc00817 	ldw	r23,32(sp)
21085a54:	dd800717 	ldw	r22,28(sp)
21085a58:	dd400617 	ldw	r21,24(sp)
21085a5c:	dd000517 	ldw	r20,20(sp)
21085a60:	dcc00417 	ldw	r19,16(sp)
21085a64:	dc800317 	ldw	r18,12(sp)
21085a68:	dc400217 	ldw	r17,8(sp)
21085a6c:	dc000117 	ldw	r16,4(sp)
21085a70:	dec00b04 	addi	sp,sp,44
21085a74:	f800283a 	ret

21085a78 <ece423_video_display_colored_screen>:
 *  Purpose: Draw a colored screen
 *
 ******************************************************************/
void ece423_video_display_colored_screen(ece423_video_display* display) {

	int* frame = display->buffer_ptrs[display->buffer_being_displayed]->buffer;
21085a78:	20c02617 	ldw	r3,152(r4)

	int i_scale = (display->height + 255) / 255;
21085a7c:	21402917 	ldw	r5,164(r4)
	int j_scale = (display->width + 255) / 255;
21085a80:	20802817 	ldw	r2,160(r4)
 *  Purpose: Draw a colored screen
 *
 ******************************************************************/
void ece423_video_display_colored_screen(ece423_video_display* display) {

	int* frame = display->buffer_ptrs[display->buffer_being_displayed]->buffer;
21085a84:	18c00044 	addi	r3,r3,1
21085a88:	18c7883a 	add	r3,r3,r3
21085a8c:	18c7883a 	add	r3,r3,r3
21085a90:	20c7883a 	add	r3,r4,r3
21085a94:	19800017 	ldw	r6,0(r3)
 *  Function: ece423_video_display_colored_screen
 *
 *  Purpose: Draw a colored screen
 *
 ******************************************************************/
void ece423_video_display_colored_screen(ece423_video_display* display) {
21085a98:	defff204 	addi	sp,sp,-56

	int* frame = display->buffer_ptrs[display->buffer_being_displayed]->buffer;

	int i_scale = (display->height + 255) / 255;
21085a9c:	00c03fc4 	movi	r3,255
 *  Function: ece423_video_display_colored_screen
 *
 *  Purpose: Draw a colored screen
 *
 ******************************************************************/
void ece423_video_display_colored_screen(ece423_video_display* display) {
21085aa0:	dd000815 	stw	r20,32(sp)

	int* frame = display->buffer_ptrs[display->buffer_being_displayed]->buffer;

	int i_scale = (display->height + 255) / 255;
	int j_scale = (display->width + 255) / 255;
21085aa4:	10dd883a 	add	r14,r2,r3
 ******************************************************************/
void ece423_video_display_colored_screen(ece423_video_display* display) {

	int* frame = display->buffer_ptrs[display->buffer_being_displayed]->buffer;

	int i_scale = (display->height + 255) / 255;
21085aa8:	28e9883a 	add	r20,r5,r3
 *  Function: ece423_video_display_colored_screen
 *
 *  Purpose: Draw a colored screen
 *
 ******************************************************************/
void ece423_video_display_colored_screen(ece423_video_display* display) {
21085aac:	dfc00d15 	stw	ra,52(sp)
21085ab0:	df000c15 	stw	fp,48(sp)
21085ab4:	ddc00b15 	stw	r23,44(sp)
21085ab8:	dd800a15 	stw	r22,40(sp)
21085abc:	dd400915 	stw	r21,36(sp)
21085ac0:	dcc00715 	stw	r19,28(sp)
21085ac4:	dc800615 	stw	r18,24(sp)
21085ac8:	dc400515 	stw	r17,20(sp)
21085acc:	dc000415 	stw	r16,16(sp)

	int* frame = display->buffer_ptrs[display->buffer_being_displayed]->buffer;
21085ad0:	32c00117 	ldw	r11,4(r6)

	int i_scale = (display->height + 255) / 255;
21085ad4:	a0e9283a 	div	r20,r20,r3
	int j_scale = (display->width + 255) / 255;
21085ad8:	70dd283a 	div	r14,r14,r3

	unsigned char y = 104;
	unsigned char cr = 0;

	for(int i = 0; i < display->height; i = i + i_scale) {
21085adc:	0140430e 	bge	zero,r5,21085bec <ece423_video_display_colored_screen+0x174>
21085ae0:	70ffffc4 	addi	r3,r14,-1
21085ae4:	050dc83a 	sub	r6,zero,r20
21085ae8:	03adc83a 	sub	r22,zero,r14
21085aec:	198d383a 	mul	r6,r3,r6
21085af0:	1dad383a 	mul	r22,r3,r22
21085af4:	dd000205 	stb	r20,8(sp)
21085af8:	d9800305 	stb	r6,12(sp)
21085afc:	7039883a 	mov	fp,r14
21085b00:	003f883a 	mov	ra,zero
21085b04:	d8000105 	stb	zero,4(sp)
21085b08:	002b883a 	mov	r21,zero
21085b0c:	d8000005 	stb	zero,0(sp)
21085b10:	03001a04 	movi	r12,104
21085b14:	ad1f883a 	add	r15,r21,r20
		unsigned char cb = 0;
		for(int j = 0; j < display->width; j = j + j_scale) {
21085b18:	0080290e 	bge	zero,r2,21085bc0 <ece423_video_display_colored_screen+0x148>
21085b1c:	ddc00003 	ldbu	r23,0(sp)
21085b20:	dcc00103 	ldbu	r19,4(sp)
21085b24:	f813883a 	mov	r9,ra
21085b28:	b82e943a 	slli	r23,r23,16
21085b2c:	001b883a 	mov	r13,zero
21085b30:	0025883a 	mov	r18,zero
21085b34:	ad1f883a 	add	r15,r21,r20
21085b38:	a823883a 	mov	r17,r21
21085b3c:	7355883a 	add	r10,r14,r13
			for(int ip = 0; ip < i_scale; ip++)
21085b40:	0500190e 	bge	zero,r20,21085ba8 <ece423_video_display_colored_screen+0x130>
21085b44:	92003fcc 	andi	r8,r18,255
21085b48:	45d0b03a 	or	r8,r8,r23
21085b4c:	a80f883a 	mov	r7,r21
21085b50:	7355883a 	add	r10,r14,r13
21085b54:	9b61c83a 	sub	r16,r19,r13
				for(int jp = 0; jp < j_scale; jp++){
21085b58:	0380110e 	bge	zero,r14,21085ba0 <ece423_video_display_colored_screen+0x128>
21085b5c:	680b883a 	mov	r5,r13
21085b60:	600d883a 	mov	r6,r12
					frame[ (i + ip) * display->width + (j + jp)] = (cr << 16) | (y << 8) | (cb);
21085b64:	3885383a 	mul	r2,r7,r2
21085b68:	30c03fcc 	andi	r3,r6,255
21085b6c:	1806923a 	slli	r3,r3,8
21085b70:	1145883a 	add	r2,r2,r5
21085b74:	1085883a 	add	r2,r2,r2
21085b78:	1085883a 	add	r2,r2,r2
21085b7c:	5885883a 	add	r2,r11,r2
21085b80:	1a06b03a 	or	r3,r3,r8
21085b84:	10c00015 	stw	r3,0(r2)
21085b88:	29400044 	addi	r5,r5,1
21085b8c:	498d883a 	add	r6,r9,r6
21085b90:	20802817 	ldw	r2,160(r4)

	for(int i = 0; i < display->height; i = i + i_scale) {
		unsigned char cb = 0;
		for(int j = 0; j < display->width; j = j + j_scale) {
			for(int ip = 0; ip < i_scale; ip++)
				for(int jp = 0; jp < j_scale; jp++){
21085b94:	2abff31e 	bne	r5,r10,21085b64 <__flash_rwdata_start+0xfffe391c>
21085b98:	6459c83a 	sub	r12,r12,r17
21085b9c:	6419883a 	add	r12,r12,r16
21085ba0:	39c00044 	addi	r7,r7,1
	unsigned char cr = 0;

	for(int i = 0; i < display->height; i = i + i_scale) {
		unsigned char cb = 0;
		for(int j = 0; j < display->width; j = j + j_scale) {
			for(int ip = 0; ip < i_scale; ip++)
21085ba4:	3bffec1e 	bne	r7,r15,21085b58 <__flash_rwdata_start+0xfffe3910>
				for(int jp = 0; jp < j_scale; jp++){
					frame[ (i + ip) * display->width + (j + jp)] = (cr << 16) | (y << 8) | (cb);
					y = y - (i & 0xFF) - (j & 0x00FF);
				}
			cb = cb + 1;
21085ba8:	94800044 	addi	r18,r18,1
	unsigned char y = 104;
	unsigned char cr = 0;

	for(int i = 0; i < display->height; i = i + i_scale) {
		unsigned char cb = 0;
		for(int j = 0; j < display->width; j = j + j_scale) {
21085bac:	501b883a 	mov	r13,r10
21085bb0:	9da7883a 	add	r19,r19,r22
21085bb4:	4f13c83a 	sub	r9,r9,fp
21085bb8:	50bfe016 	blt	r10,r2,21085b3c <__flash_rwdata_start+0xfffe38f4>
21085bbc:	21402917 	ldw	r5,164(r4)
					frame[ (i + ip) * display->width + (j + jp)] = (cr << 16) | (y << 8) | (cb);
					y = y - (i & 0xFF) - (j & 0x00FF);
				}
			cb = cb + 1;
		}
		cr = cr + 1;
21085bc0:	d8c00003 	ldbu	r3,0(sp)
21085bc4:	d9800103 	ldbu	r6,4(sp)
	int j_scale = (display->width + 255) / 255;

	unsigned char y = 104;
	unsigned char cr = 0;

	for(int i = 0; i < display->height; i = i + i_scale) {
21085bc8:	782b883a 	mov	r21,r15
					frame[ (i + ip) * display->width + (j + jp)] = (cr << 16) | (y << 8) | (cb);
					y = y - (i & 0xFF) - (j & 0x00FF);
				}
			cb = cb + 1;
		}
		cr = cr + 1;
21085bcc:	18c00044 	addi	r3,r3,1
21085bd0:	d8c00005 	stb	r3,0(sp)
21085bd4:	d8c00303 	ldbu	r3,12(sp)
21085bd8:	30cd883a 	add	r6,r6,r3
21085bdc:	d9800105 	stb	r6,4(sp)
21085be0:	d9800203 	ldbu	r6,8(sp)
21085be4:	f9bfc83a 	sub	ra,ra,r6
	int j_scale = (display->width + 255) / 255;

	unsigned char y = 104;
	unsigned char cr = 0;

	for(int i = 0; i < display->height; i = i + i_scale) {
21085be8:	797fca16 	blt	r15,r5,21085b14 <__flash_rwdata_start+0xfffe38cc>
				}
			cb = cb + 1;
		}
		cr = cr + 1;
	}
}
21085bec:	dfc00d17 	ldw	ra,52(sp)
21085bf0:	df000c17 	ldw	fp,48(sp)
21085bf4:	ddc00b17 	ldw	r23,44(sp)
21085bf8:	dd800a17 	ldw	r22,40(sp)
21085bfc:	dd400917 	ldw	r21,36(sp)
21085c00:	dd000817 	ldw	r20,32(sp)
21085c04:	dcc00717 	ldw	r19,28(sp)
21085c08:	dc800617 	ldw	r18,24(sp)
21085c0c:	dc400517 	ldw	r17,20(sp)
21085c10:	dc000417 	ldw	r16,16(sp)
21085c14:	dec00e04 	addi	sp,sp,56
21085c18:	f800283a 	ret

21085c1c <ece423_video_display_add_frame_number>:
 *                 -----------------------------------------
 *
 *  This add a frame number pointed to by buffer_being_written
 *
 ******************************************************************/
void ece423_video_display_add_frame_number(ece423_video_display* display, int frame_num, int total_frames) {
21085c1c:	defff504 	addi	sp,sp,-44
21085c20:	dd000915 	stw	r20,36(sp)
21085c24:	dc800715 	stw	r18,28(sp)
21085c28:	05000034 	movhi	r20,0
21085c2c:	dc800384 	addi	r18,sp,14
21085c30:	dcc00815 	stw	r19,32(sp)
21085c34:	dc400615 	stw	r17,24(sp)
21085c38:	dc000515 	stw	r16,20(sp)
21085c3c:	3027883a 	mov	r19,r6
21085c40:	dfc00a15 	stw	ra,40(sp)
21085c44:	2021883a 	mov	r16,r4
21085c48:	9023883a 	mov	r17,r18
21085c4c:	900f883a 	mov	r7,r18
21085c50:	a5013a04 	addi	r20,r20,1256
    char* ptr = result, *ptr1 = result, tmp_char;
    int tmp_value;

    do {
        tmp_value = value;
        value /= base;
21085c54:	01800284 	movi	r6,10
21085c58:	00000106 	br	21085c60 <ece423_video_display_add_frame_number+0x44>
        *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz" [35 + (tmp_value - value * base)];
    } while ( value );
21085c5c:	180b883a 	mov	r5,r3
    char* ptr = result, *ptr1 = result, tmp_char;
    int tmp_value;

    do {
        tmp_value = value;
        value /= base;
21085c60:	2987283a 	div	r3,r5,r6
        *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz" [35 + (tmp_value - value * base)];
21085c64:	188002a4 	muli	r2,r3,10
21085c68:	3809883a 	mov	r4,r7
21085c6c:	39c00044 	addi	r7,r7,1
21085c70:	2885c83a 	sub	r2,r5,r2
21085c74:	a085883a 	add	r2,r20,r2
21085c78:	108008c3 	ldbu	r2,35(r2)
21085c7c:	20800005 	stb	r2,0(r4)
    } while ( value );
21085c80:	183ff61e 	bne	r3,zero,21085c5c <__flash_rwdata_start+0xfffe3a14>

    // Apply negative sign
    if (tmp_value < 0) *ptr++ = '-';
21085c84:	28008816 	blt	r5,zero,21085ea8 <ece423_video_display_add_frame_number+0x28c>
    *ptr-- = '\0';
21085c88:	38bfffc4 	addi	r2,r7,-1
21085c8c:	38000005 	stb	zero,0(r7)
    while (ptr1 < ptr) {
21085c90:	9007883a 	mov	r3,r18
21085c94:	9080082e 	bgeu	r18,r2,21085cb8 <ece423_video_display_add_frame_number+0x9c>
        tmp_char = *ptr;
        *ptr--= *ptr1;
21085c98:	19800003 	ldbu	r6,0(r3)

    // Apply negative sign
    if (tmp_value < 0) *ptr++ = '-';
    *ptr-- = '\0';
    while (ptr1 < ptr) {
        tmp_char = *ptr;
21085c9c:	11400003 	ldbu	r5,0(r2)
21085ca0:	1809883a 	mov	r4,r3
        *ptr--= *ptr1;
21085ca4:	11800005 	stb	r6,0(r2)
21085ca8:	18c00044 	addi	r3,r3,1
        *ptr1++ = tmp_char;
21085cac:	21400005 	stb	r5,0(r4)
21085cb0:	10bfffc4 	addi	r2,r2,-1
    } while ( value );

    // Apply negative sign
    if (tmp_value < 0) *ptr++ = '-';
    *ptr-- = '\0';
    while (ptr1 < ptr) {
21085cb4:	18bff836 	bltu	r3,r2,21085c98 <__flash_rwdata_start+0xfffe3a50>
	char text[2*num_str_len+4];
	char num[num_str_len];
	int num_len;

	itoa(frame_num, num, 10);
	num_len = strlen(num);
21085cb8:	9009883a 	mov	r4,r18
21085cbc:	108e7200 	call	2108e720 <strlen>
21085cc0:	00c00144 	movi	r3,5
21085cc4:	1885c83a 	sub	r2,r3,r2
	for(int i = 0, j = 0; i < num_str_len; i++)
		text[i] = (i < num_str_len-num_len)? ' ' : num[j++];
21085cc8:	00806316 	blt	zero,r2,21085e58 <ece423_video_display_add_frame_number+0x23c>
21085ccc:	d8800383 	ldbu	r2,14(sp)
21085cd0:	00c00044 	movi	r3,1
21085cd4:	d8800005 	stb	r2,0(sp)
21085cd8:	90c5883a 	add	r2,r18,r3
21085cdc:	10800003 	ldbu	r2,0(r2)
21085ce0:	18c00044 	addi	r3,r3,1
21085ce4:	d8800045 	stb	r2,1(sp)
21085ce8:	90c5883a 	add	r2,r18,r3
21085cec:	10800003 	ldbu	r2,0(r2)
21085cf0:	18c00044 	addi	r3,r3,1
21085cf4:	d8800085 	stb	r2,2(sp)
21085cf8:	90c5883a 	add	r2,r18,r3
21085cfc:	10800003 	ldbu	r2,0(r2)
21085d00:	18c00044 	addi	r3,r3,1
21085d04:	d88000c5 	stb	r2,3(sp)
21085d08:	90c7883a 	add	r3,r18,r3
21085d0c:	19000003 	ldbu	r4,0(r3)

	text[num_str_len] = ' ';
21085d10:	00800804 	movi	r2,32
	text[num_str_len+1] = '/';
21085d14:	00c00bc4 	movi	r3,47
	itoa(frame_num, num, 10);
	num_len = strlen(num);
	for(int i = 0, j = 0; i < num_str_len; i++)
		text[i] = (i < num_str_len-num_len)? ' ' : num[j++];

	text[num_str_len] = ' ';
21085d18:	d8800145 	stb	r2,5(sp)
	text[num_str_len+1] = '/';
	text[num_str_len+2] = ' ';
21085d1c:	d88001c5 	stb	r2,7(sp)
	int num_len;

	itoa(frame_num, num, 10);
	num_len = strlen(num);
	for(int i = 0, j = 0; i < num_str_len; i++)
		text[i] = (i < num_str_len-num_len)? ' ' : num[j++];
21085d20:	d9000105 	stb	r4,4(sp)

	text[num_str_len] = ' ';
	text[num_str_len+1] = '/';
21085d24:	d8c00185 	stb	r3,6(sp)
	text[num_str_len+2] = ' ';
21085d28:	9005883a 	mov	r2,r18
    char* ptr = result, *ptr1 = result, tmp_char;
    int tmp_value;

    do {
        tmp_value = value;
        value /= base;
21085d2c:	01800284 	movi	r6,10
21085d30:	00000106 	br	21085d38 <ece423_video_display_add_frame_number+0x11c>
        *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz" [35 + (tmp_value - value * base)];
    } while ( value );
21085d34:	2827883a 	mov	r19,r5
    char* ptr = result, *ptr1 = result, tmp_char;
    int tmp_value;

    do {
        tmp_value = value;
        value /= base;
21085d38:	998b283a 	div	r5,r19,r6
        *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz" [35 + (tmp_value - value * base)];
21085d3c:	28c002a4 	muli	r3,r5,10
21085d40:	1009883a 	mov	r4,r2
21085d44:	10800044 	addi	r2,r2,1
21085d48:	98c7c83a 	sub	r3,r19,r3
21085d4c:	a0c7883a 	add	r3,r20,r3
21085d50:	18c008c3 	ldbu	r3,35(r3)
21085d54:	20c00005 	stb	r3,0(r4)
    } while ( value );
21085d58:	283ff61e 	bne	r5,zero,21085d34 <__flash_rwdata_start+0xfffe3aec>

    // Apply negative sign
    if (tmp_value < 0) *ptr++ = '-';
21085d5c:	98004e16 	blt	r19,zero,21085e98 <ece423_video_display_add_frame_number+0x27c>
    *ptr-- = '\0';
21085d60:	10000005 	stb	zero,0(r2)
21085d64:	10bfffc4 	addi	r2,r2,-1
    while (ptr1 < ptr) {
21085d68:	9080082e 	bgeu	r18,r2,21085d8c <ece423_video_display_add_frame_number+0x170>
        tmp_char = *ptr;
        *ptr--= *ptr1;
21085d6c:	89400003 	ldbu	r5,0(r17)

    // Apply negative sign
    if (tmp_value < 0) *ptr++ = '-';
    *ptr-- = '\0';
    while (ptr1 < ptr) {
        tmp_char = *ptr;
21085d70:	11000003 	ldbu	r4,0(r2)
21085d74:	8807883a 	mov	r3,r17
        *ptr--= *ptr1;
21085d78:	11400005 	stb	r5,0(r2)
21085d7c:	8c400044 	addi	r17,r17,1
        *ptr1++ = tmp_char;
21085d80:	19000005 	stb	r4,0(r3)
21085d84:	10bfffc4 	addi	r2,r2,-1
    } while ( value );

    // Apply negative sign
    if (tmp_value < 0) *ptr++ = '-';
    *ptr-- = '\0';
    while (ptr1 < ptr) {
21085d88:	88bff836 	bltu	r17,r2,21085d6c <__flash_rwdata_start+0xfffe3b24>
	text[num_str_len] = ' ';
	text[num_str_len+1] = '/';
	text[num_str_len+2] = ' ';

	itoa(total_frames, num, 10);
	num_len = strlen(num);
21085d8c:	9009883a 	mov	r4,r18
21085d90:	108e7200 	call	2108e720 <strlen>

	for(int i = 0, j = 0; i < 7; i++)
		text[i+num_str_len+3] = (i >= num_len)? ' ' : num[j++];
21085d94:	0080250e 	bge	zero,r2,21085e2c <ece423_video_display_add_frame_number+0x210>
21085d98:	d8c00383 	ldbu	r3,14(sp)
21085d9c:	d8c00205 	stb	r3,8(sp)
21085da0:	00c00044 	movi	r3,1
21085da4:	1880440e 	bge	r3,r2,21085eb8 <ece423_video_display_add_frame_number+0x29c>
21085da8:	d8c003c3 	ldbu	r3,15(sp)
21085dac:	d8c00245 	stb	r3,9(sp)
21085db0:	00c00084 	movi	r3,2
21085db4:	1880480e 	bge	r3,r2,21085ed8 <ece423_video_display_add_frame_number+0x2bc>
21085db8:	d8c00403 	ldbu	r3,16(sp)
21085dbc:	d8c00285 	stb	r3,10(sp)
21085dc0:	00c000c4 	movi	r3,3
21085dc4:	1880420e 	bge	r3,r2,21085ed0 <ece423_video_display_add_frame_number+0x2b4>
21085dc8:	d8c00443 	ldbu	r3,17(sp)
21085dcc:	d8c002c5 	stb	r3,11(sp)
21085dd0:	00c00104 	movi	r3,4
21085dd4:	18803c0e 	bge	r3,r2,21085ec8 <ece423_video_display_add_frame_number+0x2ac>
21085dd8:	d8c00483 	ldbu	r3,18(sp)
21085ddc:	d8c00305 	stb	r3,12(sp)
21085de0:	00c00144 	movi	r3,5
21085de4:	18801a0e 	bge	r3,r2,21085e50 <ece423_video_display_add_frame_number+0x234>
21085de8:	00c00184 	movi	r3,6
21085dec:	1880180e 	bge	r3,r2,21085e50 <ece423_video_display_add_frame_number+0x234>
21085df0:	d8800503 	ldbu	r2,20(sp)

	text[2*num_str_len+3] = '\0';
	// ece423_video_display_add_text(display, text, display->width - 10*(2*num_str_len + 7), 20, RGB_BLACK);
	ece423_video_display_add_text(display, text, 10, 32, RGB_BLACK, 1);
21085df4:	8009883a 	mov	r4,r16
21085df8:	d80b883a 	mov	r5,sp
21085dfc:	01800804 	movi	r6,32

	itoa(total_frames, num, 10);
	num_len = strlen(num);

	for(int i = 0, j = 0; i < 7; i++)
		text[i+num_str_len+3] = (i >= num_len)? ' ' : num[j++];
21085e00:	d8800385 	stb	r2,14(sp)

	text[2*num_str_len+3] = '\0';
21085e04:	d8000345 	stb	zero,13(sp)
	// ece423_video_display_add_text(display, text, display->width - 10*(2*num_str_len + 7), 20, RGB_BLACK);
	ece423_video_display_add_text(display, text, 10, 32, RGB_BLACK, 1);
21085e08:	108538c0 	call	2108538c <ece423_video_display_add_text.constprop.2>
}
21085e0c:	dfc00a17 	ldw	ra,40(sp)
21085e10:	dd000917 	ldw	r20,36(sp)
21085e14:	dcc00817 	ldw	r19,32(sp)
21085e18:	dc800717 	ldw	r18,28(sp)
21085e1c:	dc400617 	ldw	r17,24(sp)
21085e20:	dc000517 	ldw	r16,20(sp)
21085e24:	dec00b04 	addi	sp,sp,44
21085e28:	f800283a 	ret

	itoa(total_frames, num, 10);
	num_len = strlen(num);

	for(int i = 0, j = 0; i < 7; i++)
		text[i+num_str_len+3] = (i >= num_len)? ' ' : num[j++];
21085e2c:	00800804 	movi	r2,32
21085e30:	d8800205 	stb	r2,8(sp)
21085e34:	d8800245 	stb	r2,9(sp)
21085e38:	00800804 	movi	r2,32
21085e3c:	d8800285 	stb	r2,10(sp)
21085e40:	00800804 	movi	r2,32
21085e44:	d88002c5 	stb	r2,11(sp)
21085e48:	00800804 	movi	r2,32
21085e4c:	d8800305 	stb	r2,12(sp)
21085e50:	00800804 	movi	r2,32
21085e54:	003fe706 	br	21085df4 <__flash_rwdata_start+0xfffe3bac>
	int num_len;

	itoa(frame_num, num, 10);
	num_len = strlen(num);
	for(int i = 0, j = 0; i < num_str_len; i++)
		text[i] = (i < num_str_len-num_len)? ' ' : num[j++];
21085e58:	01000804 	movi	r4,32
21085e5c:	d9000005 	stb	r4,0(sp)
21085e60:	01400044 	movi	r5,1
	char num[num_str_len];
	int num_len;

	itoa(frame_num, num, 10);
	num_len = strlen(num);
	for(int i = 0, j = 0; i < num_str_len; i++)
21085e64:	0007883a 	mov	r3,zero
		text[i] = (i < num_str_len-num_len)? ' ' : num[j++];
21085e68:	28bf9b0e 	bge	r5,r2,21085cd8 <__flash_rwdata_start+0xfffe3a90>
21085e6c:	d9000045 	stb	r4,1(sp)
21085e70:	01400084 	movi	r5,2
21085e74:	2880120e 	bge	r5,r2,21085ec0 <ece423_video_display_add_frame_number+0x2a4>
21085e78:	d9000085 	stb	r4,2(sp)
21085e7c:	014000c4 	movi	r5,3
21085e80:	28bf9d0e 	bge	r5,r2,21085cf8 <__flash_rwdata_start+0xfffe3ab0>
21085e84:	d90000c5 	stb	r4,3(sp)
21085e88:	00c00104 	movi	r3,4
21085e8c:	18bfa016 	blt	r3,r2,21085d10 <__flash_rwdata_start+0xfffe3ac8>
	char num[num_str_len];
	int num_len;

	itoa(frame_num, num, 10);
	num_len = strlen(num);
	for(int i = 0, j = 0; i < num_str_len; i++)
21085e90:	0007883a 	mov	r3,zero
21085e94:	003f9c06 	br	21085d08 <__flash_rwdata_start+0xfffe3ac0>
        value /= base;
        *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz" [35 + (tmp_value - value * base)];
    } while ( value );

    // Apply negative sign
    if (tmp_value < 0) *ptr++ = '-';
21085e98:	00c00b44 	movi	r3,45
21085e9c:	20800084 	addi	r2,r4,2
21085ea0:	20c00045 	stb	r3,1(r4)
21085ea4:	003fae06 	br	21085d60 <__flash_rwdata_start+0xfffe3b18>
21085ea8:	00800b44 	movi	r2,45
21085eac:	21c00084 	addi	r7,r4,2
21085eb0:	20800045 	stb	r2,1(r4)
21085eb4:	003f7406 	br	21085c88 <__flash_rwdata_start+0xfffe3a40>

	itoa(total_frames, num, 10);
	num_len = strlen(num);

	for(int i = 0, j = 0; i < 7; i++)
		text[i+num_str_len+3] = (i >= num_len)? ' ' : num[j++];
21085eb8:	00800804 	movi	r2,32
21085ebc:	003fdd06 	br	21085e34 <__flash_rwdata_start+0xfffe3bec>
	char num[num_str_len];
	int num_len;

	itoa(frame_num, num, 10);
	num_len = strlen(num);
	for(int i = 0, j = 0; i < num_str_len; i++)
21085ec0:	0007883a 	mov	r3,zero
21085ec4:	003f8806 	br	21085ce8 <__flash_rwdata_start+0xfffe3aa0>

	itoa(total_frames, num, 10);
	num_len = strlen(num);

	for(int i = 0, j = 0; i < 7; i++)
		text[i+num_str_len+3] = (i >= num_len)? ' ' : num[j++];
21085ec8:	00800804 	movi	r2,32
21085ecc:	003fdf06 	br	21085e4c <__flash_rwdata_start+0xfffe3c04>
21085ed0:	00800804 	movi	r2,32
21085ed4:	003fdb06 	br	21085e44 <__flash_rwdata_start+0xfffe3bfc>
21085ed8:	00800804 	movi	r2,32
21085edc:	003fd706 	br	21085e3c <__flash_rwdata_start+0xfffe3bf4>

21085ee0 <ece423_video_display_set_video_name>:
 *  Purpose: Set the video name to display on the frames
 *
 ******************************************************************/
void ece423_video_display_set_video_name(ece423_video_display* display, char* name) {

	display->video_name = name;
21085ee0:	21402e15 	stw	r5,184(r4)
21085ee4:	f800283a 	ret

21085ee8 <ece423_video_display_draw_logo>:
 *  Function: ece423_video_display_draw_logo
 *
 *  Purpose: Draw Logo in the middle of the screen
 *
 ******************************************************************/
void ece423_video_display_draw_logo(ece423_video_display* display) {
21085ee8:	defffa04 	addi	sp,sp,-24
21085eec:	dd000415 	stw	r20,16(sp)

	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;

	int k1 = (display->height / 2 - logo_height/2) * display->width
21085ef0:	05000034 	movhi	r20,0
21085ef4:	a5176804 	addi	r20,r20,23968
21085ef8:	21802917 	ldw	r6,164(r4)
21085efc:	a1400017 	ldw	r5,0(r20)
 *  Function: ece423_video_display_draw_logo
 *
 *  Purpose: Draw Logo in the middle of the screen
 *
 ******************************************************************/
void ece423_video_display_draw_logo(ece423_video_display* display) {
21085f00:	dc800215 	stw	r18,8(sp)

	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;

	int k1 = (display->height / 2 - logo_height/2) * display->width
			+ (display->width / 2 - logo_width/2);
21085f04:	04800034 	movhi	r18,0
21085f08:	94976904 	addi	r18,r18,23972
 ******************************************************************/
void ece423_video_display_draw_logo(ece423_video_display* display) {

	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;

	int k1 = (display->height / 2 - logo_height/2) * display->width
21085f0c:	20c02817 	ldw	r3,160(r4)
21085f10:	300ed7fa 	srli	r7,r6,31
			+ (display->width / 2 - logo_width/2);
21085f14:	93400017 	ldw	r13,0(r18)
 ******************************************************************/
void ece423_video_display_draw_logo(ece423_video_display* display) {

	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;

	int k1 = (display->height / 2 - logo_height/2) * display->width
21085f18:	2816d7fa 	srli	r11,r5,31
 *  Purpose: Draw Logo in the middle of the screen
 *
 ******************************************************************/
void ece423_video_display_draw_logo(ece423_video_display* display) {

	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
21085f1c:	20802717 	ldw	r2,156(r4)

	int k1 = (display->height / 2 - logo_height/2) * display->width
21085f20:	398d883a 	add	r6,r7,r6
21085f24:	5957883a 	add	r11,r11,r5
			+ (display->width / 2 - logo_width/2);
21085f28:	180ed7fa 	srli	r7,r3,31
21085f2c:	6810d7fa 	srli	r8,r13,31
 ******************************************************************/
void ece423_video_display_draw_logo(ece423_video_display* display) {

	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;

	int k1 = (display->height / 2 - logo_height/2) * display->width
21085f30:	300dd07a 	srai	r6,r6,1
 *  Purpose: Draw Logo in the middle of the screen
 *
 ******************************************************************/
void ece423_video_display_draw_logo(ece423_video_display* display) {

	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
21085f34:	10800044 	addi	r2,r2,1

	int k1 = (display->height / 2 - logo_height/2) * display->width
21085f38:	5817d07a 	srai	r11,r11,1
 *  Purpose: Draw Logo in the middle of the screen
 *
 ******************************************************************/
void ece423_video_display_draw_logo(ece423_video_display* display) {

	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
21085f3c:	1085883a 	add	r2,r2,r2

	int k1 = (display->height / 2 - logo_height/2) * display->width
			+ (display->width / 2 - logo_width/2);
21085f40:	38cf883a 	add	r7,r7,r3
21085f44:	4351883a 	add	r8,r8,r13
 *  Purpose: Draw Logo in the middle of the screen
 *
 ******************************************************************/
void ece423_video_display_draw_logo(ece423_video_display* display) {

	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
21085f48:	1085883a 	add	r2,r2,r2

	int k1 = (display->height / 2 - logo_height/2) * display->width
21085f4c:	32d7c83a 	sub	r11,r6,r11
 *  Purpose: Draw Logo in the middle of the screen
 *
 ******************************************************************/
void ece423_video_display_draw_logo(ece423_video_display* display) {

	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
21085f50:	2085883a 	add	r2,r4,r2

	int k1 = (display->height / 2 - logo_height/2) * display->width
			+ (display->width / 2 - logo_width/2);
21085f54:	380dd07a 	srai	r6,r7,1
21085f58:	400fd07a 	srai	r7,r8,1
 *  Purpose: Draw Logo in the middle of the screen
 *
 ******************************************************************/
void ece423_video_display_draw_logo(ece423_video_display* display) {

	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
21085f5c:	12000017 	ldw	r8,0(r2)

	int k1 = (display->height / 2 - logo_height/2) * display->width
21085f60:	58c5383a 	mul	r2,r11,r3
 *  Function: ece423_video_display_draw_logo
 *
 *  Purpose: Draw Logo in the middle of the screen
 *
 ******************************************************************/
void ece423_video_display_draw_logo(ece423_video_display* display) {
21085f64:	dcc00315 	stw	r19,12(sp)

	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;

	int k1 = (display->height / 2 - logo_height/2) * display->width
			+ (display->width / 2 - logo_width/2);
21085f68:	31d7c83a 	sub	r11,r6,r7
 *  Function: ece423_video_display_draw_logo
 *
 *  Purpose: Draw Logo in the middle of the screen
 *
 ******************************************************************/
void ece423_video_display_draw_logo(ece423_video_display* display) {
21085f6c:	dd400515 	stw	r21,20(sp)
21085f70:	dc400115 	stw	r17,4(sp)
21085f74:	dc000015 	stw	r16,0(sp)

	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
21085f78:	44c00117 	ldw	r19,4(r8)

	int k1 = (display->height / 2 - logo_height/2) * display->width
21085f7c:	12d7883a 	add	r11,r2,r11
			+ (display->width / 2 - logo_width/2);
	int k2 = 0;
	for (int i = 0; i < logo_height; i++) {
21085f80:	01404d0e 	bge	zero,r5,210860b8 <ece423_video_display_draw_logo+0x1d0>
21085f84:	00800034 	movhi	r2,0
21085f88:	10978104 	addi	r2,r2,24068
21085f8c:	13c00017 	ldw	r15,0(r2)
21085f90:	0023883a 	mov	r17,zero
21085f94:	001d883a 	mov	r14,zero
		for (int j = 0; j < logo_width; j++) {
21085f98:	0340430e 	bge	zero,r13,210860a8 <ece423_video_display_draw_logo+0x1c0>
21085f9c:	743fff24 	muli	r16,r14,-4
21085fa0:	7395883a 	add	r10,r14,r14
21085fa4:	5ac5883a 	add	r2,r11,r11
21085fa8:	5295883a 	add	r10,r10,r10
21085fac:	1085883a 	add	r2,r2,r2
21085fb0:	52000104 	addi	r8,r10,4
21085fb4:	527fff04 	addi	r9,r10,-4
21085fb8:	1421883a 	add	r16,r2,r16
21085fbc:	0005883a 	mov	r2,zero
21085fc0:	7007883a 	mov	r3,r14
21085fc4:	59c00044 	addi	r7,r11,1
21085fc8:	71800044 	addi	r6,r14,1
21085fcc:	7a19883a 	add	r12,r15,r8
21085fd0:	7a8b883a 	add	r5,r15,r10
21085fd4:	7a53883a 	add	r9,r15,r9
			// TODO: this is just a hack to remove balck dots on the sides of the logo, the image quality should be better
			int cond1 = (j > 0) && (j < logo_width - 1) && (logo[k2] != 0) && (logo[k2-1] == 0) && (logo[k2+1] != logo[k2]);
21085fd8:	0080110e 	bge	zero,r2,21086020 <ece423_video_display_draw_logo+0x138>
21085fdc:	6affffc4 	addi	r11,r13,-1
21085fe0:	12c00f0e 	bge	r2,r11,21086020 <ece423_video_display_draw_logo+0x138>
21085fe4:	2ac00017 	ldw	r11,0(r5)
21085fe8:	5800151e 	bne	r11,zero,21086040 <ece423_video_display_draw_logo+0x158>
21085fec:	18c00044 	addi	r3,r3,1

	int k1 = (display->height / 2 - logo_height/2) * display->width
			+ (display->width / 2 - logo_width/2);
	int k2 = 0;
	for (int i = 0; i < logo_height; i++) {
		for (int j = 0; j < logo_width; j++) {
21085ff0:	10800044 	addi	r2,r2,1
			if(logo[k2] == 0 || cond1 || cond2) {
				k1++; k2++;
				continue;
			}

			frame[k1++] = logo[k2++];
21085ff4:	3817883a 	mov	r11,r7
21085ff8:	301d883a 	mov	r14,r6
21085ffc:	39c00044 	addi	r7,r7,1
21086000:	31800044 	addi	r6,r6,1
21086004:	4015883a 	mov	r10,r8
21086008:	63000104 	addi	r12,r12,4
2108600c:	29400104 	addi	r5,r5,4
21086010:	4a400104 	addi	r9,r9,4

	int k1 = (display->height / 2 - logo_height/2) * display->width
			+ (display->width / 2 - logo_width/2);
	int k2 = 0;
	for (int i = 0; i < logo_height; i++) {
		for (int j = 0; j < logo_width; j++) {
21086014:	1340220e 	bge	r2,r13,210860a0 <ece423_video_display_draw_logo+0x1b8>
21086018:	42000104 	addi	r8,r8,4
			// TODO: this is just a hack to remove balck dots on the sides of the logo, the image quality should be better
			int cond1 = (j > 0) && (j < logo_width - 1) && (logo[k2] != 0) && (logo[k2-1] == 0) && (logo[k2+1] != logo[k2]);
2108601c:	00bfef16 	blt	zero,r2,21085fdc <__flash_rwdata_start+0xfffe3d94>
21086020:	2ac00017 	ldw	r11,0(r5)
21086024:	18c00044 	addi	r3,r3,1
			int cond2 = (j > 0) && (j < logo_width - 1) && (logo[k2] != 0) && (logo[k2+1] == 0) && (logo[k2-1] != logo[k2]);
			if(logo[k2] == 0 || cond1 || cond2) {
21086028:	583ff126 	beq	r11,zero,21085ff0 <__flash_rwdata_start+0xfffe3da8>
2108602c:	5415883a 	add	r10,r10,r16
21086030:	9a95883a 	add	r10,r19,r10
				k1++; k2++;
				continue;
			}

			frame[k1++] = logo[k2++];
21086034:	52c00015 	stw	r11,0(r10)
21086038:	93400017 	ldw	r13,0(r18)
2108603c:	003fec06 	br	21085ff0 <__flash_rwdata_start+0xfffe3da8>
			+ (display->width / 2 - logo_width/2);
	int k2 = 0;
	for (int i = 0; i < logo_height; i++) {
		for (int j = 0; j < logo_width; j++) {
			// TODO: this is just a hack to remove balck dots on the sides of the logo, the image quality should be better
			int cond1 = (j > 0) && (j < logo_width - 1) && (logo[k2] != 0) && (logo[k2-1] == 0) && (logo[k2+1] != logo[k2]);
21086040:	4b800017 	ldw	r14,0(r9)
21086044:	70000e1e 	bne	r14,zero,21086080 <ece423_video_display_draw_logo+0x198>
21086048:	63800017 	ldw	r14,0(r12)
2108604c:	5b800c26 	beq	r11,r14,21086080 <ece423_video_display_draw_logo+0x198>
			int cond2 = (j > 0) && (j < logo_width - 1) && (logo[k2] != 0) && (logo[k2+1] == 0) && (logo[k2-1] != logo[k2]);
21086050:	18c00044 	addi	r3,r3,1
21086054:	18dd883a 	add	r14,r3,r3
21086058:	739d883a 	add	r14,r14,r14
2108605c:	7b9d883a 	add	r14,r15,r14
21086060:	75400017 	ldw	r21,0(r14)
			+ (display->width / 2 - logo_width/2);
	int k2 = 0;
	for (int i = 0; i < logo_height; i++) {
		for (int j = 0; j < logo_width; j++) {
			// TODO: this is just a hack to remove balck dots on the sides of the logo, the image quality should be better
			int cond1 = (j > 0) && (j < logo_width - 1) && (logo[k2] != 0) && (logo[k2-1] == 0) && (logo[k2+1] != logo[k2]);
21086064:	03800044 	movi	r14,1
			int cond2 = (j > 0) && (j < logo_width - 1) && (logo[k2] != 0) && (logo[k2+1] == 0) && (logo[k2-1] != logo[k2]);
21086068:	a83fe11e 	bne	r21,zero,21085ff0 <__flash_rwdata_start+0xfffe3da8>
2108606c:	7aab883a 	add	r21,r15,r10
21086070:	ad7fff17 	ldw	r21,-4(r21)
21086074:	aaffde1e 	bne	r21,r11,21085ff0 <__flash_rwdata_start+0xfffe3da8>
			if(logo[k2] == 0 || cond1 || cond2) {
21086078:	703fdd1e 	bne	r14,zero,21085ff0 <__flash_rwdata_start+0xfffe3da8>
2108607c:	003feb06 	br	2108602c <__flash_rwdata_start+0xfffe3de4>
	int k2 = 0;
	for (int i = 0; i < logo_height; i++) {
		for (int j = 0; j < logo_width; j++) {
			// TODO: this is just a hack to remove balck dots on the sides of the logo, the image quality should be better
			int cond1 = (j > 0) && (j < logo_width - 1) && (logo[k2] != 0) && (logo[k2-1] == 0) && (logo[k2+1] != logo[k2]);
			int cond2 = (j > 0) && (j < logo_width - 1) && (logo[k2] != 0) && (logo[k2+1] == 0) && (logo[k2-1] != logo[k2]);
21086080:	18c00044 	addi	r3,r3,1
21086084:	18dd883a 	add	r14,r3,r3
21086088:	739d883a 	add	r14,r14,r14
2108608c:	7b9d883a 	add	r14,r15,r14
21086090:	73800017 	ldw	r14,0(r14)
21086094:	703fe51e 	bne	r14,zero,2108602c <__flash_rwdata_start+0xfffe3de4>
21086098:	001d883a 	mov	r14,zero
2108609c:	003ff306 	br	2108606c <__flash_rwdata_start+0xfffe3e24>
210860a0:	a1400017 	ldw	r5,0(r20)
210860a4:	20c02817 	ldw	r3,160(r4)
				continue;
			}

			frame[k1++] = logo[k2++];
		}
		k1 += display->width - logo_width;
210860a8:	1b45c83a 	sub	r2,r3,r13
	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;

	int k1 = (display->height / 2 - logo_height/2) * display->width
			+ (display->width / 2 - logo_width/2);
	int k2 = 0;
	for (int i = 0; i < logo_height; i++) {
210860ac:	8c400044 	addi	r17,r17,1
				continue;
			}

			frame[k1++] = logo[k2++];
		}
		k1 += display->width - logo_width;
210860b0:	5897883a 	add	r11,r11,r2
	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;

	int k1 = (display->height / 2 - logo_height/2) * display->width
			+ (display->width / 2 - logo_width/2);
	int k2 = 0;
	for (int i = 0; i < logo_height; i++) {
210860b4:	897fb816 	blt	r17,r5,21085f98 <__flash_rwdata_start+0xfffe3d50>
			frame[k1++] = logo[k2++];
		}
		k1 += display->width - logo_width;
	}

}
210860b8:	dd400517 	ldw	r21,20(sp)
210860bc:	dd000417 	ldw	r20,16(sp)
210860c0:	dcc00317 	ldw	r19,12(sp)
210860c4:	dc800217 	ldw	r18,8(sp)
210860c8:	dc400117 	ldw	r17,4(sp)
210860cc:	dc000017 	ldw	r16,0(sp)
210860d0:	dec00604 	addi	sp,sp,24
210860d4:	f800283a 	ret

210860d8 <ece423_video_display_demo>:
 *  Function: ece423_video_display_demo
 *
 *  Purpose: Display a simple animation to test the functionality
 *
 ******************************************************************/
void ece423_video_display_demo(ece423_video_display* display) {
210860d8:	201f883a 	mov	r15,r4

	int i_scale = (display->height + 255) / 255;
	int j_scale = (display->width + 255) / 255;
210860dc:	78c02817 	ldw	r3,160(r15)
 *  Purpose: Display a simple animation to test the functionality
 *
 ******************************************************************/
void ece423_video_display_demo(ece423_video_display* display) {

	int i_scale = (display->height + 255) / 255;
210860e0:	21002917 	ldw	r4,164(r4)
210860e4:	00803fc4 	movi	r2,255
 *  Function: ece423_video_display_demo
 *
 *  Purpose: Display a simple animation to test the functionality
 *
 ******************************************************************/
void ece423_video_display_demo(ece423_video_display* display) {
210860e8:	deffd404 	addi	sp,sp,-176

	int i_scale = (display->height + 255) / 255;
	int j_scale = (display->width + 255) / 255;
210860ec:	1887883a 	add	r3,r3,r2
 *  Purpose: Display a simple animation to test the functionality
 *
 ******************************************************************/
void ece423_video_display_demo(ece423_video_display* display) {

	int i_scale = (display->height + 255) / 255;
210860f0:	208b883a 	add	r5,r4,r2
210860f4:	288b283a 	div	r5,r5,r2
 *  Function: ece423_video_display_demo
 *
 *  Purpose: Display a simple animation to test the functionality
 *
 ******************************************************************/
void ece423_video_display_demo(ece423_video_display* display) {
210860f8:	dc002215 	stw	r16,136(sp)

	int i_scale = (display->height + 255) / 255;
	int j_scale = (display->width + 255) / 255;
210860fc:	18a1283a 	div	r16,r3,r2
21086100:	80c001a4 	muli	r3,r16,6
 *  Purpose: Display a simple animation to test the functionality
 *
 ******************************************************************/
void ece423_video_display_demo(ece423_video_display* display) {

	int i_scale = (display->height + 255) / 255;
21086104:	d9400d15 	stw	r5,52(sp)
21086108:	294002a4 	muli	r5,r5,10
2108610c:	81bfffc4 	addi	r6,r16,-1
21086110:	00cfc83a 	sub	r7,zero,r3
21086114:	0151c83a 	sub	r8,zero,r5
21086118:	3211383a 	mul	r8,r6,r8
2108611c:	31cf383a 	mul	r7,r6,r7
 *  Function: ece423_video_display_demo
 *
 *  Purpose: Display a simple animation to test the functionality
 *
 ******************************************************************/
void ece423_video_display_demo(ece423_video_display* display) {
21086120:	dd002615 	stw	r20,152(sp)
21086124:	dcc02515 	stw	r19,148(sp)

	int i_scale = (display->height + 255) / 255;
	int j_scale = (display->width + 255) / 255;
21086128:	05027b04 	movi	r20,2540
 *  Function: ece423_video_display_demo
 *
 *  Purpose: Display a simple animation to test the functionality
 *
 ******************************************************************/
void ece423_video_display_demo(ece423_video_display* display) {
2108612c:	dc802415 	stw	r18,144(sp)
21086130:	d8c01505 	stb	r3,84(sp)

	int i_scale = (display->height + 255) / 255;
	int j_scale = (display->width + 255) / 255;
21086134:	0025883a 	mov	r18,zero
21086138:	00ffffc4 	movi	r3,-1

	unsigned char y = 0;
2108613c:	0027883a 	mov	r19,zero
 *  Function: ece423_video_display_demo
 *
 *  Purpose: Display a simple animation to test the functionality
 *
 ******************************************************************/
void ece423_video_display_demo(ece423_video_display* display) {
21086140:	df002a15 	stw	fp,168(sp)
21086144:	ddc02915 	stw	r23,164(sp)
21086148:	dd802815 	stw	r22,160(sp)
2108614c:	dd402715 	stw	r21,156(sp)
						}

						int f_c = m*f < 128? m*f : m*(254 - f) < 128 ? m*(254 - f) : -1;
						if (f_c >= 0) {
							if (cb >= 128) {
								cb_f = cb - 128 < 128 - f_c? cb - 128 : 128 - f_c;
21086150:	a039883a 	mov	fp,r20
 *  Function: ece423_video_display_demo
 *
 *  Purpose: Display a simple animation to test the functionality
 *
 ******************************************************************/
void ece423_video_display_demo(ece423_video_display* display) {
21086154:	dfc02b15 	stw	ra,172(sp)
						}

						int f_c = m*f < 128? m*f : m*(254 - f) < 128 ? m*(254 - f) : -1;
						if (f_c >= 0) {
							if (cb >= 128) {
								cb_f = cb - 128 < 128 - f_c? cb - 128 : 128 - f_c;
21086158:	8029883a 	mov	r20,r16
 *  Function: ece423_video_display_demo
 *
 *  Purpose: Display a simple animation to test the functionality
 *
 ******************************************************************/
void ece423_video_display_demo(ece423_video_display* display) {
2108615c:	dc402315 	stw	r17,140(sp)
21086160:	da001e05 	stb	r8,120(sp)
21086164:	d9c01605 	stb	r7,88(sp)
21086168:	d9401d05 	stb	r5,116(sp)

	int i_scale = (display->height + 255) / 255;
	int j_scale = (display->width + 255) / 255;
2108616c:	d8c01c05 	stb	r3,112(sp)
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
21086170:	102d883a 	mov	r22,r2
21086174:	05c01fc4 	movi	r23,127
						}

						int f_c = m*f < 128? m*f : m*(254 - f) < 128 ? m*(254 - f) : -1;
						if (f_c >= 0) {
							if (cb >= 128) {
								cb_f = cb - 128 < 128 - f_c? cb - 128 : 128 - f_c;
21086178:	982b883a 	mov	r21,r19
2108617c:	9021883a 	mov	r16,r18
21086180:	79402c17 	ldw	r5,176(r15)
21086184:	02000044 	movi	r8,1
21086188:	78802717 	ldw	r2,156(r15)
2108618c:	4140070e 	bge	r8,r5,210861ac <ece423_video_display_demo+0xd4>

int ece423_video_display_buffer_is_available(ece423_video_display* display) {


	if (display->num_frame_buffers > 1) {
		int iNext_Rd_Buf = ((display->buffer_being_displayed - 1 + display->num_frame_buffers)
21086190:	78c02617 	ldw	r3,152(r15)
21086194:	18ffffc4 	addi	r3,r3,-1
21086198:	1947883a 	add	r3,r3,r5
2108619c:	194d283a 	div	r6,r3,r5
210861a0:	314b383a 	mul	r5,r6,r5
210861a4:	1947c83a 	sub	r3,r3,r5
			% display->num_frame_buffers);
		if (iNext_Rd_Buf == display->buffer_being_written) // If Frame Buf free to write to
210861a8:	18bfff26 	beq	r3,r2,210861a8 <__flash_rwdata_start+0xfffe3f60>
 *           -1 - No new frame available, so no switch
 *
 ******************************************************************/
alt_u32* ece423_video_display_get_buffer(ece423_video_display* display) {

	return (display->buffer_ptrs[display->buffer_being_written]->buffer);
210861ac:	10800044 	addi	r2,r2,1
210861b0:	1085883a 	add	r2,r2,r2
210861b4:	1085883a 	add	r2,r2,r2
210861b8:	7885883a 	add	r2,r15,r2
210861bc:	10800017 	ldw	r2,0(r2)
210861c0:	13400117 	ldw	r13,4(r2)

		int* frame = ece423_video_display_get_buffer(display);

		unsigned char cr = 0;

		for(int i = 0; i < display->height; i = i + i_scale) {
210861c4:	0101360e 	bge	zero,r4,210866a0 <ece423_video_display_demo+0x5c8>
210861c8:	02803f84 	movi	r10,254
210861cc:	7b002817 	ldw	r12,160(r15)
210861d0:	54012e0e 	bge	r10,r16,2108668c <ece423_video_display_demo+0x5b4>
210861d4:	e005883a 	mov	r2,fp
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
210861d8:	b0bfc83a 	sub	ra,r22,r2
210861dc:	bc01290e 	bge	r23,r16,21086684 <ece423_video_display_demo+0x5ac>
210861e0:	e005883a 	mov	r2,fp
						}

						int f_c = m*f < 128? m*f : m*(254 - f) < 128 ? m*(254 - f) : -1;
						if (f_c >= 0) {
							if (cb >= 128) {
								cb_f = cb - 128 < 128 - f_c? cb - 128 : 128 - f_c;
210861e4:	03802004 	movi	r14,128
210861e8:	00ffe004 	movi	r3,-128
210861ec:	709dc83a 	sub	r14,r14,r2
210861f0:	1885c83a 	sub	r2,r3,r2
210861f4:	d8800e05 	stb	r2,56(sp)
210861f8:	db800315 	stw	r14,12(sp)
210861fc:	8005883a 	mov	r2,r16
21086200:	d8001a05 	stb	zero,104(sp)
21086204:	d8001b05 	stb	zero,108(sp)
21086208:	d8000b15 	stw	zero,44(sp)
2108620c:	d8000805 	stb	zero,32(sp)
21086210:	e021883a 	mov	r16,fp
21086214:	1039883a 	mov	fp,r2

		unsigned char cr = 0;

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
21086218:	0300c70e 	bge	zero,r12,21086538 <ece423_video_display_demo+0x460>
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
2108621c:	d8800803 	ldbu	r2,32(sp)
21086220:	db800b17 	ldw	r14,44(sp)
21086224:	1006943a 	slli	r3,r2,16
21086228:	738002a4 	muli	r14,r14,10
2108622c:	d8c01415 	stw	r3,80(sp)
21086230:	db800005 	stb	r14,0(sp)
21086234:	bf01110e 	bge	r23,fp,2108667c <ece423_video_display_demo+0x5a4>
21086238:	1007883a 	mov	r3,r2
2108623c:	18c03fcc 	andi	r3,r3,255
21086240:	1806943a 	slli	r3,r3,16
								cb_f = 128 - cb < 128 - f_c? 128 - cb : 128 - f_c;
								cb_f = cb + cb_f;
							}
							if (cr >= 128) {
								cr_f = cr - 128 < 128 - f_c? cr - 128 : 128 - f_c;
								cr_f = cr - cr_f;
21086244:	d9000803 	ldbu	r4,32(sp)
21086248:	d9400e03 	ldbu	r5,56(sp)
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
2108624c:	d8c01215 	stw	r3,72(sp)
								cb_f = 128 - cb < 128 - f_c? 128 - cb : 128 - f_c;
								cb_f = cb + cb_f;
							}
							if (cr >= 128) {
								cr_f = cr - 128 < 128 - f_c? cr - 128 : 128 - f_c;
								cr_f = cr - cr_f;
21086250:	2147c83a 	sub	r3,r4,r5
21086254:	bf00010e 	bge	r23,fp,2108625c <ece423_video_display_demo+0x184>
21086258:	2007883a 	mov	r3,r4
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
2108625c:	18c03fcc 	andi	r3,r3,255
21086260:	1806943a 	slli	r3,r3,16
21086264:	d9400803 	ldbu	r5,32(sp)
21086268:	da001b03 	ldbu	r8,108(sp)
2108626c:	da800b17 	ldw	r10,44(sp)
21086270:	db800d17 	ldw	r14,52(sp)
							}
							if (cr >= 128) {
								cr_f = cr - 128 < 128 - f_c? cr - 128 : 128 - f_c;
								cr_f = cr - cr_f;
							} else {
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
21086274:	01002004 	movi	r4,128
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086278:	d9c01a03 	ldbu	r7,104(sp)
2108627c:	dcc00807 	ldb	r19,32(sp)
21086280:	d8c01315 	stw	r3,76(sp)
21086284:	027fe004 	movi	r9,-128
							} else {
								cb_f = 128 - cb < 128 - f_c? 128 - cb : 128 - f_c;
								cb_f = cb + cb_f;
							}
							if (cr >= 128) {
								cr_f = cr - 128 < 128 - f_c? cr - 128 : 128 - f_c;
21086288:	10ffe044 	addi	r3,r2,-127
2108628c:	297fe004 	addi	r5,r5,-128
								cr_f = cr - cr_f;
							} else {
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
21086290:	2085c83a 	sub	r2,r4,r2
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086294:	da000905 	stb	r8,36(sp)
21086298:	a00d883a 	mov	r6,r20
2108629c:	da400a05 	stb	r9,40(sp)
210862a0:	0023883a 	mov	r17,zero
210862a4:	d8000205 	stb	zero,8(sp)
210862a8:	53a5883a 	add	r18,r10,r14
							} else {
								cb_f = 128 - cb < 128 - f_c? 128 - cb : 128 - f_c;
								cb_f = cb + cb_f;
							}
							if (cr >= 128) {
								cr_f = cr - 128 < 128 - f_c? cr - 128 : 128 - f_c;
210862ac:	d8c01115 	stw	r3,68(sp)
								cr_f = cr - cr_f;
							} else {
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
210862b0:	d8800c15 	stw	r2,48(sp)
210862b4:	d9401905 	stb	r5,100(sp)
		unsigned char cr = 0;

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
				for(int ip = 0; ip < i_scale; ip++)
210862b8:	da800d17 	ldw	r10,52(sp)
210862bc:	0280810e 	bge	zero,r10,210864c4 <ece423_video_display_demo+0x3ec>
						}

						int f_c = m*f < 128? m*f : m*(254 - f) < 128 ? m*(254 - f) : -1;
						if (f_c >= 0) {
							if (cb >= 128) {
								cb_f = cb - 128 < 128 - f_c? cb - 128 : 128 - f_c;
210862c0:	db800203 	ldbu	r14,8(sp)
								cb_f = cb - cb_f;
							} else {
								cb_f = 128 - cb < 128 - f_c? 128 - cb : 128 - f_c;
210862c4:	00c02004 	movi	r3,128
210862c8:	890001a4 	muli	r4,r17,6
210862cc:	1b85c83a 	sub	r2,r3,r14
210862d0:	d8c00317 	ldw	r3,12(sp)
						}

						int f_c = m*f < 128? m*f : m*(254 - f) < 128 ? m*(254 - f) : -1;
						if (f_c >= 0) {
							if (cb >= 128) {
								cb_f = cb - 128 < 128 - f_c? cb - 128 : 128 - f_c;
210862d4:	db800415 	stw	r14,16(sp)
210862d8:	d9000f05 	stb	r4,60(sp)
								cb_f = cb - cb_f;
							} else {
								cb_f = 128 - cb < 128 - f_c? 128 - cb : 128 - f_c;
210862dc:	10c0010e 	bge	r2,r3,210862e4 <ece423_video_display_demo+0x20c>
210862e0:	1007883a 	mov	r3,r2
								cb_f = cb + cb_f;
210862e4:	d9400203 	ldbu	r5,8(sp)
							}
							if (cr >= 128) {
								cr_f = cr - 128 < 128 - f_c? cr - 128 : 128 - f_c;
								cr_f = cr - cr_f;
							} else {
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
210862e8:	da000c17 	ldw	r8,48(sp)
							if (cb >= 128) {
								cb_f = cb - 128 < 128 - f_c? cb - 128 : 128 - f_c;
								cb_f = cb - cb_f;
							} else {
								cb_f = 128 - cb < 128 - f_c? 128 - cb : 128 - f_c;
								cb_f = cb + cb_f;
210862ec:	1947883a 	add	r3,r3,r5
							}
							if (cr >= 128) {
								cr_f = cr - 128 < 128 - f_c? cr - 128 : 128 - f_c;
								cr_f = cr - cr_f;
							} else {
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
210862f0:	d9400317 	ldw	r5,12(sp)
							if (cb >= 128) {
								cb_f = cb - 128 < 128 - f_c? cb - 128 : 128 - f_c;
								cb_f = cb - cb_f;
							} else {
								cb_f = 128 - cb < 128 - f_c? 128 - cb : 128 - f_c;
								cb_f = cb + cb_f;
210862f4:	181d883a 	mov	r14,r3
							}
							if (cr >= 128) {
								cr_f = cr - 128 < 128 - f_c? cr - 128 : 128 - f_c;
								cr_f = cr - cr_f;
							} else {
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
210862f8:	4140010e 	bge	r8,r5,21086300 <ece423_video_display_demo+0x228>
210862fc:	400b883a 	mov	r5,r8
						}

						int f_c = m*f < 128? m*f : m*(254 - f) < 128 ? m*(254 - f) : -1;
						if (f_c >= 0) {
							if (cb >= 128) {
								cb_f = cb - 128 < 128 - f_c? cb - 128 : 128 - f_c;
21086300:	da400417 	ldw	r9,16(sp)
21086304:	d8800b17 	ldw	r2,44(sp)
							if (cr >= 128) {
								cr_f = cr - 128 < 128 - f_c? cr - 128 : 128 - f_c;
								cr_f = cr - cr_f;
							} else {
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
21086308:	da800803 	ldbu	r10,32(sp)
2108630c:	da000317 	ldw	r8,12(sp)
						}

						int f_c = m*f < 128? m*f : m*(254 - f) < 128 ? m*(254 - f) : -1;
						if (f_c >= 0) {
							if (cb >= 128) {
								cb_f = cb - 128 < 128 - f_c? cb - 128 : 128 - f_c;
21086310:	493fe044 	addi	r4,r9,-127
21086314:	d8802015 	stw	r2,128(sp)
							if (cr >= 128) {
								cr_f = cr - 128 < 128 - f_c? cr - 128 : 128 - f_c;
								cr_f = cr - cr_f;
							} else {
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
21086318:	2a8b883a 	add	r5,r5,r10
2108631c:	4100d30e 	bge	r8,r4,2108666c <ece423_video_display_demo+0x594>
21086320:	d9000e03 	ldbu	r4,56(sp)

						int f_c = m*f < 128? m*f : m*(254 - f) < 128 ? m*(254 - f) : -1;
						if (f_c >= 0) {
							if (cb >= 128) {
								cb_f = cb - 128 < 128 - f_c? cb - 128 : 128 - f_c;
								cb_f = cb - cb_f;
21086324:	da400203 	ldbu	r9,8(sp)
21086328:	da800317 	ldw	r10,12(sp)
2108632c:	d8801117 	ldw	r2,68(sp)
21086330:	4909c83a 	sub	r4,r9,r4
21086334:	5080cb0e 	bge	r10,r2,21086664 <ece423_video_display_demo+0x58c>
21086338:	da800e03 	ldbu	r10,56(sp)
								cb_f = 128 - cb < 128 - f_c? 128 - cb : 128 - f_c;
								cb_f = cb + cb_f;
							}
							if (cr >= 128) {
								cr_f = cr - 128 < 128 - f_c? cr - 128 : 128 - f_c;
								cr_f = cr - cr_f;
2108633c:	da000803 	ldbu	r8,32(sp)
21086340:	da400207 	ldb	r9,8(sp)
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086344:	20803fcc 	andi	r2,r4,255
								cb_f = 128 - cb < 128 - f_c? 128 - cb : 128 - f_c;
								cb_f = cb + cb_f;
							}
							if (cr >= 128) {
								cr_f = cr - 128 < 128 - f_c? cr - 128 : 128 - f_c;
								cr_f = cr - cr_f;
21086348:	4295c83a 	sub	r10,r8,r10
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
2108634c:	52803fcc 	andi	r10,r10,255
21086350:	da400115 	stw	r9,4(sp)
21086354:	d8800615 	stw	r2,24(sp)
21086358:	5014943a 	slli	r10,r10,16
2108635c:	4800c516 	blt	r9,zero,21086674 <ece423_video_display_demo+0x59c>
21086360:	1811883a 	mov	r8,r3
21086364:	42403fcc 	andi	r9,r8,255
21086368:	2ac03fcc 	andi	r11,r5,255
2108636c:	da400715 	stw	r9,28(sp)
21086370:	5816943a 	slli	r11,r11,16
21086374:	bf00010e 	bge	r23,fp,2108637c <ece423_video_display_demo+0x2a4>
21086378:	d9400803 	ldbu	r5,32(sp)
2108637c:	2a403fcc 	andi	r9,r5,255
21086380:	4812943a 	slli	r9,r9,16
21086384:	bf00010e 	bge	r23,fp,2108638c <ece423_video_display_demo+0x2b4>
21086388:	d9000203 	ldbu	r4,8(sp)
2108638c:	21003fcc 	andi	r4,r4,255
21086390:	d9002115 	stw	r4,132(sp)
21086394:	bf00010e 	bge	r23,fp,2108639c <ece423_video_display_demo+0x2c4>
21086398:	d8c00203 	ldbu	r3,8(sp)
2108639c:	18c03fcc 	andi	r3,r3,255
210863a0:	bf00010e 	bge	r23,fp,210863a8 <ece423_video_display_demo+0x2d0>
210863a4:	da000203 	ldbu	r8,8(sp)
210863a8:	73803fcc 	andi	r14,r14,255
210863ac:	db800515 	stw	r14,20(sp)
210863b0:	d9000f03 	ldbu	r4,60(sp)
210863b4:	db800717 	ldw	r14,28(sp)
210863b8:	d8800903 	ldbu	r2,36(sp)
210863bc:	42003fcc 	andi	r8,r8,255
210863c0:	538ab03a 	or	r5,r10,r14
210863c4:	111dc83a 	sub	r14,r2,r4
210863c8:	d8801217 	ldw	r2,72(sp)
210863cc:	d9001317 	ldw	r4,76(sp)
210863d0:	48c6b03a 	or	r3,r9,r3
210863d4:	4084b03a 	or	r2,r8,r2
210863d8:	d8800f15 	stw	r2,60(sp)
210863dc:	d8800517 	ldw	r2,20(sp)
210863e0:	4110b03a 	or	r8,r8,r4
210863e4:	da001015 	stw	r8,64(sp)
210863e8:	12c4b03a 	or	r2,r2,r11
210863ec:	da000617 	ldw	r8,24(sp)
210863f0:	d9000417 	ldw	r4,16(sp)
210863f4:	d8801815 	stw	r2,96(sp)
210863f8:	d8801417 	ldw	r2,80(sp)
210863fc:	42d0b03a 	or	r8,r8,r11
21086400:	da001715 	stw	r8,92(sp)
21086404:	2090b03a 	or	r8,r4,r2
21086408:	d8802117 	ldw	r2,132(sp)
2108640c:	1248b03a 	or	r4,r2,r9
21086410:	da400717 	ldw	r9,28(sp)
21086414:	d8800517 	ldw	r2,20(sp)
21086418:	5a56b03a 	or	r11,r11,r9
2108641c:	da400617 	ldw	r9,24(sp)
21086420:	5084b03a 	or	r2,r10,r2
21086424:	d8800715 	stw	r2,28(sp)
21086428:	d8802017 	ldw	r2,128(sp)
2108642c:	4a94b03a 	or	r10,r9,r10
21086430:	dac00415 	stw	r11,16(sp)
21086434:	da800615 	stw	r10,24(sp)

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
				for(int ip = 0; ip < i_scale; ip++)
					for(int jp = 0; jp < j_scale; jp++){
21086438:	0500200e 	bge	zero,r20,210864bc <ece423_video_display_demo+0x3e4>
2108643c:	02803f84 	movi	r10,254
21086440:	57013e36 	bltu	r10,fp,2108693c <ece423_video_display_demo+0x864>
21086444:	bc00d40e 	bge	r23,r16,21086798 <ece423_video_display_demo+0x6c0>
21086448:	98003f16 	blt	r19,zero,21086548 <ece423_video_display_demo+0x470>
2108644c:	da800117 	ldw	r10,4(sp)
21086450:	8817883a 	mov	r11,r17
21086454:	50006a16 	blt	r10,zero,21086600 <ece423_video_display_demo+0x528>
21086458:	a815883a 	mov	r10,r21
2108645c:	6013883a 	mov	r9,r12
21086460:	00000106 	br	21086468 <ece423_video_display_demo+0x390>
21086464:	7a402817 	ldw	r9,160(r15)
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086468:	1253383a 	mul	r9,r2,r9
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
2108646c:	53003fcc 	andi	r12,r10,255
21086470:	b319c83a 	sub	r12,r22,r12
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086474:	4ad3883a 	add	r9,r9,r11
21086478:	4a53883a 	add	r9,r9,r9
2108647c:	4a53883a 	add	r9,r9,r9
21086480:	6a53883a 	add	r9,r13,r9
21086484:	5ac00044 	addi	r11,r11,1
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
21086488:	fb00010e 	bge	ra,r12,21086490 <ece423_video_display_demo+0x3b8>
2108648c:	f819883a 	mov	r12,ra
							y_f = y + y_f;
21086490:	6299883a 	add	r12,r12,r10
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086494:	63003fcc 	andi	r12,r12,255
21086498:	6018923a 	slli	r12,r12,8
2108649c:	51d5883a 	add	r10,r10,r7
210864a0:	1b18b03a 	or	r12,r3,r12
210864a4:	4b000015 	stw	r12,0(r9)

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
				for(int ip = 0; ip < i_scale; ip++)
					for(int jp = 0; jp < j_scale; jp++){
210864a8:	32ffee1e 	bne	r6,r11,21086464 <__flash_rwdata_start+0xfffe421c>
210864ac:	da400003 	ldbu	r9,0(sp)
210864b0:	aa6bc83a 	sub	r21,r21,r9
210864b4:	abab883a 	add	r21,r21,r14
210864b8:	7b002817 	ldw	r12,160(r15)
210864bc:	10800044 	addi	r2,r2,1
		unsigned char cr = 0;

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
				for(int ip = 0; ip < i_scale; ip++)
210864c0:	14bfdd1e 	bne	r2,r18,21086438 <__flash_rwdata_start+0xfffe41f0>
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
						y = y - (i*10 & 0xFF) - (j*6 & 0x00FF);
					}
				cb = cb + 1;
210864c4:	db800203 	ldbu	r14,8(sp)
210864c8:	d8800903 	ldbu	r2,36(sp)
210864cc:	da400a03 	ldbu	r9,40(sp)
210864d0:	d8c01603 	ldbu	r3,88(sp)
210864d4:	da001503 	ldbu	r8,84(sp)
210864d8:	73800044 	addi	r14,r14,1
210864dc:	10c5883a 	add	r2,r2,r3
210864e0:	4a400044 	addi	r9,r9,1

		unsigned char cr = 0;

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
210864e4:	8d23883a 	add	r17,r17,r20
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
						y = y - (i*10 & 0xFF) - (j*6 & 0x00FF);
					}
				cb = cb + 1;
210864e8:	db800205 	stb	r14,8(sp)
210864ec:	d8800905 	stb	r2,36(sp)
210864f0:	da400a05 	stb	r9,40(sp)
210864f4:	350d883a 	add	r6,r6,r20
210864f8:	3a0fc83a 	sub	r7,r7,r8

		unsigned char cr = 0;

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
210864fc:	8b3f6e16 	blt	r17,r12,210862b8 <__flash_rwdata_start+0xfffe4070>
21086500:	79002917 	ldw	r4,164(r15)
21086504:	da801b03 	ldbu	r10,108(sp)
21086508:	d8801a03 	ldbu	r2,104(sp)
2108650c:	db801e03 	ldbu	r14,120(sp)
21086510:	d8c01d03 	ldbu	r3,116(sp)

		int* frame = ece423_video_display_get_buffer(display);

		unsigned char cr = 0;

		for(int i = 0; i < display->height; i = i + i_scale) {
21086514:	dc800b15 	stw	r18,44(sp)
21086518:	5395883a 	add	r10,r10,r14
2108651c:	10c5c83a 	sub	r2,r2,r3
21086520:	da801b05 	stb	r10,108(sp)
21086524:	d8801a05 	stb	r2,104(sp)
21086528:	91005a0e 	bge	r18,r4,21086694 <ece423_video_display_demo+0x5bc>
						y = y - (i*10 & 0xFF) - (j*6 & 0x00FF);
					}
				cb = cb + 1;

			}
			cr = 255 - f;
2108652c:	da001c03 	ldbu	r8,112(sp)
21086530:	da000805 	stb	r8,32(sp)

		unsigned char cr = 0;

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
21086534:	033f3916 	blt	zero,r12,2108621c <__flash_rwdata_start+0xfffe3fd4>
21086538:	da400b17 	ldw	r9,44(sp)
2108653c:	da800d17 	ldw	r10,52(sp)
21086540:	4aa5883a 	add	r18,r9,r10
21086544:	003fef06 	br	21086504 <__flash_rwdata_start+0xfffe42bc>
21086548:	8817883a 	mov	r11,r17
				for(int ip = 0; ip < i_scale; ip++)
					for(int jp = 0; jp < j_scale; jp++){
2108654c:	a815883a 	mov	r10,r21
21086550:	6013883a 	mov	r9,r12
21086554:	bf00020e 	bge	r23,fp,21086560 <ece423_video_display_demo+0x488>
21086558:	00001706 	br	210865b8 <ece423_video_display_demo+0x4e0>
2108655c:	7a402817 	ldw	r9,160(r15)
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086560:	1253383a 	mul	r9,r2,r9
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
21086564:	53003fcc 	andi	r12,r10,255
21086568:	b319c83a 	sub	r12,r22,r12
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
2108656c:	4ad3883a 	add	r9,r9,r11
21086570:	4a53883a 	add	r9,r9,r9
21086574:	4a53883a 	add	r9,r9,r9
21086578:	6a53883a 	add	r9,r13,r9
2108657c:	5ac00044 	addi	r11,r11,1
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
21086580:	fb00010e 	bge	ra,r12,21086588 <ece423_video_display_demo+0x4b0>
21086584:	f819883a 	mov	r12,ra
							y_f = y + y_f;
21086588:	6299883a 	add	r12,r12,r10
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
2108658c:	63003fcc 	andi	r12,r12,255
21086590:	6018923a 	slli	r12,r12,8
21086594:	51d5883a 	add	r10,r10,r7
21086598:	2b18b03a 	or	r12,r5,r12
2108659c:	4b000015 	stw	r12,0(r9)

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
				for(int ip = 0; ip < i_scale; ip++)
					for(int jp = 0; jp < j_scale; jp++){
210865a0:	32ffee1e 	bne	r6,r11,2108655c <__flash_rwdata_start+0xfffe4314>
210865a4:	da800003 	ldbu	r10,0(sp)
210865a8:	aaabc83a 	sub	r21,r21,r10
210865ac:	abab883a 	add	r21,r21,r14
210865b0:	003fc106 	br	210864b8 <__flash_rwdata_start+0xfffe4270>
210865b4:	7a402817 	ldw	r9,160(r15)
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
210865b8:	1253383a 	mul	r9,r2,r9
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
210865bc:	53003fcc 	andi	r12,r10,255
210865c0:	b319c83a 	sub	r12,r22,r12
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
210865c4:	4ad3883a 	add	r9,r9,r11
210865c8:	4a53883a 	add	r9,r9,r9
210865cc:	4a53883a 	add	r9,r9,r9
210865d0:	6a53883a 	add	r9,r13,r9
210865d4:	5ac00044 	addi	r11,r11,1
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
210865d8:	fb00010e 	bge	ra,r12,210865e0 <ece423_video_display_demo+0x508>
210865dc:	f819883a 	mov	r12,ra
							y_f = y + y_f;
210865e0:	6299883a 	add	r12,r12,r10
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
210865e4:	63003fcc 	andi	r12,r12,255
210865e8:	6018923a 	slli	r12,r12,8
210865ec:	51d5883a 	add	r10,r10,r7
210865f0:	4318b03a 	or	r12,r8,r12
210865f4:	4b000015 	stw	r12,0(r9)

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
				for(int ip = 0; ip < i_scale; ip++)
					for(int jp = 0; jp < j_scale; jp++){
210865f8:	32ffee1e 	bne	r6,r11,210865b4 <__flash_rwdata_start+0xfffe436c>
210865fc:	003fab06 	br	210864ac <__flash_rwdata_start+0xfffe4264>
21086600:	a815883a 	mov	r10,r21
21086604:	6013883a 	mov	r9,r12
21086608:	00000106 	br	21086610 <ece423_video_display_demo+0x538>
2108660c:	7a402817 	ldw	r9,160(r15)
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086610:	1253383a 	mul	r9,r2,r9
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
21086614:	53003fcc 	andi	r12,r10,255
21086618:	b319c83a 	sub	r12,r22,r12
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
2108661c:	4ad3883a 	add	r9,r9,r11
21086620:	4a53883a 	add	r9,r9,r9
21086624:	4a53883a 	add	r9,r9,r9
21086628:	6a53883a 	add	r9,r13,r9
2108662c:	5ac00044 	addi	r11,r11,1
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
21086630:	fb00010e 	bge	ra,r12,21086638 <ece423_video_display_demo+0x560>
21086634:	f819883a 	mov	r12,ra
							y_f = y + y_f;
21086638:	6299883a 	add	r12,r12,r10
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
2108663c:	63003fcc 	andi	r12,r12,255
21086640:	6018923a 	slli	r12,r12,8
21086644:	51d5883a 	add	r10,r10,r7
21086648:	2318b03a 	or	r12,r4,r12
2108664c:	4b000015 	stw	r12,0(r9)

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
				for(int ip = 0; ip < i_scale; ip++)
					for(int jp = 0; jp < j_scale; jp++){
21086650:	32ffee1e 	bne	r6,r11,2108660c <__flash_rwdata_start+0xfffe43c4>
21086654:	da800003 	ldbu	r10,0(sp)
21086658:	aaabc83a 	sub	r21,r21,r10
2108665c:	abab883a 	add	r21,r21,r14
21086660:	003f9506 	br	210864b8 <__flash_rwdata_start+0xfffe4270>
21086664:	da801903 	ldbu	r10,100(sp)
21086668:	003f3406 	br	2108633c <__flash_rwdata_start+0xfffe40f4>
2108666c:	d9000a03 	ldbu	r4,40(sp)
21086670:	003f2c06 	br	21086324 <__flash_rwdata_start+0xfffe40dc>
21086674:	2011883a 	mov	r8,r4
21086678:	003f3a06 	br	21086364 <__flash_rwdata_start+0xfffe411c>
2108667c:	00ffe004 	movi	r3,-128
21086680:	003eee06 	br	2108623c <__flash_rwdata_start+0xfffe3ff4>
21086684:	8005883a 	mov	r2,r16
21086688:	003ed606 	br	210861e4 <__flash_rwdata_start+0xfffe3f9c>
2108668c:	8005883a 	mov	r2,r16
21086690:	003ed106 	br	210861d8 <__flash_rwdata_start+0xfffe3f90>
21086694:	e005883a 	mov	r2,fp
21086698:	8039883a 	mov	fp,r16
2108669c:	1021883a 	mov	r16,r2

			}
			cr = 255 - f;
		}

		ece423_video_display_draw_logo(display);
210866a0:	7809883a 	mov	r4,r15
210866a4:	dbc01f15 	stw	r15,124(sp)
210866a8:	1085ee80 	call	21085ee8 <ece423_video_display_draw_logo>
	 * Note: The new buffer_being_written may NOT Yet be FREE
	 * So Call
	 * ece423_video_display_buffer_is_available
	 * to Check Before Drawing in it
	 */
	if(display->video_name)
210866ac:	dbc01f17 	ldw	r15,124(sp)
210866b0:	79402e17 	ldw	r5,184(r15)
210866b4:	28000426 	beq	r5,zero,210866c8 <ece423_video_display_demo+0x5f0>
		ece423_video_display_add_text(display, display->video_name, 10, 10, RGB_BLACK, 1);
210866b8:	7809883a 	mov	r4,r15
210866bc:	01800284 	movi	r6,10
210866c0:	108538c0 	call	2108538c <ece423_video_display_add_text.constprop.2>
210866c4:	dbc01f17 	ldw	r15,124(sp)
	display->buffer_being_written = (display->buffer_being_written + 1)
210866c8:	78802717 	ldw	r2,156(r15)
			% display->num_frame_buffers;
210866cc:	78c02c17 	ldw	r3,176(r15)
int ece423_video_display_switch_frames(ece423_video_display* display) {
	int iNext_Rd_Buf;

	alt_u32 RD_Desc_Fifo_Level;

	iNext_Rd_Buf = ((display->buffer_being_displayed + 1)
210866d0:	79002617 	ldw	r4,152(r15)
	 * ece423_video_display_buffer_is_available
	 * to Check Before Drawing in it
	 */
	if(display->video_name)
		ece423_video_display_add_text(display, display->video_name, 10, 10, RGB_BLACK, 1);
	display->buffer_being_written = (display->buffer_being_written + 1)
210866d4:	10800044 	addi	r2,r2,1
			% display->num_frame_buffers;
210866d8:	10cb283a 	div	r5,r2,r3
int ece423_video_display_switch_frames(ece423_video_display* display) {
	int iNext_Rd_Buf;

	alt_u32 RD_Desc_Fifo_Level;

	iNext_Rd_Buf = ((display->buffer_being_displayed + 1)
210866dc:	21000044 	addi	r4,r4,1
	 * to Check Before Drawing in it
	 */
	if(display->video_name)
		ece423_video_display_add_text(display, display->video_name, 10, 10, RGB_BLACK, 1);
	display->buffer_being_written = (display->buffer_being_written + 1)
			% display->num_frame_buffers;
210866e0:	28cb383a 	mul	r5,r5,r3
int ece423_video_display_switch_frames(ece423_video_display* display) {
	int iNext_Rd_Buf;

	alt_u32 RD_Desc_Fifo_Level;

	iNext_Rd_Buf = ((display->buffer_being_displayed + 1)
210866e4:	20e3283a 	div	r17,r4,r3
210866e8:	88c7383a 	mul	r3,r17,r3
	 * to Check Before Drawing in it
	 */
	if(display->video_name)
		ece423_video_display_add_text(display, display->video_name, 10, 10, RGB_BLACK, 1);
	display->buffer_being_written = (display->buffer_being_written + 1)
			% display->num_frame_buffers;
210866ec:	1145c83a 	sub	r2,r2,r5
	 * ece423_video_display_buffer_is_available
	 * to Check Before Drawing in it
	 */
	if(display->video_name)
		ece423_video_display_add_text(display, display->video_name, 10, 10, RGB_BLACK, 1);
	display->buffer_being_written = (display->buffer_being_written + 1)
210866f0:	78802715 	stw	r2,156(r15)
int ece423_video_display_switch_frames(ece423_video_display* display) {
	int iNext_Rd_Buf;

	alt_u32 RD_Desc_Fifo_Level;

	iNext_Rd_Buf = ((display->buffer_being_displayed + 1)
210866f4:	20e3c83a 	sub	r17,r4,r3
			% display->num_frame_buffers);

	// Check if there is a new buffer to display
	if ((iNext_Rd_Buf != display->buffer_being_written)) {
210866f8:	14401226 	beq	r2,r17,21086744 <ece423_video_display_demo+0x66c>
210866fc:	88800044 	addi	r2,r17,1

		// Transfer Descriptor for Frame to mSGDMA
		while (alt_msgdma_standard_descriptor_async_transfer(display->mSGDMA,
				display->buffer_ptrs[iNext_Rd_Buf]->desc_base) != 0) {
21086700:	1085883a 	add	r2,r2,r2
21086704:	1085883a 	add	r2,r2,r2
21086708:	78a5883a 	add	r18,r15,r2
2108670c:	7827883a 	mov	r19,r15

	// Check if there is a new buffer to display
	if ((iNext_Rd_Buf != display->buffer_being_written)) {

		// Transfer Descriptor for Frame to mSGDMA
		while (alt_msgdma_standard_descriptor_async_transfer(display->mSGDMA,
21086710:	90800017 	ldw	r2,0(r18)
21086714:	99000017 	ldw	r4,0(r19)
21086718:	11400017 	ldw	r5,0(r2)
2108671c:	109d1400 	call	2109d140 <alt_msgdma_standard_descriptor_async_transfer>
21086720:	103ffb1e 	bne	r2,zero,21086710 <__flash_rwdata_start+0xfffe44c8>
21086724:	98c00017 	ldw	r3,0(r19)
21086728:	981f883a 	mov	r15,r19
				display->buffer_ptrs[iNext_Rd_Buf]->desc_base) != 0) {
		}  // Keep Trying until there is room to Transfer another Frame

		// Wait if there is another frame waiting in the list
		do {
			RD_Desc_Fifo_Level = (IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(
2108672c:	18800317 	ldw	r2,12(r3)
21086730:	10800237 	ldwio	r2,8(r2)
					display->mSGDMA->csr_base)
					& ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK)
					>> ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		} while (RD_Desc_Fifo_Level > 1);
21086734:	02000044 	movi	r8,1
				display->buffer_ptrs[iNext_Rd_Buf]->desc_base) != 0) {
		}  // Keep Trying until there is room to Transfer another Frame

		// Wait if there is another frame waiting in the list
		do {
			RD_Desc_Fifo_Level = (IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(
21086738:	10bfffcc 	andi	r2,r2,65535
					display->mSGDMA->csr_base)
					& ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK)
					>> ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		} while (RD_Desc_Fifo_Level > 1);
2108673c:	40bffb36 	bltu	r8,r2,2108672c <__flash_rwdata_start+0xfffe44e4>

		display->buffer_being_displayed = iNext_Rd_Buf;
21086740:	7c402615 	stw	r17,152(r15)
21086744:	da401c03 	ldbu	r9,112(sp)
21086748:	84000784 	addi	r16,r16,30

	int i_scale = (display->height + 255) / 255;
	int j_scale = (display->width + 255) / 255;

	unsigned char y = 0;
	for (int f = 0; f < 255; f = f + 3) {
2108674c:	00c27d84 	movi	r3,2550
21086750:	48bfff44 	addi	r2,r9,-3
21086754:	e73ff884 	addi	fp,fp,-30
21086758:	80c00326 	beq	r16,r3,21086768 <ece423_video_display_demo+0x690>
2108675c:	79002917 	ldw	r4,164(r15)
21086760:	d8801c05 	stb	r2,112(sp)
21086764:	003e8606 	br	21086180 <__flash_rwdata_start+0xfffe3f38>
		ece423_video_display_draw_logo(display);
		ece423_video_display_register_written_buffer(display);
		ece423_video_display_switch_frames(display);
	}

}
21086768:	dfc02b17 	ldw	ra,172(sp)
2108676c:	df002a17 	ldw	fp,168(sp)
21086770:	ddc02917 	ldw	r23,164(sp)
21086774:	dd802817 	ldw	r22,160(sp)
21086778:	dd402717 	ldw	r21,156(sp)
2108677c:	dd002617 	ldw	r20,152(sp)
21086780:	dcc02517 	ldw	r19,148(sp)
21086784:	dc802417 	ldw	r18,144(sp)
21086788:	dc402317 	ldw	r17,140(sp)
2108678c:	dc002217 	ldw	r16,136(sp)
21086790:	dec02c04 	addi	sp,sp,176
21086794:	f800283a 	ret
21086798:	98003316 	blt	r19,zero,21086868 <ece423_video_display_demo+0x790>

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
				for(int ip = 0; ip < i_scale; ip++)
					for(int jp = 0; jp < j_scale; jp++){
2108679c:	d9000515 	stw	r4,20(sp)
210867a0:	6013883a 	mov	r9,r12
210867a4:	8817883a 	mov	r11,r17
210867a8:	1819883a 	mov	r12,r3
210867ac:	1007883a 	mov	r3,r2
210867b0:	a805883a 	mov	r2,r21
210867b4:	bf001416 	blt	r23,fp,21086808 <ece423_video_display_demo+0x730>
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
210867b8:	1a53383a 	mul	r9,r3,r9
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
210867bc:	12803fcc 	andi	r10,r2,255
210867c0:	b295c83a 	sub	r10,r22,r10
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
210867c4:	4ad3883a 	add	r9,r9,r11
210867c8:	4a53883a 	add	r9,r9,r9
210867cc:	4a53883a 	add	r9,r9,r9
210867d0:	6a53883a 	add	r9,r13,r9
210867d4:	5ac00044 	addi	r11,r11,1
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
210867d8:	fa80010e 	bge	ra,r10,210867e0 <ece423_video_display_demo+0x708>
210867dc:	f815883a 	mov	r10,ra
							y_f = y + y_f;
210867e0:	5095883a 	add	r10,r10,r2
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
210867e4:	52803fcc 	andi	r10,r10,255
210867e8:	5014923a 	slli	r10,r10,8
210867ec:	d9000417 	ldw	r4,16(sp)
210867f0:	11c5883a 	add	r2,r2,r7
210867f4:	2294b03a 	or	r10,r4,r10
210867f8:	4a800015 	stw	r10,0(r9)

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
				for(int ip = 0; ip < i_scale; ip++)
					for(int jp = 0; jp < j_scale; jp++){
210867fc:	32c01626 	beq	r6,r11,21086858 <ece423_video_display_demo+0x780>
21086800:	7a402817 	ldw	r9,160(r15)
21086804:	003fec06 	br	210867b8 <__flash_rwdata_start+0xfffe4570>
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086808:	1a53383a 	mul	r9,r3,r9
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
2108680c:	12803fcc 	andi	r10,r2,255
21086810:	b295c83a 	sub	r10,r22,r10
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086814:	4ad3883a 	add	r9,r9,r11
21086818:	4a53883a 	add	r9,r9,r9
2108681c:	4a53883a 	add	r9,r9,r9
21086820:	6a53883a 	add	r9,r13,r9
21086824:	5ac00044 	addi	r11,r11,1
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
21086828:	fa80010e 	bge	ra,r10,21086830 <ece423_video_display_demo+0x758>
2108682c:	f815883a 	mov	r10,ra
							y_f = y + y_f;
21086830:	5095883a 	add	r10,r10,r2
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086834:	52803fcc 	andi	r10,r10,255
21086838:	5014923a 	slli	r10,r10,8
2108683c:	d9000417 	ldw	r4,16(sp)
21086840:	11c5883a 	add	r2,r2,r7
21086844:	2294b03a 	or	r10,r4,r10
21086848:	4a800015 	stw	r10,0(r9)

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
				for(int ip = 0; ip < i_scale; ip++)
					for(int jp = 0; jp < j_scale; jp++){
2108684c:	32c00226 	beq	r6,r11,21086858 <ece423_video_display_demo+0x780>
21086850:	7a402817 	ldw	r9,160(r15)
21086854:	003fec06 	br	21086808 <__flash_rwdata_start+0xfffe45c0>
21086858:	1805883a 	mov	r2,r3
2108685c:	d9000517 	ldw	r4,20(sp)
21086860:	6007883a 	mov	r3,r12
21086864:	003f1106 	br	210864ac <__flash_rwdata_start+0xfffe4264>
21086868:	da400117 	ldw	r9,4(sp)
2108686c:	8817883a 	mov	r11,r17
21086870:	48001916 	blt	r9,zero,210868d8 <ece423_video_display_demo+0x800>
21086874:	6013883a 	mov	r9,r12
21086878:	d9000515 	stw	r4,20(sp)
2108687c:	1819883a 	mov	r12,r3
21086880:	1007883a 	mov	r3,r2
21086884:	a805883a 	mov	r2,r21
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086888:	1a53383a 	mul	r9,r3,r9
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
2108688c:	12803fcc 	andi	r10,r2,255
21086890:	b295c83a 	sub	r10,r22,r10
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086894:	4ad3883a 	add	r9,r9,r11
21086898:	4a53883a 	add	r9,r9,r9
2108689c:	4a53883a 	add	r9,r9,r9
210868a0:	6a53883a 	add	r9,r13,r9
210868a4:	5ac00044 	addi	r11,r11,1
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
210868a8:	fa80010e 	bge	ra,r10,210868b0 <ece423_video_display_demo+0x7d8>
210868ac:	f815883a 	mov	r10,ra
							y_f = y + y_f;
210868b0:	5095883a 	add	r10,r10,r2
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
210868b4:	52803fcc 	andi	r10,r10,255
210868b8:	5014923a 	slli	r10,r10,8
210868bc:	d9000717 	ldw	r4,28(sp)
210868c0:	11c5883a 	add	r2,r2,r7
210868c4:	2294b03a 	or	r10,r4,r10
210868c8:	4a800015 	stw	r10,0(r9)

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
				for(int ip = 0; ip < i_scale; ip++)
					for(int jp = 0; jp < j_scale; jp++){
210868cc:	32ffe226 	beq	r6,r11,21086858 <__flash_rwdata_start+0xfffe4610>
210868d0:	7a402817 	ldw	r9,160(r15)
210868d4:	003fec06 	br	21086888 <__flash_rwdata_start+0xfffe4640>
210868d8:	6013883a 	mov	r9,r12
210868dc:	d9000515 	stw	r4,20(sp)
210868e0:	1819883a 	mov	r12,r3
210868e4:	1007883a 	mov	r3,r2
210868e8:	a805883a 	mov	r2,r21
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
210868ec:	1a53383a 	mul	r9,r3,r9
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
210868f0:	12803fcc 	andi	r10,r2,255
210868f4:	b295c83a 	sub	r10,r22,r10
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
210868f8:	4ad3883a 	add	r9,r9,r11
210868fc:	4a53883a 	add	r9,r9,r9
21086900:	4a53883a 	add	r9,r9,r9
21086904:	6a53883a 	add	r9,r13,r9
21086908:	5ac00044 	addi	r11,r11,1
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
2108690c:	fa80010e 	bge	ra,r10,21086914 <ece423_video_display_demo+0x83c>
21086910:	f815883a 	mov	r10,ra
							y_f = y + y_f;
21086914:	5095883a 	add	r10,r10,r2
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086918:	52803fcc 	andi	r10,r10,255
2108691c:	5014923a 	slli	r10,r10,8
21086920:	d9000617 	ldw	r4,24(sp)
21086924:	11c5883a 	add	r2,r2,r7
21086928:	2294b03a 	or	r10,r4,r10
2108692c:	4a800015 	stw	r10,0(r9)

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
				for(int ip = 0; ip < i_scale; ip++)
					for(int jp = 0; jp < j_scale; jp++){
21086930:	32ffc926 	beq	r6,r11,21086858 <__flash_rwdata_start+0xfffe4610>
21086934:	7a402817 	ldw	r9,160(r15)
21086938:	003fec06 	br	210868ec <__flash_rwdata_start+0xfffe46a4>
2108693c:	98001316 	blt	r19,zero,2108698c <ece423_video_display_demo+0x8b4>
21086940:	bc003e0e 	bge	r23,r16,21086a3c <ece423_video_display_demo+0x964>
21086944:	02403f84 	movi	r9,254
21086948:	8817883a 	mov	r11,r17
2108694c:	a815883a 	mov	r10,r21
21086950:	4c00260e 	bge	r9,r16,210869ec <ece423_video_display_demo+0x914>
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086954:	1313383a 	mul	r9,r2,r12
21086958:	53003fcc 	andi	r12,r10,255
2108695c:	6018923a 	slli	r12,r12,8
21086960:	4ad3883a 	add	r9,r9,r11
21086964:	4a53883a 	add	r9,r9,r9
21086968:	4a53883a 	add	r9,r9,r9
2108696c:	6a53883a 	add	r9,r13,r9
21086970:	4318b03a 	or	r12,r8,r12
21086974:	4b000015 	stw	r12,0(r9)
21086978:	5ac00044 	addi	r11,r11,1
2108697c:	51d5883a 	add	r10,r10,r7

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
				for(int ip = 0; ip < i_scale; ip++)
					for(int jp = 0; jp < j_scale; jp++){
21086980:	32ff0826 	beq	r6,r11,210865a4 <__flash_rwdata_start+0xfffe435c>
21086984:	7b002817 	ldw	r12,160(r15)
21086988:	003ff206 	br	21086954 <__flash_rwdata_start+0xfffe470c>
2108698c:	bc008b0e 	bge	r23,r16,21086bbc <ece423_video_display_demo+0xae4>
21086990:	da800317 	ldw	r10,12(sp)
21086994:	da401117 	ldw	r9,68(sp)
21086998:	8817883a 	mov	r11,r17
2108699c:	5240740e 	bge	r10,r9,21086b70 <ece423_video_display_demo+0xa98>
210869a0:	02403f84 	movi	r9,254
210869a4:	a815883a 	mov	r10,r21
210869a8:	4c005b0e 	bge	r9,r16,21086b18 <ece423_video_display_demo+0xa40>
210869ac:	d8c00515 	stw	r3,20(sp)
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
210869b0:	1313383a 	mul	r9,r2,r12
210869b4:	53003fcc 	andi	r12,r10,255
210869b8:	6018923a 	slli	r12,r12,8
210869bc:	4ad3883a 	add	r9,r9,r11
210869c0:	d8c01017 	ldw	r3,64(sp)
210869c4:	4a53883a 	add	r9,r9,r9
210869c8:	4a53883a 	add	r9,r9,r9
210869cc:	6a53883a 	add	r9,r13,r9
210869d0:	1b18b03a 	or	r12,r3,r12
210869d4:	4b000015 	stw	r12,0(r9)
210869d8:	5ac00044 	addi	r11,r11,1
210869dc:	51d5883a 	add	r10,r10,r7

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
				for(int ip = 0; ip < i_scale; ip++)
					for(int jp = 0; jp < j_scale; jp++){
210869e0:	59804b26 	beq	r11,r6,21086b10 <ece423_video_display_demo+0xa38>
210869e4:	7b002817 	ldw	r12,160(r15)
210869e8:	003ff106 	br	210869b0 <__flash_rwdata_start+0xfffe4768>
210869ec:	6013883a 	mov	r9,r12
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
210869f0:	53003fcc 	andi	r12,r10,255
210869f4:	b319c83a 	sub	r12,r22,r12
210869f8:	fb00010e 	bge	ra,r12,21086a00 <ece423_video_display_demo+0x928>
210869fc:	f819883a 	mov	r12,ra
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086a00:	1253383a 	mul	r9,r2,r9
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
							y_f = y + y_f;
21086a04:	6299883a 	add	r12,r12,r10
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086a08:	63003fcc 	andi	r12,r12,255
21086a0c:	4ad3883a 	add	r9,r9,r11
21086a10:	6018923a 	slli	r12,r12,8
21086a14:	4a53883a 	add	r9,r9,r9
21086a18:	4a53883a 	add	r9,r9,r9
21086a1c:	6a53883a 	add	r9,r13,r9
21086a20:	4318b03a 	or	r12,r8,r12
21086a24:	4b000015 	stw	r12,0(r9)
21086a28:	5ac00044 	addi	r11,r11,1
21086a2c:	51d5883a 	add	r10,r10,r7

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
				for(int ip = 0; ip < i_scale; ip++)
					for(int jp = 0; jp < j_scale; jp++){
21086a30:	32fedc26 	beq	r6,r11,210865a4 <__flash_rwdata_start+0xfffe435c>
21086a34:	7a402817 	ldw	r9,160(r15)
21086a38:	003fed06 	br	210869f0 <__flash_rwdata_start+0xfffe47a8>
21086a3c:	da400117 	ldw	r9,4(sp)
21086a40:	8817883a 	mov	r11,r17
21086a44:	48001916 	blt	r9,zero,21086aac <ece423_video_display_demo+0x9d4>
21086a48:	6013883a 	mov	r9,r12
21086a4c:	d9000515 	stw	r4,20(sp)
21086a50:	1819883a 	mov	r12,r3
21086a54:	1007883a 	mov	r3,r2
21086a58:	a805883a 	mov	r2,r21
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086a5c:	1a53383a 	mul	r9,r3,r9
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
21086a60:	12803fcc 	andi	r10,r2,255
21086a64:	b295c83a 	sub	r10,r22,r10
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086a68:	4ad3883a 	add	r9,r9,r11
21086a6c:	4a53883a 	add	r9,r9,r9
21086a70:	4a53883a 	add	r9,r9,r9
21086a74:	6a53883a 	add	r9,r13,r9
21086a78:	5ac00044 	addi	r11,r11,1
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
21086a7c:	fa80010e 	bge	ra,r10,21086a84 <ece423_video_display_demo+0x9ac>
21086a80:	f815883a 	mov	r10,ra
							y_f = y + y_f;
21086a84:	5095883a 	add	r10,r10,r2
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086a88:	52803fcc 	andi	r10,r10,255
21086a8c:	5014923a 	slli	r10,r10,8
21086a90:	d9001817 	ldw	r4,96(sp)
21086a94:	11c5883a 	add	r2,r2,r7
21086a98:	2294b03a 	or	r10,r4,r10
21086a9c:	4a800015 	stw	r10,0(r9)

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
				for(int ip = 0; ip < i_scale; ip++)
					for(int jp = 0; jp < j_scale; jp++){
21086aa0:	32ff6d26 	beq	r6,r11,21086858 <__flash_rwdata_start+0xfffe4610>
21086aa4:	7a402817 	ldw	r9,160(r15)
21086aa8:	003fec06 	br	21086a5c <__flash_rwdata_start+0xfffe4814>
21086aac:	6013883a 	mov	r9,r12
21086ab0:	d9000515 	stw	r4,20(sp)
21086ab4:	1819883a 	mov	r12,r3
21086ab8:	1007883a 	mov	r3,r2
21086abc:	a805883a 	mov	r2,r21
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086ac0:	1a53383a 	mul	r9,r3,r9
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
21086ac4:	12803fcc 	andi	r10,r2,255
21086ac8:	b295c83a 	sub	r10,r22,r10
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086acc:	4ad3883a 	add	r9,r9,r11
21086ad0:	4a53883a 	add	r9,r9,r9
21086ad4:	4a53883a 	add	r9,r9,r9
21086ad8:	6a53883a 	add	r9,r13,r9
21086adc:	5ac00044 	addi	r11,r11,1
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
21086ae0:	fa80010e 	bge	ra,r10,21086ae8 <ece423_video_display_demo+0xa10>
21086ae4:	f815883a 	mov	r10,ra
							y_f = y + y_f;
21086ae8:	5095883a 	add	r10,r10,r2
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086aec:	52803fcc 	andi	r10,r10,255
21086af0:	5014923a 	slli	r10,r10,8
21086af4:	d9001717 	ldw	r4,92(sp)
21086af8:	11c5883a 	add	r2,r2,r7
21086afc:	2294b03a 	or	r10,r4,r10
21086b00:	4a800015 	stw	r10,0(r9)

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
				for(int ip = 0; ip < i_scale; ip++)
					for(int jp = 0; jp < j_scale; jp++){
21086b04:	32ff5426 	beq	r6,r11,21086858 <__flash_rwdata_start+0xfffe4610>
21086b08:	7a402817 	ldw	r9,160(r15)
21086b0c:	003fec06 	br	21086ac0 <__flash_rwdata_start+0xfffe4878>
21086b10:	d8c00517 	ldw	r3,20(sp)
21086b14:	003e6506 	br	210864ac <__flash_rwdata_start+0xfffe4264>
21086b18:	6013883a 	mov	r9,r12
21086b1c:	d8c00515 	stw	r3,20(sp)
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
21086b20:	53003fcc 	andi	r12,r10,255
21086b24:	b319c83a 	sub	r12,r22,r12
21086b28:	fb00010e 	bge	ra,r12,21086b30 <ece423_video_display_demo+0xa58>
21086b2c:	f819883a 	mov	r12,ra
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086b30:	1253383a 	mul	r9,r2,r9
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
							y_f = y + y_f;
21086b34:	6299883a 	add	r12,r12,r10
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086b38:	63003fcc 	andi	r12,r12,255
21086b3c:	4ad3883a 	add	r9,r9,r11
21086b40:	6018923a 	slli	r12,r12,8
21086b44:	d8c01017 	ldw	r3,64(sp)
21086b48:	4a53883a 	add	r9,r9,r9
21086b4c:	4a53883a 	add	r9,r9,r9
21086b50:	6a53883a 	add	r9,r13,r9
21086b54:	1b18b03a 	or	r12,r3,r12
21086b58:	4b000015 	stw	r12,0(r9)
21086b5c:	5ac00044 	addi	r11,r11,1
21086b60:	51d5883a 	add	r10,r10,r7

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
				for(int ip = 0; ip < i_scale; ip++)
					for(int jp = 0; jp < j_scale; jp++){
21086b64:	59bfea26 	beq	r11,r6,21086b10 <__flash_rwdata_start+0xfffe48c8>
21086b68:	7a402817 	ldw	r9,160(r15)
21086b6c:	003fec06 	br	21086b20 <__flash_rwdata_start+0xfffe48d8>
21086b70:	02403f84 	movi	r9,254
21086b74:	a815883a 	mov	r10,r21
21086b78:	4c00280e 	bge	r9,r16,21086c1c <ece423_video_display_demo+0xb44>
21086b7c:	d8c00515 	stw	r3,20(sp)
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086b80:	1313383a 	mul	r9,r2,r12
21086b84:	53003fcc 	andi	r12,r10,255
21086b88:	6018923a 	slli	r12,r12,8
21086b8c:	4ad3883a 	add	r9,r9,r11
21086b90:	d8c00f17 	ldw	r3,60(sp)
21086b94:	4a53883a 	add	r9,r9,r9
21086b98:	4a53883a 	add	r9,r9,r9
21086b9c:	6a53883a 	add	r9,r13,r9
21086ba0:	1b18b03a 	or	r12,r3,r12
21086ba4:	4b000015 	stw	r12,0(r9)
21086ba8:	5ac00044 	addi	r11,r11,1
21086bac:	51d5883a 	add	r10,r10,r7

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
				for(int ip = 0; ip < i_scale; ip++)
					for(int jp = 0; jp < j_scale; jp++){
21086bb0:	32ffd726 	beq	r6,r11,21086b10 <__flash_rwdata_start+0xfffe48c8>
21086bb4:	7b002817 	ldw	r12,160(r15)
21086bb8:	003ff106 	br	21086b80 <__flash_rwdata_start+0xfffe4938>
21086bbc:	6013883a 	mov	r9,r12
21086bc0:	8817883a 	mov	r11,r17
21086bc4:	1819883a 	mov	r12,r3
21086bc8:	1007883a 	mov	r3,r2
21086bcc:	a805883a 	mov	r2,r21
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086bd0:	1a53383a 	mul	r9,r3,r9
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
21086bd4:	12803fcc 	andi	r10,r2,255
21086bd8:	b295c83a 	sub	r10,r22,r10
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086bdc:	4ad3883a 	add	r9,r9,r11
21086be0:	4a53883a 	add	r9,r9,r9
21086be4:	4a53883a 	add	r9,r9,r9
21086be8:	6a53883a 	add	r9,r13,r9
21086bec:	5ac00044 	addi	r11,r11,1
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
21086bf0:	fa80010e 	bge	ra,r10,21086bf8 <ece423_video_display_demo+0xb20>
21086bf4:	f815883a 	mov	r10,ra
							y_f = y + y_f;
21086bf8:	5095883a 	add	r10,r10,r2
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086bfc:	52803fcc 	andi	r10,r10,255
21086c00:	5014923a 	slli	r10,r10,8
21086c04:	11c5883a 	add	r2,r2,r7
21086c08:	2a94b03a 	or	r10,r5,r10
21086c0c:	4a800015 	stw	r10,0(r9)

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
				for(int ip = 0; ip < i_scale; ip++)
					for(int jp = 0; jp < j_scale; jp++){
21086c10:	32c01826 	beq	r6,r11,21086c74 <ece423_video_display_demo+0xb9c>
21086c14:	7a402817 	ldw	r9,160(r15)
21086c18:	003fed06 	br	21086bd0 <__flash_rwdata_start+0xfffe4988>
21086c1c:	6013883a 	mov	r9,r12
21086c20:	d8c00515 	stw	r3,20(sp)
						unsigned char y_f =y, cr_f = cr, cb_f = cb;
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
21086c24:	53003fcc 	andi	r12,r10,255
21086c28:	b319c83a 	sub	r12,r22,r12
21086c2c:	fb00010e 	bge	ra,r12,21086c34 <ece423_video_display_demo+0xb5c>
21086c30:	f819883a 	mov	r12,ra
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086c34:	1253383a 	mul	r9,r2,r9
						int m = 10;

						int f_y = m*f < 255? m*f : m*(254 - f) < 255 ? m*(254 - f) : -1;
						if (f_y >= 0) {
							y_f = 0xFF - y < 0xFF-f_y? 0xFF - y : 0xFF-f_y;
							y_f = y + y_f;
21086c38:	6299883a 	add	r12,r12,r10
								cr_f = 128 - cr < 128 - f_c? 128 - cr : 128 - f_c;
								cr_f = cr + cr_f;
							}
						}

						frame[ (i + ip) * display->width + (j + jp) ] = (cr_f << 16) | (y_f << 8) | (cb_f);
21086c3c:	63003fcc 	andi	r12,r12,255
21086c40:	4ad3883a 	add	r9,r9,r11
21086c44:	6018923a 	slli	r12,r12,8
21086c48:	d8c00f17 	ldw	r3,60(sp)
21086c4c:	4a53883a 	add	r9,r9,r9
21086c50:	4a53883a 	add	r9,r9,r9
21086c54:	6a53883a 	add	r9,r13,r9
21086c58:	1b18b03a 	or	r12,r3,r12
21086c5c:	4b000015 	stw	r12,0(r9)
21086c60:	5ac00044 	addi	r11,r11,1
21086c64:	51d5883a 	add	r10,r10,r7

		for(int i = 0; i < display->height; i = i + i_scale) {
			unsigned char cb = 0;
			for(int j = 0; j < display->width; j = j + j_scale) {
				for(int ip = 0; ip < i_scale; ip++)
					for(int jp = 0; jp < j_scale; jp++){
21086c68:	32ffa926 	beq	r6,r11,21086b10 <__flash_rwdata_start+0xfffe48c8>
21086c6c:	7a402817 	ldw	r9,160(r15)
21086c70:	003fec06 	br	21086c24 <__flash_rwdata_start+0xfffe49dc>
21086c74:	da800003 	ldbu	r10,0(sp)
21086c78:	1805883a 	mov	r2,r3
21086c7c:	6007883a 	mov	r3,r12
21086c80:	aaabc83a 	sub	r21,r21,r10
21086c84:	abab883a 	add	r21,r21,r14
21086c88:	003e0b06 	br	210864b8 <__flash_rwdata_start+0xfffe4270>

21086c8c <ece423_video_display_add_text>:
 *  Purpose: Add a string to the screen
 *
 ******************************************************************/
void ece423_video_display_add_text(ece423_video_display* display, char* text, int x, int y, uint rgb_color, int scale) {

	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
21086c8c:	20802717 	ldw	r2,156(r4)
 *  Function: ece423_video_display_add_text
 *
 *  Purpose: Add a string to the screen
 *
 ******************************************************************/
void ece423_video_display_add_text(ece423_video_display* display, char* text, int x, int y, uint rgb_color, int scale) {
21086c90:	deffea04 	addi	sp,sp,-88
21086c94:	dc400d15 	stw	r17,52(sp)

	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
21086c98:	10800044 	addi	r2,r2,1
21086c9c:	1085883a 	add	r2,r2,r2
 *  Function: ece423_video_display_add_text
 *
 *  Purpose: Add a string to the screen
 *
 ******************************************************************/
void ece423_video_display_add_text(ece423_video_display* display, char* text, int x, int y, uint rgb_color, int scale) {
21086ca0:	2023883a 	mov	r17,r4

	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
21086ca4:	1085883a 	add	r2,r2,r2
21086ca8:	8885883a 	add	r2,r17,r2
21086cac:	10800017 	ldw	r2,0(r2)
	b = rgb & 0xff;
	g = (rgb >> 8) & 0xff;
	r = (rgb >> 16) & 0xff;

	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
21086cb0:	d9001683 	ldbu	r4,90(sp)
 *  Function: ece423_video_display_add_text
 *
 *  Purpose: Add a string to the screen
 *
 ******************************************************************/
void ece423_video_display_add_text(ece423_video_display* display, char* text, int x, int y, uint rgb_color, int scale) {
21086cb4:	dd001015 	stw	r20,64(sp)

uint rgb2ycbcr(uint rgb) {
	unsigned char r, g, b;
	b = rgb & 0xff;
	g = (rgb >> 8) & 0xff;
	r = (rgb >> 16) & 0xff;
21086cb8:	dd001617 	ldw	r20,88(sp)
 *  Function: ece423_video_display_add_text
 *
 *  Purpose: Add a string to the screen
 *
 ******************************************************************/
void ece423_video_display_add_text(ece423_video_display* display, char* text, int x, int y, uint rgb_color, int scale) {
21086cbc:	dfc01515 	stw	ra,84(sp)
21086cc0:	d9c00715 	stw	r7,28(sp)
21086cc4:	d9400615 	stw	r5,24(sp)
21086cc8:	df001415 	stw	fp,80(sp)
21086ccc:	ddc01315 	stw	r23,76(sp)
21086cd0:	dd801215 	stw	r22,72(sp)
21086cd4:	dd401115 	stw	r21,68(sp)
21086cd8:	dcc00f15 	stw	r19,60(sp)
21086cdc:	dc800e15 	stw	r18,56(sp)
21086ce0:	dc000c15 	stw	r16,48(sp)

	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
21086ce4:	14800117 	ldw	r18,4(r2)
 *  Function: ece423_video_display_add_text
 *
 *  Purpose: Add a string to the screen
 *
 ******************************************************************/
void ece423_video_display_add_text(ece423_video_display* display, char* text, int x, int y, uint rgb_color, int scale) {
21086ce8:	3021883a 	mov	r16,r6
	b = rgb & 0xff;
	g = (rgb >> 8) & 0xff;
	r = (rgb >> 16) & 0xff;

	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
21086cec:	108cfdc0 	call	2108cfdc <__floatsidf>
}

uint rgb2ycbcr(uint rgb) {
	unsigned char r, g, b;
	b = rgb & 0xff;
	g = (rgb >> 8) & 0xff;
21086cf0:	a008d23a 	srli	r4,r20,8
	r = (rgb >> 16) & 0xff;

	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
21086cf4:	1827883a 	mov	r19,r3
21086cf8:	d8800015 	stw	r2,0(sp)
21086cfc:	21003fcc 	andi	r4,r4,255
	uint color = rgb2ycbcr(rgb_color);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {
21086d00:	d8000515 	stw	zero,20(sp)
	b = rgb & 0xff;
	g = (rgb >> 8) & 0xff;
	r = (rgb >> 16) & 0xff;

	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
21086d04:	108cfdc0 	call	2108cfdc <__floatsidf>
21086d08:	a1003fcc 	andi	r4,r20,255
21086d0c:	d8800115 	stw	r2,4(sp)
21086d10:	d8c00215 	stw	r3,8(sp)
21086d14:	108cfdc0 	call	2108cfdc <__floatsidf>
 *  Function: ece423_video_display_add_text
 *
 *  Purpose: Add a string to the screen
 *
 ******************************************************************/
void ece423_video_display_add_text(ece423_video_display* display, char* text, int x, int y, uint rgb_color, int scale) {
21086d18:	dd801717 	ldw	r22,92(sp)
	b = rgb & 0xff;
	g = (rgb >> 8) & 0xff;
	r = (rgb >> 16) & 0xff;

	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
21086d1c:	d8800315 	stw	r2,12(sp)
21086d20:	d8800717 	ldw	r2,28(sp)
	cb = -0.168736 * r - 0.331264 * g + 0.5 * b + 128;
21086d24:	d9000017 	ldw	r4,0(sp)
21086d28:	018a3534 	movhi	r6,10452
21086d2c:	01eff1b4 	movhi	r7,49094
21086d30:	980b883a 	mov	r5,r19
21086d34:	318d2804 	addi	r6,r6,13472
21086d38:	39e64904 	addi	r7,r7,-26332
21086d3c:	b085883a 	add	r2,r22,r2
	b = rgb & 0xff;
	g = (rgb >> 8) & 0xff;
	r = (rgb >> 16) & 0xff;

	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
21086d40:	d8c00415 	stw	r3,16(sp)
21086d44:	d8800815 	stw	r2,32(sp)
	cb = -0.168736 * r - 0.331264 * g + 0.5 * b + 128;
21086d48:	108bf600 	call	2108bf60 <__muldf3>
21086d4c:	d9000117 	ldw	r4,4(sp)
21086d50:	d9400217 	ldw	r5,8(sp)
21086d54:	01bae5b4 	movhi	r6,60310
21086d58:	01cff574 	movhi	r7,16341
21086d5c:	31b96c04 	addi	r6,r6,-6736
21086d60:	39ccdb44 	addi	r7,r7,13165
21086d64:	1039883a 	mov	fp,r2
21086d68:	182b883a 	mov	r21,r3
21086d6c:	108bf600 	call	2108bf60 <__muldf3>
21086d70:	e009883a 	mov	r4,fp
21086d74:	a80b883a 	mov	r5,r21
21086d78:	100d883a 	mov	r6,r2
21086d7c:	180f883a 	mov	r7,r3
21086d80:	108c6840 	call	2108c684 <__subdf3>
21086d84:	d9000317 	ldw	r4,12(sp)
21086d88:	d9400417 	ldw	r5,16(sp)
21086d8c:	000d883a 	mov	r6,zero
21086d90:	01cff834 	movhi	r7,16352
21086d94:	1039883a 	mov	fp,r2
21086d98:	182b883a 	mov	r21,r3
21086d9c:	108bf600 	call	2108bf60 <__muldf3>
21086da0:	e009883a 	mov	r4,fp
21086da4:	a80b883a 	mov	r5,r21
21086da8:	100d883a 	mov	r6,r2
21086dac:	180f883a 	mov	r7,r3
21086db0:	108ad180 	call	2108ad18 <__adddf3>
21086db4:	000d883a 	mov	r6,zero
21086db8:	01d01834 	movhi	r7,16480
21086dbc:	1009883a 	mov	r4,r2
21086dc0:	180b883a 	mov	r5,r3
21086dc4:	108ad180 	call	2108ad18 <__adddf3>
21086dc8:	180b883a 	mov	r5,r3
21086dcc:	1009883a 	mov	r4,r2
21086dd0:	108a3200 	call	2108a320 <__fixunsdfsi>
	b = rgb & 0xff;
	g = (rgb >> 8) & 0xff;
	r = (rgb >> 16) & 0xff;

	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
21086dd4:	d9000017 	ldw	r4,0(sp)
21086dd8:	01b95834 	movhi	r6,58720
21086ddc:	01cff4f4 	movhi	r7,16339
	cb = -0.168736 * r - 0.331264 * g + 0.5 * b + 128;
	cr = 0.5 * r - 0.418688 * g - 0.081312 * b + 128;

	uint ycbcr = (cr << 16) | (y << 8) | (cb);
21086de0:	12803fcc 	andi	r10,r2,255
	b = rgb & 0xff;
	g = (rgb >> 8) & 0xff;
	r = (rgb >> 16) & 0xff;

	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
21086de4:	980b883a 	mov	r5,r19
21086de8:	31906244 	addi	r6,r6,16777
21086dec:	39c8b404 	addi	r7,r7,8912
21086df0:	da800b15 	stw	r10,44(sp)
21086df4:	108bf600 	call	2108bf60 <__muldf3>
21086df8:	d9000117 	ldw	r4,4(sp)
21086dfc:	d9400217 	ldw	r5,8(sp)
21086e00:	018e5634 	movhi	r6,14680
21086e04:	01cff8f4 	movhi	r7,16355
21086e08:	31841884 	addi	r6,r6,4194
21086e0c:	39f22d04 	addi	r7,r7,-14156
21086e10:	d8c00a15 	stw	r3,40(sp)
21086e14:	d8800915 	stw	r2,36(sp)
21086e18:	108bf600 	call	2108bf60 <__muldf3>
21086e1c:	da000a17 	ldw	r8,40(sp)
21086e20:	da400917 	ldw	r9,36(sp)
21086e24:	100d883a 	mov	r6,r2
21086e28:	400b883a 	mov	r5,r8
21086e2c:	4809883a 	mov	r4,r9
21086e30:	180f883a 	mov	r7,r3
21086e34:	108ad180 	call	2108ad18 <__adddf3>
21086e38:	d9000317 	ldw	r4,12(sp)
21086e3c:	d9400417 	ldw	r5,16(sp)
21086e40:	01a7efb4 	movhi	r6,40894
21086e44:	01cfef74 	movhi	r7,16317
21086e48:	319db244 	addi	r6,r6,30409
21086e4c:	39cbc684 	addi	r7,r7,12058
21086e50:	d8c00a15 	stw	r3,40(sp)
21086e54:	d8800915 	stw	r2,36(sp)
21086e58:	108bf600 	call	2108bf60 <__muldf3>
21086e5c:	da400917 	ldw	r9,36(sp)
21086e60:	da000a17 	ldw	r8,40(sp)
21086e64:	100d883a 	mov	r6,r2
21086e68:	4809883a 	mov	r4,r9
21086e6c:	400b883a 	mov	r5,r8
21086e70:	180f883a 	mov	r7,r3
21086e74:	108ad180 	call	2108ad18 <__adddf3>
21086e78:	180b883a 	mov	r5,r3
21086e7c:	1009883a 	mov	r4,r2
21086e80:	108a3200 	call	2108a320 <__fixunsdfsi>
	cb = -0.168736 * r - 0.331264 * g + 0.5 * b + 128;
	cr = 0.5 * r - 0.418688 * g - 0.081312 * b + 128;

	uint ycbcr = (cr << 16) | (y << 8) | (cb);
21086e84:	10803fcc 	andi	r2,r2,255
21086e88:	da800b17 	ldw	r10,44(sp)
21086e8c:	1004923a 	slli	r2,r2,8
	r = (rgb >> 16) & 0xff;

	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
	cb = -0.168736 * r - 0.331264 * g + 0.5 * b + 128;
	cr = 0.5 * r - 0.418688 * g - 0.081312 * b + 128;
21086e90:	d9000017 	ldw	r4,0(sp)
21086e94:	980b883a 	mov	r5,r19
21086e98:	000d883a 	mov	r6,zero
21086e9c:	01cff834 	movhi	r7,16352
21086ea0:	50a6b03a 	or	r19,r10,r2
21086ea4:	108bf600 	call	2108bf60 <__muldf3>
21086ea8:	d9000117 	ldw	r4,4(sp)
21086eac:	d9400217 	ldw	r5,8(sp)
21086eb0:	01b033f4 	movhi	r6,49359
21086eb4:	01cff6f4 	movhi	r7,16347
21086eb8:	31a47244 	addi	r6,r6,-28215
21086ebc:	39f2f204 	addi	r7,r7,-13368
21086ec0:	d8800a15 	stw	r2,40(sp)
21086ec4:	d8c00915 	stw	r3,36(sp)
21086ec8:	108bf600 	call	2108bf60 <__muldf3>
21086ecc:	da000a17 	ldw	r8,40(sp)
21086ed0:	da400917 	ldw	r9,36(sp)
21086ed4:	100d883a 	mov	r6,r2
21086ed8:	4009883a 	mov	r4,r8
21086edc:	480b883a 	mov	r5,r9
21086ee0:	180f883a 	mov	r7,r3
21086ee4:	108c6840 	call	2108c684 <__subdf3>
21086ee8:	d9400417 	ldw	r5,16(sp)
21086eec:	d9000317 	ldw	r4,12(sp)
21086ef0:	01bf31b4 	movhi	r6,64710
21086ef4:	01cfed74 	movhi	r7,16309
21086ef8:	31ae3704 	addi	r6,r6,-18212
21086efc:	39f43704 	addi	r7,r7,-12068
21086f00:	d8c00a15 	stw	r3,40(sp)
21086f04:	d8800915 	stw	r2,36(sp)
21086f08:	108bf600 	call	2108bf60 <__muldf3>
21086f0c:	da400917 	ldw	r9,36(sp)
21086f10:	da000a17 	ldw	r8,40(sp)
21086f14:	100d883a 	mov	r6,r2
21086f18:	4809883a 	mov	r4,r9
21086f1c:	400b883a 	mov	r5,r8
21086f20:	180f883a 	mov	r7,r3
21086f24:	108c6840 	call	2108c684 <__subdf3>
21086f28:	000d883a 	mov	r6,zero
21086f2c:	01d01834 	movhi	r7,16480
21086f30:	1009883a 	mov	r4,r2
21086f34:	180b883a 	mov	r5,r3
21086f38:	108ad180 	call	2108ad18 <__adddf3>
21086f3c:	180b883a 	mov	r5,r3
21086f40:	1009883a 	mov	r4,r2
21086f44:	108a3200 	call	2108a320 <__fixunsdfsi>

	uint ycbcr = (cr << 16) | (y << 8) | (cb);
21086f48:	10803fcc 	andi	r2,r2,255
21086f4c:	1004943a 	slli	r2,r2,16
21086f50:	d9000617 	ldw	r4,24(sp)
							p_color += 0x00005000;
							if(p_color > 0x0000FF00)
								p_color = 0x0000FF00;
							else if(p_color < 0x0000CC00)
								p_color = 0x0000CC00;
							frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
21086f54:	057ffff4 	movhi	r21,65535
	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
	cb = -0.168736 * r - 0.331264 * g + 0.5 * b + 128;
	cr = 0.5 * r - 0.418688 * g - 0.081312 * b + 128;

	uint ycbcr = (cr << 16) | (y << 8) | (cb);
21086f58:	98a6b03a 	or	r19,r19,r2
	int spacing = 0;
	uint color = rgb2ycbcr(rgb_color);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
21086f5c:	00800034 	movhi	r2,0
21086f60:	10976304 	addi	r2,r2,23948
21086f64:	10800017 	ldw	r2,0(r2)
							frame[frame_offset] = color;
							continue;
						}
						unsigned int bg_color = frame[frame_offset];
						unsigned int p_color = bg_color & 0x0000FF00;
						if(p_color < 0x0000DD00) {
21086f68:	05373fd4 	movui	r20,56575
							p_color += 0x00005000;
							if(p_color > 0x0000FF00)
21086f6c:	05ffc014 	movui	r23,65280
	int spacing = 0;
	uint color = rgb2ycbcr(rgb_color);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
21086f70:	d8800415 	stw	r2,16(sp)
21086f74:	108e7200 	call	2108e720 <strlen>
21086f78:	00c00034 	movhi	r3,0
21086f7c:	18d78004 	addi	r3,r3,24064
21086f80:	18c00017 	ldw	r3,0(r3)
21086f84:	d9400517 	ldw	r5,20(sp)
						unsigned int p_color = bg_color & 0x0000FF00;
						if(p_color < 0x0000DD00) {
							p_color += 0x00005000;
							if(p_color > 0x0000FF00)
								p_color = 0x0000FF00;
							else if(p_color < 0x0000CC00)
21086f88:	0732ffd4 	movui	fp,52223
21086f8c:	d8c00115 	stw	r3,4(sp)
								p_color = 0x0000CC00;
							frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
21086f90:	ad403fc4 	addi	r21,r21,255
	uint color = rgb2ycbcr(rgb_color);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {
21086f94:	2880702e 	bgeu	r5,r2,21087158 <ece423_video_display_add_text+0x4cc>
21086f98:	d9000617 	ldw	r4,24(sp)
21086f9c:	2147883a 	add	r3,r4,r5

		int c_offset = text[i] - 32;
21086fa0:	18c00007 	ldb	r3,0(r3)

		int c_width = font_glyph_dsc[c_offset].w_px;
21086fa4:	01400034 	movhi	r5,0
21086fa8:	29419004 	addi	r5,r5,1600
	int y_offset = y;

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {

		int c_offset = text[i] - 32;
21086fac:	18fff804 	addi	r3,r3,-32

		int c_width = font_glyph_dsc[c_offset].w_px;
21086fb0:	180690fa 	slli	r3,r3,3
21086fb4:	28c9883a 	add	r4,r5,r3
		int c_index = font_glyph_dsc[c_offset].glyph_index;
21086fb8:	2007883a 	mov	r3,r4
	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {

		int c_offset = text[i] - 32;

		int c_width = font_glyph_dsc[c_offset].w_px;
21086fbc:	21000017 	ldw	r4,0(r4)
		int c_index = font_glyph_dsc[c_offset].glyph_index;
21086fc0:	1b800117 	ldw	r14,4(r3)

		for (int j = 0; j < c_height; j++) {
21086fc4:	d8c00417 	ldw	r3,16(sp)
	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {

		int c_offset = text[i] - 32;

		int c_width = font_glyph_dsc[c_offset].w_px;
21086fc8:	d9000015 	stw	r4,0(sp)
		int c_index = font_glyph_dsc[c_offset].glyph_index;

		for (int j = 0; j < c_height; j++) {
21086fcc:	00c05a0e 	bge	zero,r3,21087138 <ece423_video_display_add_text+0x4ac>
21086fd0:	d9400117 	ldw	r5,4(sp)
21086fd4:	d8000215 	stw	zero,8(sp)
21086fd8:	d8000315 	stw	zero,12(sp)
21086fdc:	2b85883a 	add	r2,r5,r14
21086fe0:	10800003 	ldbu	r2,0(r2)
			int k = 0;
			unsigned char mask = 0x80;
			unsigned char b = font_glyph_bitmap[c_index];
			while(k < c_width) {
21086fe4:	d8c00017 	ldw	r3,0(sp)
		int c_index = font_glyph_dsc[c_offset].glyph_index;

		for (int j = 0; j < c_height; j++) {
			int k = 0;
			unsigned char mask = 0x80;
			unsigned char b = font_glyph_bitmap[c_index];
21086fe8:	101f883a 	mov	r15,r2
			while(k < c_width) {
21086fec:	00c0480e 	bge	zero,r3,21087110 <ece423_video_display_add_text+0x484>
21086ff0:	d9400217 	ldw	r5,8(sp)
21086ff4:	d9000717 	ldw	r4,28(sp)
21086ff8:	d8800817 	ldw	r2,32(sp)
21086ffc:	b011883a 	mov	r8,r22
21087000:	0015883a 	mov	r10,zero
21087004:	033fe004 	movi	r12,-128
21087008:	001b883a 	mov	r13,zero
2108700c:	217f883a 	add	ra,r4,r5
21087010:	1157883a 	add	r11,r2,r5

				for(int l = 0; l < scale; l++)
21087014:	0580270e 	bge	zero,r22,210870b4 <ece423_video_display_add_text+0x428>
21087018:	63d2703a 	and	r9,r12,r15
2108701c:	f80f883a 	mov	r7,ra
21087020:	4a403fcc 	andi	r9,r9,255
		int c_offset = text[i] - 32;

		int c_width = font_glyph_dsc[c_offset].w_px;
		int c_index = font_glyph_dsc[c_offset].glyph_index;

		for (int j = 0; j < c_height; j++) {
21087024:	5007883a 	mov	r3,r10
21087028:	4800161e 	bne	r9,zero,21087084 <ece423_video_display_add_text+0x3f8>
2108702c:	00000606 	br	21087048 <ece423_video_display_add_text+0x3bc>
						unsigned int bg_color = frame[frame_offset];
						unsigned int p_color = bg_color & 0x0000FF00;
						if(p_color < 0x0000DD00) {
							p_color += 0x00005000;
							if(p_color > 0x0000FF00)
								p_color = 0x0000FF00;
21087030:	017fc014 	movui	r5,65280
							else if(p_color < 0x0000CC00)
								p_color = 0x0000CC00;
							frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
21087034:	2548703a 	and	r4,r4,r21
21087038:	2908b03a 	or	r4,r5,r4
2108703c:	11000015 	stw	r4,0(r2)
21087040:	18c00044 	addi	r3,r3,1
			unsigned char mask = 0x80;
			unsigned char b = font_glyph_bitmap[c_index];
			while(k < c_width) {

				for(int l = 0; l < scale; l++)
					for(int m = 0; m < scale; m++) {
21087044:	1a001926 	beq	r3,r8,210870ac <ece423_video_display_add_text+0x420>
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;
21087048:	88802817 	ldw	r2,160(r17)
2108704c:	3885383a 	mul	r2,r7,r2
21087050:	1405883a 	add	r2,r2,r16
21087054:	10c5883a 	add	r2,r2,r3

						if(b & mask) {
							frame[frame_offset] = color;
							continue;
						}
						unsigned int bg_color = frame[frame_offset];
21087058:	1085883a 	add	r2,r2,r2
2108705c:	1085883a 	add	r2,r2,r2
21087060:	9085883a 	add	r2,r18,r2
21087064:	11000017 	ldw	r4,0(r2)
						unsigned int p_color = bg_color & 0x0000FF00;
21087068:	21bfc00c 	andi	r6,r4,65280
						if(p_color < 0x0000DD00) {
							p_color += 0x00005000;
2108706c:	31540004 	addi	r5,r6,20480
							frame[frame_offset] = color;
							continue;
						}
						unsigned int bg_color = frame[frame_offset];
						unsigned int p_color = bg_color & 0x0000FF00;
						if(p_color < 0x0000DD00) {
21087070:	a1bff336 	bltu	r20,r6,21087040 <__flash_rwdata_start+0xfffe4df8>
							p_color += 0x00005000;
							if(p_color > 0x0000FF00)
21087074:	b97fee36 	bltu	r23,r5,21087030 <__flash_rwdata_start+0xfffe4de8>
								p_color = 0x0000FF00;
							else if(p_color < 0x0000CC00)
21087078:	e17fee36 	bltu	fp,r5,21087034 <__flash_rwdata_start+0xfffe4dec>
								p_color = 0x0000CC00;
2108707c:	01730014 	movui	r5,52224
21087080:	003fec06 	br	21087034 <__flash_rwdata_start+0xfffe4dec>

				for(int l = 0; l < scale; l++)
					for(int m = 0; m < scale; m++) {
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;
21087084:	88802817 	ldw	r2,160(r17)

						if(b & mask) {
							frame[frame_offset] = color;
21087088:	1c09883a 	add	r4,r3,r16
2108708c:	18c00044 	addi	r3,r3,1

				for(int l = 0; l < scale; l++)
					for(int m = 0; m < scale; m++) {
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;
21087090:	3885383a 	mul	r2,r7,r2

						if(b & mask) {
							frame[frame_offset] = color;
21087094:	2085883a 	add	r2,r4,r2
21087098:	1085883a 	add	r2,r2,r2
2108709c:	1085883a 	add	r2,r2,r2
210870a0:	9085883a 	add	r2,r18,r2
210870a4:	14c00015 	stw	r19,0(r2)
			unsigned char mask = 0x80;
			unsigned char b = font_glyph_bitmap[c_index];
			while(k < c_width) {

				for(int l = 0; l < scale; l++)
					for(int m = 0; m < scale; m++) {
210870a8:	40fff61e 	bne	r8,r3,21087084 <__flash_rwdata_start+0xfffe4e3c>
210870ac:	39c00044 	addi	r7,r7,1
			int k = 0;
			unsigned char mask = 0x80;
			unsigned char b = font_glyph_bitmap[c_index];
			while(k < c_width) {

				for(int l = 0; l < scale; l++)
210870b0:	3affdc1e 	bne	r7,r11,21087024 <__flash_rwdata_start+0xfffe4ddc>
							frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
						}
					}

				k++;
				mask = mask >> 1;
210870b4:	60803fcc 	andi	r2,r12,255
210870b8:	1004d07a 	srli	r2,r2,1
								p_color = 0x0000CC00;
							frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
						}
					}

				k++;
210870bc:	6b400044 	addi	r13,r13,1
				mask = mask >> 1;
210870c0:	1019883a 	mov	r12,r2

				if (mask == 0 || k >= c_width) {
210870c4:	10000526 	beq	r2,zero,210870dc <ece423_video_display_add_text+0x450>
210870c8:	d8c00017 	ldw	r3,0(sp)
210870cc:	68c00c0e 	bge	r13,r3,21087100 <ece423_video_display_add_text+0x474>
210870d0:	5595883a 	add	r10,r10,r22
210870d4:	4591883a 	add	r8,r8,r22
210870d8:	003fce06 	br	21087014 <__flash_rwdata_start+0xfffe4dcc>
					c_index++;
					b = font_glyph_bitmap[c_index];
210870dc:	d9400117 	ldw	r5,4(sp)

				k++;
				mask = mask >> 1;

				if (mask == 0 || k >= c_width) {
					c_index++;
210870e0:	73800044 	addi	r14,r14,1

		for (int j = 0; j < c_height; j++) {
			int k = 0;
			unsigned char mask = 0x80;
			unsigned char b = font_glyph_bitmap[c_index];
			while(k < c_width) {
210870e4:	d8c00017 	ldw	r3,0(sp)
				k++;
				mask = mask >> 1;

				if (mask == 0 || k >= c_width) {
					c_index++;
					b = font_glyph_bitmap[c_index];
210870e8:	2b85883a 	add	r2,r5,r14
210870ec:	13c00003 	ldbu	r15,0(r2)
210870f0:	7805883a 	mov	r2,r15

		for (int j = 0; j < c_height; j++) {
			int k = 0;
			unsigned char mask = 0x80;
			unsigned char b = font_glyph_bitmap[c_index];
			while(k < c_width) {
210870f4:	68c0060e 	bge	r13,r3,21087110 <ece423_video_display_add_text+0x484>
				mask = mask >> 1;

				if (mask == 0 || k >= c_width) {
					c_index++;
					b = font_glyph_bitmap[c_index];
					mask = 0x80;
210870f8:	033fe004 	movi	r12,-128
210870fc:	003ff406 	br	210870d0 <__flash_rwdata_start+0xfffe4e88>
				k++;
				mask = mask >> 1;

				if (mask == 0 || k >= c_width) {
					c_index++;
					b = font_glyph_bitmap[c_index];
21087100:	d8c00117 	ldw	r3,4(sp)

				k++;
				mask = mask >> 1;

				if (mask == 0 || k >= c_width) {
					c_index++;
21087104:	73800044 	addi	r14,r14,1
					b = font_glyph_bitmap[c_index];
21087108:	1b85883a 	add	r2,r3,r14
2108710c:	10800003 	ldbu	r2,0(r2)
		int c_offset = text[i] - 32;

		int c_width = font_glyph_dsc[c_offset].w_px;
		int c_index = font_glyph_dsc[c_offset].glyph_index;

		for (int j = 0; j < c_height; j++) {
21087110:	d9000317 	ldw	r4,12(sp)
21087114:	d9400217 	ldw	r5,8(sp)
21087118:	d8c00417 	ldw	r3,16(sp)
2108711c:	21000044 	addi	r4,r4,1
21087120:	2d8b883a 	add	r5,r5,r22
21087124:	d9000315 	stw	r4,12(sp)
21087128:	d9400215 	stw	r5,8(sp)
2108712c:	20ffad1e 	bne	r4,r3,21086fe4 <__flash_rwdata_start+0xfffe4d9c>
21087130:	d9000617 	ldw	r4,24(sp)
21087134:	108e7200 	call	2108e720 <strlen>
					b = font_glyph_bitmap[c_index];
					mask = 0x80;
				}
			}
		}
		x_offset += scale*c_width + spacing;
21087138:	d9400017 	ldw	r5,0(sp)
	uint color = rgb2ycbcr(rgb_color);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {
2108713c:	d9000517 	ldw	r4,20(sp)
					b = font_glyph_bitmap[c_index];
					mask = 0x80;
				}
			}
		}
		x_offset += scale*c_width + spacing;
21087140:	b147383a 	mul	r3,r22,r5
	uint color = rgb2ycbcr(rgb_color);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {
21087144:	21000044 	addi	r4,r4,1
21087148:	d9000515 	stw	r4,20(sp)
2108714c:	200b883a 	mov	r5,r4
					b = font_glyph_bitmap[c_index];
					mask = 0x80;
				}
			}
		}
		x_offset += scale*c_width + spacing;
21087150:	80e1883a 	add	r16,r16,r3
	uint color = rgb2ycbcr(rgb_color);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {
21087154:	28bf9036 	bltu	r5,r2,21086f98 <__flash_rwdata_start+0xfffe4d50>
			}
		}
		x_offset += scale*c_width + spacing;
	}

}
21087158:	dfc01517 	ldw	ra,84(sp)
2108715c:	df001417 	ldw	fp,80(sp)
21087160:	ddc01317 	ldw	r23,76(sp)
21087164:	dd801217 	ldw	r22,72(sp)
21087168:	dd401117 	ldw	r21,68(sp)
2108716c:	dd001017 	ldw	r20,64(sp)
21087170:	dcc00f17 	ldw	r19,60(sp)
21087174:	dc800e17 	ldw	r18,56(sp)
21087178:	dc400d17 	ldw	r17,52(sp)
2108717c:	dc000c17 	ldw	r16,48(sp)
21087180:	dec01604 	addi	sp,sp,88
21087184:	f800283a 	ret

21087188 <ece423_video_display_text_frame>:
 *
 ******************************************************************/
void ece423_video_display_color_screen(ece423_video_display* display,
		uint rgb_color) {
	uint color = rgb2ycbcr(rgb_color);
	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
21087188:	20802717 	ldw	r2,156(r4)
	for (int i = 0; i < display->bytes_per_frame / 4; i += 1)
2108718c:	20c02b17 	ldw	r3,172(r4)
 *  Function: ece423_video_display_text_frame
 *
 *  Purpose: Add a string to the screen
 *
 ******************************************************************/
void ece423_video_display_text_frame(ece423_video_display* display, char* text) {
21087190:	deffec04 	addi	sp,sp,-80
 *
 ******************************************************************/
void ece423_video_display_color_screen(ece423_video_display* display,
		uint rgb_color) {
	uint color = rgb2ycbcr(rgb_color);
	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
21087194:	10800044 	addi	r2,r2,1
21087198:	1085883a 	add	r2,r2,r2
2108719c:	1085883a 	add	r2,r2,r2
210871a0:	2085883a 	add	r2,r4,r2
210871a4:	10800017 	ldw	r2,0(r2)
 *  Function: ece423_video_display_text_frame
 *
 *  Purpose: Add a string to the screen
 *
 ******************************************************************/
void ece423_video_display_text_frame(ece423_video_display* display, char* text) {
210871a8:	dc400b15 	stw	r17,44(sp)
210871ac:	dfc01315 	stw	ra,76(sp)
210871b0:	2023883a 	mov	r17,r4
210871b4:	df001215 	stw	fp,72(sp)
210871b8:	ddc01115 	stw	r23,68(sp)
210871bc:	dd801015 	stw	r22,64(sp)
210871c0:	dd400f15 	stw	r21,60(sp)
210871c4:	dd000e15 	stw	r20,56(sp)
210871c8:	dcc00d15 	stw	r19,52(sp)
210871cc:	dc800c15 	stw	r18,48(sp)
210871d0:	dc000a15 	stw	r16,40(sp)
210871d4:	d9400515 	stw	r5,20(sp)
 ******************************************************************/
void ece423_video_display_color_screen(ece423_video_display* display,
		uint rgb_color) {
	uint color = rgb2ycbcr(rgb_color);
	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
	for (int i = 0; i < display->bytes_per_frame / 4; i += 1)
210871d8:	010000c4 	movi	r4,3
 *
 ******************************************************************/
void ece423_video_display_color_screen(ece423_video_display* display,
		uint rgb_color) {
	uint color = rgb2ycbcr(rgb_color);
	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
210871dc:	10800117 	ldw	r2,4(r2)
	for (int i = 0; i < display->bytes_per_frame / 4; i += 1)
210871e0:	20c0160e 	bge	r4,r3,2108723c <ece423_video_display_text_frame+0xb4>
		frame[i] = color;
210871e4:	01402074 	movhi	r5,129
210871e8:	297fe004 	addi	r5,r5,-128
 ******************************************************************/
void ece423_video_display_color_screen(ece423_video_display* display,
		uint rgb_color) {
	uint color = rgb2ycbcr(rgb_color);
	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
	for (int i = 0; i < display->bytes_per_frame / 4; i += 1)
210871ec:	0009883a 	mov	r4,zero
210871f0:	00000206 	br	210871fc <ece423_video_display_text_frame+0x74>
210871f4:	1807d0ba 	srai	r3,r3,2
210871f8:	20c0080e 	bge	r4,r3,2108721c <ece423_video_display_text_frame+0x94>
		frame[i] = color;
210871fc:	11400015 	stw	r5,0(r2)
 ******************************************************************/
void ece423_video_display_color_screen(ece423_video_display* display,
		uint rgb_color) {
	uint color = rgb2ycbcr(rgb_color);
	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
	for (int i = 0; i < display->bytes_per_frame / 4; i += 1)
21087200:	88c02b17 	ldw	r3,172(r17)
21087204:	21000044 	addi	r4,r4,1
21087208:	10800104 	addi	r2,r2,4
2108720c:	183ff90e 	bge	r3,zero,210871f4 <__flash_rwdata_start+0xfffe4fac>
21087210:	18c000c4 	addi	r3,r3,3
21087214:	1807d0ba 	srai	r3,r3,2
21087218:	20fff816 	blt	r4,r3,210871fc <__flash_rwdata_start+0xfffe4fb4>
2108721c:	88802717 	ldw	r2,156(r17)
21087220:	10800044 	addi	r2,r2,1
21087224:	1085883a 	add	r2,r2,r2
21087228:	1085883a 	add	r2,r2,r2
2108722c:	8885883a 	add	r2,r17,r2
21087230:	10800017 	ldw	r2,0(r2)
21087234:	14000117 	ldw	r16,4(r2)
21087238:	00000106 	br	21087240 <ece423_video_display_text_frame+0xb8>
2108723c:	1021883a 	mov	r16,r2
21087240:	d9000517 	ldw	r4,20(sp)
21087244:	108e7200 	call	2108e720 <strlen>
21087248:	d9000517 	ldw	r4,20(sp)
	ece423_video_display_clear_screen(display);
	// ece423_video_display_draw_logo(display);
	int text_width = 0;
	for(int i = 0; i < strlen(text); i++) {
		int c_offset = text[i] - 32;
		text_width += font_glyph_dsc[c_offset].w_px*scale;
2108724c:	01800034 	movhi	r6,0
 ******************************************************************/
void ece423_video_display_color_screen(ece423_video_display* display,
		uint rgb_color) {
	uint color = rgb2ycbcr(rgb_color);
	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
	for (int i = 0; i < display->bytes_per_frame / 4; i += 1)
21087250:	000b883a 	mov	r5,zero
21087254:	208f883a 	add	r7,r4,r2
	ece423_video_display_clear_screen(display);
	// ece423_video_display_draw_logo(display);
	int text_width = 0;
	for(int i = 0; i < strlen(text); i++) {
		int c_offset = text[i] - 32;
		text_width += font_glyph_dsc[c_offset].w_px*scale;
21087258:	31819004 	addi	r6,r6,1600

	int scale = 4;
	ece423_video_display_clear_screen(display);
	// ece423_video_display_draw_logo(display);
	int text_width = 0;
	for(int i = 0; i < strlen(text); i++) {
2108725c:	21c00a26 	beq	r4,r7,21087288 <ece423_video_display_text_frame+0x100>
		int c_offset = text[i] - 32;
21087260:	20c00007 	ldb	r3,0(r4)
21087264:	21000044 	addi	r4,r4,1
		text_width += font_glyph_dsc[c_offset].w_px*scale;
21087268:	18fff804 	addi	r3,r3,-32
2108726c:	180690fa 	slli	r3,r3,3
21087270:	30c7883a 	add	r3,r6,r3
21087274:	18c00017 	ldw	r3,0(r3)
21087278:	18c7883a 	add	r3,r3,r3
2108727c:	18c7883a 	add	r3,r3,r3
21087280:	28cb883a 	add	r5,r5,r3

	int scale = 4;
	ece423_video_display_clear_screen(display);
	// ece423_video_display_draw_logo(display);
	int text_width = 0;
	for(int i = 0; i < strlen(text); i++) {
21087284:	21fff61e 	bne	r4,r7,21087260 <__flash_rwdata_start+0xfffe5018>
		int c_offset = text[i] - 32;
		text_width += font_glyph_dsc[c_offset].w_px*scale;
	}
	int x = (display->width - text_width)/2;
	// int y = 5*display->height/10;
	int y = (display->height - font_height*scale)/2;
21087288:	01800034 	movhi	r6,0
2108728c:	31976304 	addi	r6,r6,23948
21087290:	31800017 	ldw	r6,0(r6)
	int text_width = 0;
	for(int i = 0; i < strlen(text); i++) {
		int c_offset = text[i] - 32;
		text_width += font_glyph_dsc[c_offset].w_px*scale;
	}
	int x = (display->width - text_width)/2;
21087294:	88c02817 	ldw	r3,160(r17)
	// int y = 5*display->height/10;
	int y = (display->height - font_height*scale)/2;
21087298:	89002917 	ldw	r4,164(r17)
2108729c:	d9800615 	stw	r6,24(sp)
	int text_width = 0;
	for(int i = 0; i < strlen(text); i++) {
		int c_offset = text[i] - 32;
		text_width += font_glyph_dsc[c_offset].w_px*scale;
	}
	int x = (display->width - text_width)/2;
210872a0:	194bc83a 	sub	r5,r3,r5
	// int y = 5*display->height/10;
	int y = (display->height - font_height*scale)/2;
210872a4:	3187883a 	add	r3,r6,r6
210872a8:	18c7883a 	add	r3,r3,r3
210872ac:	20c7c83a 	sub	r3,r4,r3
210872b0:	1808d7fa 	srli	r4,r3,31
		int c_index = font_glyph_dsc[c_offset].glyph_index;

		for (int j = 0; j < c_height; j++) {
			int k = 0;
			unsigned char mask = 0x80;
			unsigned char b = font_glyph_bitmap[c_index];
210872b4:	01800034 	movhi	r6,0
210872b8:	31978004 	addi	r6,r6,24064
		int c_offset = text[i] - 32;
		text_width += font_glyph_dsc[c_offset].w_px*scale;
	}
	int x = (display->width - text_width)/2;
	// int y = 5*display->height/10;
	int y = (display->height - font_height*scale)/2;
210872bc:	20c7883a 	add	r3,r4,r3
210872c0:	1807d07a 	srai	r3,r3,1
	int text_width = 0;
	for(int i = 0; i < strlen(text); i++) {
		int c_offset = text[i] - 32;
		text_width += font_glyph_dsc[c_offset].w_px*scale;
	}
	int x = (display->width - text_width)/2;
210872c4:	2824d7fa 	srli	r18,r5,31
		int c_index = font_glyph_dsc[c_offset].glyph_index;

		for (int j = 0; j < c_height; j++) {
			int k = 0;
			unsigned char mask = 0x80;
			unsigned char b = font_glyph_bitmap[c_index];
210872c8:	31800017 	ldw	r6,0(r6)
	uint color = rgb2ycbcr(rgb_color);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {
210872cc:	d8000715 	stw	zero,28(sp)
210872d0:	d9c00717 	ldw	r7,28(sp)
210872d4:	18c00104 	addi	r3,r3,4
	int text_width = 0;
	for(int i = 0; i < strlen(text); i++) {
		int c_offset = text[i] - 32;
		text_width += font_glyph_dsc[c_offset].w_px*scale;
	}
	int x = (display->width - text_width)/2;
210872d8:	914b883a 	add	r5,r18,r5
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;

						if(b & mask) {
							frame[frame_offset] = color;
210872dc:	04c03ff4 	movhi	r19,255
							p_color += 0x00005000;
							if(p_color > 0x0000FF00)
								p_color = 0x0000FF00;
							else if(p_color < 0x0000CC00)
								p_color = 0x0000CC00;
							frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
210872e0:	05fffff4 	movhi	r23,65535
		int c_index = font_glyph_dsc[c_offset].glyph_index;

		for (int j = 0; j < c_height; j++) {
			int k = 0;
			unsigned char mask = 0x80;
			unsigned char b = font_glyph_bitmap[c_index];
210872e4:	d9800415 	stw	r6,16(sp)
210872e8:	d8c00915 	stw	r3,36(sp)
	int text_width = 0;
	for(int i = 0; i < strlen(text); i++) {
		int c_offset = text[i] - 32;
		text_width += font_glyph_dsc[c_offset].w_px*scale;
	}
	int x = (display->width - text_width)/2;
210872ec:	2825d07a 	srai	r18,r5,1
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;

						if(b & mask) {
							frame[frame_offset] = color;
210872f0:	9cd31504 	addi	r19,r19,19540
							continue;
						}
						unsigned int bg_color = frame[frame_offset];
						unsigned int p_color = bg_color & 0x0000FF00;
						if(p_color < 0x0000DD00) {
210872f4:	05373fd4 	movui	r20,56575
							p_color += 0x00005000;
							if(p_color > 0x0000FF00)
210872f8:	057fc014 	movui	r21,65280
								p_color = 0x0000FF00;
							else if(p_color < 0x0000CC00)
210872fc:	05b2ffd4 	movui	r22,52223
								p_color = 0x0000CC00;
							frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
21087300:	bdc03fc4 	addi	r23,r23,255
	uint color = rgb2ycbcr(rgb_color);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {
21087304:	3880b92e 	bgeu	r7,r2,210875ec <ece423_video_display_text_frame+0x464>
21087308:	d8c00517 	ldw	r3,20(sp)
2108730c:	19c5883a 	add	r2,r3,r7

		int c_offset = text[i] - 32;
21087310:	10800007 	ldb	r2,0(r2)

		int c_width = font_glyph_dsc[c_offset].w_px;
21087314:	01c00034 	movhi	r7,0
21087318:	39c19004 	addi	r7,r7,1600
	int y_offset = y;

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {

		int c_offset = text[i] - 32;
2108731c:	10bff804 	addi	r2,r2,-32

		int c_width = font_glyph_dsc[c_offset].w_px;
21087320:	100490fa 	slli	r2,r2,3
21087324:	3887883a 	add	r3,r7,r2
		int c_index = font_glyph_dsc[c_offset].glyph_index;
21087328:	1805883a 	mov	r2,r3
	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {

		int c_offset = text[i] - 32;

		int c_width = font_glyph_dsc[c_offset].w_px;
2108732c:	18c00017 	ldw	r3,0(r3)
		int c_index = font_glyph_dsc[c_offset].glyph_index;
21087330:	10800117 	ldw	r2,4(r2)
	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {

		int c_offset = text[i] - 32;

		int c_width = font_glyph_dsc[c_offset].w_px;
21087334:	d8c00215 	stw	r3,8(sp)
		int c_index = font_glyph_dsc[c_offset].glyph_index;

		for (int j = 0; j < c_height; j++) {
21087338:	d8c00617 	ldw	r3,24(sp)
	for (int i = 0; i < strlen(text); i++) {

		int c_offset = text[i] - 32;

		int c_width = font_glyph_dsc[c_offset].w_px;
		int c_index = font_glyph_dsc[c_offset].glyph_index;
2108733c:	d8800015 	stw	r2,0(sp)

		for (int j = 0; j < c_height; j++) {
21087340:	00c09f0e 	bge	zero,r3,210875c0 <ece423_video_display_text_frame+0x438>
21087344:	dbc00917 	ldw	r15,36(sp)
21087348:	d8000815 	stw	zero,32(sp)
			int k = 0;
			unsigned char mask = 0x80;
			unsigned char b = font_glyph_bitmap[c_index];
2108734c:	d9800417 	ldw	r6,16(sp)
21087350:	d9c00017 	ldw	r7,0(sp)
21087354:	31c5883a 	add	r2,r6,r7
21087358:	10800003 	ldbu	r2,0(r2)
2108735c:	d8800105 	stb	r2,4(sp)
			while(k < c_width) {
21087360:	d8800217 	ldw	r2,8(sp)
21087364:	0080900e 	bge	zero,r2,210875a8 <ece423_video_display_text_frame+0x420>
21087368:	78ffff04 	addi	r3,r15,-4
2108736c:	01c000c4 	movi	r7,3
21087370:	023fe004 	movi	r8,-128
21087374:	001d883a 	mov	r14,zero
21087378:	d8c00315 	stw	r3,12(sp)
2108737c:	1809883a 	mov	r4,r3
21087380:	d8800103 	ldbu	r2,4(sp)
21087384:	738b883a 	add	r5,r14,r14
21087388:	3a7fffc4 	addi	r9,r7,-1
2108738c:	120c703a 	and	r6,r2,r8
21087390:	3abfff84 	addi	r10,r7,-2
21087394:	294b883a 	add	r5,r5,r5
21087398:	31803fcc 	andi	r6,r6,255
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;

						if(b & mask) {
							frame[frame_offset] = color;
2108739c:	929b883a 	add	r13,r18,r10
210873a0:	9259883a 	add	r12,r18,r9
210873a4:	91d7883a 	add	r11,r18,r7
210873a8:	00003b06 	br	21087498 <ece423_video_display_text_frame+0x310>
							continue;
						}
						unsigned int bg_color = frame[frame_offset];
210873ac:	1fc00017 	ldw	ra,0(r3)
						unsigned int p_color = bg_color & 0x0000FF00;
210873b0:	ff3fc00c 	andi	fp,ra,65280
						if(p_color < 0x0000DD00) {
210873b4:	a7000936 	bltu	r20,fp,210873dc <ece423_video_display_text_frame+0x254>
							p_color += 0x00005000;
210873b8:	e7140004 	addi	fp,fp,20480
							if(p_color > 0x0000FF00)
210873bc:	af00602e 	bgeu	r21,fp,21087540 <ece423_video_display_text_frame+0x3b8>
								p_color = 0x0000FF00;
210873c0:	073fc014 	movui	fp,65280
							else if(p_color < 0x0000CC00)
								p_color = 0x0000CC00;
							frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
210873c4:	fdfe703a 	and	ra,ra,r23
210873c8:	e7f8b03a 	or	fp,fp,ra
210873cc:	1f000015 	stw	fp,0(r3)
210873d0:	88802817 	ldw	r2,160(r17)
210873d4:	2085383a 	mul	r2,r4,r2
210873d8:	9085883a 	add	r2,r18,r2

				for(int l = 0; l < scale; l++)
					for(int m = 0; m < scale; m++) {
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;
210873dc:	5087883a 	add	r3,r10,r2

						if(b & mask) {
							frame[frame_offset] = color;
							continue;
						}
						unsigned int bg_color = frame[frame_offset];
210873e0:	18c7883a 	add	r3,r3,r3
210873e4:	18c7883a 	add	r3,r3,r3
210873e8:	80c7883a 	add	r3,r16,r3
210873ec:	1fc00017 	ldw	ra,0(r3)
						unsigned int p_color = bg_color & 0x0000FF00;
210873f0:	ff3fc00c 	andi	fp,ra,65280
						if(p_color < 0x0000DD00) {
210873f4:	a7000936 	bltu	r20,fp,2108741c <ece423_video_display_text_frame+0x294>
							p_color += 0x00005000;
210873f8:	e7140004 	addi	fp,fp,20480
							if(p_color > 0x0000FF00)
210873fc:	af00592e 	bgeu	r21,fp,21087564 <ece423_video_display_text_frame+0x3dc>
								p_color = 0x0000FF00;
21087400:	073fc014 	movui	fp,65280
							else if(p_color < 0x0000CC00)
								p_color = 0x0000CC00;
							frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
21087404:	fdfe703a 	and	ra,ra,r23
21087408:	e7f8b03a 	or	fp,fp,ra
2108740c:	1f000015 	stw	fp,0(r3)
21087410:	88802817 	ldw	r2,160(r17)
21087414:	2085383a 	mul	r2,r4,r2
21087418:	9085883a 	add	r2,r18,r2

				for(int l = 0; l < scale; l++)
					for(int m = 0; m < scale; m++) {
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;
2108741c:	4887883a 	add	r3,r9,r2

						if(b & mask) {
							frame[frame_offset] = color;
							continue;
						}
						unsigned int bg_color = frame[frame_offset];
21087420:	18c7883a 	add	r3,r3,r3
21087424:	18c7883a 	add	r3,r3,r3
21087428:	80c7883a 	add	r3,r16,r3
2108742c:	1fc00017 	ldw	ra,0(r3)
						unsigned int p_color = bg_color & 0x0000FF00;
21087430:	ff3fc00c 	andi	fp,ra,65280
						if(p_color < 0x0000DD00) {
21087434:	a7000936 	bltu	r20,fp,2108745c <ece423_video_display_text_frame+0x2d4>
							p_color += 0x00005000;
21087438:	e7140004 	addi	fp,fp,20480
							if(p_color > 0x0000FF00)
2108743c:	af00432e 	bgeu	r21,fp,2108754c <ece423_video_display_text_frame+0x3c4>
								p_color = 0x0000FF00;
21087440:	073fc014 	movui	fp,65280
							else if(p_color < 0x0000CC00)
								p_color = 0x0000CC00;
							frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
21087444:	fdfe703a 	and	ra,ra,r23
21087448:	e7f8b03a 	or	fp,fp,ra
2108744c:	1f000015 	stw	fp,0(r3)
21087450:	88802817 	ldw	r2,160(r17)
21087454:	2085383a 	mul	r2,r4,r2
21087458:	9085883a 	add	r2,r18,r2

				for(int l = 0; l < scale; l++)
					for(int m = 0; m < scale; m++) {
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;
2108745c:	11c5883a 	add	r2,r2,r7

						if(b & mask) {
							frame[frame_offset] = color;
							continue;
						}
						unsigned int bg_color = frame[frame_offset];
21087460:	1085883a 	add	r2,r2,r2
21087464:	1085883a 	add	r2,r2,r2
21087468:	8085883a 	add	r2,r16,r2
2108746c:	17000017 	ldw	fp,0(r2)
						unsigned int p_color = bg_color & 0x0000FF00;
21087470:	e0ffc00c 	andi	r3,fp,65280
						if(p_color < 0x0000DD00) {
21087474:	a0c00636 	bltu	r20,r3,21087490 <ece423_video_display_text_frame+0x308>
							p_color += 0x00005000;
21087478:	18d40004 	addi	r3,r3,20480
							if(p_color > 0x0000FF00)
2108747c:	a8c0362e 	bgeu	r21,r3,21087558 <ece423_video_display_text_frame+0x3d0>
								p_color = 0x0000FF00;
21087480:	00ffc014 	movui	r3,65280
							else if(p_color < 0x0000CC00)
								p_color = 0x0000CC00;
							frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
21087484:	e5f8703a 	and	fp,fp,r23
21087488:	1f06b03a 	or	r3,r3,fp
2108748c:	10c00015 	stw	r3,0(r2)
21087490:	21000044 	addi	r4,r4,1
			int k = 0;
			unsigned char mask = 0x80;
			unsigned char b = font_glyph_bitmap[c_index];
			while(k < c_width) {

				for(int l = 0; l < scale; l++)
21087494:	79002026 	beq	r15,r4,21087518 <ece423_video_display_text_frame+0x390>
					for(int m = 0; m < scale; m++) {
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;
21087498:	88802817 	ldw	r2,160(r17)
2108749c:	2085383a 	mul	r2,r4,r2
210874a0:	1485883a 	add	r2,r2,r18
210874a4:	2887883a 	add	r3,r5,r2

						if(b & mask) {
							frame[frame_offset] = color;
210874a8:	18c7883a 	add	r3,r3,r3
210874ac:	18c7883a 	add	r3,r3,r3
210874b0:	80c7883a 	add	r3,r16,r3
					for(int m = 0; m < scale; m++) {
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;

						if(b & mask) {
210874b4:	303fbd26 	beq	r6,zero,210873ac <__flash_rwdata_start+0xfffe5164>
							frame[frame_offset] = color;
210874b8:	1cc00015 	stw	r19,0(r3)

				for(int l = 0; l < scale; l++)
					for(int m = 0; m < scale; m++) {
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;
210874bc:	88802817 	ldw	r2,160(r17)
210874c0:	2085383a 	mul	r2,r4,r2

						if(b & mask) {
							frame[frame_offset] = color;
210874c4:	6885883a 	add	r2,r13,r2
210874c8:	1085883a 	add	r2,r2,r2
210874cc:	1085883a 	add	r2,r2,r2
210874d0:	8085883a 	add	r2,r16,r2
210874d4:	14c00015 	stw	r19,0(r2)

				for(int l = 0; l < scale; l++)
					for(int m = 0; m < scale; m++) {
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;
210874d8:	88802817 	ldw	r2,160(r17)
210874dc:	2085383a 	mul	r2,r4,r2

						if(b & mask) {
							frame[frame_offset] = color;
210874e0:	6085883a 	add	r2,r12,r2
210874e4:	1085883a 	add	r2,r2,r2
210874e8:	1085883a 	add	r2,r2,r2
210874ec:	8085883a 	add	r2,r16,r2
210874f0:	14c00015 	stw	r19,0(r2)

				for(int l = 0; l < scale; l++)
					for(int m = 0; m < scale; m++) {
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;
210874f4:	88802817 	ldw	r2,160(r17)
210874f8:	2085383a 	mul	r2,r4,r2
210874fc:	21000044 	addi	r4,r4,1

						if(b & mask) {
							frame[frame_offset] = color;
21087500:	5885883a 	add	r2,r11,r2
21087504:	1085883a 	add	r2,r2,r2
21087508:	1085883a 	add	r2,r2,r2
2108750c:	8085883a 	add	r2,r16,r2
21087510:	14c00015 	stw	r19,0(r2)
			int k = 0;
			unsigned char mask = 0x80;
			unsigned char b = font_glyph_bitmap[c_index];
			while(k < c_width) {

				for(int l = 0; l < scale; l++)
21087514:	793fe01e 	bne	r15,r4,21087498 <__flash_rwdata_start+0xfffe5250>
							frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
						}
					}

				k++;
				mask = mask >> 1;
21087518:	40803fcc 	andi	r2,r8,255
2108751c:	1004d07a 	srli	r2,r2,1
								p_color = 0x0000CC00;
							frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
						}
					}

				k++;
21087520:	73800044 	addi	r14,r14,1
				mask = mask >> 1;
21087524:	1011883a 	mov	r8,r2

				if (mask == 0 || k >= c_width) {
21087528:	10001126 	beq	r2,zero,21087570 <ece423_video_display_text_frame+0x3e8>
2108752c:	d9000217 	ldw	r4,8(sp)
21087530:	71001a0e 	bge	r14,r4,2108759c <ece423_video_display_text_frame+0x414>
21087534:	39c00104 	addi	r7,r7,4
21087538:	d9000317 	ldw	r4,12(sp)
2108753c:	003f9006 	br	21087380 <__flash_rwdata_start+0xfffe5138>
						unsigned int p_color = bg_color & 0x0000FF00;
						if(p_color < 0x0000DD00) {
							p_color += 0x00005000;
							if(p_color > 0x0000FF00)
								p_color = 0x0000FF00;
							else if(p_color < 0x0000CC00)
21087540:	b73fa036 	bltu	r22,fp,210873c4 <__flash_rwdata_start+0xfffe517c>
								p_color = 0x0000CC00;
21087544:	07330014 	movui	fp,52224
21087548:	003f9e06 	br	210873c4 <__flash_rwdata_start+0xfffe517c>
						unsigned int p_color = bg_color & 0x0000FF00;
						if(p_color < 0x0000DD00) {
							p_color += 0x00005000;
							if(p_color > 0x0000FF00)
								p_color = 0x0000FF00;
							else if(p_color < 0x0000CC00)
2108754c:	b73fbd36 	bltu	r22,fp,21087444 <__flash_rwdata_start+0xfffe51fc>
								p_color = 0x0000CC00;
21087550:	07330014 	movui	fp,52224
21087554:	003fbb06 	br	21087444 <__flash_rwdata_start+0xfffe51fc>
						unsigned int p_color = bg_color & 0x0000FF00;
						if(p_color < 0x0000DD00) {
							p_color += 0x00005000;
							if(p_color > 0x0000FF00)
								p_color = 0x0000FF00;
							else if(p_color < 0x0000CC00)
21087558:	b0ffca36 	bltu	r22,r3,21087484 <__flash_rwdata_start+0xfffe523c>
								p_color = 0x0000CC00;
2108755c:	00f30014 	movui	r3,52224
21087560:	003fc806 	br	21087484 <__flash_rwdata_start+0xfffe523c>
						unsigned int p_color = bg_color & 0x0000FF00;
						if(p_color < 0x0000DD00) {
							p_color += 0x00005000;
							if(p_color > 0x0000FF00)
								p_color = 0x0000FF00;
							else if(p_color < 0x0000CC00)
21087564:	b73fa736 	bltu	r22,fp,21087404 <__flash_rwdata_start+0xfffe51bc>
								p_color = 0x0000CC00;
21087568:	07330014 	movui	fp,52224
2108756c:	003fa506 	br	21087404 <__flash_rwdata_start+0xfffe51bc>

				k++;
				mask = mask >> 1;

				if (mask == 0 || k >= c_width) {
					c_index++;
21087570:	d9800017 	ldw	r6,0(sp)
					b = font_glyph_bitmap[c_index];
21087574:	d8c00417 	ldw	r3,16(sp)

		for (int j = 0; j < c_height; j++) {
			int k = 0;
			unsigned char mask = 0x80;
			unsigned char b = font_glyph_bitmap[c_index];
			while(k < c_width) {
21087578:	d9000217 	ldw	r4,8(sp)

				k++;
				mask = mask >> 1;

				if (mask == 0 || k >= c_width) {
					c_index++;
2108757c:	31800044 	addi	r6,r6,1
					b = font_glyph_bitmap[c_index];
21087580:	1985883a 	add	r2,r3,r6
21087584:	10800003 	ldbu	r2,0(r2)

				k++;
				mask = mask >> 1;

				if (mask == 0 || k >= c_width) {
					c_index++;
21087588:	d9800015 	stw	r6,0(sp)
					b = font_glyph_bitmap[c_index];
2108758c:	d8800105 	stb	r2,4(sp)

		for (int j = 0; j < c_height; j++) {
			int k = 0;
			unsigned char mask = 0x80;
			unsigned char b = font_glyph_bitmap[c_index];
			while(k < c_width) {
21087590:	7100050e 	bge	r14,r4,210875a8 <ece423_video_display_text_frame+0x420>
				mask = mask >> 1;

				if (mask == 0 || k >= c_width) {
					c_index++;
					b = font_glyph_bitmap[c_index];
					mask = 0x80;
21087594:	023fe004 	movi	r8,-128
21087598:	003fe606 	br	21087534 <__flash_rwdata_start+0xfffe52ec>

				k++;
				mask = mask >> 1;

				if (mask == 0 || k >= c_width) {
					c_index++;
2108759c:	d8c00017 	ldw	r3,0(sp)
210875a0:	18c00044 	addi	r3,r3,1
210875a4:	d8c00015 	stw	r3,0(sp)
		int c_offset = text[i] - 32;

		int c_width = font_glyph_dsc[c_offset].w_px;
		int c_index = font_glyph_dsc[c_offset].glyph_index;

		for (int j = 0; j < c_height; j++) {
210875a8:	d9800817 	ldw	r6,32(sp)
210875ac:	d9c00617 	ldw	r7,24(sp)
210875b0:	7bc00104 	addi	r15,r15,4
210875b4:	31800044 	addi	r6,r6,1
210875b8:	d9800815 	stw	r6,32(sp)
210875bc:	31ff631e 	bne	r6,r7,2108734c <__flash_rwdata_start+0xfffe5104>
					b = font_glyph_bitmap[c_index];
					mask = 0x80;
				}
			}
		}
		x_offset += scale*c_width + spacing;
210875c0:	d8c00217 	ldw	r3,8(sp)
	uint color = rgb2ycbcr(rgb_color);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {
210875c4:	d9800717 	ldw	r6,28(sp)
210875c8:	d9000517 	ldw	r4,20(sp)
					b = font_glyph_bitmap[c_index];
					mask = 0x80;
				}
			}
		}
		x_offset += scale*c_width + spacing;
210875cc:	18c5883a 	add	r2,r3,r3
210875d0:	1085883a 	add	r2,r2,r2
	uint color = rgb2ycbcr(rgb_color);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {
210875d4:	31800044 	addi	r6,r6,1
					b = font_glyph_bitmap[c_index];
					mask = 0x80;
				}
			}
		}
		x_offset += scale*c_width + spacing;
210875d8:	90a5883a 	add	r18,r18,r2
	uint color = rgb2ycbcr(rgb_color);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {
210875dc:	d9800715 	stw	r6,28(sp)
210875e0:	108e7200 	call	2108e720 <strlen>
210875e4:	d9c00717 	ldw	r7,28(sp)
210875e8:	38bf4736 	bltu	r7,r2,21087308 <__flash_rwdata_start+0xfffe50c0>
	 * Note: The new buffer_being_written may NOT Yet be FREE
	 * So Call
	 * ece423_video_display_buffer_is_available
	 * to Check Before Drawing in it
	 */
	if(display->video_name)
210875ec:	89402e17 	ldw	r5,184(r17)
210875f0:	28000326 	beq	r5,zero,21087600 <ece423_video_display_text_frame+0x478>
		ece423_video_display_add_text(display, display->video_name, 10, 10, RGB_BLACK, 1);
210875f4:	8809883a 	mov	r4,r17
210875f8:	01800284 	movi	r6,10
210875fc:	108538c0 	call	2108538c <ece423_video_display_add_text.constprop.2>
	display->buffer_being_written = (display->buffer_being_written + 1)
21087600:	88c02717 	ldw	r3,156(r17)
			% display->num_frame_buffers;
21087604:	89002c17 	ldw	r4,176(r17)
int ece423_video_display_switch_frames(ece423_video_display* display) {
	int iNext_Rd_Buf;

	alt_u32 RD_Desc_Fifo_Level;

	iNext_Rd_Buf = ((display->buffer_being_displayed + 1)
21087608:	88802617 	ldw	r2,152(r17)
	 * ece423_video_display_buffer_is_available
	 * to Check Before Drawing in it
	 */
	if(display->video_name)
		ece423_video_display_add_text(display, display->video_name, 10, 10, RGB_BLACK, 1);
	display->buffer_being_written = (display->buffer_being_written + 1)
2108760c:	18c00044 	addi	r3,r3,1
			% display->num_frame_buffers;
21087610:	190b283a 	div	r5,r3,r4
int ece423_video_display_switch_frames(ece423_video_display* display) {
	int iNext_Rd_Buf;

	alt_u32 RD_Desc_Fifo_Level;

	iNext_Rd_Buf = ((display->buffer_being_displayed + 1)
21087614:	10800044 	addi	r2,r2,1
	 * to Check Before Drawing in it
	 */
	if(display->video_name)
		ece423_video_display_add_text(display, display->video_name, 10, 10, RGB_BLACK, 1);
	display->buffer_being_written = (display->buffer_being_written + 1)
			% display->num_frame_buffers;
21087618:	290b383a 	mul	r5,r5,r4
int ece423_video_display_switch_frames(ece423_video_display* display) {
	int iNext_Rd_Buf;

	alt_u32 RD_Desc_Fifo_Level;

	iNext_Rd_Buf = ((display->buffer_being_displayed + 1)
2108761c:	1125283a 	div	r18,r2,r4
21087620:	9109383a 	mul	r4,r18,r4
	 * to Check Before Drawing in it
	 */
	if(display->video_name)
		ece423_video_display_add_text(display, display->video_name, 10, 10, RGB_BLACK, 1);
	display->buffer_being_written = (display->buffer_being_written + 1)
			% display->num_frame_buffers;
21087624:	1947c83a 	sub	r3,r3,r5
	 * ece423_video_display_buffer_is_available
	 * to Check Before Drawing in it
	 */
	if(display->video_name)
		ece423_video_display_add_text(display, display->video_name, 10, 10, RGB_BLACK, 1);
	display->buffer_being_written = (display->buffer_being_written + 1)
21087628:	88c02715 	stw	r3,156(r17)
int ece423_video_display_switch_frames(ece423_video_display* display) {
	int iNext_Rd_Buf;

	alt_u32 RD_Desc_Fifo_Level;

	iNext_Rd_Buf = ((display->buffer_being_displayed + 1)
2108762c:	1125c83a 	sub	r18,r2,r4
			% display->num_frame_buffers);

	// Check if there is a new buffer to display
	if ((iNext_Rd_Buf != display->buffer_being_written)) {
21087630:	1c801026 	beq	r3,r18,21087674 <ece423_video_display_text_frame+0x4ec>
21087634:	90800044 	addi	r2,r18,1

		// Transfer Descriptor for Frame to mSGDMA
		while (alt_msgdma_standard_descriptor_async_transfer(display->mSGDMA,
				display->buffer_ptrs[iNext_Rd_Buf]->desc_base) != 0) {
21087638:	1085883a 	add	r2,r2,r2
2108763c:	1085883a 	add	r2,r2,r2
21087640:	88a1883a 	add	r16,r17,r2

	// Check if there is a new buffer to display
	if ((iNext_Rd_Buf != display->buffer_being_written)) {

		// Transfer Descriptor for Frame to mSGDMA
		while (alt_msgdma_standard_descriptor_async_transfer(display->mSGDMA,
21087644:	80800017 	ldw	r2,0(r16)
21087648:	89000017 	ldw	r4,0(r17)
2108764c:	11400017 	ldw	r5,0(r2)
21087650:	109d1400 	call	2109d140 <alt_msgdma_standard_descriptor_async_transfer>
21087654:	103ffb1e 	bne	r2,zero,21087644 <__flash_rwdata_start+0xfffe53fc>
21087658:	89000017 	ldw	r4,0(r17)
		do {
			RD_Desc_Fifo_Level = (IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(
					display->mSGDMA->csr_base)
					& ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK)
					>> ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		} while (RD_Desc_Fifo_Level > 1);
2108765c:	00c00044 	movi	r3,1
				display->buffer_ptrs[iNext_Rd_Buf]->desc_base) != 0) {
		}  // Keep Trying until there is room to Transfer another Frame

		// Wait if there is another frame waiting in the list
		do {
			RD_Desc_Fifo_Level = (IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(
21087660:	20800317 	ldw	r2,12(r4)
21087664:	10800237 	ldwio	r2,8(r2)
21087668:	10bfffcc 	andi	r2,r2,65535
					display->mSGDMA->csr_base)
					& ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK)
					>> ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		} while (RD_Desc_Fifo_Level > 1);
2108766c:	18bffc36 	bltu	r3,r2,21087660 <__flash_rwdata_start+0xfffe5418>

		display->buffer_being_displayed = iNext_Rd_Buf;
21087670:	8c802615 	stw	r18,152(r17)
	// int y = 5*display->height/10;
	int y = (display->height - font_height*scale)/2;
	ece423_video_display_add_text(display, text, x, y, RGB_RED, scale);
	ece423_video_display_register_written_buffer(display);
	ece423_video_display_switch_frames(display);
}
21087674:	dfc01317 	ldw	ra,76(sp)
21087678:	df001217 	ldw	fp,72(sp)
2108767c:	ddc01117 	ldw	r23,68(sp)
21087680:	dd801017 	ldw	r22,64(sp)
21087684:	dd400f17 	ldw	r21,60(sp)
21087688:	dd000e17 	ldw	r20,56(sp)
2108768c:	dcc00d17 	ldw	r19,52(sp)
21087690:	dc800c17 	ldw	r18,48(sp)
21087694:	dc400b17 	ldw	r17,44(sp)
21087698:	dc000a17 	ldw	r16,40(sp)
2108769c:	dec01404 	addi	sp,sp,80
210876a0:	f800283a 	ret

210876a4 <ece423_video_display_text_on_last_frame>:
 *
 ******************************************************************/
void ece423_video_display_text_on_last_frame(ece423_video_display* display, char* text) {

	// copy current buffer
	int* frame = display->buffer_ptrs[display->buffer_being_displayed]->buffer;
210876a4:	20802617 	ldw	r2,152(r4)
 *  Function: ece423_video_display_text_on_last_frame
 *
 *  Purpose: Add a string to the screen
 *
 ******************************************************************/
void ece423_video_display_text_on_last_frame(ece423_video_display* display, char* text) {
210876a8:	deffeb04 	addi	sp,sp,-84

	// copy current buffer
	int* frame = display->buffer_ptrs[display->buffer_being_displayed]->buffer;
	int* text_frame = display->text_buffer_ptr->buffer;
210876ac:	20c02517 	ldw	r3,148(r4)
 *
 ******************************************************************/
void ece423_video_display_text_on_last_frame(ece423_video_display* display, char* text) {

	// copy current buffer
	int* frame = display->buffer_ptrs[display->buffer_being_displayed]->buffer;
210876b0:	10800044 	addi	r2,r2,1
210876b4:	1085883a 	add	r2,r2,r2
 *  Function: ece423_video_display_text_on_last_frame
 *
 *  Purpose: Add a string to the screen
 *
 ******************************************************************/
void ece423_video_display_text_on_last_frame(ece423_video_display* display, char* text) {
210876b8:	dc400c15 	stw	r17,48(sp)

	// copy current buffer
	int* frame = display->buffer_ptrs[display->buffer_being_displayed]->buffer;
210876bc:	1085883a 	add	r2,r2,r2
 *  Function: ece423_video_display_text_on_last_frame
 *
 *  Purpose: Add a string to the screen
 *
 ******************************************************************/
void ece423_video_display_text_on_last_frame(ece423_video_display* display, char* text) {
210876c0:	2023883a 	mov	r17,r4

	// copy current buffer
	int* frame = display->buffer_ptrs[display->buffer_being_displayed]->buffer;
210876c4:	8885883a 	add	r2,r17,r2
	int* text_frame = display->text_buffer_ptr->buffer;
210876c8:	d8c00915 	stw	r3,36(sp)
 *
 ******************************************************************/
void ece423_video_display_text_on_last_frame(ece423_video_display* display, char* text) {

	// copy current buffer
	int* frame = display->buffer_ptrs[display->buffer_being_displayed]->buffer;
210876cc:	10800017 	ldw	r2,0(r2)
	int* text_frame = display->text_buffer_ptr->buffer;
210876d0:	d9800917 	ldw	r6,36(sp)
	for (int i = 0; i < display->bytes_per_frame / 4; i += 1)
210876d4:	21002b17 	ldw	r4,172(r4)
 *  Function: ece423_video_display_text_on_last_frame
 *
 *  Purpose: Add a string to the screen
 *
 ******************************************************************/
void ece423_video_display_text_on_last_frame(ece423_video_display* display, char* text) {
210876d8:	dc000b15 	stw	r16,44(sp)

	// copy current buffer
	int* frame = display->buffer_ptrs[display->buffer_being_displayed]->buffer;
210876dc:	10c00117 	ldw	r3,4(r2)
 *  Function: ece423_video_display_text_on_last_frame
 *
 *  Purpose: Add a string to the screen
 *
 ******************************************************************/
void ece423_video_display_text_on_last_frame(ece423_video_display* display, char* text) {
210876e0:	dfc01415 	stw	ra,80(sp)
210876e4:	df001315 	stw	fp,76(sp)
210876e8:	ddc01215 	stw	r23,72(sp)
210876ec:	dd801115 	stw	r22,68(sp)
210876f0:	dd401015 	stw	r21,64(sp)
210876f4:	dd000f15 	stw	r20,60(sp)
210876f8:	dcc00e15 	stw	r19,56(sp)
210876fc:	dc800d15 	stw	r18,52(sp)
21087700:	d9400715 	stw	r5,28(sp)

	// copy current buffer
	int* frame = display->buffer_ptrs[display->buffer_being_displayed]->buffer;
	int* text_frame = display->text_buffer_ptr->buffer;
	for (int i = 0; i < display->bytes_per_frame / 4; i += 1)
21087704:	008000c4 	movi	r2,3
 ******************************************************************/
void ece423_video_display_text_on_last_frame(ece423_video_display* display, char* text) {

	// copy current buffer
	int* frame = display->buffer_ptrs[display->buffer_being_displayed]->buffer;
	int* text_frame = display->text_buffer_ptr->buffer;
21087708:	34000117 	ldw	r16,4(r6)
	for (int i = 0; i < display->bytes_per_frame / 4; i += 1)
2108770c:	11000f0e 	bge	r2,r4,2108774c <ece423_video_display_text_on_last_frame+0xa8>
21087710:	800b883a 	mov	r5,r16
21087714:	0009883a 	mov	r4,zero
21087718:	00000206 	br	21087724 <ece423_video_display_text_on_last_frame+0x80>
2108771c:	1005d0ba 	srai	r2,r2,2
21087720:	20800a0e 	bge	r4,r2,2108774c <ece423_video_display_text_on_last_frame+0xa8>
		text_frame[i] = frame[i];
21087724:	18800017 	ldw	r2,0(r3)
void ece423_video_display_text_on_last_frame(ece423_video_display* display, char* text) {

	// copy current buffer
	int* frame = display->buffer_ptrs[display->buffer_being_displayed]->buffer;
	int* text_frame = display->text_buffer_ptr->buffer;
	for (int i = 0; i < display->bytes_per_frame / 4; i += 1)
21087728:	21000044 	addi	r4,r4,1
2108772c:	18c00104 	addi	r3,r3,4
		text_frame[i] = frame[i];
21087730:	28800015 	stw	r2,0(r5)
void ece423_video_display_text_on_last_frame(ece423_video_display* display, char* text) {

	// copy current buffer
	int* frame = display->buffer_ptrs[display->buffer_being_displayed]->buffer;
	int* text_frame = display->text_buffer_ptr->buffer;
	for (int i = 0; i < display->bytes_per_frame / 4; i += 1)
21087734:	88802b17 	ldw	r2,172(r17)
21087738:	29400104 	addi	r5,r5,4
2108773c:	103ff70e 	bge	r2,zero,2108771c <__flash_rwdata_start+0xfffe54d4>
21087740:	108000c4 	addi	r2,r2,3
21087744:	1005d0ba 	srai	r2,r2,2
21087748:	20bff616 	blt	r4,r2,21087724 <__flash_rwdata_start+0xfffe54dc>
2108774c:	d9000717 	ldw	r4,28(sp)
21087750:	108e7200 	call	2108e720 <strlen>
21087754:	d9000717 	ldw	r4,28(sp)
	int scale = 4;

	int text_width = 0;
	for(int i = 0; i < strlen(text); i++) {
		int c_offset = text[i] - 32;
		text_width += font_glyph_dsc[c_offset].w_px*scale;
21087758:	01400034 	movhi	r5,0
void ece423_video_display_text_on_last_frame(ece423_video_display* display, char* text) {

	// copy current buffer
	int* frame = display->buffer_ptrs[display->buffer_being_displayed]->buffer;
	int* text_frame = display->text_buffer_ptr->buffer;
	for (int i = 0; i < display->bytes_per_frame / 4; i += 1)
2108775c:	000d883a 	mov	r6,zero
21087760:	208f883a 	add	r7,r4,r2
	int scale = 4;

	int text_width = 0;
	for(int i = 0; i < strlen(text); i++) {
		int c_offset = text[i] - 32;
		text_width += font_glyph_dsc[c_offset].w_px*scale;
21087764:	29419004 	addi	r5,r5,1600

	// draw th text
	int scale = 4;

	int text_width = 0;
	for(int i = 0; i < strlen(text); i++) {
21087768:	21c00a26 	beq	r4,r7,21087794 <ece423_video_display_text_on_last_frame+0xf0>
		int c_offset = text[i] - 32;
2108776c:	20c00007 	ldb	r3,0(r4)
21087770:	21000044 	addi	r4,r4,1
		text_width += font_glyph_dsc[c_offset].w_px*scale;
21087774:	18fff804 	addi	r3,r3,-32
21087778:	180690fa 	slli	r3,r3,3
2108777c:	28c7883a 	add	r3,r5,r3
21087780:	18c00017 	ldw	r3,0(r3)
21087784:	18c7883a 	add	r3,r3,r3
21087788:	18c7883a 	add	r3,r3,r3
2108778c:	30cd883a 	add	r6,r6,r3

	// draw th text
	int scale = 4;

	int text_width = 0;
	for(int i = 0; i < strlen(text); i++) {
21087790:	21fff61e 	bne	r4,r7,2108776c <__flash_rwdata_start+0xfffe5524>
		int c_offset = text[i] - 32;
		text_width += font_glyph_dsc[c_offset].w_px*scale;
	}
	int x = (display->width - text_width)/2;
21087794:	88c02817 	ldw	r3,160(r17)
	// int y = (display->height - font_height*scale)/2;
	int y = (display->height - font_height*scale - 20);
21087798:	01000034 	movhi	r4,0
2108779c:	21176304 	addi	r4,r4,23948
	int text_width = 0;
	for(int i = 0; i < strlen(text); i++) {
		int c_offset = text[i] - 32;
		text_width += font_glyph_dsc[c_offset].w_px*scale;
	}
	int x = (display->width - text_width)/2;
210877a0:	1987c83a 	sub	r3,r3,r6
210877a4:	1824d7fa 	srli	r18,r3,31
	// int y = (display->height - font_height*scale)/2;
	int y = (display->height - font_height*scale - 20);
210877a8:	21000017 	ldw	r4,0(r4)
210877ac:	89402917 	ldw	r5,164(r17)
	int text_width = 0;
	for(int i = 0; i < strlen(text); i++) {
		int c_offset = text[i] - 32;
		text_width += font_glyph_dsc[c_offset].w_px*scale;
	}
	int x = (display->width - text_width)/2;
210877b0:	90c7883a 	add	r3,r18,r3
210877b4:	1825d07a 	srai	r18,r3,1
		int c_index = font_glyph_dsc[c_offset].glyph_index;

		for (int j = 0; j < c_height; j++) {
			int k = 0;
			unsigned char mask = 0x80;
			unsigned char b = font_glyph_bitmap[c_index];
210877b8:	00c00034 	movhi	r3,0
		int c_offset = text[i] - 32;
		text_width += font_glyph_dsc[c_offset].w_px*scale;
	}
	int x = (display->width - text_width)/2;
	// int y = (display->height - font_height*scale)/2;
	int y = (display->height - font_height*scale - 20);
210877bc:	d9000615 	stw	r4,24(sp)
		int c_index = font_glyph_dsc[c_offset].glyph_index;

		for (int j = 0; j < c_height; j++) {
			int k = 0;
			unsigned char mask = 0x80;
			unsigned char b = font_glyph_bitmap[c_index];
210877c0:	18d78004 	addi	r3,r3,24064
		int c_offset = text[i] - 32;
		text_width += font_glyph_dsc[c_offset].w_px*scale;
	}
	int x = (display->width - text_width)/2;
	// int y = (display->height - font_height*scale)/2;
	int y = (display->height - font_height*scale - 20);
210877c4:	2109883a 	add	r4,r4,r4
210877c8:	2109883a 	add	r4,r4,r4
		int c_index = font_glyph_dsc[c_offset].glyph_index;

		for (int j = 0; j < c_height; j++) {
			int k = 0;
			unsigned char mask = 0x80;
			unsigned char b = font_glyph_bitmap[c_index];
210877cc:	18c00017 	ldw	r3,0(r3)
	uint color = rgb2ycbcr(RGB_BLACK);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {
210877d0:	d8000815 	stw	zero,32(sp)
		int c_offset = text[i] - 32;
		text_width += font_glyph_dsc[c_offset].w_px*scale;
	}
	int x = (display->width - text_width)/2;
	// int y = (display->height - font_height*scale)/2;
	int y = (display->height - font_height*scale - 20);
210877d4:	2909c83a 	sub	r4,r5,r4
	uint color = rgb2ycbcr(RGB_BLACK);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {
210877d8:	d9800817 	ldw	r6,32(sp)
210877dc:	213ffc04 	addi	r4,r4,-16
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;

						if(b & mask) {
							text_frame[frame_offset] = color;
210877e0:	04c02034 	movhi	r19,128
							p_color += 0x00005000;
							if(p_color > 0x0000FF00)
								p_color = 0x0000FF00;
							else if(p_color < 0x0000CC00)
								p_color = 0x0000CC00;
							text_frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
210877e4:	05fffff4 	movhi	r23,65535
		int c_index = font_glyph_dsc[c_offset].glyph_index;

		for (int j = 0; j < c_height; j++) {
			int k = 0;
			unsigned char mask = 0x80;
			unsigned char b = font_glyph_bitmap[c_index];
210877e8:	d8c00415 	stw	r3,16(sp)
210877ec:	d9000a15 	stw	r4,40(sp)
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;

						if(b & mask) {
							text_frame[frame_offset] = color;
210877f0:	9cc02004 	addi	r19,r19,128
							continue;
						}
						unsigned int bg_color = text_frame[frame_offset];
						unsigned int p_color = bg_color & 0x0000FF00;
						if(p_color < 0x0000DD00) {
210877f4:	05373fd4 	movui	r20,56575
							p_color += 0x00005000;
							if(p_color > 0x0000FF00)
210877f8:	057fc014 	movui	r21,65280
								p_color = 0x0000FF00;
							else if(p_color < 0x0000CC00)
210877fc:	05b2ffd4 	movui	r22,52223
								p_color = 0x0000CC00;
							text_frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
21087800:	bdc03fc4 	addi	r23,r23,255
	uint color = rgb2ycbcr(RGB_BLACK);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {
21087804:	3080b72e 	bgeu	r6,r2,21087ae4 <ece423_video_display_text_on_last_frame+0x440>
21087808:	d8c00717 	ldw	r3,28(sp)
		int c_offset = text[i] - 32;

		int c_width = font_glyph_dsc[c_offset].w_px;
2108780c:	01c00034 	movhi	r7,0
21087810:	39c19004 	addi	r7,r7,1600
21087814:	1985883a 	add	r2,r3,r6
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {
		int c_offset = text[i] - 32;
21087818:	10800007 	ldb	r2,0(r2)
2108781c:	10bff804 	addi	r2,r2,-32

		int c_width = font_glyph_dsc[c_offset].w_px;
21087820:	100490fa 	slli	r2,r2,3
21087824:	3887883a 	add	r3,r7,r2
		int c_index = font_glyph_dsc[c_offset].glyph_index;
21087828:	1805883a 	mov	r2,r3

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {
		int c_offset = text[i] - 32;

		int c_width = font_glyph_dsc[c_offset].w_px;
2108782c:	18c00017 	ldw	r3,0(r3)
		int c_index = font_glyph_dsc[c_offset].glyph_index;
21087830:	10800117 	ldw	r2,4(r2)

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {
		int c_offset = text[i] - 32;

		int c_width = font_glyph_dsc[c_offset].w_px;
21087834:	d8c00215 	stw	r3,8(sp)
		int c_index = font_glyph_dsc[c_offset].glyph_index;

		for (int j = 0; j < c_height; j++) {
21087838:	d8c00617 	ldw	r3,24(sp)
	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {
		int c_offset = text[i] - 32;

		int c_width = font_glyph_dsc[c_offset].w_px;
		int c_index = font_glyph_dsc[c_offset].glyph_index;
2108783c:	d8800015 	stw	r2,0(sp)

		for (int j = 0; j < c_height; j++) {
21087840:	00c09d0e 	bge	zero,r3,21087ab8 <ece423_video_display_text_on_last_frame+0x414>
21087844:	dbc00a17 	ldw	r15,40(sp)
21087848:	d8000515 	stw	zero,20(sp)
			int k = 0;
			unsigned char mask = 0x80;
			unsigned char b = font_glyph_bitmap[c_index];
2108784c:	d9800417 	ldw	r6,16(sp)
21087850:	d9c00017 	ldw	r7,0(sp)
21087854:	31c5883a 	add	r2,r6,r7
21087858:	10800003 	ldbu	r2,0(r2)
2108785c:	d8800105 	stb	r2,4(sp)
			while(k < c_width) {
21087860:	d8800217 	ldw	r2,8(sp)
21087864:	00808e0e 	bge	zero,r2,21087aa0 <ece423_video_display_text_on_last_frame+0x3fc>
21087868:	78ffff04 	addi	r3,r15,-4
2108786c:	020000c4 	movi	r8,3
21087870:	01bfe004 	movi	r6,-128
21087874:	0013883a 	mov	r9,zero
21087878:	d8c00315 	stw	r3,12(sp)
2108787c:	1809883a 	mov	r4,r3
21087880:	d8800103 	ldbu	r2,4(sp)
21087884:	4a4b883a 	add	r5,r9,r9
21087888:	42bfffc4 	addi	r10,r8,-1
2108788c:	308e703a 	and	r7,r6,r2
21087890:	42ffff84 	addi	r11,r8,-2
21087894:	294b883a 	add	r5,r5,r5
21087898:	39c03fcc 	andi	r7,r7,255
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;

						if(b & mask) {
							text_frame[frame_offset] = color;
2108789c:	92dd883a 	add	r14,r18,r11
210878a0:	929b883a 	add	r13,r18,r10
210878a4:	9219883a 	add	r12,r18,r8

				for(int l = 0; l < scale; l++)
					for(int m = 0; m < scale; m++) {
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;
210878a8:	88802817 	ldw	r2,160(r17)
210878ac:	2085383a 	mul	r2,r4,r2
210878b0:	1485883a 	add	r2,r2,r18
210878b4:	1147883a 	add	r3,r2,r5

						if(b & mask) {
							text_frame[frame_offset] = color;
210878b8:	18c7883a 	add	r3,r3,r3
210878bc:	18c7883a 	add	r3,r3,r3
210878c0:	80c7883a 	add	r3,r16,r3
					for(int m = 0; m < scale; m++) {
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;

						if(b & mask) {
210878c4:	3800451e 	bne	r7,zero,210879dc <ece423_video_display_text_on_last_frame+0x338>
							text_frame[frame_offset] = color;
							continue;
						}
						unsigned int bg_color = text_frame[frame_offset];
210878c8:	1fc00017 	ldw	ra,0(r3)
						unsigned int p_color = bg_color & 0x0000FF00;
210878cc:	ff3fc00c 	andi	fp,ra,65280
						if(p_color < 0x0000DD00) {
210878d0:	a7000936 	bltu	r20,fp,210878f8 <ece423_video_display_text_on_last_frame+0x254>
							p_color += 0x00005000;
210878d4:	e7140004 	addi	fp,fp,20480
							if(p_color > 0x0000FF00)
210878d8:	af005a2e 	bgeu	r21,fp,21087a44 <ece423_video_display_text_on_last_frame+0x3a0>
								p_color = 0x0000FF00;
210878dc:	073fc014 	movui	fp,65280
							else if(p_color < 0x0000CC00)
								p_color = 0x0000CC00;
							text_frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
210878e0:	fdfe703a 	and	ra,ra,r23
210878e4:	e7f8b03a 	or	fp,fp,ra
210878e8:	1f000015 	stw	fp,0(r3)
210878ec:	88802817 	ldw	r2,160(r17)
210878f0:	2085383a 	mul	r2,r4,r2
210878f4:	9085883a 	add	r2,r18,r2

				for(int l = 0; l < scale; l++)
					for(int m = 0; m < scale; m++) {
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;
210878f8:	5887883a 	add	r3,r11,r2

						if(b & mask) {
							text_frame[frame_offset] = color;
							continue;
						}
						unsigned int bg_color = text_frame[frame_offset];
210878fc:	18c7883a 	add	r3,r3,r3
21087900:	18c7883a 	add	r3,r3,r3
21087904:	80c7883a 	add	r3,r16,r3
21087908:	1fc00017 	ldw	ra,0(r3)
						unsigned int p_color = bg_color & 0x0000FF00;
2108790c:	ff3fc00c 	andi	fp,ra,65280
						if(p_color < 0x0000DD00) {
21087910:	a7000936 	bltu	r20,fp,21087938 <ece423_video_display_text_on_last_frame+0x294>
							p_color += 0x00005000;
21087914:	e7140004 	addi	fp,fp,20480
							if(p_color > 0x0000FF00)
21087918:	af00472e 	bgeu	r21,fp,21087a38 <ece423_video_display_text_on_last_frame+0x394>
								p_color = 0x0000FF00;
2108791c:	073fc014 	movui	fp,65280
							else if(p_color < 0x0000CC00)
								p_color = 0x0000CC00;
							text_frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
21087920:	fdfe703a 	and	ra,ra,r23
21087924:	e7f8b03a 	or	fp,fp,ra
21087928:	1f000015 	stw	fp,0(r3)
2108792c:	88802817 	ldw	r2,160(r17)
21087930:	2085383a 	mul	r2,r4,r2
21087934:	9085883a 	add	r2,r18,r2

				for(int l = 0; l < scale; l++)
					for(int m = 0; m < scale; m++) {
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;
21087938:	5087883a 	add	r3,r10,r2

						if(b & mask) {
							text_frame[frame_offset] = color;
							continue;
						}
						unsigned int bg_color = text_frame[frame_offset];
2108793c:	18c7883a 	add	r3,r3,r3
21087940:	18c7883a 	add	r3,r3,r3
21087944:	80c7883a 	add	r3,r16,r3
21087948:	1fc00017 	ldw	ra,0(r3)
						unsigned int p_color = bg_color & 0x0000FF00;
2108794c:	ff3fc00c 	andi	fp,ra,65280
						if(p_color < 0x0000DD00) {
21087950:	a7000936 	bltu	r20,fp,21087978 <ece423_video_display_text_on_last_frame+0x2d4>
							p_color += 0x00005000;
21087954:	e7140004 	addi	fp,fp,20480
							if(p_color > 0x0000FF00)
21087958:	af003d2e 	bgeu	r21,fp,21087a50 <ece423_video_display_text_on_last_frame+0x3ac>
								p_color = 0x0000FF00;
2108795c:	073fc014 	movui	fp,65280
							else if(p_color < 0x0000CC00)
								p_color = 0x0000CC00;
							text_frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
21087960:	fdfe703a 	and	ra,ra,r23
21087964:	e7f8b03a 	or	fp,fp,ra
21087968:	1f000015 	stw	fp,0(r3)
2108796c:	88802817 	ldw	r2,160(r17)
21087970:	2085383a 	mul	r2,r4,r2
21087974:	9085883a 	add	r2,r18,r2

				for(int l = 0; l < scale; l++)
					for(int m = 0; m < scale; m++) {
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;
21087978:	1205883a 	add	r2,r2,r8

						if(b & mask) {
							text_frame[frame_offset] = color;
							continue;
						}
						unsigned int bg_color = text_frame[frame_offset];
2108797c:	1085883a 	add	r2,r2,r2
21087980:	1085883a 	add	r2,r2,r2
21087984:	8085883a 	add	r2,r16,r2
21087988:	17000017 	ldw	fp,0(r2)
						unsigned int p_color = bg_color & 0x0000FF00;
2108798c:	e0ffc00c 	andi	r3,fp,65280
						if(p_color < 0x0000DD00) {
21087990:	a0c00636 	bltu	r20,r3,210879ac <ece423_video_display_text_on_last_frame+0x308>
							p_color += 0x00005000;
21087994:	18d40004 	addi	r3,r3,20480
							if(p_color > 0x0000FF00)
21087998:	a8c0302e 	bgeu	r21,r3,21087a5c <ece423_video_display_text_on_last_frame+0x3b8>
								p_color = 0x0000FF00;
2108799c:	00ffc014 	movui	r3,65280
							else if(p_color < 0x0000CC00)
								p_color = 0x0000CC00;
							text_frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
210879a0:	e5f8703a 	and	fp,fp,r23
210879a4:	1f06b03a 	or	r3,r3,fp
210879a8:	10c00015 	stw	r3,0(r2)
210879ac:	21000044 	addi	r4,r4,1
			int k = 0;
			unsigned char mask = 0x80;
			unsigned char b = font_glyph_bitmap[c_index];
			while(k < c_width) {

				for(int l = 0; l < scale; l++)
210879b0:	793fbd1e 	bne	r15,r4,210878a8 <__flash_rwdata_start+0xfffe5660>
							text_frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
						}
					}

				k++;
				mask = mask >> 1;
210879b4:	31803fcc 	andi	r6,r6,255
210879b8:	3004d07a 	srli	r2,r6,1
								p_color = 0x0000CC00;
							text_frame[frame_offset] = (bg_color & 0xFFFF00FF) | p_color;
						}
					}

				k++;
210879bc:	4a400044 	addi	r9,r9,1
				mask = mask >> 1;
210879c0:	100d883a 	mov	r6,r2

				if (mask == 0 || k >= c_width) {
210879c4:	10002826 	beq	r2,zero,21087a68 <ece423_video_display_text_on_last_frame+0x3c4>
210879c8:	d9000217 	ldw	r4,8(sp)
210879cc:	4900310e 	bge	r9,r4,21087a94 <ece423_video_display_text_on_last_frame+0x3f0>
210879d0:	42000104 	addi	r8,r8,4
210879d4:	d9000317 	ldw	r4,12(sp)
210879d8:	003fa906 	br	21087880 <__flash_rwdata_start+0xfffe5638>
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;

						if(b & mask) {
							text_frame[frame_offset] = color;
210879dc:	1cc00015 	stw	r19,0(r3)

				for(int l = 0; l < scale; l++)
					for(int m = 0; m < scale; m++) {
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;
210879e0:	88802817 	ldw	r2,160(r17)
210879e4:	2085383a 	mul	r2,r4,r2

						if(b & mask) {
							text_frame[frame_offset] = color;
210879e8:	7085883a 	add	r2,r14,r2
210879ec:	1085883a 	add	r2,r2,r2
210879f0:	1085883a 	add	r2,r2,r2
210879f4:	8085883a 	add	r2,r16,r2
210879f8:	14c00015 	stw	r19,0(r2)

				for(int l = 0; l < scale; l++)
					for(int m = 0; m < scale; m++) {
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;
210879fc:	88802817 	ldw	r2,160(r17)
21087a00:	2085383a 	mul	r2,r4,r2

						if(b & mask) {
							text_frame[frame_offset] = color;
21087a04:	6885883a 	add	r2,r13,r2
21087a08:	1085883a 	add	r2,r2,r2
21087a0c:	1085883a 	add	r2,r2,r2
21087a10:	8085883a 	add	r2,r16,r2
21087a14:	14c00015 	stw	r19,0(r2)

				for(int l = 0; l < scale; l++)
					for(int m = 0; m < scale; m++) {
						int jl = j*scale + l;
						int km = k*scale + m;
						int frame_offset = x_offset + (jl + y_offset)* display->width + km;
21087a18:	88802817 	ldw	r2,160(r17)
21087a1c:	2085383a 	mul	r2,r4,r2

						if(b & mask) {
							text_frame[frame_offset] = color;
21087a20:	6085883a 	add	r2,r12,r2
21087a24:	1085883a 	add	r2,r2,r2
21087a28:	1085883a 	add	r2,r2,r2
21087a2c:	8085883a 	add	r2,r16,r2
21087a30:	14c00015 	stw	r19,0(r2)
21087a34:	003fdd06 	br	210879ac <__flash_rwdata_start+0xfffe5764>
						unsigned int p_color = bg_color & 0x0000FF00;
						if(p_color < 0x0000DD00) {
							p_color += 0x00005000;
							if(p_color > 0x0000FF00)
								p_color = 0x0000FF00;
							else if(p_color < 0x0000CC00)
21087a38:	b73fb936 	bltu	r22,fp,21087920 <__flash_rwdata_start+0xfffe56d8>
								p_color = 0x0000CC00;
21087a3c:	07330014 	movui	fp,52224
21087a40:	003fb706 	br	21087920 <__flash_rwdata_start+0xfffe56d8>
						unsigned int p_color = bg_color & 0x0000FF00;
						if(p_color < 0x0000DD00) {
							p_color += 0x00005000;
							if(p_color > 0x0000FF00)
								p_color = 0x0000FF00;
							else if(p_color < 0x0000CC00)
21087a44:	b73fa636 	bltu	r22,fp,210878e0 <__flash_rwdata_start+0xfffe5698>
								p_color = 0x0000CC00;
21087a48:	07330014 	movui	fp,52224
21087a4c:	003fa406 	br	210878e0 <__flash_rwdata_start+0xfffe5698>
						unsigned int p_color = bg_color & 0x0000FF00;
						if(p_color < 0x0000DD00) {
							p_color += 0x00005000;
							if(p_color > 0x0000FF00)
								p_color = 0x0000FF00;
							else if(p_color < 0x0000CC00)
21087a50:	b73fc336 	bltu	r22,fp,21087960 <__flash_rwdata_start+0xfffe5718>
								p_color = 0x0000CC00;
21087a54:	07330014 	movui	fp,52224
21087a58:	003fc106 	br	21087960 <__flash_rwdata_start+0xfffe5718>
						unsigned int p_color = bg_color & 0x0000FF00;
						if(p_color < 0x0000DD00) {
							p_color += 0x00005000;
							if(p_color > 0x0000FF00)
								p_color = 0x0000FF00;
							else if(p_color < 0x0000CC00)
21087a5c:	b0ffd036 	bltu	r22,r3,210879a0 <__flash_rwdata_start+0xfffe5758>
								p_color = 0x0000CC00;
21087a60:	00f30014 	movui	r3,52224
21087a64:	003fce06 	br	210879a0 <__flash_rwdata_start+0xfffe5758>

				k++;
				mask = mask >> 1;

				if (mask == 0 || k >= c_width) {
					c_index++;
21087a68:	d9800017 	ldw	r6,0(sp)
					b = font_glyph_bitmap[c_index];
21087a6c:	d9c00417 	ldw	r7,16(sp)

				k++;
				mask = mask >> 1;

				if (mask == 0 || k >= c_width) {
					c_index++;
21087a70:	31800044 	addi	r6,r6,1
					b = font_glyph_bitmap[c_index];
21087a74:	3985883a 	add	r2,r7,r6
21087a78:	10800003 	ldbu	r2,0(r2)

				k++;
				mask = mask >> 1;

				if (mask == 0 || k >= c_width) {
					c_index++;
21087a7c:	d9800015 	stw	r6,0(sp)
					b = font_glyph_bitmap[c_index];
21087a80:	d8800105 	stb	r2,4(sp)

		for (int j = 0; j < c_height; j++) {
			int k = 0;
			unsigned char mask = 0x80;
			unsigned char b = font_glyph_bitmap[c_index];
			while(k < c_width) {
21087a84:	d8800217 	ldw	r2,8(sp)
21087a88:	4880050e 	bge	r9,r2,21087aa0 <ece423_video_display_text_on_last_frame+0x3fc>
				mask = mask >> 1;

				if (mask == 0 || k >= c_width) {
					c_index++;
					b = font_glyph_bitmap[c_index];
					mask = 0x80;
21087a8c:	01bfe004 	movi	r6,-128
21087a90:	003fcf06 	br	210879d0 <__flash_rwdata_start+0xfffe5788>

				k++;
				mask = mask >> 1;

				if (mask == 0 || k >= c_width) {
					c_index++;
21087a94:	d8c00017 	ldw	r3,0(sp)
21087a98:	18c00044 	addi	r3,r3,1
21087a9c:	d8c00015 	stw	r3,0(sp)
		int c_offset = text[i] - 32;

		int c_width = font_glyph_dsc[c_offset].w_px;
		int c_index = font_glyph_dsc[c_offset].glyph_index;

		for (int j = 0; j < c_height; j++) {
21087aa0:	d8c00517 	ldw	r3,20(sp)
21087aa4:	d9800617 	ldw	r6,24(sp)
21087aa8:	7bc00104 	addi	r15,r15,4
21087aac:	18c00044 	addi	r3,r3,1
21087ab0:	d8c00515 	stw	r3,20(sp)
21087ab4:	19bf651e 	bne	r3,r6,2108784c <__flash_rwdata_start+0xfffe5604>
					b = font_glyph_bitmap[c_index];
					mask = 0x80;
				}
			}
		}
		x_offset += scale*c_width + spacing;
21087ab8:	d9c00217 	ldw	r7,8(sp)
	uint color = rgb2ycbcr(RGB_BLACK);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {
21087abc:	d8c00817 	ldw	r3,32(sp)
21087ac0:	d9000717 	ldw	r4,28(sp)
					b = font_glyph_bitmap[c_index];
					mask = 0x80;
				}
			}
		}
		x_offset += scale*c_width + spacing;
21087ac4:	39c5883a 	add	r2,r7,r7
21087ac8:	1085883a 	add	r2,r2,r2
	uint color = rgb2ycbcr(RGB_BLACK);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {
21087acc:	18c00044 	addi	r3,r3,1
					b = font_glyph_bitmap[c_index];
					mask = 0x80;
				}
			}
		}
		x_offset += scale*c_width + spacing;
21087ad0:	90a5883a 	add	r18,r18,r2
	uint color = rgb2ycbcr(RGB_BLACK);
	int x_offset = x;
	int y_offset = y;

	int c_height = font_height;
	for (int i = 0; i < strlen(text); i++) {
21087ad4:	d8c00815 	stw	r3,32(sp)
21087ad8:	108e7200 	call	2108e720 <strlen>
21087adc:	d9800817 	ldw	r6,32(sp)
21087ae0:	30bf4936 	bltu	r6,r2,21087808 <__flash_rwdata_start+0xfffe55c0>
21087ae4:	d8800917 	ldw	r2,36(sp)
21087ae8:	00000106 	br	21087af0 <ece423_video_display_text_on_last_frame+0x44c>
21087aec:	88802517 	ldw	r2,148(r17)
		x_offset += scale*c_width + spacing;
	}


	// Transfer Descriptor for Frame to mSGDMA
	while (alt_msgdma_standard_descriptor_async_transfer(display->mSGDMA,
21087af0:	11400017 	ldw	r5,0(r2)
21087af4:	89000017 	ldw	r4,0(r17)
21087af8:	109d1400 	call	2109d140 <alt_msgdma_standard_descriptor_async_transfer>
21087afc:	103ffb1e 	bne	r2,zero,21087aec <__flash_rwdata_start+0xfffe58a4>
			display->text_buffer_ptr->desc_base) != 0) {
	}  // Keep Trying until there is room to Transfer another Frame


}
21087b00:	dfc01417 	ldw	ra,80(sp)
21087b04:	df001317 	ldw	fp,76(sp)
21087b08:	ddc01217 	ldw	r23,72(sp)
21087b0c:	dd801117 	ldw	r22,68(sp)
21087b10:	dd401017 	ldw	r21,64(sp)
21087b14:	dd000f17 	ldw	r20,60(sp)
21087b18:	dcc00e17 	ldw	r19,56(sp)
21087b1c:	dc800d17 	ldw	r18,52(sp)
21087b20:	dc400c17 	ldw	r17,48(sp)
21087b24:	dc000b17 	ldw	r16,44(sp)
21087b28:	dec01504 	addi	sp,sp,84
21087b2c:	f800283a 	ret

21087b30 <ece423_video_display_get_descriptor_span>:
 *  MUST be SetUp Before Calling this func
 *
 * Returns: Size (in bytes) of descriptor memory required.
 ******************************************************************/
alt_u32 ece423_video_display_get_descriptor_span(ece423_video_display *display) {
	return ((display->descriptors_per_frame + 2)
21087b30:	20802d17 	ldw	r2,180(r4)
21087b34:	10800084 	addi	r2,r2,2
			* sizeof(alt_msgdma_standard_descriptor));
}
21087b38:	1004913a 	slli	r2,r2,4
21087b3c:	f800283a 	ret

21087b40 <ece423_video_display_allocate_buffers>:
 *  This Allocates memory for Frame Bufs & descriptors
 *  Returns:  0 - Success
 *           -1 - Error allocating memory
 ******************************************************************/
int ece423_video_display_allocate_buffers(ece423_video_display* display,
		int bytes_per_frame, int num_buffers) {
21087b40:	defff704 	addi	sp,sp,-36
21087b44:	dd800615 	stw	r22,24(sp)
21087b48:	dd400515 	stw	r21,20(sp)
21087b4c:	dd000415 	stw	r20,16(sp)
21087b50:	dcc00315 	stw	r19,12(sp)
21087b54:	dfc00815 	stw	ra,32(sp)
21087b58:	ddc00715 	stw	r23,28(sp)
21087b5c:	dc800215 	stw	r18,8(sp)
21087b60:	dc400115 	stw	r17,4(sp)
21087b64:	dc000015 	stw	r16,0(sp)
21087b68:	302b883a 	mov	r21,r6
21087b6c:	2027883a 	mov	r19,r4
21087b70:	2829883a 	mov	r20,r5
	int i, ret_code = 0;
21087b74:	002d883a 	mov	r22,zero

	/* Allocate Frame Bufs and descriptor Bufs */

	for (i = 0; i < num_buffers; i++) {
21087b78:	01801a0e 	bge	zero,r6,21087be4 <ece423_video_display_allocate_buffers+0xa4>
21087b7c:	24000104 	addi	r16,r4,4
21087b80:	002d883a 	mov	r22,zero
21087b84:	0025883a 	mov	r18,zero
		display->buffer_ptrs[i] = (ece423_video_frame*) malloc(
21087b88:	01000204 	movi	r4,8
21087b8c:	108d8e80 	call	2108d8e8 <malloc>
21087b90:	80800015 	stw	r2,0(r16)
21087b94:	1023883a 	mov	r17,r2

		if (display->buffer_ptrs[i] == NULL) {
			ret_code = -1;
		}

		display->buffer_ptrs[i]->buffer = (void*) alt_uncached_malloc(
21087b98:	a009883a 	mov	r4,r20
		int bytes_per_frame, int num_buffers) {
	int i, ret_code = 0;

	/* Allocate Frame Bufs and descriptor Bufs */

	for (i = 0; i < num_buffers; i++) {
21087b9c:	94800044 	addi	r18,r18,1
		display->buffer_ptrs[i] = (ece423_video_frame*) malloc(
				sizeof(ece423_video_frame)); // malloc Struct with 2 Ptrs

		if (display->buffer_ptrs[i] == NULL) {
21087ba0:	10003326 	beq	r2,zero,21087c70 <ece423_video_display_allocate_buffers+0x130>
			ret_code = -1;
		}

		display->buffer_ptrs[i]->buffer = (void*) alt_uncached_malloc(
21087ba4:	109b7f40 	call	2109b7f4 <alt_uncached_malloc>
				(bytes_per_frame)); // malloc Frame Buf on Heap
//      display->buffer_ptrs[i]->buffer =
//        (void*) memalign(16, bytes_per_frame); // malloc Frame Buf on Heap
		if (display->buffer_ptrs[i]->buffer == NULL)
21087ba8:	85c00017 	ldw	r23,0(r16)

		if (display->buffer_ptrs[i] == NULL) {
			ret_code = -1;
		}

		display->buffer_ptrs[i]->buffer = (void*) alt_uncached_malloc(
21087bac:	88800115 	stw	r2,4(r17)
//        (void*) memalign(16, bytes_per_frame); // malloc Frame Buf on Heap
		if (display->buffer_ptrs[i]->buffer == NULL)
			ret_code = -1;

		display->buffer_ptrs[i]->desc_base =
				(alt_msgdma_standard_descriptor*) memalign(32,
21087bb0:	01000804 	movi	r4,32

		display->buffer_ptrs[i]->buffer = (void*) alt_uncached_malloc(
				(bytes_per_frame)); // malloc Frame Buf on Heap
//      display->buffer_ptrs[i]->buffer =
//        (void*) memalign(16, bytes_per_frame); // malloc Frame Buf on Heap
		if (display->buffer_ptrs[i]->buffer == NULL)
21087bb4:	b8800117 	ldw	r2,4(r23)
21087bb8:	10002f26 	beq	r2,zero,21087c78 <ece423_video_display_allocate_buffers+0x138>
 *  MUST be SetUp Before Calling this func
 *
 * Returns: Size (in bytes) of descriptor memory required.
 ******************************************************************/
alt_u32 ece423_video_display_get_descriptor_span(ece423_video_display *display) {
	return ((display->descriptors_per_frame + 2)
21087bbc:	99402d17 	ldw	r5,180(r19)
21087bc0:	84000104 	addi	r16,r16,4
21087bc4:	29400084 	addi	r5,r5,2
//        (void*) memalign(16, bytes_per_frame); // malloc Frame Buf on Heap
		if (display->buffer_ptrs[i]->buffer == NULL)
			ret_code = -1;

		display->buffer_ptrs[i]->desc_base =
				(alt_msgdma_standard_descriptor*) memalign(32,
21087bc8:	280a913a 	slli	r5,r5,4
21087bcc:	108d7180 	call	2108d718 <memalign>
//      display->buffer_ptrs[i]->buffer =
//        (void*) memalign(16, bytes_per_frame); // malloc Frame Buf on Heap
		if (display->buffer_ptrs[i]->buffer == NULL)
			ret_code = -1;

		display->buffer_ptrs[i]->desc_base =
21087bd0:	b8800015 	stw	r2,0(r23)
				(alt_msgdma_standard_descriptor*) memalign(32,
						ece423_video_display_get_descriptor_span(display)); // Desc on Heap

		if (display->buffer_ptrs[i]->desc_base == NULL) {
21087bd4:	80bfff17 	ldw	r2,-4(r16)
21087bd8:	10800017 	ldw	r2,0(r2)
21087bdc:	10002126 	beq	r2,zero,21087c64 <ece423_video_display_allocate_buffers+0x124>
		int bytes_per_frame, int num_buffers) {
	int i, ret_code = 0;

	/* Allocate Frame Bufs and descriptor Bufs */

	for (i = 0; i < num_buffers; i++) {
21087be0:	957fe91e 	bne	r18,r21,21087b88 <__flash_rwdata_start+0xfffe5940>
		if (display->buffer_ptrs[i]->desc_base == NULL) {
			ret_code = -1;
		}
	}

	display->text_buffer_ptr = (ece423_video_frame*) malloc(
21087be4:	01000204 	movi	r4,8
21087be8:	108d8e80 	call	2108d8e8 <malloc>
21087bec:	98802515 	stw	r2,148(r19)
21087bf0:	1021883a 	mov	r16,r2
				sizeof(ece423_video_frame)); // malloc Struct with 2 Ptrs
	if (display->text_buffer_ptr == NULL) {
21087bf4:	10002226 	beq	r2,zero,21087c80 <ece423_video_display_allocate_buffers+0x140>
		ret_code = -1;
	}
	display->text_buffer_ptr->buffer = (void*) alt_uncached_malloc(
21087bf8:	a009883a 	mov	r4,r20
21087bfc:	109b7f40 	call	2109b7f4 <alt_uncached_malloc>
					(bytes_per_frame)); // malloc Frame Buf on Heap

	if (display->text_buffer_ptr->buffer == NULL)
21087c00:	9c402517 	ldw	r17,148(r19)
	display->text_buffer_ptr = (ece423_video_frame*) malloc(
				sizeof(ece423_video_frame)); // malloc Struct with 2 Ptrs
	if (display->text_buffer_ptr == NULL) {
		ret_code = -1;
	}
	display->text_buffer_ptr->buffer = (void*) alt_uncached_malloc(
21087c04:	80800115 	stw	r2,4(r16)
					(bytes_per_frame)); // malloc Frame Buf on Heap

	if (display->text_buffer_ptr->buffer == NULL)
21087c08:	88800117 	ldw	r2,4(r17)
21087c0c:	10001e26 	beq	r2,zero,21087c88 <ece423_video_display_allocate_buffers+0x148>
 *  MUST be SetUp Before Calling this func
 *
 * Returns: Size (in bytes) of descriptor memory required.
 ******************************************************************/
alt_u32 ece423_video_display_get_descriptor_span(ece423_video_display *display) {
	return ((display->descriptors_per_frame + 2)
21087c10:	99402d17 	ldw	r5,180(r19)

	if (display->text_buffer_ptr->buffer == NULL)
		ret_code = -1;

	display->text_buffer_ptr->desc_base =
			(alt_msgdma_standard_descriptor*) memalign(32,
21087c14:	01000804 	movi	r4,32
 *  MUST be SetUp Before Calling this func
 *
 * Returns: Size (in bytes) of descriptor memory required.
 ******************************************************************/
alt_u32 ece423_video_display_get_descriptor_span(ece423_video_display *display) {
	return ((display->descriptors_per_frame + 2)
21087c18:	29400084 	addi	r5,r5,2

	if (display->text_buffer_ptr->buffer == NULL)
		ret_code = -1;

	display->text_buffer_ptr->desc_base =
			(alt_msgdma_standard_descriptor*) memalign(32,
21087c1c:	280a913a 	slli	r5,r5,4
21087c20:	108d7180 	call	2108d718 <memalign>
					ece423_video_display_get_descriptor_span(display)); // Desc on Heap

	if (display->text_buffer_ptr->desc_base == NULL) {
21087c24:	98c02517 	ldw	r3,148(r19)
					(bytes_per_frame)); // malloc Frame Buf on Heap

	if (display->text_buffer_ptr->buffer == NULL)
		ret_code = -1;

	display->text_buffer_ptr->desc_base =
21087c28:	88800015 	stw	r2,0(r17)
			(alt_msgdma_standard_descriptor*) memalign(32,
					ece423_video_display_get_descriptor_span(display)); // Desc on Heap

	if (display->text_buffer_ptr->desc_base == NULL) {
21087c2c:	18800017 	ldw	r2,0(r3)
21087c30:	10001726 	beq	r2,zero,21087c90 <ece423_video_display_allocate_buffers+0x150>
		ret_code = -1;
	}

	return ret_code;
}
21087c34:	b005883a 	mov	r2,r22
21087c38:	dfc00817 	ldw	ra,32(sp)
21087c3c:	ddc00717 	ldw	r23,28(sp)
21087c40:	dd800617 	ldw	r22,24(sp)
21087c44:	dd400517 	ldw	r21,20(sp)
21087c48:	dd000417 	ldw	r20,16(sp)
21087c4c:	dcc00317 	ldw	r19,12(sp)
21087c50:	dc800217 	ldw	r18,8(sp)
21087c54:	dc400117 	ldw	r17,4(sp)
21087c58:	dc000017 	ldw	r16,0(sp)
21087c5c:	dec00904 	addi	sp,sp,36
21087c60:	f800283a 	ret
		display->buffer_ptrs[i]->desc_base =
				(alt_msgdma_standard_descriptor*) memalign(32,
						ece423_video_display_get_descriptor_span(display)); // Desc on Heap

		if (display->buffer_ptrs[i]->desc_base == NULL) {
			ret_code = -1;
21087c64:	05bfffc4 	movi	r22,-1
		int bytes_per_frame, int num_buffers) {
	int i, ret_code = 0;

	/* Allocate Frame Bufs and descriptor Bufs */

	for (i = 0; i < num_buffers; i++) {
21087c68:	957fc71e 	bne	r18,r21,21087b88 <__flash_rwdata_start+0xfffe5940>
21087c6c:	003fdd06 	br	21087be4 <__flash_rwdata_start+0xfffe599c>
		display->buffer_ptrs[i] = (ece423_video_frame*) malloc(
				sizeof(ece423_video_frame)); // malloc Struct with 2 Ptrs

		if (display->buffer_ptrs[i] == NULL) {
			ret_code = -1;
21087c70:	05bfffc4 	movi	r22,-1
21087c74:	003fcb06 	br	21087ba4 <__flash_rwdata_start+0xfffe595c>
		display->buffer_ptrs[i]->buffer = (void*) alt_uncached_malloc(
				(bytes_per_frame)); // malloc Frame Buf on Heap
//      display->buffer_ptrs[i]->buffer =
//        (void*) memalign(16, bytes_per_frame); // malloc Frame Buf on Heap
		if (display->buffer_ptrs[i]->buffer == NULL)
			ret_code = -1;
21087c78:	05bfffc4 	movi	r22,-1
21087c7c:	003fcf06 	br	21087bbc <__flash_rwdata_start+0xfffe5974>
	}

	display->text_buffer_ptr = (ece423_video_frame*) malloc(
				sizeof(ece423_video_frame)); // malloc Struct with 2 Ptrs
	if (display->text_buffer_ptr == NULL) {
		ret_code = -1;
21087c80:	05bfffc4 	movi	r22,-1
21087c84:	003fdc06 	br	21087bf8 <__flash_rwdata_start+0xfffe59b0>
	}
	display->text_buffer_ptr->buffer = (void*) alt_uncached_malloc(
					(bytes_per_frame)); // malloc Frame Buf on Heap

	if (display->text_buffer_ptr->buffer == NULL)
		ret_code = -1;
21087c88:	05bfffc4 	movi	r22,-1
21087c8c:	003fe006 	br	21087c10 <__flash_rwdata_start+0xfffe59c8>
	display->text_buffer_ptr->desc_base =
			(alt_msgdma_standard_descriptor*) memalign(32,
					ece423_video_display_get_descriptor_span(display)); // Desc on Heap

	if (display->text_buffer_ptr->desc_base == NULL) {
		ret_code = -1;
21087c90:	05bfffc4 	movi	r22,-1
21087c94:	003fe706 	br	21087c34 <__flash_rwdata_start+0xfffe59ec>

21087c98 <reg_read>:
	return ret_code;
}

// ************************************************************
int reg_read(int slave_addr, int reg, void *data) {
	bool r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, (alt_u8) reg,
21087c98:	20803fcc 	andi	r2,r4,255
21087c9c:	1080201c 	xori	r2,r2,128

	return ret_code;
}

// ************************************************************
int reg_read(int slave_addr, int reg, void *data) {
21087ca0:	defffe04 	addi	sp,sp,-8
	bool r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, (alt_u8) reg,
21087ca4:	29c03fcc 	andi	r7,r5,255
21087ca8:	10bfe004 	addi	r2,r2,-128
21087cac:	01080034 	movhi	r4,8192
21087cb0:	01480034 	movhi	r5,8192
21087cb4:	d9800015 	stw	r6,0(sp)
21087cb8:	21015804 	addi	r4,r4,1376
21087cbc:	29415404 	addi	r5,r5,1360
21087cc0:	100d883a 	mov	r6,r2

	return ret_code;
}

// ************************************************************
int reg_read(int slave_addr, int reg, void *data) {
21087cc4:	dfc00115 	stw	ra,4(sp)
	bool r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, (alt_u8) reg,
21087cc8:	10899e80 	call	210899e8 <I2C_Read>
			(alt_u8 *) data);
	if (!r)
21087ccc:	1005003a 	cmpeq	r2,r2,zero
		return -1;

	return 0;
}
21087cd0:	0085c83a 	sub	r2,zero,r2
21087cd4:	dfc00117 	ldw	ra,4(sp)
21087cd8:	dec00204 	addi	sp,sp,8
21087cdc:	f800283a 	ret

21087ce0 <reg_write>:

int reg_write(int slave_addr, int reg, int data) {
	bool r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, (alt_u8) reg,
21087ce0:	20803fcc 	andi	r2,r4,255
21087ce4:	1080201c 	xori	r2,r2,128
		return -1;

	return 0;
}

int reg_write(int slave_addr, int reg, int data) {
21087ce8:	defffe04 	addi	sp,sp,-8
	bool r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, (alt_u8) reg,
21087cec:	29c03fcc 	andi	r7,r5,255
21087cf0:	10bfe004 	addi	r2,r2,-128
21087cf4:	31803fcc 	andi	r6,r6,255
21087cf8:	01080034 	movhi	r4,8192
21087cfc:	01480034 	movhi	r5,8192
21087d00:	d9800015 	stw	r6,0(sp)
21087d04:	21015804 	addi	r4,r4,1376
21087d08:	29415404 	addi	r5,r5,1360
21087d0c:	100d883a 	mov	r6,r2
		return -1;

	return 0;
}

int reg_write(int slave_addr, int reg, int data) {
21087d10:	dfc00115 	stw	ra,4(sp)
	bool r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, (alt_u8) reg,
21087d14:	10897940 	call	21089794 <I2C_Write>
			(alt_u8) data);
	if (!r)
21087d18:	1005003a 	cmpeq	r2,r2,zero
		return -1;

	return 0;
}
21087d1c:	0085c83a 	sub	r2,zero,r2
21087d20:	dfc00117 	ldw	ra,4(sp)
21087d24:	dec00204 	addi	sp,sp,8
21087d28:	f800283a 	ret

21087d2c <reg_update_bits>:

int reg_update_bits(int slave_addr, int reg, int mask, int data) {
21087d2c:	defff904 	addi	sp,sp,-28
21087d30:	dc800415 	stw	r18,16(sp)
	bool r = 0;
	alt_u8 regv = 0;

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
21087d34:	24803fcc 	andi	r18,r4,255
21087d38:	9480201c 	xori	r18,r18,128
		return -1;

	return 0;
}

int reg_update_bits(int slave_addr, int reg, int mask, int data) {
21087d3c:	dc400315 	stw	r17,12(sp)
	bool r = 0;
	alt_u8 regv = 0;

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
21087d40:	94bfe004 	addi	r18,r18,-128
21087d44:	2c403fcc 	andi	r17,r5,255
21087d48:	01080034 	movhi	r4,8192
21087d4c:	01480034 	movhi	r5,8192
21087d50:	d8800104 	addi	r2,sp,4
		return -1;

	return 0;
}

int reg_update_bits(int slave_addr, int reg, int mask, int data) {
21087d54:	dcc00515 	stw	r19,20(sp)
21087d58:	dc000215 	stw	r16,8(sp)
21087d5c:	3027883a 	mov	r19,r6
21087d60:	3821883a 	mov	r16,r7
	bool r = 0;
	alt_u8 regv = 0;

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
21087d64:	21015804 	addi	r4,r4,1376
21087d68:	29415404 	addi	r5,r5,1360
21087d6c:	d8800015 	stw	r2,0(sp)
21087d70:	900d883a 	mov	r6,r18
21087d74:	880f883a 	mov	r7,r17
		return -1;

	return 0;
}

int reg_update_bits(int slave_addr, int reg, int mask, int data) {
21087d78:	dfc00615 	stw	ra,24(sp)
	bool r = 0;
	alt_u8 regv = 0;
21087d7c:	d8000105 	stb	zero,4(sp)

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
21087d80:	10899e80 	call	210899e8 <I2C_Read>
	if (!r)
21087d84:	10001826 	beq	r2,zero,21087de8 <reg_update_bits+0xbc>
		return -1;

	regv &= ~((alt_u8) mask);
21087d88:	d8c00103 	ldbu	r3,4(sp)
21087d8c:	04c4303a 	nor	r2,zero,r19

	regv |= ((alt_u8) data & (alt_u8) mask);
21087d90:	9c20703a 	and	r16,r19,r16

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
	if (!r)
		return -1;

	regv &= ~((alt_u8) mask);
21087d94:	10c4703a 	and	r2,r2,r3

	regv |= ((alt_u8) data & (alt_u8) mask);
21087d98:	1404b03a 	or	r2,r2,r16

	r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, regv);
21087d9c:	10c03fcc 	andi	r3,r2,255
21087da0:	01080034 	movhi	r4,8192
21087da4:	01480034 	movhi	r5,8192
21087da8:	21015804 	addi	r4,r4,1376
21087dac:	29415404 	addi	r5,r5,1360
21087db0:	d8c00015 	stw	r3,0(sp)
21087db4:	900d883a 	mov	r6,r18
21087db8:	880f883a 	mov	r7,r17
	if (!r)
		return -1;

	regv &= ~((alt_u8) mask);

	regv |= ((alt_u8) data & (alt_u8) mask);
21087dbc:	d8800105 	stb	r2,4(sp)

	r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, regv);
21087dc0:	10897940 	call	21089794 <I2C_Write>
	if (!r)
21087dc4:	1005003a 	cmpeq	r2,r2,zero
21087dc8:	0085c83a 	sub	r2,zero,r2
		return -1;

	return 0;
}
21087dcc:	dfc00617 	ldw	ra,24(sp)
21087dd0:	dcc00517 	ldw	r19,20(sp)
21087dd4:	dc800417 	ldw	r18,16(sp)
21087dd8:	dc400317 	ldw	r17,12(sp)
21087ddc:	dc000217 	ldw	r16,8(sp)
21087de0:	dec00704 	addi	sp,sp,28
21087de4:	f800283a 	ret
	bool r = 0;
	alt_u8 regv = 0;

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
	if (!r)
		return -1;
21087de8:	00bfffc4 	movi	r2,-1
21087dec:	003ff706 	br	21087dcc <__flash_rwdata_start+0xfffe5b84>

21087df0 <ece423_hdmi_powerdown>:
		return -1;

	return 0;
}

int ece423_hdmi_powerdown(int slave_addr) {
21087df0:	defffc04 	addi	sp,sp,-16
21087df4:	dc000215 	stw	r16,8(sp)

int reg_update_bits(int slave_addr, int reg, int mask, int data) {
	bool r = 0;
	alt_u8 regv = 0;

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
21087df8:	24003fcc 	andi	r16,r4,255
21087dfc:	8400201c 	xori	r16,r16,128
21087e00:	843fe004 	addi	r16,r16,-128
21087e04:	01480034 	movhi	r5,8192
21087e08:	01080034 	movhi	r4,8192
21087e0c:	d8800104 	addi	r2,sp,4
21087e10:	29415404 	addi	r5,r5,1360
21087e14:	21015804 	addi	r4,r4,1376
21087e18:	d8800015 	stw	r2,0(sp)
21087e1c:	800d883a 	mov	r6,r16
21087e20:	01c01044 	movi	r7,65
		return -1;

	return 0;
}

int ece423_hdmi_powerdown(int slave_addr) {
21087e24:	dfc00315 	stw	ra,12(sp)
	return 0;
}

int reg_update_bits(int slave_addr, int reg, int mask, int data) {
	bool r = 0;
	alt_u8 regv = 0;
21087e28:	d8000105 	stb	zero,4(sp)

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
21087e2c:	10899e80 	call	210899e8 <I2C_Read>
	if (!r)
21087e30:	10001226 	beq	r2,zero,21087e7c <ece423_hdmi_powerdown+0x8c>
		return -1;

	regv &= ~((alt_u8) mask);
21087e34:	d8800103 	ldbu	r2,4(sp)

	regv |= ((alt_u8) data & (alt_u8) mask);

	r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, regv);
21087e38:	01080034 	movhi	r4,8192
21087e3c:	01480034 	movhi	r5,8192
	if (!r)
		return -1;

	regv &= ~((alt_u8) mask);

	regv |= ((alt_u8) data & (alt_u8) mask);
21087e40:	10801014 	ori	r2,r2,64

	r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, regv);
21087e44:	10c03fcc 	andi	r3,r2,255
21087e48:	21015804 	addi	r4,r4,1376
21087e4c:	29415404 	addi	r5,r5,1360
21087e50:	d8c00015 	stw	r3,0(sp)
21087e54:	800d883a 	mov	r6,r16
21087e58:	01c01044 	movi	r7,65
	if (!r)
		return -1;

	regv &= ~((alt_u8) mask);

	regv |= ((alt_u8) data & (alt_u8) mask);
21087e5c:	d8800105 	stb	r2,4(sp)

	r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, regv);
21087e60:	10897940 	call	21089794 <I2C_Write>
	if (!r)
21087e64:	10000526 	beq	r2,zero,21087e7c <ece423_hdmi_powerdown+0x8c>
int ece423_hdmi_powerdown(int slave_addr) {
	// power down the encoder
	if (reg_update_bits(slave_addr, 0x41, 0x40, 0x40) != 0)
		return -1;

	return 0;
21087e68:	0005883a 	mov	r2,zero
}
21087e6c:	dfc00317 	ldw	ra,12(sp)
21087e70:	dc000217 	ldw	r16,8(sp)
21087e74:	dec00404 	addi	sp,sp,16
21087e78:	f800283a 	ret
}

int ece423_hdmi_powerdown(int slave_addr) {
	// power down the encoder
	if (reg_update_bits(slave_addr, 0x41, 0x40, 0x40) != 0)
		return -1;
21087e7c:	00bfffc4 	movi	r2,-1

	return 0;
}
21087e80:	dfc00317 	ldw	ra,12(sp)
21087e84:	dc000217 	ldw	r16,8(sp)
21087e88:	dec00404 	addi	sp,sp,16
21087e8c:	f800283a 	ret

21087e90 <ece423_hdmi_kick_up>:

extern int ece423_hdmi_kick_up(int slave_addr) {
21087e90:	defffc04 	addi	sp,sp,-16
21087e94:	dc000215 	stw	r16,8(sp)

int reg_update_bits(int slave_addr, int reg, int mask, int data) {
	bool r = 0;
	alt_u8 regv = 0;

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
21087e98:	24003fcc 	andi	r16,r4,255
21087e9c:	8400201c 	xori	r16,r16,128
21087ea0:	843fe004 	addi	r16,r16,-128
21087ea4:	01480034 	movhi	r5,8192
21087ea8:	01080034 	movhi	r4,8192
21087eac:	d8800104 	addi	r2,sp,4
21087eb0:	29415404 	addi	r5,r5,1360
21087eb4:	21015804 	addi	r4,r4,1376
21087eb8:	d8800015 	stw	r2,0(sp)
21087ebc:	800d883a 	mov	r6,r16
21087ec0:	01c01044 	movi	r7,65
		return -1;

	return 0;
}

extern int ece423_hdmi_kick_up(int slave_addr) {
21087ec4:	dfc00315 	stw	ra,12(sp)
	return 0;
}

int reg_update_bits(int slave_addr, int reg, int mask, int data) {
	bool r = 0;
	alt_u8 regv = 0;
21087ec8:	d8000105 	stb	zero,4(sp)

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
21087ecc:	10899e80 	call	210899e8 <I2C_Read>
	if (!r)
21087ed0:	10001326 	beq	r2,zero,21087f20 <ece423_hdmi_kick_up+0x90>
		return -1;

	regv &= ~((alt_u8) mask);
21087ed4:	d8c00103 	ldbu	r3,4(sp)
21087ed8:	00bfefc4 	movi	r2,-65

	regv |= ((alt_u8) data & (alt_u8) mask);

	r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, regv);
21087edc:	01080034 	movhi	r4,8192

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
	if (!r)
		return -1;

	regv &= ~((alt_u8) mask);
21087ee0:	1884703a 	and	r2,r3,r2

	regv |= ((alt_u8) data & (alt_u8) mask);

	r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, regv);
21087ee4:	01480034 	movhi	r5,8192
21087ee8:	10c03fcc 	andi	r3,r2,255
21087eec:	21015804 	addi	r4,r4,1376
21087ef0:	29415404 	addi	r5,r5,1360
21087ef4:	d8c00015 	stw	r3,0(sp)
21087ef8:	800d883a 	mov	r6,r16
21087efc:	01c01044 	movi	r7,65

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
	if (!r)
		return -1;

	regv &= ~((alt_u8) mask);
21087f00:	d8800105 	stb	r2,4(sp)

	regv |= ((alt_u8) data & (alt_u8) mask);

	r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, regv);
21087f04:	10897940 	call	21089794 <I2C_Write>
	if (!r)
21087f08:	10000526 	beq	r2,zero,21087f20 <ece423_hdmi_kick_up+0x90>

extern int ece423_hdmi_kick_up(int slave_addr) {
	// power up the encoder
	if (reg_update_bits(slave_addr, 0x41, 0x40, 0) != 0)
		return -1;
	return 0;
21087f0c:	0005883a 	mov	r2,zero
}
21087f10:	dfc00317 	ldw	ra,12(sp)
21087f14:	dc000217 	ldw	r16,8(sp)
21087f18:	dec00404 	addi	sp,sp,16
21087f1c:	f800283a 	ret
}

extern int ece423_hdmi_kick_up(int slave_addr) {
	// power up the encoder
	if (reg_update_bits(slave_addr, 0x41, 0x40, 0) != 0)
		return -1;
21087f20:	00bfffc4 	movi	r2,-1
	return 0;
}
21087f24:	dfc00317 	ldw	ra,12(sp)
21087f28:	dc000217 	ldw	r16,8(sp)
21087f2c:	dec00404 	addi	sp,sp,16
21087f30:	f800283a 	ret

21087f34 <ece423_hdmi_powerup>:

int ece423_hdmi_powerup(int slave_addr) {
21087f34:	defffb04 	addi	sp,sp,-20
21087f38:	dc000215 	stw	r16,8(sp)

int reg_update_bits(int slave_addr, int reg, int mask, int data) {
	bool r = 0;
	alt_u8 regv = 0;

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
21087f3c:	24003fcc 	andi	r16,r4,255
21087f40:	8400201c 	xori	r16,r16,128
21087f44:	843fe004 	addi	r16,r16,-128
21087f48:	01480034 	movhi	r5,8192
21087f4c:	01080034 	movhi	r4,8192
21087f50:	d8800104 	addi	r2,sp,4
21087f54:	29415404 	addi	r5,r5,1360
21087f58:	21015804 	addi	r4,r4,1376
21087f5c:	d8800015 	stw	r2,0(sp)
21087f60:	800d883a 	mov	r6,r16
21087f64:	01c01044 	movi	r7,65
	if (reg_update_bits(slave_addr, 0x41, 0x40, 0) != 0)
		return -1;
	return 0;
}

int ece423_hdmi_powerup(int slave_addr) {
21087f68:	dfc00415 	stw	ra,16(sp)
21087f6c:	dc400315 	stw	r17,12(sp)
	return 0;
}

int reg_update_bits(int slave_addr, int reg, int mask, int data) {
	bool r = 0;
	alt_u8 regv = 0;
21087f70:	d8000105 	stb	zero,4(sp)

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
21087f74:	10899e80 	call	210899e8 <I2C_Read>
	if (!r)
21087f78:	10008226 	beq	r2,zero,21088184 <ece423_hdmi_powerup+0x250>
		return -1;

	regv &= ~((alt_u8) mask);
21087f7c:	d8c00103 	ldbu	r3,4(sp)
21087f80:	00bfefc4 	movi	r2,-65

	regv |= ((alt_u8) data & (alt_u8) mask);

	r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, regv);
21087f84:	01080034 	movhi	r4,8192

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
	if (!r)
		return -1;

	regv &= ~((alt_u8) mask);
21087f88:	1884703a 	and	r2,r3,r2

	regv |= ((alt_u8) data & (alt_u8) mask);

	r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, regv);
21087f8c:	01480034 	movhi	r5,8192
21087f90:	10c03fcc 	andi	r3,r2,255
21087f94:	21015804 	addi	r4,r4,1376
21087f98:	29415404 	addi	r5,r5,1360
21087f9c:	d8c00015 	stw	r3,0(sp)
21087fa0:	800d883a 	mov	r6,r16
21087fa4:	01c01044 	movi	r7,65

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
	if (!r)
		return -1;

	regv &= ~((alt_u8) mask);
21087fa8:	d8800105 	stb	r2,4(sp)

	regv |= ((alt_u8) data & (alt_u8) mask);

	r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, regv);
21087fac:	10897940 	call	21089794 <I2C_Write>
	if (!r)
21087fb0:	10007426 	beq	r2,zero,21088184 <ece423_hdmi_powerup+0x250>

	return 0;
}

int reg_write(int slave_addr, int reg, int data) {
	bool r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, (alt_u8) reg,
21087fb4:	01080034 	movhi	r4,8192
21087fb8:	01480034 	movhi	r5,8192
21087fbc:	008000c4 	movi	r2,3
21087fc0:	21015804 	addi	r4,r4,1376
21087fc4:	29415404 	addi	r5,r5,1360
21087fc8:	d8800015 	stw	r2,0(sp)
21087fcc:	800d883a 	mov	r6,r16
21087fd0:	01c02604 	movi	r7,152
21087fd4:	10897940 	call	21089794 <I2C_Write>
			(alt_u8) data);
	if (!r)
21087fd8:	10006a26 	beq	r2,zero,21088184 <ece423_hdmi_powerup+0x250>

int reg_update_bits(int slave_addr, int reg, int mask, int data) {
	bool r = 0;
	alt_u8 regv = 0;

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
21087fdc:	01080034 	movhi	r4,8192
21087fe0:	01480034 	movhi	r5,8192
21087fe4:	d8800104 	addi	r2,sp,4
21087fe8:	21015804 	addi	r4,r4,1376
21087fec:	29415404 	addi	r5,r5,1360
21087ff0:	d8800015 	stw	r2,0(sp)
21087ff4:	800d883a 	mov	r6,r16
21087ff8:	01c02684 	movi	r7,154
	return 0;
}

int reg_update_bits(int slave_addr, int reg, int mask, int data) {
	bool r = 0;
	alt_u8 regv = 0;
21087ffc:	d8000105 	stb	zero,4(sp)

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
21088000:	10899e80 	call	210899e8 <I2C_Read>
	if (!r)
21088004:	10005f26 	beq	r2,zero,21088184 <ece423_hdmi_powerup+0x250>
		return -1;

	regv &= ~((alt_u8) mask);
21088008:	d8c00103 	ldbu	r3,4(sp)

	regv |= ((alt_u8) data & (alt_u8) mask);
2108800c:	00bff804 	movi	r2,-32

	r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, regv);
21088010:	01080034 	movhi	r4,8192
	if (!r)
		return -1;

	regv &= ~((alt_u8) mask);

	regv |= ((alt_u8) data & (alt_u8) mask);
21088014:	1884b03a 	or	r2,r3,r2

	r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, regv);
21088018:	01480034 	movhi	r5,8192
2108801c:	10c03fcc 	andi	r3,r2,255
21088020:	21015804 	addi	r4,r4,1376
21088024:	29415404 	addi	r5,r5,1360
21088028:	d8c00015 	stw	r3,0(sp)
2108802c:	800d883a 	mov	r6,r16
21088030:	01c02684 	movi	r7,154
	if (!r)
		return -1;

	regv &= ~((alt_u8) mask);

	regv |= ((alt_u8) data & (alt_u8) mask);
21088034:	d8800105 	stb	r2,4(sp)

	r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, regv);
21088038:	10897940 	call	21089794 <I2C_Write>
	if (!r)
2108803c:	10005126 	beq	r2,zero,21088184 <ece423_hdmi_powerup+0x250>

	return 0;
}

int reg_write(int slave_addr, int reg, int data) {
	bool r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, (alt_u8) reg,
21088040:	01080034 	movhi	r4,8192
21088044:	01480034 	movhi	r5,8192
21088048:	00800c04 	movi	r2,48
2108804c:	21015804 	addi	r4,r4,1376
21088050:	29415404 	addi	r5,r5,1360
21088054:	d8800015 	stw	r2,0(sp)
21088058:	800d883a 	mov	r6,r16
2108805c:	01c02704 	movi	r7,156
21088060:	10897940 	call	21089794 <I2C_Write>
			(alt_u8) data);
	if (!r)
21088064:	10004726 	beq	r2,zero,21088184 <ece423_hdmi_powerup+0x250>

int reg_update_bits(int slave_addr, int reg, int mask, int data) {
	bool r = 0;
	alt_u8 regv = 0;

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
21088068:	01080034 	movhi	r4,8192
2108806c:	01480034 	movhi	r5,8192
21088070:	d8800104 	addi	r2,sp,4
21088074:	21015804 	addi	r4,r4,1376
21088078:	29415404 	addi	r5,r5,1360
2108807c:	d8800015 	stw	r2,0(sp)
21088080:	800d883a 	mov	r6,r16
21088084:	01c02744 	movi	r7,157
	return 0;
}

int reg_update_bits(int slave_addr, int reg, int mask, int data) {
	bool r = 0;
	alt_u8 regv = 0;
21088088:	d8000105 	stb	zero,4(sp)

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
2108808c:	10899e80 	call	210899e8 <I2C_Read>
	if (!r)
21088090:	10003c26 	beq	r2,zero,21088184 <ece423_hdmi_powerup+0x250>
		return -1;

	regv &= ~((alt_u8) mask);
21088094:	d8c00103 	ldbu	r3,4(sp)
21088098:	00bfff04 	movi	r2,-4

	regv |= ((alt_u8) data & (alt_u8) mask);

	r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, regv);
2108809c:	01080034 	movhi	r4,8192

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
	if (!r)
		return -1;

	regv &= ~((alt_u8) mask);
210880a0:	1884703a 	and	r2,r3,r2

	regv |= ((alt_u8) data & (alt_u8) mask);
210880a4:	10800054 	ori	r2,r2,1

	r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, regv);
210880a8:	01480034 	movhi	r5,8192
210880ac:	10c03fcc 	andi	r3,r2,255
210880b0:	21015804 	addi	r4,r4,1376
210880b4:	29415404 	addi	r5,r5,1360
210880b8:	d8c00015 	stw	r3,0(sp)
210880bc:	800d883a 	mov	r6,r16
210880c0:	01c02744 	movi	r7,157
	if (!r)
		return -1;

	regv &= ~((alt_u8) mask);

	regv |= ((alt_u8) data & (alt_u8) mask);
210880c4:	d8800105 	stb	r2,4(sp)

	r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, regv);
210880c8:	10897940 	call	21089794 <I2C_Write>
	if (!r)
210880cc:	10002d26 	beq	r2,zero,21088184 <ece423_hdmi_powerup+0x250>

	return 0;
}

int reg_write(int slave_addr, int reg, int data) {
	bool r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, (alt_u8) reg,
210880d0:	01080034 	movhi	r4,8192
210880d4:	01480034 	movhi	r5,8192
210880d8:	04402904 	movi	r17,164
210880dc:	21015804 	addi	r4,r4,1376
210880e0:	29415404 	addi	r5,r5,1360
210880e4:	dc400015 	stw	r17,0(sp)
210880e8:	800d883a 	mov	r6,r16
210880ec:	01c02884 	movi	r7,162
210880f0:	10897940 	call	21089794 <I2C_Write>
			(alt_u8) data);
	if (!r)
210880f4:	10002326 	beq	r2,zero,21088184 <ece423_hdmi_powerup+0x250>

	return 0;
}

int reg_write(int slave_addr, int reg, int data) {
	bool r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, (alt_u8) reg,
210880f8:	01080034 	movhi	r4,8192
210880fc:	01480034 	movhi	r5,8192
21088100:	21015804 	addi	r4,r4,1376
21088104:	29415404 	addi	r5,r5,1360
21088108:	dc400015 	stw	r17,0(sp)
2108810c:	800d883a 	mov	r6,r16
21088110:	01c028c4 	movi	r7,163
21088114:	10897940 	call	21089794 <I2C_Write>
			(alt_u8) data);
	if (!r)
21088118:	10001a26 	beq	r2,zero,21088184 <ece423_hdmi_powerup+0x250>

	return 0;
}

int reg_write(int slave_addr, int reg, int data) {
	bool r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, (alt_u8) reg,
2108811c:	01080034 	movhi	r4,8192
21088120:	01480034 	movhi	r5,8192
21088124:	00803404 	movi	r2,208
21088128:	21015804 	addi	r4,r4,1376
2108812c:	29415404 	addi	r5,r5,1360
21088130:	d8800015 	stw	r2,0(sp)
21088134:	800d883a 	mov	r6,r16
21088138:	01c03804 	movi	r7,224
2108813c:	10897940 	call	21089794 <I2C_Write>
			(alt_u8) data);
	if (!r)
21088140:	10001026 	beq	r2,zero,21088184 <ece423_hdmi_powerup+0x250>

	return 0;
}

int reg_write(int slave_addr, int reg, int data) {
	bool r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, (alt_u8) reg,
21088144:	00803fc4 	movi	r2,255
21088148:	01080034 	movhi	r4,8192
2108814c:	01480034 	movhi	r5,8192
21088150:	21015804 	addi	r4,r4,1376
21088154:	29415404 	addi	r5,r5,1360
21088158:	d8800015 	stw	r2,0(sp)
2108815c:	800d883a 	mov	r6,r16
21088160:	01c02584 	movi	r7,150
21088164:	10897940 	call	21089794 <I2C_Write>
			(alt_u8) data);
	if (!r)
21088168:	1005003a 	cmpeq	r2,r2,zero
2108816c:	0085c83a 	sub	r2,zero,r2
	// 0x96[7:6] <- 0xc0 & 0xc0
	if (reg_write(slave_addr, 0x96, 0xff) != 0)
		return -1;

	return 0;
}
21088170:	dfc00417 	ldw	ra,16(sp)
21088174:	dc400317 	ldw	r17,12(sp)
21088178:	dc000217 	ldw	r16,8(sp)
2108817c:	dec00504 	addi	sp,sp,20
21088180:	f800283a 	ret
}

int ece423_hdmi_powerup(int slave_addr) {
	// power up the encoder
	if (reg_update_bits(slave_addr, 0x41, 0x40, 0) != 0)
		return -1;
21088184:	00bfffc4 	movi	r2,-1
21088188:	003ff906 	br	21088170 <__flash_rwdata_start+0xfffe5f28>

2108818c <ece423_init_hdmi>:
		return -1;

	return 0;
}

int ece423_init_hdmi() {
2108818c:	defff004 	addi	sp,sp,-64
	int slave_addr = 0x39 << 1;
	int chip_id[4];
	int chip_rev[4];

	// Identify adv7513 chip
	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x00, &chip_rev[0]);
21088190:	01080034 	movhi	r4,8192
21088194:	01480034 	movhi	r5,8192
21088198:	d8800104 	addi	r2,sp,4
2108819c:	21015804 	addi	r4,r4,1376
210881a0:	29415404 	addi	r5,r5,1360
210881a4:	d8800015 	stw	r2,0(sp)
210881a8:	01801c84 	movi	r6,114
210881ac:	000f883a 	mov	r7,zero
		return -1;

	return 0;
}

int ece423_init_hdmi() {
210881b0:	dfc00f15 	stw	ra,60(sp)
210881b4:	dd000e15 	stw	r20,56(sp)
210881b8:	dcc00d15 	stw	r19,52(sp)
210881bc:	dc800c15 	stw	r18,48(sp)
210881c0:	dc400b15 	stw	r17,44(sp)
210881c4:	dc000a15 	stw	r16,40(sp)
	int slave_addr = 0x39 << 1;
	int chip_id[4];
	int chip_rev[4];

	// Identify adv7513 chip
	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x00, &chip_rev[0]);
210881c8:	10899e80 	call	210899e8 <I2C_Read>
	if (!r)
210881cc:	10010526 	beq	r2,zero,210885e4 <ece423_init_hdmi+0x458>
		return -1;

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0xf6, &chip_id[0]);
210881d0:	01080034 	movhi	r4,8192
210881d4:	01480034 	movhi	r5,8192
210881d8:	d8800504 	addi	r2,sp,20
210881dc:	21015804 	addi	r4,r4,1376
210881e0:	29415404 	addi	r5,r5,1360
210881e4:	d8800015 	stw	r2,0(sp)
210881e8:	01801c84 	movi	r6,114
210881ec:	01c03d84 	movi	r7,246
210881f0:	10899e80 	call	210899e8 <I2C_Read>
	if (!r)
210881f4:	1000fd26 	beq	r2,zero,210885ec <ece423_init_hdmi+0x460>
		return -2;

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0xf5, &chip_id[1]);
210881f8:	01080034 	movhi	r4,8192
210881fc:	01480034 	movhi	r5,8192
21088200:	d8800604 	addi	r2,sp,24
21088204:	21015804 	addi	r4,r4,1376
21088208:	29415404 	addi	r5,r5,1360
2108820c:	d8800015 	stw	r2,0(sp)
21088210:	01801c84 	movi	r6,114
21088214:	01c03d44 	movi	r7,245
21088218:	10899e80 	call	210899e8 <I2C_Read>
	if (!r)
2108821c:	1000f526 	beq	r2,zero,210885f4 <ece423_init_hdmi+0x468>

int reg_update_bits(int slave_addr, int reg, int mask, int data) {
	bool r = 0;
	alt_u8 regv = 0;

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
21088220:	01080034 	movhi	r4,8192
21088224:	01480034 	movhi	r5,8192
21088228:	d8800904 	addi	r2,sp,36
2108822c:	21015804 	addi	r4,r4,1376
21088230:	29415404 	addi	r5,r5,1360
21088234:	d8800015 	stw	r2,0(sp)
21088238:	01801c84 	movi	r6,114
2108823c:	01c01044 	movi	r7,65
	return 0;
}

int reg_update_bits(int slave_addr, int reg, int mask, int data) {
	bool r = 0;
	alt_u8 regv = 0;
21088240:	d8000905 	stb	zero,36(sp)

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
21088244:	10899e80 	call	210899e8 <I2C_Read>
	if (!r)
21088248:	10000d26 	beq	r2,zero,21088280 <ece423_init_hdmi+0xf4>
		return -1;

	regv &= ~((alt_u8) mask);
2108824c:	d8c00903 	ldbu	r3,36(sp)
21088250:	00bfefc4 	movi	r2,-65

	regv |= ((alt_u8) data & (alt_u8) mask);

	r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, regv);
21088254:	01080034 	movhi	r4,8192

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
	if (!r)
		return -1;

	regv &= ~((alt_u8) mask);
21088258:	1884703a 	and	r2,r3,r2

	regv |= ((alt_u8) data & (alt_u8) mask);

	r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, regv);
2108825c:	01480034 	movhi	r5,8192
21088260:	10c03fcc 	andi	r3,r2,255
21088264:	21015804 	addi	r4,r4,1376
21088268:	29415404 	addi	r5,r5,1360
2108826c:	d8c00015 	stw	r3,0(sp)
21088270:	01801c84 	movi	r6,114
21088274:	01c01044 	movi	r7,65

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, &regv);
	if (!r)
		return -1;

	regv &= ~((alt_u8) mask);
21088278:	d8800905 	stb	r2,36(sp)

	regv |= ((alt_u8) data & (alt_u8) mask);

	r = I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, reg, regv);
2108827c:	10897940 	call	21089794 <I2C_Write>

	// kickup the encoder
	ece423_hdmi_kick_up(slave_addr);

	// Initiate Color Conversion Matrix
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x18, 0xAA);
21088280:	00802a84 	movi	r2,170
21088284:	01080034 	movhi	r4,8192
21088288:	01480034 	movhi	r5,8192
2108828c:	21015804 	addi	r4,r4,1376
21088290:	29415404 	addi	r5,r5,1360
21088294:	01801c84 	movi	r6,114
21088298:	01c00604 	movi	r7,24
2108829c:	d8800015 	stw	r2,0(sp)
210882a0:	10897940 	call	21089794 <I2C_Write>
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x19, 0xF8);
210882a4:	04800644 	movi	r18,25
210882a8:	00803e04 	movi	r2,248
210882ac:	01080034 	movhi	r4,8192
210882b0:	01480034 	movhi	r5,8192
210882b4:	21015804 	addi	r4,r4,1376
210882b8:	29415404 	addi	r5,r5,1360
210882bc:	01801c84 	movi	r6,114
210882c0:	900f883a 	mov	r7,r18
210882c4:	d8800015 	stw	r2,0(sp)
210882c8:	10897940 	call	21089794 <I2C_Write>
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x1A, 0x08);
210882cc:	04400684 	movi	r17,26
210882d0:	04000204 	movi	r16,8
210882d4:	01080034 	movhi	r4,8192
210882d8:	01480034 	movhi	r5,8192
210882dc:	880f883a 	mov	r7,r17
210882e0:	21015804 	addi	r4,r4,1376
210882e4:	29415404 	addi	r5,r5,1360
210882e8:	01801c84 	movi	r6,114
210882ec:	dc000015 	stw	r16,0(sp)
210882f0:	10897940 	call	21089794 <I2C_Write>
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x1B, 0x00);
210882f4:	01080034 	movhi	r4,8192
210882f8:	01480034 	movhi	r5,8192
210882fc:	21015804 	addi	r4,r4,1376
21088300:	29415404 	addi	r5,r5,1360
21088304:	01801c84 	movi	r6,114
21088308:	01c006c4 	movi	r7,27
2108830c:	d8000015 	stw	zero,0(sp)
21088310:	10897940 	call	21089794 <I2C_Write>
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x1C, 0x00);
21088314:	01080034 	movhi	r4,8192
21088318:	01480034 	movhi	r5,8192
2108831c:	21015804 	addi	r4,r4,1376
21088320:	29415404 	addi	r5,r5,1360
21088324:	01801c84 	movi	r6,114
21088328:	01c00704 	movi	r7,28
2108832c:	d8000015 	stw	zero,0(sp)
21088330:	10897940 	call	21089794 <I2C_Write>
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x1D, 0x00);
21088334:	05000744 	movi	r20,29
21088338:	01080034 	movhi	r4,8192
2108833c:	01480034 	movhi	r5,8192
21088340:	21015804 	addi	r4,r4,1376
21088344:	29415404 	addi	r5,r5,1360
21088348:	01801c84 	movi	r6,114
2108834c:	a00f883a 	mov	r7,r20
21088350:	d8000015 	stw	zero,0(sp)
21088354:	10897940 	call	21089794 <I2C_Write>
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x1E, 0x1a);
21088358:	01080034 	movhi	r4,8192
2108835c:	01480034 	movhi	r5,8192
21088360:	21015804 	addi	r4,r4,1376
21088364:	29415404 	addi	r5,r5,1360
21088368:	01801c84 	movi	r6,114
2108836c:	01c00784 	movi	r7,30
21088370:	dc400015 	stw	r17,0(sp)
21088374:	10897940 	call	21089794 <I2C_Write>
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x1F, 0x84);
21088378:	04c007c4 	movi	r19,31
2108837c:	00802104 	movi	r2,132
21088380:	01080034 	movhi	r4,8192
21088384:	01480034 	movhi	r5,8192
21088388:	21015804 	addi	r4,r4,1376
2108838c:	29415404 	addi	r5,r5,1360
21088390:	01801c84 	movi	r6,114
21088394:	980f883a 	mov	r7,r19
21088398:	d8800015 	stw	r2,0(sp)
2108839c:	10897940 	call	21089794 <I2C_Write>

	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x20, 0x1A);
210883a0:	01080034 	movhi	r4,8192
210883a4:	01480034 	movhi	r5,8192
210883a8:	21015804 	addi	r4,r4,1376
210883ac:	29415404 	addi	r5,r5,1360
210883b0:	01801c84 	movi	r6,114
210883b4:	01c00804 	movi	r7,32
210883b8:	dc400015 	stw	r17,0(sp)
210883bc:	10897940 	call	21089794 <I2C_Write>
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x21, 0x6A);
210883c0:	00801a84 	movi	r2,106
210883c4:	01080034 	movhi	r4,8192
210883c8:	01480034 	movhi	r5,8192
210883cc:	21015804 	addi	r4,r4,1376
210883d0:	29415404 	addi	r5,r5,1360
210883d4:	01801c84 	movi	r6,114
210883d8:	01c00844 	movi	r7,33
210883dc:	d8800015 	stw	r2,0(sp)
210883e0:	10897940 	call	21089794 <I2C_Write>
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x22, 0x08);
210883e4:	01080034 	movhi	r4,8192
210883e8:	01480034 	movhi	r5,8192
210883ec:	21015804 	addi	r4,r4,1376
210883f0:	29415404 	addi	r5,r5,1360
210883f4:	01801c84 	movi	r6,114
210883f8:	01c00884 	movi	r7,34
210883fc:	dc000015 	stw	r16,0(sp)
21088400:	10897940 	call	21089794 <I2C_Write>
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x23, 0x00);
21088404:	044008c4 	movi	r17,35
21088408:	01080034 	movhi	r4,8192
2108840c:	01480034 	movhi	r5,8192
21088410:	21015804 	addi	r4,r4,1376
21088414:	29415404 	addi	r5,r5,1360
21088418:	01801c84 	movi	r6,114
2108841c:	880f883a 	mov	r7,r17
21088420:	d8000015 	stw	zero,0(sp)
21088424:	10897940 	call	21089794 <I2C_Write>
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x24, 0x1D);
21088428:	01080034 	movhi	r4,8192
2108842c:	01480034 	movhi	r5,8192
21088430:	21015804 	addi	r4,r4,1376
21088434:	29415404 	addi	r5,r5,1360
21088438:	01801c84 	movi	r6,114
2108843c:	01c00904 	movi	r7,36
21088440:	dd000015 	stw	r20,0(sp)
21088444:	10897940 	call	21089794 <I2C_Write>
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x25, 0x50);
21088448:	00801404 	movi	r2,80
2108844c:	01080034 	movhi	r4,8192
21088450:	01480034 	movhi	r5,8192
21088454:	21015804 	addi	r4,r4,1376
21088458:	29415404 	addi	r5,r5,1360
2108845c:	01801c84 	movi	r6,114
21088460:	01c00944 	movi	r7,37
21088464:	d8800015 	stw	r2,0(sp)
21088468:	10897940 	call	21089794 <I2C_Write>
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x26, 0x04);
2108846c:	00800104 	movi	r2,4
21088470:	01080034 	movhi	r4,8192
21088474:	01480034 	movhi	r5,8192
21088478:	21015804 	addi	r4,r4,1376
2108847c:	29415404 	addi	r5,r5,1360
21088480:	01801c84 	movi	r6,114
21088484:	01c00984 	movi	r7,38
21088488:	d8800015 	stw	r2,0(sp)
2108848c:	10897940 	call	21089794 <I2C_Write>
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x27, 0x23);
21088490:	01080034 	movhi	r4,8192
21088494:	01480034 	movhi	r5,8192
21088498:	21015804 	addi	r4,r4,1376
2108849c:	29415404 	addi	r5,r5,1360
210884a0:	01801c84 	movi	r6,114
210884a4:	01c009c4 	movi	r7,39
210884a8:	dc400015 	stw	r17,0(sp)
210884ac:	10897940 	call	21089794 <I2C_Write>

	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x28, 0x1F);
210884b0:	01080034 	movhi	r4,8192
210884b4:	01480034 	movhi	r5,8192
210884b8:	21015804 	addi	r4,r4,1376
210884bc:	29415404 	addi	r5,r5,1360
210884c0:	01801c84 	movi	r6,114
210884c4:	01c00a04 	movi	r7,40
210884c8:	dcc00015 	stw	r19,0(sp)
210884cc:	10897940 	call	21089794 <I2C_Write>
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x29, 0xFC);
210884d0:	00803f04 	movi	r2,252
210884d4:	01080034 	movhi	r4,8192
210884d8:	01480034 	movhi	r5,8192
210884dc:	21015804 	addi	r4,r4,1376
210884e0:	29415404 	addi	r5,r5,1360
210884e4:	01801c84 	movi	r6,114
210884e8:	01c00a44 	movi	r7,41
210884ec:	d8800015 	stw	r2,0(sp)
210884f0:	10897940 	call	21089794 <I2C_Write>
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x2A, 0x08);
210884f4:	01080034 	movhi	r4,8192
210884f8:	01480034 	movhi	r5,8192
210884fc:	21015804 	addi	r4,r4,1376
21088500:	29415404 	addi	r5,r5,1360
21088504:	01801c84 	movi	r6,114
21088508:	01c00a84 	movi	r7,42
2108850c:	dc000015 	stw	r16,0(sp)
21088510:	10897940 	call	21089794 <I2C_Write>
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x2B, 0x00);
21088514:	01080034 	movhi	r4,8192
21088518:	01480034 	movhi	r5,8192
2108851c:	21015804 	addi	r4,r4,1376
21088520:	29415404 	addi	r5,r5,1360
21088524:	01801c84 	movi	r6,114
21088528:	01c00ac4 	movi	r7,43
2108852c:	d8000015 	stw	zero,0(sp)
21088530:	10897940 	call	21089794 <I2C_Write>
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x2C, 0x0D);
21088534:	00800344 	movi	r2,13
21088538:	01080034 	movhi	r4,8192
2108853c:	01480034 	movhi	r5,8192
21088540:	21015804 	addi	r4,r4,1376
21088544:	29415404 	addi	r5,r5,1360
21088548:	01801c84 	movi	r6,114
2108854c:	01c00b04 	movi	r7,44
21088550:	d8800015 	stw	r2,0(sp)
21088554:	10897940 	call	21089794 <I2C_Write>
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x2D, 0xDE);
21088558:	00803784 	movi	r2,222
2108855c:	01080034 	movhi	r4,8192
21088560:	01480034 	movhi	r5,8192
21088564:	21015804 	addi	r4,r4,1376
21088568:	29415404 	addi	r5,r5,1360
2108856c:	01801c84 	movi	r6,114
21088570:	01c00b44 	movi	r7,45
21088574:	d8800015 	stw	r2,0(sp)
21088578:	10897940 	call	21089794 <I2C_Write>
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x2E, 0x19);
2108857c:	01080034 	movhi	r4,8192
21088580:	01480034 	movhi	r5,8192
21088584:	21015804 	addi	r4,r4,1376
21088588:	29415404 	addi	r5,r5,1360
2108858c:	01801c84 	movi	r6,114
21088590:	01c00b84 	movi	r7,46
21088594:	dc800015 	stw	r18,0(sp)
21088598:	10897940 	call	21089794 <I2C_Write>
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x2F, 0x13);
2108859c:	008004c4 	movi	r2,19
210885a0:	01080034 	movhi	r4,8192
210885a4:	01480034 	movhi	r5,8192
210885a8:	21015804 	addi	r4,r4,1376
210885ac:	29415404 	addi	r5,r5,1360
210885b0:	d8800015 	stw	r2,0(sp)
210885b4:	01801c84 	movi	r6,114
210885b8:	01c00bc4 	movi	r7,47
210885bc:	10897940 	call	21089794 <I2C_Write>

	return 0;
210885c0:	0005883a 	mov	r2,zero
}
210885c4:	dfc00f17 	ldw	ra,60(sp)
210885c8:	dd000e17 	ldw	r20,56(sp)
210885cc:	dcc00d17 	ldw	r19,52(sp)
210885d0:	dc800c17 	ldw	r18,48(sp)
210885d4:	dc400b17 	ldw	r17,44(sp)
210885d8:	dc000a17 	ldw	r16,40(sp)
210885dc:	dec01004 	addi	sp,sp,64
210885e0:	f800283a 	ret
	int chip_rev[4];

	// Identify adv7513 chip
	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x00, &chip_rev[0]);
	if (!r)
		return -1;
210885e4:	00bfffc4 	movi	r2,-1
210885e8:	003ff606 	br	210885c4 <__flash_rwdata_start+0xfffe637c>

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0xf6, &chip_id[0]);
	if (!r)
		return -2;
210885ec:	00bfff84 	movi	r2,-2
210885f0:	003ff406 	br	210885c4 <__flash_rwdata_start+0xfffe637c>

	r = I2C_Read(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0xf5, &chip_id[1]);
	if (!r)
		return -3;
210885f4:	00bfff44 	movi	r2,-3
210885f8:	003ff206 	br	210885c4 <__flash_rwdata_start+0xfffe637c>

210885fc <ece423_video_display_init>:
ece423_video_display* ece423_video_display_init(char* sgdma_name, int width,
		int height, int num_buffers) {

	/* ------------------------------- decompress ------------------------------- */

	font_glyph_bitmap = malloc(font_len_out);
210885fc:	00800034 	movhi	r2,0
21088600:	10976404 	addi	r2,r2,23952
21088604:	10800017 	ldw	r2,0(r2)
 *           the mSGDMA.
 *
 *  Returns: Ptr to  display controller structure, or NULL on failure.
 ******************************************************************/
ece423_video_display* ece423_video_display_init(char* sgdma_name, int width,
		int height, int num_buffers) {
21088608:	defff604 	addi	sp,sp,-40
2108860c:	dd400715 	stw	r21,28(sp)
21088610:	dc800415 	stw	r18,16(sp)
21088614:	202b883a 	mov	r21,r4

	/* ------------------------------- decompress ------------------------------- */

	font_glyph_bitmap = malloc(font_len_out);
21088618:	04800034 	movhi	r18,0
2108861c:	1009883a 	mov	r4,r2
 *           the mSGDMA.
 *
 *  Returns: Ptr to  display controller structure, or NULL on failure.
 ******************************************************************/
ece423_video_display* ece423_video_display_init(char* sgdma_name, int width,
		int height, int num_buffers) {
21088620:	dd000615 	stw	r20,24(sp)
21088624:	dc400315 	stw	r17,12(sp)
21088628:	dc000215 	stw	r16,8(sp)
2108862c:	dfc00915 	stw	ra,36(sp)
21088630:	3021883a 	mov	r16,r6
21088634:	dd800815 	stw	r22,32(sp)
21088638:	dcc00515 	stw	r19,20(sp)

	/* ------------------------------- decompress ------------------------------- */

	font_glyph_bitmap = malloc(font_len_out);
2108863c:	94978004 	addi	r18,r18,24064
21088640:	d8800115 	stw	r2,4(sp)
 *           the mSGDMA.
 *
 *  Returns: Ptr to  display controller structure, or NULL on failure.
 ******************************************************************/
ece423_video_display* ece423_video_display_init(char* sgdma_name, int width,
		int height, int num_buffers) {
21088644:	2823883a 	mov	r17,r5
21088648:	3829883a 	mov	r20,r7

	/* ------------------------------- decompress ------------------------------- */

	font_glyph_bitmap = malloc(font_len_out);
2108864c:	108d8e80 	call	2108d8e8 <malloc>
21088650:	90800015 	stw	r2,0(r18)
21088654:	100d883a 	mov	r6,r2
    if(font_glyph_bitmap == NULL)
21088658:	1000af26 	beq	r2,zero,21088918 <ece423_video_display_init+0x31c>
        printf("Can not allocate buffer");
    decompress(font_compressed, font_len, font_glyph_bitmap, font_len_out);
2108865c:	00800034 	movhi	r2,0
21088660:	10976504 	addi	r2,r2,23956
21088664:	11400017 	ldw	r5,0(r2)
21088668:	d9c00117 	ldw	r7,4(sp)
2108866c:	01000034 	movhi	r4,0
21088670:	21025004 	addi	r4,r4,2368
21088674:	1088cb40 	call	21088cb4 <decompress>

    logo = (uint*)malloc(logo_len_out);
21088678:	00800034 	movhi	r2,0
2108867c:	10976604 	addi	r2,r2,23960
21088680:	10800017 	ldw	r2,0(r2)
21088684:	04800034 	movhi	r18,0
21088688:	94978104 	addi	r18,r18,24068
2108868c:	1009883a 	mov	r4,r2
21088690:	d8800115 	stw	r2,4(sp)
21088694:	108d8e80 	call	2108d8e8 <malloc>
21088698:	90800015 	stw	r2,0(r18)
2108869c:	100d883a 	mov	r6,r2
    if(logo == NULL)
210886a0:	1000a226 	beq	r2,zero,2108892c <ece423_video_display_init+0x330>
        printf("Can not allocate buffer");
    decompress(logo_compressed, logo_len, logo, logo_len_out);
210886a4:	00800034 	movhi	r2,0
210886a8:	10976704 	addi	r2,r2,23964
210886ac:	11400017 	ldw	r5,0(r2)
210886b0:	d9c00117 	ldw	r7,4(sp)
210886b4:	01000034 	movhi	r4,0
210886b8:	2103d544 	addi	r4,r4,3925
210886bc:	1088cb40 	call	21088cb4 <decompress>

	/* ----------------------------- init HDMI chip ----------------------------- */
	if (ece423_init_hdmi()) {
210886c0:	108818c0 	call	2108818c <ece423_init_hdmi>
210886c4:	10009e1e 	bne	r2,zero,21088940 <ece423_video_display_init+0x344>

	alt_msgdma_dev* pVid_DMA_CSR_Dev; // Ptr to mSGDMA Cont & Status Device

	// PreCalc Values
	bytes_per_pixel = 4;
	bytes_per_frame = ((width * height) * bytes_per_pixel);
210886c8:	8c27383a 	mul	r19,r17,r16

	descriptors_per_frame = 1;

	// DON'T EXCEED MAX Frame Bufs
	if (num_buffers > ECE423_VIDEO_DISPLAY_MAX_BUFFERS) {
210886cc:	00800904 	movi	r2,36

	alt_msgdma_dev* pVid_DMA_CSR_Dev; // Ptr to mSGDMA Cont & Status Device

	// PreCalc Values
	bytes_per_pixel = 4;
	bytes_per_frame = ((width * height) * bytes_per_pixel);
210886d0:	9ce7883a 	add	r19,r19,r19
210886d4:	9ce7883a 	add	r19,r19,r19

	descriptors_per_frame = 1;

	// DON'T EXCEED MAX Frame Bufs
	if (num_buffers > ECE423_VIDEO_DISPLAY_MAX_BUFFERS) {
210886d8:	15008016 	blt	r2,r20,210888dc <ece423_video_display_init+0x2e0>
		printf("The required number of buffers exceeds the max!\n");
		num_buffers = ECE423_VIDEO_DISPLAY_MAX_BUFFERS;
	} else if (num_buffers < 2) {
210886dc:	00800044 	movi	r2,1
210886e0:	1500880e 	bge	r2,r20,21088904 <ece423_video_display_init+0x308>
210886e4:	a0a9883a 	add	r20,r20,r2
		num_buffers = 2;
	}
	num_buffers = num_buffers + 1;

	// malloc display struct
	display = (ece423_video_display*) malloc(sizeof(ece423_video_display));
210886e8:	01002f04 	movi	r4,188
210886ec:	108d8e80 	call	2108d8e8 <malloc>
210886f0:	1025883a 	mov	r18,r2
	if (!display) {
210886f4:	10008126 	beq	r2,zero,210888fc <ece423_video_display_init+0x300>
	display->height = height;
	display->num_frame_buffers = num_buffers;
	display->bytes_per_frame = bytes_per_frame;
	display->bytes_per_pixel = bytes_per_pixel;
	display->buffer_being_displayed = 0;
	display->buffer_being_written = 1; // Init iPrev_Wr_Buf MUST MATCH
210886f8:	00800044 	movi	r2,1
210886fc:	90802715 	stw	r2,156(r18)
	// See iPrev_Wr_Buf in ece423_video_display_buffer_is_available
	display->descriptors_per_frame = descriptors_per_frame;
21088700:	90802d15 	stw	r2,180(r18)
	display->video_name = "";
21088704:	00800034 	movhi	r2,0
	// Init display struct
	display->width = width;
	display->height = height;
	display->num_frame_buffers = num_buffers;
	display->bytes_per_frame = bytes_per_frame;
	display->bytes_per_pixel = bytes_per_pixel;
21088708:	00c00104 	movi	r3,4
	display->buffer_being_displayed = 0;
	display->buffer_being_written = 1; // Init iPrev_Wr_Buf MUST MATCH
	// See iPrev_Wr_Buf in ece423_video_display_buffer_is_available
	display->descriptors_per_frame = descriptors_per_frame;
	display->video_name = "";
2108870c:	10805e04 	addi	r2,r2,376

	// malloc Frame and descriptor Bufs & SetUp Frame Buf Ptrs & Descriptor Ptrs
	if (ece423_video_display_allocate_buffers(display, bytes_per_frame,
21088710:	9009883a 	mov	r4,r18
21088714:	980b883a 	mov	r5,r19
21088718:	a00d883a 	mov	r6,r20
	if (!display) {
		return NULL;
	}

	// Init display struct
	display->width = width;
2108871c:	94402815 	stw	r17,160(r18)
	display->height = height;
21088720:	94002915 	stw	r16,164(r18)
	display->num_frame_buffers = num_buffers;
21088724:	95002c15 	stw	r20,176(r18)
	display->bytes_per_frame = bytes_per_frame;
21088728:	94c02b15 	stw	r19,172(r18)
	display->bytes_per_pixel = bytes_per_pixel;
2108872c:	90c02a15 	stw	r3,168(r18)
	display->buffer_being_displayed = 0;
21088730:	90002615 	stw	zero,152(r18)
	display->buffer_being_written = 1; // Init iPrev_Wr_Buf MUST MATCH
	// See iPrev_Wr_Buf in ece423_video_display_buffer_is_available
	display->descriptors_per_frame = descriptors_per_frame;
	display->video_name = "";
21088734:	90802e15 	stw	r2,184(r18)

	// malloc Frame and descriptor Bufs & SetUp Frame Buf Ptrs & Descriptor Ptrs
	if (ece423_video_display_allocate_buffers(display, bytes_per_frame,
21088738:	1087b400 	call	21087b40 <ece423_video_display_allocate_buffers>
2108873c:	10006f1e 	bne	r2,zero,210888fc <ece423_video_display_init+0x300>
			num_buffers)) {
		return NULL;
	}

	pVid_DMA_CSR_Dev = alt_msgdma_open(sgdma_name); // Pt to Cont & Status Dev
21088740:	a809883a 	mov	r4,r21
21088744:	109cff40 	call	2109cff4 <alt_msgdma_open>
	display->mSGDMA = pVid_DMA_CSR_Dev;
21088748:	90800015 	stw	r2,0(r18)
	if (ece423_video_display_allocate_buffers(display, bytes_per_frame,
			num_buffers)) {
		return NULL;
	}

	pVid_DMA_CSR_Dev = alt_msgdma_open(sgdma_name); // Pt to Cont & Status Dev
2108874c:	102b883a 	mov	r21,r2
	display->mSGDMA = pVid_DMA_CSR_Dev;
	if (pVid_DMA_CSR_Dev == NULL) {
21088750:	10006726 	beq	r2,zero,210888f0 <ece423_video_display_init+0x2f4>
		printf("ERROR ********* UNABLE to OPEN /dev/msgdma_csr\r\n");
		return NULL;
	}
	alt_u32 DMA_Status = IORD_ALTERA_MSGDMA_CSR_STATUS(
21088754:	10800317 	ldw	r2,12(r2)
21088758:	10c00037 	ldwio	r3,0(r2)
			display->mSGDMA->csr_base);
	if (DMA_Status != 0x22) {
2108875c:	00800884 	movi	r2,34
21088760:	18807e1e 	bne	r3,r2,2108895c <ece423_video_display_init+0x360>
		exit(-1);
	}

// Construct mSGDMA descriptors for each Frame Buf
	for (i = 0; i < num_buffers; i++) {
		alt_msgdma_construct_standard_mm_to_st_descriptor(pVid_DMA_CSR_Dev,
21088764:	05a00034 	movhi	r22,32768
21088768:	94400104 	addi	r17,r18,4
		printf("\t\tExiting ....\n\n");
		exit(-1);
	}

// Construct mSGDMA descriptors for each Frame Buf
	for (i = 0; i < num_buffers; i++) {
2108876c:	0021883a 	mov	r16,zero
		alt_msgdma_construct_standard_mm_to_st_descriptor(pVid_DMA_CSR_Dev,
21088770:	b581c004 	addi	r22,r22,1792
				display->buffer_ptrs[i]->desc_base,
21088774:	88c00017 	ldw	r3,0(r17)
		exit(-1);
	}

// Construct mSGDMA descriptors for each Frame Buf
	for (i = 0; i < num_buffers; i++) {
		alt_msgdma_construct_standard_mm_to_st_descriptor(pVid_DMA_CSR_Dev,
21088778:	a809883a 	mov	r4,r21
2108877c:	980f883a 	mov	r7,r19
21088780:	19800117 	ldw	r6,4(r3)
21088784:	dd800015 	stw	r22,0(sp)
21088788:	19400017 	ldw	r5,0(r3)
		printf("\t\tExiting ....\n\n");
		exit(-1);
	}

// Construct mSGDMA descriptors for each Frame Buf
	for (i = 0; i < num_buffers; i++) {
2108878c:	84000044 	addi	r16,r16,1
21088790:	8c400104 	addi	r17,r17,4
		alt_msgdma_construct_standard_mm_to_st_descriptor(pVid_DMA_CSR_Dev,
21088794:	109c6ec0 	call	2109c6ec <alt_msgdma_construct_standard_mm_to_st_descriptor>
		printf("\t\tExiting ....\n\n");
		exit(-1);
	}

// Construct mSGDMA descriptors for each Frame Buf
	for (i = 0; i < num_buffers; i++) {
21088798:	853ff61e 	bne	r16,r20,21088774 <__flash_rwdata_start+0xfffe652c>
				(alt_u32 *) display->buffer_ptrs[i]->buffer, bytes_per_frame,
				DESC_CONTROL);
	}

	alt_msgdma_construct_standard_mm_to_st_descriptor(pVid_DMA_CSR_Dev,
			display->text_buffer_ptr->desc_base,
2108879c:	90802517 	ldw	r2,148(r18)
				display->buffer_ptrs[i]->desc_base,
				(alt_u32 *) display->buffer_ptrs[i]->buffer, bytes_per_frame,
				DESC_CONTROL);
	}

	alt_msgdma_construct_standard_mm_to_st_descriptor(pVid_DMA_CSR_Dev,
210887a0:	00e00034 	movhi	r3,32768
210887a4:	18c1c004 	addi	r3,r3,1792
210887a8:	11800117 	ldw	r6,4(r2)
210887ac:	d8c00015 	stw	r3,0(sp)
210887b0:	11400017 	ldw	r5,0(r2)
210887b4:	a809883a 	mov	r4,r21
210887b8:	980f883a 	mov	r7,r19
210887bc:	109c6ec0 	call	2109c6ec <alt_msgdma_construct_standard_mm_to_st_descriptor>
 *
 ******************************************************************/
void ece423_video_display_color_screen(ece423_video_display* display,
		uint rgb_color) {
	uint color = rgb2ycbcr(rgb_color);
	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
210887c0:	90802717 	ldw	r2,156(r18)
	for (int i = 0; i < display->bytes_per_frame / 4; i += 1)
210887c4:	91002b17 	ldw	r4,172(r18)
 *
 ******************************************************************/
void ece423_video_display_color_screen(ece423_video_display* display,
		uint rgb_color) {
	uint color = rgb2ycbcr(rgb_color);
	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
210887c8:	10800044 	addi	r2,r2,1
210887cc:	1085883a 	add	r2,r2,r2
210887d0:	1085883a 	add	r2,r2,r2
210887d4:	9085883a 	add	r2,r18,r2
210887d8:	10800017 	ldw	r2,0(r2)
210887dc:	10c00117 	ldw	r3,4(r2)
	for (int i = 0; i < display->bytes_per_frame / 4; i += 1)
210887e0:	008000c4 	movi	r2,3
210887e4:	11000e0e 	bge	r2,r4,21088820 <ece423_video_display_init+0x224>
		frame[i] = color;
210887e8:	01402074 	movhi	r5,129
210887ec:	297fe004 	addi	r5,r5,-128
 ******************************************************************/
void ece423_video_display_color_screen(ece423_video_display* display,
		uint rgb_color) {
	uint color = rgb2ycbcr(rgb_color);
	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
	for (int i = 0; i < display->bytes_per_frame / 4; i += 1)
210887f0:	0009883a 	mov	r4,zero
210887f4:	00000206 	br	21088800 <ece423_video_display_init+0x204>
210887f8:	1005d0ba 	srai	r2,r2,2
210887fc:	2080080e 	bge	r4,r2,21088820 <ece423_video_display_init+0x224>
		frame[i] = color;
21088800:	19400015 	stw	r5,0(r3)
 ******************************************************************/
void ece423_video_display_color_screen(ece423_video_display* display,
		uint rgb_color) {
	uint color = rgb2ycbcr(rgb_color);
	int* frame = display->buffer_ptrs[display->buffer_being_written]->buffer;
	for (int i = 0; i < display->bytes_per_frame / 4; i += 1)
21088804:	90802b17 	ldw	r2,172(r18)
21088808:	21000044 	addi	r4,r4,1
2108880c:	18c00104 	addi	r3,r3,4
21088810:	103ff90e 	bge	r2,zero,210887f8 <__flash_rwdata_start+0xfffe65b0>
21088814:	108000c4 	addi	r2,r2,3
21088818:	1005d0ba 	srai	r2,r2,2
2108881c:	20bff816 	blt	r4,r2,21088800 <__flash_rwdata_start+0xfffe65b8>
			(alt_u32 *) display->text_buffer_ptr->buffer, bytes_per_frame,
			DESC_CONTROL);
	// Clear First Frame to WHITE
	ece423_video_display_clear_screen(display);
	// draw UW logo
	ece423_video_display_draw_logo(display);
21088820:	9009883a 	mov	r4,r18
21088824:	1085ee80 	call	21085ee8 <ece423_video_display_draw_logo>
	 * Note: The new buffer_being_written may NOT Yet be FREE
	 * So Call
	 * ece423_video_display_buffer_is_available
	 * to Check Before Drawing in it
	 */
	if(display->video_name)
21088828:	91402e17 	ldw	r5,184(r18)
2108882c:	28000326 	beq	r5,zero,2108883c <ece423_video_display_init+0x240>
		ece423_video_display_add_text(display, display->video_name, 10, 10, RGB_BLACK, 1);
21088830:	9009883a 	mov	r4,r18
21088834:	01800284 	movi	r6,10
21088838:	108538c0 	call	2108538c <ece423_video_display_add_text.constprop.2>
	display->buffer_being_written = (display->buffer_being_written + 1)
2108883c:	90802717 	ldw	r2,156(r18)
			% display->num_frame_buffers;
21088840:	91002c17 	ldw	r4,176(r18)
int ece423_video_display_switch_frames(ece423_video_display* display) {
	int iNext_Rd_Buf;

	alt_u32 RD_Desc_Fifo_Level;

	iNext_Rd_Buf = ((display->buffer_being_displayed + 1)
21088844:	94402617 	ldw	r17,152(r18)
	 * ece423_video_display_buffer_is_available
	 * to Check Before Drawing in it
	 */
	if(display->video_name)
		ece423_video_display_add_text(display, display->video_name, 10, 10, RGB_BLACK, 1);
	display->buffer_being_written = (display->buffer_being_written + 1)
21088848:	10c00044 	addi	r3,r2,1
			% display->num_frame_buffers;
2108884c:	1905283a 	div	r2,r3,r4
int ece423_video_display_switch_frames(ece423_video_display* display) {
	int iNext_Rd_Buf;

	alt_u32 RD_Desc_Fifo_Level;

	iNext_Rd_Buf = ((display->buffer_being_displayed + 1)
21088850:	89400044 	addi	r5,r17,1
	 * to Check Before Drawing in it
	 */
	if(display->video_name)
		ece423_video_display_add_text(display, display->video_name, 10, 10, RGB_BLACK, 1);
	display->buffer_being_written = (display->buffer_being_written + 1)
			% display->num_frame_buffers;
21088854:	1105383a 	mul	r2,r2,r4
int ece423_video_display_switch_frames(ece423_video_display* display) {
	int iNext_Rd_Buf;

	alt_u32 RD_Desc_Fifo_Level;

	iNext_Rd_Buf = ((display->buffer_being_displayed + 1)
21088858:	2923283a 	div	r17,r5,r4
2108885c:	8909383a 	mul	r4,r17,r4
	 * to Check Before Drawing in it
	 */
	if(display->video_name)
		ece423_video_display_add_text(display, display->video_name, 10, 10, RGB_BLACK, 1);
	display->buffer_being_written = (display->buffer_being_written + 1)
			% display->num_frame_buffers;
21088860:	1885c83a 	sub	r2,r3,r2
	 * ece423_video_display_buffer_is_available
	 * to Check Before Drawing in it
	 */
	if(display->video_name)
		ece423_video_display_add_text(display, display->video_name, 10, 10, RGB_BLACK, 1);
	display->buffer_being_written = (display->buffer_being_written + 1)
21088864:	90802715 	stw	r2,156(r18)
int ece423_video_display_switch_frames(ece423_video_display* display) {
	int iNext_Rd_Buf;

	alt_u32 RD_Desc_Fifo_Level;

	iNext_Rd_Buf = ((display->buffer_being_displayed + 1)
21088868:	2923c83a 	sub	r17,r5,r4
			% display->num_frame_buffers);

	// Check if there is a new buffer to display
	if ((iNext_Rd_Buf != display->buffer_being_written)) {
2108886c:	14403926 	beq	r2,r17,21088954 <ece423_video_display_init+0x358>
21088870:	8c000044 	addi	r16,r17,1

		// Transfer Descriptor for Frame to mSGDMA
		while (alt_msgdma_standard_descriptor_async_transfer(display->mSGDMA,
				display->buffer_ptrs[iNext_Rd_Buf]->desc_base) != 0) {
21088874:	8421883a 	add	r16,r16,r16
21088878:	8421883a 	add	r16,r16,r16
2108887c:	9421883a 	add	r16,r18,r16

	// Check if there is a new buffer to display
	if ((iNext_Rd_Buf != display->buffer_being_written)) {

		// Transfer Descriptor for Frame to mSGDMA
		while (alt_msgdma_standard_descriptor_async_transfer(display->mSGDMA,
21088880:	80800017 	ldw	r2,0(r16)
21088884:	91000017 	ldw	r4,0(r18)
21088888:	11400017 	ldw	r5,0(r2)
2108888c:	109d1400 	call	2109d140 <alt_msgdma_standard_descriptor_async_transfer>
21088890:	103ffb1e 	bne	r2,zero,21088880 <__flash_rwdata_start+0xfffe6638>
21088894:	91000017 	ldw	r4,0(r18)
		do {
			RD_Desc_Fifo_Level = (IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(
					display->mSGDMA->csr_base)
					& ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK)
					>> ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		} while (RD_Desc_Fifo_Level > 1);
21088898:	00c00044 	movi	r3,1
				display->buffer_ptrs[iNext_Rd_Buf]->desc_base) != 0) {
		}  // Keep Trying until there is room to Transfer another Frame

		// Wait if there is another frame waiting in the list
		do {
			RD_Desc_Fifo_Level = (IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(
2108889c:	20800317 	ldw	r2,12(r4)
210888a0:	10800237 	ldwio	r2,8(r2)
210888a4:	10bfffcc 	andi	r2,r2,65535
					display->mSGDMA->csr_base)
					& ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK)
					>> ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		} while (RD_Desc_Fifo_Level > 1);
210888a8:	18bffc36 	bltu	r3,r2,2108889c <__flash_rwdata_start+0xfffe6654>

		display->buffer_being_displayed = iNext_Rd_Buf;
210888ac:	94402615 	stw	r17,152(r18)
210888b0:	9005883a 	mov	r2,r18
	ece423_video_display_draw_logo(display);
	ece423_video_display_register_written_buffer(display);
	ece423_video_display_switch_frames(display);

	return (display);
}
210888b4:	dfc00917 	ldw	ra,36(sp)
210888b8:	dd800817 	ldw	r22,32(sp)
210888bc:	dd400717 	ldw	r21,28(sp)
210888c0:	dd000617 	ldw	r20,24(sp)
210888c4:	dcc00517 	ldw	r19,20(sp)
210888c8:	dc800417 	ldw	r18,16(sp)
210888cc:	dc400317 	ldw	r17,12(sp)
210888d0:	dc000217 	ldw	r16,8(sp)
210888d4:	dec00a04 	addi	sp,sp,40
210888d8:	f800283a 	ret

	descriptors_per_frame = 1;

	// DON'T EXCEED MAX Frame Bufs
	if (num_buffers > ECE423_VIDEO_DISPLAY_MAX_BUFFERS) {
		printf("The required number of buffers exceeds the max!\n");
210888dc:	01000034 	movhi	r4,0
210888e0:	21015b04 	addi	r4,r4,1388
210888e4:	05000944 	movi	r20,37
210888e8:	108e4c00 	call	2108e4c0 <puts>
210888ec:	003f7e06 	br	210886e8 <__flash_rwdata_start+0xfffe64a0>
	}

	pVid_DMA_CSR_Dev = alt_msgdma_open(sgdma_name); // Pt to Cont & Status Dev
	display->mSGDMA = pVid_DMA_CSR_Dev;
	if (pVid_DMA_CSR_Dev == NULL) {
		printf("ERROR ********* UNABLE to OPEN /dev/msgdma_csr\r\n");
210888f0:	01000034 	movhi	r4,0
210888f4:	21017004 	addi	r4,r4,1472
210888f8:	108e4c00 	call	2108e4c0 <puts>
		return NULL;
210888fc:	0005883a 	mov	r2,zero
21088900:	003fec06 	br	210888b4 <__flash_rwdata_start+0xfffe666c>
	// DON'T EXCEED MAX Frame Bufs
	if (num_buffers > ECE423_VIDEO_DISPLAY_MAX_BUFFERS) {
		printf("The required number of buffers exceeds the max!\n");
		num_buffers = ECE423_VIDEO_DISPLAY_MAX_BUFFERS;
	} else if (num_buffers < 2) {
		printf("The number of buffers must be > 2!\n");
21088904:	01000034 	movhi	r4,0
21088908:	21016704 	addi	r4,r4,1436
2108890c:	050000c4 	movi	r20,3
21088910:	108e4c00 	call	2108e4c0 <puts>
21088914:	003f7406 	br	210886e8 <__flash_rwdata_start+0xfffe64a0>

	/* ------------------------------- decompress ------------------------------- */

	font_glyph_bitmap = malloc(font_len_out);
    if(font_glyph_bitmap == NULL)
        printf("Can not allocate buffer");
21088918:	01000034 	movhi	r4,0
2108891c:	21014c04 	addi	r4,r4,1328
21088920:	108e3bc0 	call	2108e3bc <printf>
21088924:	91800017 	ldw	r6,0(r18)
21088928:	003f4c06 	br	2108865c <__flash_rwdata_start+0xfffe6414>
    decompress(font_compressed, font_len, font_glyph_bitmap, font_len_out);

    logo = (uint*)malloc(logo_len_out);
    if(logo == NULL)
        printf("Can not allocate buffer");
2108892c:	01000034 	movhi	r4,0
21088930:	21014c04 	addi	r4,r4,1328
21088934:	108e3bc0 	call	2108e3bc <printf>
21088938:	91800017 	ldw	r6,0(r18)
2108893c:	003f5906 	br	210886a4 <__flash_rwdata_start+0xfffe645c>
    decompress(logo_compressed, logo_len, logo, logo_len_out);

	/* ----------------------------- init HDMI chip ----------------------------- */
	if (ece423_init_hdmi()) {
		printf("Failed to initiate the HDMI chip!\n");
21088940:	01000034 	movhi	r4,0
21088944:	21015204 	addi	r4,r4,1352
21088948:	108e4c00 	call	2108e4c0 <puts>
		return 0;
2108894c:	0005883a 	mov	r2,zero
21088950:	003fd806 	br	210888b4 <__flash_rwdata_start+0xfffe666c>

	iNext_Rd_Buf = ((display->buffer_being_displayed + 1)
			% display->num_frame_buffers);

	// Check if there is a new buffer to display
	if ((iNext_Rd_Buf != display->buffer_being_written)) {
21088954:	9005883a 	mov	r2,r18
21088958:	003fd606 	br	210888b4 <__flash_rwdata_start+0xfffe666c>
		return NULL;
	}
	alt_u32 DMA_Status = IORD_ALTERA_MSGDMA_CSR_STATUS(
			display->mSGDMA->csr_base);
	if (DMA_Status != 0x22) {
		printf("\n\t\tVideo DMA Error\n");
2108895c:	01000034 	movhi	r4,0
21088960:	21017c04 	addi	r4,r4,1520
21088964:	108e4c00 	call	2108e4c0 <puts>
		printf("\t\tReset the CPU or re-program the hardware!\n");
21088968:	01000034 	movhi	r4,0
2108896c:	21018104 	addi	r4,r4,1540
21088970:	108e4c00 	call	2108e4c0 <puts>
		printf("\t\tExiting ....\n\n");
21088974:	01000034 	movhi	r4,0
21088978:	21018c04 	addi	r4,r4,1584
2108897c:	108e4c00 	call	2108e4c0 <puts>
		exit(-1);
21088980:	013fffc4 	movi	r4,-1
21088984:	108d5880 	call	2108d588 <exit>

21088988 <rgb2ycbcr>:
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x2F, 0x13);

	return 0;
}

uint rgb2ycbcr(uint rgb) {
21088988:	defff604 	addi	sp,sp,-40
2108898c:	dc000015 	stw	r16,0(sp)
21088990:	2021883a 	mov	r16,r4
	unsigned char r, g, b;
	b = rgb & 0xff;
	g = (rgb >> 8) & 0xff;
	r = (rgb >> 16) & 0xff;
21088994:	2008d43a 	srli	r4,r4,16
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x2F, 0x13);

	return 0;
}

uint rgb2ycbcr(uint rgb) {
21088998:	dfc00915 	stw	ra,36(sp)
2108899c:	df000815 	stw	fp,32(sp)
	b = rgb & 0xff;
	g = (rgb >> 8) & 0xff;
	r = (rgb >> 16) & 0xff;

	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
210889a0:	21003fcc 	andi	r4,r4,255
	I2C_Write(I2C_SCL_BASE, I2C_SDA_BASE, slave_addr, 0x2F, 0x13);

	return 0;
}

uint rgb2ycbcr(uint rgb) {
210889a4:	ddc00715 	stw	r23,28(sp)
210889a8:	dd800615 	stw	r22,24(sp)
210889ac:	dd400515 	stw	r21,20(sp)
210889b0:	dd000415 	stw	r20,16(sp)
210889b4:	dcc00315 	stw	r19,12(sp)
210889b8:	dc800215 	stw	r18,8(sp)
210889bc:	dc400115 	stw	r17,4(sp)
	b = rgb & 0xff;
	g = (rgb >> 8) & 0xff;
	r = (rgb >> 16) & 0xff;

	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
210889c0:	108cfdc0 	call	2108cfdc <__floatsidf>
}

uint rgb2ycbcr(uint rgb) {
	unsigned char r, g, b;
	b = rgb & 0xff;
	g = (rgb >> 8) & 0xff;
210889c4:	8008d23a 	srli	r4,r16,8
	r = (rgb >> 16) & 0xff;

	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
210889c8:	102d883a 	mov	r22,r2
210889cc:	182b883a 	mov	r21,r3
210889d0:	21003fcc 	andi	r4,r4,255
210889d4:	108cfdc0 	call	2108cfdc <__floatsidf>
210889d8:	81003fcc 	andi	r4,r16,255
210889dc:	1029883a 	mov	r20,r2
210889e0:	1827883a 	mov	r19,r3
210889e4:	108cfdc0 	call	2108cfdc <__floatsidf>
	cb = -0.168736 * r - 0.331264 * g + 0.5 * b + 128;
210889e8:	018a3534 	movhi	r6,10452
210889ec:	01eff1b4 	movhi	r7,49094
210889f0:	b009883a 	mov	r4,r22
210889f4:	a80b883a 	mov	r5,r21
210889f8:	318d2804 	addi	r6,r6,13472
210889fc:	39e64904 	addi	r7,r7,-26332
	b = rgb & 0xff;
	g = (rgb >> 8) & 0xff;
	r = (rgb >> 16) & 0xff;

	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
21088a00:	1025883a 	mov	r18,r2
21088a04:	1823883a 	mov	r17,r3
	cb = -0.168736 * r - 0.331264 * g + 0.5 * b + 128;
21088a08:	108bf600 	call	2108bf60 <__muldf3>
21088a0c:	01bae5b4 	movhi	r6,60310
21088a10:	01cff574 	movhi	r7,16341
21088a14:	a009883a 	mov	r4,r20
21088a18:	980b883a 	mov	r5,r19
21088a1c:	31b96c04 	addi	r6,r6,-6736
21088a20:	39ccdb44 	addi	r7,r7,13165
21088a24:	102f883a 	mov	r23,r2
21088a28:	1821883a 	mov	r16,r3
21088a2c:	108bf600 	call	2108bf60 <__muldf3>
21088a30:	b809883a 	mov	r4,r23
21088a34:	800b883a 	mov	r5,r16
21088a38:	100d883a 	mov	r6,r2
21088a3c:	180f883a 	mov	r7,r3
21088a40:	108c6840 	call	2108c684 <__subdf3>
21088a44:	9009883a 	mov	r4,r18
21088a48:	880b883a 	mov	r5,r17
21088a4c:	000d883a 	mov	r6,zero
21088a50:	01cff834 	movhi	r7,16352
21088a54:	102f883a 	mov	r23,r2
21088a58:	1821883a 	mov	r16,r3
21088a5c:	108bf600 	call	2108bf60 <__muldf3>
21088a60:	b809883a 	mov	r4,r23
21088a64:	800b883a 	mov	r5,r16
21088a68:	100d883a 	mov	r6,r2
21088a6c:	180f883a 	mov	r7,r3
21088a70:	108ad180 	call	2108ad18 <__adddf3>
21088a74:	000d883a 	mov	r6,zero
21088a78:	01d01834 	movhi	r7,16480
21088a7c:	1009883a 	mov	r4,r2
21088a80:	180b883a 	mov	r5,r3
21088a84:	108ad180 	call	2108ad18 <__adddf3>
21088a88:	180b883a 	mov	r5,r3
21088a8c:	1009883a 	mov	r4,r2
21088a90:	108a3200 	call	2108a320 <__fixunsdfsi>
	b = rgb & 0xff;
	g = (rgb >> 8) & 0xff;
	r = (rgb >> 16) & 0xff;

	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
21088a94:	01b95834 	movhi	r6,58720
21088a98:	01cff4f4 	movhi	r7,16339
21088a9c:	b009883a 	mov	r4,r22
21088aa0:	a80b883a 	mov	r5,r21
21088aa4:	31906244 	addi	r6,r6,16777
21088aa8:	39c8b404 	addi	r7,r7,8912
	cb = -0.168736 * r - 0.331264 * g + 0.5 * b + 128;
	cr = 0.5 * r - 0.418688 * g - 0.081312 * b + 128;

	uint ycbcr = (cr << 16) | (y << 8) | (cb);
21088aac:	14003fcc 	andi	r16,r2,255
	b = rgb & 0xff;
	g = (rgb >> 8) & 0xff;
	r = (rgb >> 16) & 0xff;

	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
21088ab0:	108bf600 	call	2108bf60 <__muldf3>
21088ab4:	018e5634 	movhi	r6,14680
21088ab8:	01cff8f4 	movhi	r7,16355
21088abc:	a009883a 	mov	r4,r20
21088ac0:	980b883a 	mov	r5,r19
21088ac4:	31841884 	addi	r6,r6,4194
21088ac8:	39f22d04 	addi	r7,r7,-14156
21088acc:	1039883a 	mov	fp,r2
21088ad0:	182f883a 	mov	r23,r3
21088ad4:	108bf600 	call	2108bf60 <__muldf3>
21088ad8:	e009883a 	mov	r4,fp
21088adc:	b80b883a 	mov	r5,r23
21088ae0:	100d883a 	mov	r6,r2
21088ae4:	180f883a 	mov	r7,r3
21088ae8:	108ad180 	call	2108ad18 <__adddf3>
21088aec:	01a7efb4 	movhi	r6,40894
21088af0:	01cfef74 	movhi	r7,16317
21088af4:	9009883a 	mov	r4,r18
21088af8:	880b883a 	mov	r5,r17
21088afc:	319db244 	addi	r6,r6,30409
21088b00:	39cbc684 	addi	r7,r7,12058
21088b04:	1039883a 	mov	fp,r2
21088b08:	182f883a 	mov	r23,r3
21088b0c:	108bf600 	call	2108bf60 <__muldf3>
21088b10:	e009883a 	mov	r4,fp
21088b14:	b80b883a 	mov	r5,r23
21088b18:	100d883a 	mov	r6,r2
21088b1c:	180f883a 	mov	r7,r3
21088b20:	108ad180 	call	2108ad18 <__adddf3>
21088b24:	180b883a 	mov	r5,r3
21088b28:	1009883a 	mov	r4,r2
21088b2c:	108a3200 	call	2108a320 <__fixunsdfsi>
	cb = -0.168736 * r - 0.331264 * g + 0.5 * b + 128;
	cr = 0.5 * r - 0.418688 * g - 0.081312 * b + 128;

	uint ycbcr = (cr << 16) | (y << 8) | (cb);
21088b30:	10803fcc 	andi	r2,r2,255
21088b34:	1010923a 	slli	r8,r2,8
	r = (rgb >> 16) & 0xff;

	unsigned char y, cb, cr;
	y = 0.299 * r + 0.587 * g + 0.114 * b;
	cb = -0.168736 * r - 0.331264 * g + 0.5 * b + 128;
	cr = 0.5 * r - 0.418688 * g - 0.081312 * b + 128;
21088b38:	b009883a 	mov	r4,r22
21088b3c:	a80b883a 	mov	r5,r21
21088b40:	000d883a 	mov	r6,zero
21088b44:	01cff834 	movhi	r7,16352
21088b48:	8220b03a 	or	r16,r16,r8
21088b4c:	108bf600 	call	2108bf60 <__muldf3>
21088b50:	01b033f4 	movhi	r6,49359
21088b54:	01cff6f4 	movhi	r7,16347
21088b58:	a009883a 	mov	r4,r20
21088b5c:	980b883a 	mov	r5,r19
21088b60:	31a47244 	addi	r6,r6,-28215
21088b64:	39f2f204 	addi	r7,r7,-13368
21088b68:	102d883a 	mov	r22,r2
21088b6c:	182b883a 	mov	r21,r3
21088b70:	108bf600 	call	2108bf60 <__muldf3>
21088b74:	b009883a 	mov	r4,r22
21088b78:	a80b883a 	mov	r5,r21
21088b7c:	100d883a 	mov	r6,r2
21088b80:	180f883a 	mov	r7,r3
21088b84:	108c6840 	call	2108c684 <__subdf3>
21088b88:	01bf31b4 	movhi	r6,64710
21088b8c:	01cfed74 	movhi	r7,16309
21088b90:	9009883a 	mov	r4,r18
21088b94:	880b883a 	mov	r5,r17
21088b98:	31ae3704 	addi	r6,r6,-18212
21088b9c:	39f43704 	addi	r7,r7,-12068
21088ba0:	1029883a 	mov	r20,r2
21088ba4:	1827883a 	mov	r19,r3
21088ba8:	108bf600 	call	2108bf60 <__muldf3>
21088bac:	a009883a 	mov	r4,r20
21088bb0:	980b883a 	mov	r5,r19
21088bb4:	100d883a 	mov	r6,r2
21088bb8:	180f883a 	mov	r7,r3
21088bbc:	108c6840 	call	2108c684 <__subdf3>
21088bc0:	000d883a 	mov	r6,zero
21088bc4:	01d01834 	movhi	r7,16480
21088bc8:	1009883a 	mov	r4,r2
21088bcc:	180b883a 	mov	r5,r3
21088bd0:	108ad180 	call	2108ad18 <__adddf3>
21088bd4:	1009883a 	mov	r4,r2
21088bd8:	180b883a 	mov	r5,r3
21088bdc:	108a3200 	call	2108a320 <__fixunsdfsi>

	uint ycbcr = (cr << 16) | (y << 8) | (cb);
21088be0:	10803fcc 	andi	r2,r2,255
21088be4:	1004943a 	slli	r2,r2,16
	return ycbcr & 0x00ffffff;
}
21088be8:	8084b03a 	or	r2,r16,r2
21088bec:	dfc00917 	ldw	ra,36(sp)
21088bf0:	df000817 	ldw	fp,32(sp)
21088bf4:	ddc00717 	ldw	r23,28(sp)
21088bf8:	dd800617 	ldw	r22,24(sp)
21088bfc:	dd400517 	ldw	r21,20(sp)
21088c00:	dd000417 	ldw	r20,16(sp)
21088c04:	dcc00317 	ldw	r19,12(sp)
21088c08:	dc800217 	ldw	r18,8(sp)
21088c0c:	dc400117 	ldw	r17,4(sp)
21088c10:	dc000017 	ldw	r16,0(sp)
21088c14:	dec00a04 	addi	sp,sp,40
21088c18:	f800283a 	ret

21088c1c <itoa>:

char *
itoa (int value, char *result, int base)
{
21088c1c:	2805883a 	mov	r2,r5
    // check that the base if valid
    if (base < 2 || base > 36) { *result = '\0'; return result; }
21088c20:	30ffff84 	addi	r3,r6,-2
21088c24:	01400884 	movi	r5,34
21088c28:	28c01c36 	bltu	r5,r3,21088c9c <itoa+0x80>
21088c2c:	02c00034 	movhi	r11,0
21088c30:	1011883a 	mov	r8,r2
21088c34:	1007883a 	mov	r3,r2
21088c38:	5ac13a04 	addi	r11,r11,1256
21088c3c:	00000106 	br	21088c44 <itoa+0x28>

    do {
        tmp_value = value;
        value /= base;
        *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz" [35 + (tmp_value - value * base)];
    } while ( value );
21088c40:	4809883a 	mov	r4,r9
    char* ptr = result, *ptr1 = result, tmp_char;
    int tmp_value;

    do {
        tmp_value = value;
        value /= base;
21088c44:	2193283a 	div	r9,r4,r6
        *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz" [35 + (tmp_value - value * base)];
21088c48:	324f383a 	mul	r7,r6,r9
21088c4c:	1815883a 	mov	r10,r3
21088c50:	18c00044 	addi	r3,r3,1
21088c54:	21cfc83a 	sub	r7,r4,r7
21088c58:	59cf883a 	add	r7,r11,r7
21088c5c:	39c008c3 	ldbu	r7,35(r7)
21088c60:	51c00005 	stb	r7,0(r10)
    } while ( value );
21088c64:	483ff61e 	bne	r9,zero,21088c40 <__flash_rwdata_start+0xfffe69f8>

    // Apply negative sign
    if (tmp_value < 0) *ptr++ = '-';
21088c68:	20000e16 	blt	r4,zero,21088ca4 <itoa+0x88>
    *ptr-- = '\0';
21088c6c:	18000005 	stb	zero,0(r3)
21088c70:	18ffffc4 	addi	r3,r3,-1
    while (ptr1 < ptr) {
21088c74:	10c0082e 	bgeu	r2,r3,21088c98 <itoa+0x7c>
        tmp_char = *ptr;
        *ptr--= *ptr1;
21088c78:	41c00003 	ldbu	r7,0(r8)

    // Apply negative sign
    if (tmp_value < 0) *ptr++ = '-';
    *ptr-- = '\0';
    while (ptr1 < ptr) {
        tmp_char = *ptr;
21088c7c:	19800003 	ldbu	r6,0(r3)
21088c80:	4009883a 	mov	r4,r8
        *ptr--= *ptr1;
21088c84:	19c00005 	stb	r7,0(r3)
21088c88:	42000044 	addi	r8,r8,1
        *ptr1++ = tmp_char;
21088c8c:	21800005 	stb	r6,0(r4)
21088c90:	18ffffc4 	addi	r3,r3,-1
    } while ( value );

    // Apply negative sign
    if (tmp_value < 0) *ptr++ = '-';
    *ptr-- = '\0';
    while (ptr1 < ptr) {
21088c94:	40fff836 	bltu	r8,r3,21088c78 <__flash_rwdata_start+0xfffe6a30>
        tmp_char = *ptr;
        *ptr--= *ptr1;
        *ptr1++ = tmp_char;
    }
    return result;
}
21088c98:	f800283a 	ret

char *
itoa (int value, char *result, int base)
{
    // check that the base if valid
    if (base < 2 || base > 36) { *result = '\0'; return result; }
21088c9c:	10000005 	stb	zero,0(r2)
21088ca0:	f800283a 	ret
        value /= base;
        *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz" [35 + (tmp_value - value * base)];
    } while ( value );

    // Apply negative sign
    if (tmp_value < 0) *ptr++ = '-';
21088ca4:	01000b44 	movi	r4,45
21088ca8:	50c00084 	addi	r3,r10,2
21088cac:	51000045 	stb	r4,1(r10)
21088cb0:	003fee06 	br	21088c6c <__flash_rwdata_start+0xfffe6a24>

21088cb4 <decompress>:
    } while (sunk < data_sz);

    return 0;
}

int decompress(char* in, int in_size, char* out, int out_size) {
21088cb4:	defff104 	addi	sp,sp,-60
21088cb8:	df000d15 	stw	fp,52(sp)
21088cbc:	dc800715 	stw	r18,28(sp)
21088cc0:	dc000515 	stw	r16,20(sp)
21088cc4:	dfc00e15 	stw	ra,56(sp)
21088cc8:	ddc00c15 	stw	r23,48(sp)
21088ccc:	dd800b15 	stw	r22,44(sp)
21088cd0:	dd400a15 	stw	r21,40(sp)
21088cd4:	dd000915 	stw	r20,36(sp)
21088cd8:	dcc00815 	stw	r19,32(sp)
21088cdc:	dc400615 	stw	r17,24(sp)
21088ce0:	df000d04 	addi	fp,sp,52
21088ce4:	e13ff515 	stw	r4,-44(fp)
21088ce8:	e17ff615 	stw	r5,-40(fp)
21088cec:	3021883a 	mov	r16,r6
    size_t window_sz = 1 << DEF_WINDOW_SZ2;
    size_t ibs = DEF_DECODER_INPUT_BUFFER_SIZE;
    heatshrink_decoder *hsd = heatshrink_decoder_alloc(ibs,
21088cf0:	01004004 	movi	r4,256
21088cf4:	01400384 	movi	r5,14
21088cf8:	01800284 	movi	r6,10
21088cfc:	1088e700 	call	21088e70 <heatshrink_decoder_alloc>
21088d00:	1025883a 	mov	r18,r2
        DEF_WINDOW_SZ2, DEF_LOOKAHEAD_SZ2);

    if (hsd == NULL) { die("failed to init decoder"); }
21088d04:	10005626 	beq	r2,zero,21088e60 <decompress+0x1ac>
    } while (sunk < data_sz);

    return 0;
}

int decompress(char* in, int in_size, char* out, int out_size) {
21088d08:	002d883a 	mov	r22,zero
            if (pres < 0) { die("poll"); }
            memcpy(out_ptr, out_buf, poll_sz);
            out_ptr = out_ptr + poll_sz;
            *out = out_ptr;
            
        } while (pres == HSDR_POLL_MORE);
21088d0c:	04c00044 	movi	r19,1
21088d10:	e0bff617 	ldw	r2,-40(fp)
21088d14:	00000606 	br	21088d30 <decompress+0x7c>
        int rem_sz = in_size - done_sz;
        read_sz = rem_sz >= window_sz? window_sz : rem_sz;
        uint8_t *input = in + done_sz;
        
        if (rem_sz == 0) {
            fres = heatshrink_decoder_finish(hsd);
21088d18:	9009883a 	mov	r4,r18
21088d1c:	10897600 	call	21089760 <heatshrink_decoder_finish>
            if (fres < 0) { die("finish"); }
21088d20:	10003b16 	blt	r2,zero,21088e10 <decompress+0x15c>
            if (fres == HSDR_FINISH_DONE) break;        
21088d24:	10003e26 	beq	r2,zero,21088e20 <decompress+0x16c>
    } while (sunk < data_sz);

    return 0;
}

int decompress(char* in, int in_size, char* out, int out_size) {
21088d28:	e5bff617 	ldw	r22,-40(fp)
21088d2c:	b005883a 	mov	r2,r22
    int done_sz = 0;
    char* out_ptr = out;
//    printf("Decoding\n");
    /* Process input until end of stream */
    while (1) {
        int rem_sz = in_size - done_sz;
21088d30:	15abc83a 	sub	r21,r2,r22
        read_sz = rem_sz >= window_sz? window_sz : rem_sz;
        uint8_t *input = in + done_sz;
        
        if (rem_sz == 0) {
21088d34:	a83ff826 	beq	r21,zero,21088d18 <__flash_rwdata_start+0xfffe6ad0>
    char* out_ptr = out;
//    printf("Decoding\n");
    /* Process input until end of stream */
    while (1) {
        int rem_sz = in_size - done_sz;
        read_sz = rem_sz >= window_sz? window_sz : rem_sz;
21088d38:	00900004 	movi	r2,16384
21088d3c:	1540012e 	bgeu	r2,r21,21088d44 <decompress+0x90>
21088d40:	102b883a 	mov	r21,r2
21088d44:	e6fff715 	stw	sp,-36(fp)
static int decoder_sink_read(char** out, heatshrink_decoder *hsd,
        uint8_t *data, size_t data_sz) {
    size_t sink_sz = 0;
    size_t poll_sz = 0;
    size_t out_sz = 4096;
    uint8_t out_buf[out_sz];
21088d48:	defc0004 	addi	sp,sp,-4096
    memset(out_buf, 0, out_sz);
21088d4c:	d809883a 	mov	r4,sp
21088d50:	000b883a 	mov	r5,zero
21088d54:	01840004 	movi	r6,4096
}


static int decoder_sink_read(char** out, heatshrink_decoder *hsd,
        uint8_t *data, size_t data_sz) {
    size_t sink_sz = 0;
21088d58:	e03ff415 	stw	zero,-48(fp)
    size_t poll_sz = 0;
21088d5c:	e03ff315 	stw	zero,-52(fp)
    size_t out_sz = 4096;
    uint8_t out_buf[out_sz];
21088d60:	d823883a 	mov	r17,sp
    memset(out_buf, 0, out_sz);
21088d64:	108e26c0 	call	2108e26c <memset>
    HSD_sink_res sres;
    HSD_poll_res pres;
    HSD_finish_res fres;
//    printf("Sinking: %d\n", data_sz);
    char* out_ptr = *out;
    size_t sunk = 0;
21088d68:	0029883a 	mov	r20,zero
    do {
        if (data_sz > 0) {
            sres = heatshrink_decoder_sink(hsd, &data[sunk], data_sz - sunk, &sink_sz);
21088d6c:	e0bff517 	ldw	r2,-44(fp)
21088d70:	a58b883a 	add	r5,r20,r22
21088d74:	9009883a 	mov	r4,r18
21088d78:	114b883a 	add	r5,r2,r5
21088d7c:	ad0dc83a 	sub	r6,r21,r20
21088d80:	e1fff404 	addi	r7,fp,-48
21088d84:	1088fac0 	call	21088fac <heatshrink_decoder_sink>
            if (sres < 0) { die("sink"); }
21088d88:	10001d16 	blt	r2,zero,21088e00 <decompress+0x14c>
            sunk += sink_sz;
21088d8c:	e0bff417 	ldw	r2,-48(fp)
21088d90:	a0a9883a 	add	r20,r20,r2
21088d94:	00000506 	br	21088dac <decompress+0xf8>
        }

        do {
            pres = heatshrink_decoder_poll(hsd, out_buf, out_sz, &poll_sz);
            if (pres < 0) { die("poll"); }
            memcpy(out_ptr, out_buf, poll_sz);
21088d98:	e1bff317 	ldw	r6,-52(fp)
21088d9c:	108e1340 	call	2108e134 <memcpy>
            out_ptr = out_ptr + poll_sz;
21088da0:	e0bff317 	ldw	r2,-52(fp)
21088da4:	80a1883a 	add	r16,r16,r2
            *out = out_ptr;
            
        } while (pres == HSDR_POLL_MORE);
21088da8:	bcc0121e 	bne	r23,r19,21088df4 <decompress+0x140>
            if (sres < 0) { die("sink"); }
            sunk += sink_sz;
        }

        do {
            pres = heatshrink_decoder_poll(hsd, out_buf, out_sz, &poll_sz);
21088dac:	9009883a 	mov	r4,r18
21088db0:	880b883a 	mov	r5,r17
21088db4:	01840004 	movi	r6,4096
21088db8:	e1fff304 	addi	r7,fp,-52
21088dbc:	10890440 	call	21089044 <heatshrink_decoder_poll>
21088dc0:	102f883a 	mov	r23,r2
            if (pres < 0) { die("poll"); }
            memcpy(out_ptr, out_buf, poll_sz);
21088dc4:	8009883a 	mov	r4,r16
21088dc8:	880b883a 	mov	r5,r17
            sunk += sink_sz;
        }

        do {
            pres = heatshrink_decoder_poll(hsd, out_buf, out_sz, &poll_sz);
            if (pres < 0) { die("poll"); }
21088dcc:	103ff20e 	bge	r2,zero,21088d98 <__flash_rwdata_start+0xfffe6b50>
#define DEF_DECODER_INPUT_BUFFER_SIZE 256
#define DEF_BUFFER_SIZE (64 * 1024)


static void die(char *msg) {
    printf("%s\n", msg);
21088dd0:	01000034 	movhi	r4,0
21088dd4:	2103d404 	addi	r4,r4,3920
21088dd8:	108e4c00 	call	2108e4c0 <puts>
        }

        do {
            pres = heatshrink_decoder_poll(hsd, out_buf, out_sz, &poll_sz);
            if (pres < 0) { die("poll"); }
            memcpy(out_ptr, out_buf, poll_sz);
21088ddc:	e1bff317 	ldw	r6,-52(fp)
21088de0:	8009883a 	mov	r4,r16
21088de4:	880b883a 	mov	r5,r17
21088de8:	108e1340 	call	2108e134 <memcpy>
            out_ptr = out_ptr + poll_sz;
21088dec:	e0bff317 	ldw	r2,-52(fp)
21088df0:	80a1883a 	add	r16,r16,r2
        if (data_sz == 0 && poll_sz == 0) {
            fres = heatshrink_decoder_finish(hsd);
            if (fres < 0) { die("finish"); }
            if (fres == HSDR_FINISH_DONE) { return 1; }
        }
    } while (sunk < data_sz);
21088df4:	a57fdd36 	bltu	r20,r21,21088d6c <__flash_rwdata_start+0xfffe6b24>
21088df8:	e6fff717 	ldw	sp,-36(fp)
21088dfc:	003fca06 	br	21088d28 <__flash_rwdata_start+0xfffe6ae0>
#define DEF_DECODER_INPUT_BUFFER_SIZE 256
#define DEF_BUFFER_SIZE (64 * 1024)


static void die(char *msg) {
    printf("%s\n", msg);
21088e00:	01000034 	movhi	r4,0
21088e04:	2103d204 	addi	r4,r4,3912
21088e08:	108e4c00 	call	2108e4c0 <puts>
21088e0c:	003fdf06 	br	21088d8c <__flash_rwdata_start+0xfffe6b44>
21088e10:	01000034 	movhi	r4,0
21088e14:	2103d004 	addi	r4,r4,3904
21088e18:	108e4c00 	call	2108e4c0 <puts>
21088e1c:	003fc206 	br	21088d28 <__flash_rwdata_start+0xfffe6ae0>
            if (decoder_sink_read(&out_ptr, hsd, input, read_sz)) { break; }
        }
        done_sz = done_sz + rem_sz;
    }
        
    heatshrink_decoder_free(hsd);
21088e20:	9009883a 	mov	r4,r18
21088e24:	1088f480 	call	21088f48 <heatshrink_decoder_free>
    return 0;
}
21088e28:	0005883a 	mov	r2,zero
21088e2c:	e6fff804 	addi	sp,fp,-32
21088e30:	dfc00917 	ldw	ra,36(sp)
21088e34:	df000817 	ldw	fp,32(sp)
21088e38:	ddc00717 	ldw	r23,28(sp)
21088e3c:	dd800617 	ldw	r22,24(sp)
21088e40:	dd400517 	ldw	r21,20(sp)
21088e44:	dd000417 	ldw	r20,16(sp)
21088e48:	dcc00317 	ldw	r19,12(sp)
21088e4c:	dc800217 	ldw	r18,8(sp)
21088e50:	dc400117 	ldw	r17,4(sp)
21088e54:	dc000017 	ldw	r16,0(sp)
21088e58:	dec00a04 	addi	sp,sp,40
21088e5c:	f800283a 	ret
#define DEF_DECODER_INPUT_BUFFER_SIZE 256
#define DEF_BUFFER_SIZE (64 * 1024)


static void die(char *msg) {
    printf("%s\n", msg);
21088e60:	01000034 	movhi	r4,0
21088e64:	2103ca04 	addi	r4,r4,3880
21088e68:	108e4c00 	call	2108e4c0 <puts>
21088e6c:	003fa606 	br	21088d08 <__flash_rwdata_start+0xfffe6ac0>

21088e70 <heatshrink_decoder_alloc>:
static void push_byte(heatshrink_decoder *hsd, output_info *oi, uint8_t byte);

#if HEATSHRINK_DYNAMIC_ALLOC
heatshrink_decoder *heatshrink_decoder_alloc(uint16_t input_buffer_size,
                                             uint8_t window_sz2,
                                             uint8_t lookahead_sz2) {
21088e70:	defffa04 	addi	sp,sp,-24
    if ((window_sz2 < HEATSHRINK_MIN_WINDOW_BITS) ||
21088e74:	28bfff04 	addi	r2,r5,-4
static void push_byte(heatshrink_decoder *hsd, output_info *oi, uint8_t byte);

#if HEATSHRINK_DYNAMIC_ALLOC
heatshrink_decoder *heatshrink_decoder_alloc(uint16_t input_buffer_size,
                                             uint8_t window_sz2,
                                             uint8_t lookahead_sz2) {
21088e78:	dc800215 	stw	r18,8(sp)
21088e7c:	dfc00515 	stw	ra,20(sp)
21088e80:	dd000415 	stw	r20,16(sp)
21088e84:	dcc00315 	stw	r19,12(sp)
21088e88:	dc400115 	stw	r17,4(sp)
21088e8c:	dc000015 	stw	r16,0(sp)
    if ((window_sz2 < HEATSHRINK_MIN_WINDOW_BITS) ||
21088e90:	10803fcc 	andi	r2,r2,255
21088e94:	00c002c4 	movi	r3,11
static void push_byte(heatshrink_decoder *hsd, output_info *oi, uint8_t byte);

#if HEATSHRINK_DYNAMIC_ALLOC
heatshrink_decoder *heatshrink_decoder_alloc(uint16_t input_buffer_size,
                                             uint8_t window_sz2,
                                             uint8_t lookahead_sz2) {
21088e98:	2825883a 	mov	r18,r5
    if ((window_sz2 < HEATSHRINK_MIN_WINDOW_BITS) ||
21088e9c:	18802836 	bltu	r3,r2,21088f40 <heatshrink_decoder_alloc+0xd0>
        (window_sz2 > HEATSHRINK_MAX_WINDOW_BITS) ||
21088ea0:	20bfffcc 	andi	r2,r4,65535
21088ea4:	2027883a 	mov	r19,r4
21088ea8:	10002526 	beq	r2,zero,21088f40 <heatshrink_decoder_alloc+0xd0>
        (input_buffer_size == 0) ||
21088eac:	30c03fcc 	andi	r3,r6,255
21088eb0:	01000084 	movi	r4,2
21088eb4:	3029883a 	mov	r20,r6
21088eb8:	20c0212e 	bgeu	r4,r3,21088f40 <heatshrink_decoder_alloc+0xd0>
        (lookahead_sz2 < HEATSHRINK_MIN_LOOKAHEAD_BITS) ||
21088ebc:	2c403fcc 	andi	r17,r5,255
21088ec0:	1c401f2e 	bgeu	r3,r17,21088f40 <heatshrink_decoder_alloc+0xd0>
        (lookahead_sz2 >= window_sz2)) {
        return NULL;
    }
    size_t buffers_sz = (1 << window_sz2) + input_buffer_size;
21088ec4:	00c00044 	movi	r3,1
21088ec8:	1c62983a 	sll	r17,r3,r17
21088ecc:	88a3883a 	add	r17,r17,r2
    size_t sz = sizeof(heatshrink_decoder) + buffers_sz;
    heatshrink_decoder *hsd = HEATSHRINK_MALLOC(sz);
21088ed0:	89000484 	addi	r4,r17,18
21088ed4:	108d8e80 	call	2108d8e8 <malloc>
21088ed8:	1021883a 	mov	r16,r2
    if (hsd == NULL) { return NULL; }
21088edc:	10001826 	beq	r2,zero,21088f40 <heatshrink_decoder_alloc+0xd0>
#endif

void heatshrink_decoder_reset(heatshrink_decoder *hsd) {
    size_t buf_sz = 1 << HEATSHRINK_DECODER_WINDOW_BITS(hsd);
    size_t input_sz = HEATSHRINK_DECODER_INPUT_BUFFER_SIZE(hsd);
    memset(hsd->buffers, 0, buf_sz + input_sz);
21088ee0:	11000484 	addi	r4,r2,18
21088ee4:	000b883a 	mov	r5,zero
21088ee8:	880d883a 	mov	r6,r17
    }
    size_t buffers_sz = (1 << window_sz2) + input_buffer_size;
    size_t sz = sizeof(heatshrink_decoder) + buffers_sz;
    heatshrink_decoder *hsd = HEATSHRINK_MALLOC(sz);
    if (hsd == NULL) { return NULL; }
    hsd->input_buffer_size = input_buffer_size;
21088eec:	14c0040d 	sth	r19,16(r2)
    hsd->window_sz2 = window_sz2;
21088ef0:	14800345 	stb	r18,13(r2)
    hsd->lookahead_sz2 = lookahead_sz2;
21088ef4:	15000385 	stb	r20,14(r2)
#endif

void heatshrink_decoder_reset(heatshrink_decoder *hsd) {
    size_t buf_sz = 1 << HEATSHRINK_DECODER_WINDOW_BITS(hsd);
    size_t input_sz = HEATSHRINK_DECODER_INPUT_BUFFER_SIZE(hsd);
    memset(hsd->buffers, 0, buf_sz + input_sz);
21088ef8:	108e26c0 	call	2108e26c <memset>
    hsd->input_index = 0;
    hsd->bit_index = 0x00;
    hsd->current_byte = 0x00;
    hsd->output_count = 0;
    hsd->output_index = 0;
    hsd->head_index = 0;
21088efc:	8005883a 	mov	r2,r16

void heatshrink_decoder_reset(heatshrink_decoder *hsd) {
    size_t buf_sz = 1 << HEATSHRINK_DECODER_WINDOW_BITS(hsd);
    size_t input_sz = HEATSHRINK_DECODER_INPUT_BUFFER_SIZE(hsd);
    memset(hsd->buffers, 0, buf_sz + input_sz);
    hsd->state = HSDS_TAG_BIT;
21088f00:	80000285 	stb	zero,10(r16)
    hsd->input_size = 0;
21088f04:	8000000d 	sth	zero,0(r16)
    hsd->input_index = 0;
21088f08:	8000008d 	sth	zero,2(r16)
    hsd->bit_index = 0x00;
21088f0c:	80000305 	stb	zero,12(r16)
    hsd->current_byte = 0x00;
21088f10:	800002c5 	stb	zero,11(r16)
    hsd->output_count = 0;
21088f14:	8000010d 	sth	zero,4(r16)
    hsd->output_index = 0;
21088f18:	8000018d 	sth	zero,6(r16)
    hsd->head_index = 0;
21088f1c:	8000020d 	sth	zero,8(r16)
    hsd->lookahead_sz2 = lookahead_sz2;
    heatshrink_decoder_reset(hsd);
    LOG("-- allocated decoder with buffer size of %zu (%zu + %u + %u)\n",
        sz, sizeof(heatshrink_decoder), (1 << window_sz2), input_buffer_size);
    return hsd;
}
21088f20:	dfc00517 	ldw	ra,20(sp)
21088f24:	dd000417 	ldw	r20,16(sp)
21088f28:	dcc00317 	ldw	r19,12(sp)
21088f2c:	dc800217 	ldw	r18,8(sp)
21088f30:	dc400117 	ldw	r17,4(sp)
21088f34:	dc000017 	ldw	r16,0(sp)
21088f38:	dec00604 	addi	sp,sp,24
21088f3c:	f800283a 	ret
        return NULL;
    }
    size_t buffers_sz = (1 << window_sz2) + input_buffer_size;
    size_t sz = sizeof(heatshrink_decoder) + buffers_sz;
    heatshrink_decoder *hsd = HEATSHRINK_MALLOC(sz);
    if (hsd == NULL) { return NULL; }
21088f40:	0005883a 	mov	r2,zero
21088f44:	003ff606 	br	21088f20 <__flash_rwdata_start+0xfffe6cd8>

21088f48 <heatshrink_decoder_free>:
}

void heatshrink_decoder_free(heatshrink_decoder *hsd) {
    size_t buffers_sz = (1 << hsd->window_sz2) + hsd->input_buffer_size;
    size_t sz = sizeof(heatshrink_decoder) + buffers_sz;
    HEATSHRINK_FREE(hsd, sz);
21088f48:	108d8fc1 	jmpi	2108d8fc <free>

21088f4c <heatshrink_decoder_reset>:
    (void)sz;   /* may not be used by free */
}
#endif

void heatshrink_decoder_reset(heatshrink_decoder *hsd) {
21088f4c:	defffe04 	addi	sp,sp,-8
21088f50:	dc000015 	stw	r16,0(sp)
21088f54:	dfc00115 	stw	ra,4(sp)
    size_t buf_sz = 1 << HEATSHRINK_DECODER_WINDOW_BITS(hsd);
21088f58:	20c00343 	ldbu	r3,13(r4)
21088f5c:	00800044 	movi	r2,1
    size_t input_sz = HEATSHRINK_DECODER_INPUT_BUFFER_SIZE(hsd);
21088f60:	2180040b 	ldhu	r6,16(r4)
    (void)sz;   /* may not be used by free */
}
#endif

void heatshrink_decoder_reset(heatshrink_decoder *hsd) {
    size_t buf_sz = 1 << HEATSHRINK_DECODER_WINDOW_BITS(hsd);
21088f64:	10c4983a 	sll	r2,r2,r3
    HEATSHRINK_FREE(hsd, sz);
    (void)sz;   /* may not be used by free */
}
#endif

void heatshrink_decoder_reset(heatshrink_decoder *hsd) {
21088f68:	2021883a 	mov	r16,r4
    size_t buf_sz = 1 << HEATSHRINK_DECODER_WINDOW_BITS(hsd);
    size_t input_sz = HEATSHRINK_DECODER_INPUT_BUFFER_SIZE(hsd);
    memset(hsd->buffers, 0, buf_sz + input_sz);
21088f6c:	000b883a 	mov	r5,zero
21088f70:	21000484 	addi	r4,r4,18
21088f74:	118d883a 	add	r6,r2,r6
21088f78:	108e26c0 	call	2108e26c <memset>
    hsd->state = HSDS_TAG_BIT;
21088f7c:	80000285 	stb	zero,10(r16)
    hsd->input_size = 0;
21088f80:	8000000d 	sth	zero,0(r16)
    hsd->input_index = 0;
21088f84:	8000008d 	sth	zero,2(r16)
    hsd->bit_index = 0x00;
21088f88:	80000305 	stb	zero,12(r16)
    hsd->current_byte = 0x00;
21088f8c:	800002c5 	stb	zero,11(r16)
    hsd->output_count = 0;
21088f90:	8000010d 	sth	zero,4(r16)
    hsd->output_index = 0;
21088f94:	8000018d 	sth	zero,6(r16)
    hsd->head_index = 0;
21088f98:	8000020d 	sth	zero,8(r16)
}
21088f9c:	dfc00117 	ldw	ra,4(sp)
21088fa0:	dc000017 	ldw	r16,0(sp)
21088fa4:	dec00204 	addi	sp,sp,8
21088fa8:	f800283a 	ret

21088fac <heatshrink_decoder_sink>:

/* Copy SIZE bytes into the decoder's input buffer, if it will fit. */
HSD_sink_res heatshrink_decoder_sink(heatshrink_decoder *hsd,
        uint8_t *in_buf, size_t size, size_t *input_size) {
    if ((hsd == NULL) || (in_buf == NULL) || (input_size == NULL)) {
21088fac:	20002326 	beq	r4,zero,2108903c <heatshrink_decoder_sink+0x90>
21088fb0:	28002226 	beq	r5,zero,2108903c <heatshrink_decoder_sink+0x90>
21088fb4:	38002126 	beq	r7,zero,2108903c <heatshrink_decoder_sink+0x90>
        return HSDR_SINK_ERROR_NULL;
    }

    size_t rem = HEATSHRINK_DECODER_INPUT_BUFFER_SIZE(hsd) - hsd->input_size;
21088fb8:	20c0000b 	ldhu	r3,0(r4)
21088fbc:	2080040b 	ldhu	r2,16(r4)
21088fc0:	10c5c83a 	sub	r2,r2,r3
    if (rem == 0) {
21088fc4:	1000031e 	bne	r2,zero,21088fd4 <heatshrink_decoder_sink+0x28>
        *input_size = 0;
21088fc8:	38000015 	stw	zero,0(r7)
        return HSDR_SINK_FULL;
21088fcc:	00800044 	movi	r2,1
21088fd0:	f800283a 	ret
    hsd->head_index = 0;
}

/* Copy SIZE bytes into the decoder's input buffer, if it will fit. */
HSD_sink_res heatshrink_decoder_sink(heatshrink_decoder *hsd,
        uint8_t *in_buf, size_t size, size_t *input_size) {
21088fd4:	defffc04 	addi	sp,sp,-16
21088fd8:	dc000015 	stw	r16,0(sp)
21088fdc:	dfc00315 	stw	ra,12(sp)
21088fe0:	dc800215 	stw	r18,8(sp)
21088fe4:	dc400115 	stw	r17,4(sp)
    if (rem == 0) {
        *input_size = 0;
        return HSDR_SINK_FULL;
    }

    size = rem < size ? rem : size;
21088fe8:	1021883a 	mov	r16,r2
21088fec:	30801136 	bltu	r6,r2,21089034 <heatshrink_decoder_sink+0x88>
21088ff0:	2023883a 	mov	r17,r4
    LOG("-- sinking %zd bytes\n", size);
    /* copy into input buffer (at head of buffers) */
    memcpy(&hsd->buffers[hsd->input_size], in_buf, size);
21088ff4:	20c9883a 	add	r4,r4,r3
21088ff8:	21000484 	addi	r4,r4,18
21088ffc:	800d883a 	mov	r6,r16
21089000:	3825883a 	mov	r18,r7
21089004:	108e1340 	call	2108e134 <memcpy>
    hsd->input_size += size;
21089008:	88c0000b 	ldhu	r3,0(r17)
    *input_size = size;
    return HSDR_SINK_OK;
2108900c:	0005883a 	mov	r2,zero

    size = rem < size ? rem : size;
    LOG("-- sinking %zd bytes\n", size);
    /* copy into input buffer (at head of buffers) */
    memcpy(&hsd->buffers[hsd->input_size], in_buf, size);
    hsd->input_size += size;
21089010:	80c7883a 	add	r3,r16,r3
21089014:	88c0000d 	sth	r3,0(r17)
    *input_size = size;
21089018:	94000015 	stw	r16,0(r18)
    return HSDR_SINK_OK;
}
2108901c:	dfc00317 	ldw	ra,12(sp)
21089020:	dc800217 	ldw	r18,8(sp)
21089024:	dc400117 	ldw	r17,4(sp)
21089028:	dc000017 	ldw	r16,0(sp)
2108902c:	dec00404 	addi	sp,sp,16
21089030:	f800283a 	ret
    if (rem == 0) {
        *input_size = 0;
        return HSDR_SINK_FULL;
    }

    size = rem < size ? rem : size;
21089034:	3021883a 	mov	r16,r6
21089038:	003fed06 	br	21088ff0 <__flash_rwdata_start+0xfffe6da8>

/* Copy SIZE bytes into the decoder's input buffer, if it will fit. */
HSD_sink_res heatshrink_decoder_sink(heatshrink_decoder *hsd,
        uint8_t *in_buf, size_t size, size_t *input_size) {
    if ((hsd == NULL) || (in_buf == NULL) || (input_size == NULL)) {
        return HSDR_SINK_ERROR_NULL;
2108903c:	00bfffc4 	movi	r2,-1
21089040:	f800283a 	ret

21089044 <heatshrink_decoder_poll>:
static HSD_state st_yield_backref(heatshrink_decoder *hsd,
    output_info *oi);

HSD_poll_res heatshrink_decoder_poll(heatshrink_decoder *hsd,
        uint8_t *out_buf, size_t out_buf_size, size_t *output_size) {
    if ((hsd == NULL) || (out_buf == NULL) || (output_size == NULL)) {
21089044:	2001ba26 	beq	r4,zero,21089730 <heatshrink_decoder_poll+0x6ec>
21089048:	2801b926 	beq	r5,zero,21089730 <heatshrink_decoder_poll+0x6ec>
2108904c:	3801b826 	beq	r7,zero,21089730 <heatshrink_decoder_poll+0x6ec>
        return HSDR_POLL_ERROR_NULL;
    }
    *output_size = 0;
21089050:	38000015 	stw	zero,0(r7)
21089054:	20c00283 	ldbu	r3,10(r4)
static HSD_state st_backref_count_lsb(heatshrink_decoder *hsd);
static HSD_state st_yield_backref(heatshrink_decoder *hsd,
    output_info *oi);

HSD_poll_res heatshrink_decoder_poll(heatshrink_decoder *hsd,
        uint8_t *out_buf, size_t out_buf_size, size_t *output_size) {
21089058:	defff704 	addi	sp,sp,-36

    while (1) {
        LOG("-- poll, state is %d (%s), input_size %d\n",
            hsd->state, state_names[hsd->state], hsd->input_size);
        uint8_t in_state = hsd->state;
        switch (in_state) {
2108905c:	03484274 	movhi	r13,8457
static HSD_state st_backref_count_lsb(heatshrink_decoder *hsd);
static HSD_state st_yield_backref(heatshrink_decoder *hsd,
    output_info *oi);

HSD_poll_res heatshrink_decoder_poll(heatshrink_decoder *hsd,
        uint8_t *out_buf, size_t out_buf_size, size_t *output_size) {
21089060:	dd800615 	stw	r22,24(sp)
21089064:	dd400515 	stw	r21,20(sp)
21089068:	dd000415 	stw	r20,16(sp)
2108906c:	dcc00315 	stw	r19,12(sp)
21089070:	dc000015 	stw	r16,0(sp)
21089074:	df000815 	stw	fp,32(sp)
21089078:	ddc00715 	stw	r23,28(sp)
2108907c:	dc800215 	stw	r18,8(sp)
21089080:	dc400115 	stw	r17,4(sp)

    while (1) {
        LOG("-- poll, state is %d (%s), input_size %d\n",
            hsd->state, state_names[hsd->state], hsd->input_size);
        uint8_t in_state = hsd->state;
        switch (in_state) {
21089084:	02c00184 	movi	r11,6
21089088:	6b642f04 	addi	r13,r13,-28484
    size_t count = oi->buf_size - *oi->output_size;
    if (count > 0) {
        size_t i = 0;
        if (hsd->output_count < count) count = hsd->output_count;
        uint8_t *buf = &hsd->buffers[HEATSHRINK_DECODER_INPUT_BUFFER_SIZE(hsd)];
        uint16_t mask = (1 << HEATSHRINK_DECODER_WINDOW_BITS(hsd)) - 1;
2108908c:	04c00044 	movi	r19,1
    return HSDS_BACKREF_COUNT_LSB;
}

static HSD_state st_backref_count_lsb(heatshrink_decoder *hsd) {
    uint8_t br_bit_ct = BACKREF_COUNT_BITS(hsd);
    uint16_t bits = get_bits(hsd, br_bit_ct < 8 ? br_bit_ct : 8);
21089090:	04000204 	movi	r16,8
    LOG("-- backref count (lsb), got 0x%04x (+1)\n", bits);
    if (bits == NO_BITS) { return HSDS_BACKREF_COUNT_LSB; }
21089094:	053fffd4 	movui	r20,65535
/* Get the next COUNT bits from the input buffer, saving incremental progress.
 * Returns NO_BITS on end of input, or if more than 15 bits are requested. */
static uint16_t get_bits(heatshrink_decoder *hsd, uint8_t count) {
    uint16_t accumulator = 0;
    int i = 0;
    if (count > 15) { return NO_BITS; }
21089098:	008003c4 	movi	r2,15
    if (bits == NO_BITS) { return HSDS_BACKREF_INDEX_LSB; }
    hsd->output_index |= bits;
    hsd->output_index++;
    uint8_t br_bit_ct = BACKREF_COUNT_BITS(hsd);
    hsd->output_count = 0;
    return (br_bit_ct > 8) ? HSDS_BACKREF_COUNT_MSB : HSDS_BACKREF_COUNT_LSB;
2108909c:	05400144 	movi	r21,5
    LOG("-- popping %u bit(s)\n", count);

    /* If we aren't able to get COUNT bits, suspend immediately, because we
     * don't track how many bits of COUNT we've accumulated before suspend. */
    if (hsd->input_size == 0) {
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
210890a0:	05801fc4 	movi	r22,127

    while (1) {
        LOG("-- poll, state is %d (%s), input_size %d\n",
            hsd->state, state_names[hsd->state], hsd->input_size);
        uint8_t in_state = hsd->state;
        switch (in_state) {
210890a4:	1a403fcc 	andi	r9,r3,255
210890a8:	5a41ab36 	bltu	r11,r9,21089758 <heatshrink_decoder_poll+0x714>
210890ac:	481090ba 	slli	r8,r9,2
210890b0:	4351883a 	add	r8,r8,r13
210890b4:	42000017 	ldw	r8,0(r8)
210890b8:	4000683a 	jmp	r8
210890bc:	210892ec 	andhi	r4,r4,8779
210890c0:	210893ec 	andhi	r4,r4,8783
210890c4:	21089250 	cmplti	r4,r4,8777
210890c8:	210891bc 	xorhi	r4,r4,8774
210890cc:	2108916c 	andhi	r4,r4,8773
210890d0:	210890d8 	cmpnei	r4,r4,8771
210890d4:	21089334 	orhi	r4,r4,8780
    return HSDS_BACKREF_COUNT_LSB;
}

static HSD_state st_backref_count_lsb(heatshrink_decoder *hsd) {
    uint8_t br_bit_ct = BACKREF_COUNT_BITS(hsd);
    uint16_t bits = get_bits(hsd, br_bit_ct < 8 ? br_bit_ct : 8);
210890d8:	23c00383 	ldbu	r15,14(r4)
210890dc:	83c10136 	bltu	r16,r15,210894e4 <heatshrink_decoder_poll+0x4a0>
    if (count > 15) { return NO_BITS; }
    LOG("-- popping %u bit(s)\n", count);

    /* If we aren't able to get COUNT bits, suspend immediately, because we
     * don't track how many bits of COUNT we've accumulated before suspend. */
    if (hsd->input_size == 0) {
210890e0:	2200000b 	ldhu	r8,0(r4)
210890e4:	40012b26 	beq	r8,zero,21089594 <heatshrink_decoder_poll+0x550>
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
    }

    for (i = 0; i < count; i++) {
210890e8:	78019926 	beq	r15,zero,21089750 <heatshrink_decoder_poll+0x70c>
210890ec:	22800303 	ldbu	r10,12(r4)
210890f0:	001d883a 	mov	r14,zero
210890f4:	0019883a 	mov	r12,zero
210890f8:	00000c06 	br	2108912c <heatshrink_decoder_poll+0xe8>
        if (hsd->bit_index == 0x00) {
210890fc:	5025883a 	mov	r18,r10
21089100:	220002c3 	ldbu	r8,11(r4)
21089104:	8814d07a 	srli	r10,r17,1
                hsd->input_size = 0;
            }
            hsd->bit_index = 0x80;
        }
        accumulator <<= 1;
        if (hsd->current_byte & hsd->bit_index) {
21089108:	9210703a 	and	r8,r18,r8
                hsd->input_index = 0; /* input is exhausted */
                hsd->input_size = 0;
            }
            hsd->bit_index = 0x80;
        }
        accumulator <<= 1;
2108910c:	6323883a 	add	r17,r12,r12
        if (hsd->current_byte & hsd->bit_index) {
21089110:	42003fcc 	andi	r8,r8,255
                hsd->input_index = 0; /* input is exhausted */
                hsd->input_size = 0;
            }
            hsd->bit_index = 0x80;
        }
        accumulator <<= 1;
21089114:	8819883a 	mov	r12,r17
        if (hsd->current_byte & hsd->bit_index) {
21089118:	40000126 	beq	r8,zero,21089120 <heatshrink_decoder_poll+0xdc>
            accumulator |= 0x01;
2108911c:	8b000054 	ori	r12,r17,1
            if (0) {
                LOG("  -- got 0, accumulator 0x%04x, bit_index 0x%02x\n",
                accumulator, hsd->bit_index);
            }
        }
        hsd->bit_index >>= 1;
21089120:	22800305 	stb	r10,12(r4)
     * don't track how many bits of COUNT we've accumulated before suspend. */
    if (hsd->input_size == 0) {
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
    }

    for (i = 0; i < count; i++) {
21089124:	73800044 	addi	r14,r14,1
21089128:	73c15a26 	beq	r14,r15,21089694 <heatshrink_decoder_poll+0x650>
        if (hsd->bit_index == 0x00) {
2108912c:	54403fcc 	andi	r17,r10,255
21089130:	883ff21e 	bne	r17,zero,210890fc <__flash_rwdata_start+0xfffe6eb4>
            if (hsd->input_size == 0) {
21089134:	2440000b 	ldhu	r17,0(r4)
21089138:	88001026 	beq	r17,zero,2108917c <heatshrink_decoder_poll+0x138>
                LOG("  -- out of bits, suspending w/ accumulator of %u (0x%02x)\n",
                    accumulator, accumulator);
                return NO_BITS;
            }
            hsd->current_byte = hsd->buffers[hsd->input_index++];
2108913c:	2280008b 	ldhu	r10,2(r4)
21089140:	523fffcc 	andi	r8,r10,65535
21089144:	2211883a 	add	r8,r4,r8
21089148:	42000483 	ldbu	r8,18(r8)
2108914c:	52800044 	addi	r10,r10,1
21089150:	2280008d 	sth	r10,2(r4)
21089154:	220002c5 	stb	r8,11(r4)
            LOG("  -- pulled byte 0x%02x\n", hsd->current_byte);
            if (hsd->input_index == hsd->input_size) {
21089158:	52bfffcc 	andi	r10,r10,65535
2108915c:	8a812926 	beq	r17,r10,21089604 <heatshrink_decoder_poll+0x5c0>
    if (hsd->input_size == 0) {
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
    }

    for (i = 0; i < count; i++) {
        if (hsd->bit_index == 0x00) {
21089160:	02801004 	movi	r10,64
21089164:	04bfe004 	movi	r18,-128
21089168:	003fe706 	br	21089108 <__flash_rwdata_start+0xfffe6ec0>
}

static HSD_state st_backref_count_msb(heatshrink_decoder *hsd) {
    uint8_t br_bit_ct = BACKREF_COUNT_BITS(hsd);
    ASSERT(br_bit_ct > 8);
    uint16_t bits = get_bits(hsd, br_bit_ct - 8);
2108916c:	23800383 	ldbu	r14,14(r4)
21089170:	73bffe04 	addi	r14,r14,-8
/* Get the next COUNT bits from the input buffer, saving incremental progress.
 * Returns NO_BITS on end of input, or if more than 15 bits are requested. */
static uint16_t get_bits(heatshrink_decoder *hsd, uint8_t count) {
    uint16_t accumulator = 0;
    int i = 0;
    if (count > 15) { return NO_BITS; }
21089174:	73803fcc 	andi	r14,r14,255
21089178:	1380de2e 	bgeu	r2,r14,210894f4 <heatshrink_decoder_poll+0x4b0>
            break;
        case HSDS_BACKREF_COUNT_LSB:
            hsd->state = st_backref_count_lsb(hsd);
            break;
        case HSDS_YIELD_BACKREF:
            hsd->state = st_yield_backref(hsd, &oi);
2108917c:	20c00285 	stb	r3,10(r4)
21089180:	1a003fcc 	andi	r8,r3,255
            return HSDR_POLL_ERROR_UNKNOWN;
        }
        
        /* If the current state cannot advance, check if input or output
         * buffer are exhausted. */
        if (hsd->state == in_state) {
21089184:	427fc71e 	bne	r8,r9,210890a4 <__flash_rwdata_start+0xfffe6e5c>
            if (*output_size == out_buf_size) { return HSDR_POLL_MORE; }
21089188:	38800017 	ldw	r2,0(r7)
2108918c:	3085003a 	cmpeq	r2,r6,r2
            return HSDR_POLL_EMPTY;
        }
    }
}
21089190:	df000817 	ldw	fp,32(sp)
21089194:	ddc00717 	ldw	r23,28(sp)
21089198:	dd800617 	ldw	r22,24(sp)
2108919c:	dd400517 	ldw	r21,20(sp)
210891a0:	dd000417 	ldw	r20,16(sp)
210891a4:	dcc00317 	ldw	r19,12(sp)
210891a8:	dc800217 	ldw	r18,8(sp)
210891ac:	dc400117 	ldw	r17,4(sp)
210891b0:	dc000017 	ldw	r16,0(sp)
210891b4:	dec00904 	addi	sp,sp,36
210891b8:	f800283a 	ret
    return HSDS_BACKREF_INDEX_LSB;
}

static HSD_state st_backref_index_lsb(heatshrink_decoder *hsd) {
    uint8_t bit_ct = BACKREF_INDEX_BITS(hsd);
    uint16_t bits = get_bits(hsd, bit_ct < 8 ? bit_ct : 8);
210891bc:	23c00343 	ldbu	r15,13(r4)
210891c0:	83c0c436 	bltu	r16,r15,210894d4 <heatshrink_decoder_poll+0x490>
    if (count > 15) { return NO_BITS; }
    LOG("-- popping %u bit(s)\n", count);

    /* If we aren't able to get COUNT bits, suspend immediately, because we
     * don't track how many bits of COUNT we've accumulated before suspend. */
    if (hsd->input_size == 0) {
210891c4:	2200000b 	ldhu	r8,0(r4)
210891c8:	4000ed26 	beq	r8,zero,21089580 <heatshrink_decoder_poll+0x53c>
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
    }

    for (i = 0; i < count; i++) {
210891cc:	78015e26 	beq	r15,zero,21089748 <heatshrink_decoder_poll+0x704>
210891d0:	22800303 	ldbu	r10,12(r4)
210891d4:	001d883a 	mov	r14,zero
210891d8:	0019883a 	mov	r12,zero
210891dc:	00000c06 	br	21089210 <heatshrink_decoder_poll+0x1cc>
        if (hsd->bit_index == 0x00) {
210891e0:	5025883a 	mov	r18,r10
210891e4:	220002c3 	ldbu	r8,11(r4)
210891e8:	8814d07a 	srli	r10,r17,1
                hsd->input_size = 0;
            }
            hsd->bit_index = 0x80;
        }
        accumulator <<= 1;
        if (hsd->current_byte & hsd->bit_index) {
210891ec:	9210703a 	and	r8,r18,r8
                hsd->input_index = 0; /* input is exhausted */
                hsd->input_size = 0;
            }
            hsd->bit_index = 0x80;
        }
        accumulator <<= 1;
210891f0:	6323883a 	add	r17,r12,r12
        if (hsd->current_byte & hsd->bit_index) {
210891f4:	42003fcc 	andi	r8,r8,255
                hsd->input_index = 0; /* input is exhausted */
                hsd->input_size = 0;
            }
            hsd->bit_index = 0x80;
        }
        accumulator <<= 1;
210891f8:	8819883a 	mov	r12,r17
        if (hsd->current_byte & hsd->bit_index) {
210891fc:	40000126 	beq	r8,zero,21089204 <heatshrink_decoder_poll+0x1c0>
            accumulator |= 0x01;
21089200:	8b000054 	ori	r12,r17,1
            if (0) {
                LOG("  -- got 0, accumulator 0x%04x, bit_index 0x%02x\n",
                accumulator, hsd->bit_index);
            }
        }
        hsd->bit_index >>= 1;
21089204:	22800305 	stb	r10,12(r4)
     * don't track how many bits of COUNT we've accumulated before suspend. */
    if (hsd->input_size == 0) {
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
    }

    for (i = 0; i < count; i++) {
21089208:	73800044 	addi	r14,r14,1
2108920c:	73c12b26 	beq	r14,r15,210896bc <heatshrink_decoder_poll+0x678>
        if (hsd->bit_index == 0x00) {
21089210:	54403fcc 	andi	r17,r10,255
21089214:	883ff21e 	bne	r17,zero,210891e0 <__flash_rwdata_start+0xfffe6f98>
            if (hsd->input_size == 0) {
21089218:	2440000b 	ldhu	r17,0(r4)
2108921c:	883fd726 	beq	r17,zero,2108917c <__flash_rwdata_start+0xfffe6f34>
                LOG("  -- out of bits, suspending w/ accumulator of %u (0x%02x)\n",
                    accumulator, accumulator);
                return NO_BITS;
            }
            hsd->current_byte = hsd->buffers[hsd->input_index++];
21089220:	2280008b 	ldhu	r10,2(r4)
21089224:	523fffcc 	andi	r8,r10,65535
21089228:	2211883a 	add	r8,r4,r8
2108922c:	42000483 	ldbu	r8,18(r8)
21089230:	52800044 	addi	r10,r10,1
21089234:	2280008d 	sth	r10,2(r4)
21089238:	220002c5 	stb	r8,11(r4)
            LOG("  -- pulled byte 0x%02x\n", hsd->current_byte);
            if (hsd->input_index == hsd->input_size) {
2108923c:	52bfffcc 	andi	r10,r10,65535
21089240:	8a80f326 	beq	r17,r10,21089610 <heatshrink_decoder_poll+0x5cc>
    if (hsd->input_size == 0) {
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
    }

    for (i = 0; i < count; i++) {
        if (hsd->bit_index == 0x00) {
21089244:	02801004 	movi	r10,64
21089248:	04bfe004 	movi	r18,-128
2108924c:	003fe706 	br	210891ec <__flash_rwdata_start+0xfffe6fa4>
}

static HSD_state st_backref_index_msb(heatshrink_decoder *hsd) {
    uint8_t bit_ct = BACKREF_INDEX_BITS(hsd);
    ASSERT(bit_ct > 8);
    uint16_t bits = get_bits(hsd, bit_ct - 8);
21089250:	23800343 	ldbu	r14,13(r4)
21089254:	73bffe04 	addi	r14,r14,-8
/* Get the next COUNT bits from the input buffer, saving incremental progress.
 * Returns NO_BITS on end of input, or if more than 15 bits are requested. */
static uint16_t get_bits(heatshrink_decoder *hsd, uint8_t count) {
    uint16_t accumulator = 0;
    int i = 0;
    if (count > 15) { return NO_BITS; }
21089258:	73803fcc 	andi	r14,r14,255
2108925c:	13bfc736 	bltu	r2,r14,2108917c <__flash_rwdata_start+0xfffe6f34>
    LOG("-- popping %u bit(s)\n", count);

    /* If we aren't able to get COUNT bits, suspend immediately, because we
     * don't track how many bits of COUNT we've accumulated before suspend. */
    if (hsd->input_size == 0) {
21089260:	2200000b 	ldhu	r8,0(r4)
21089264:	4000dc26 	beq	r8,zero,210895d8 <heatshrink_decoder_poll+0x594>
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
    }

    for (i = 0; i < count; i++) {
21089268:	70013326 	beq	r14,zero,21089738 <heatshrink_decoder_poll+0x6f4>
2108926c:	23000303 	ldbu	r12,12(r4)
21089270:	001f883a 	mov	r15,zero
21089274:	0015883a 	mov	r10,zero
21089278:	00000c06 	br	210892ac <heatshrink_decoder_poll+0x268>
        if (hsd->bit_index == 0x00) {
2108927c:	6025883a 	mov	r18,r12
21089280:	220002c3 	ldbu	r8,11(r4)
21089284:	8818d07a 	srli	r12,r17,1
                hsd->input_size = 0;
            }
            hsd->bit_index = 0x80;
        }
        accumulator <<= 1;
        if (hsd->current_byte & hsd->bit_index) {
21089288:	9210703a 	and	r8,r18,r8
                hsd->input_index = 0; /* input is exhausted */
                hsd->input_size = 0;
            }
            hsd->bit_index = 0x80;
        }
        accumulator <<= 1;
2108928c:	52a3883a 	add	r17,r10,r10
        if (hsd->current_byte & hsd->bit_index) {
21089290:	42003fcc 	andi	r8,r8,255
                hsd->input_index = 0; /* input is exhausted */
                hsd->input_size = 0;
            }
            hsd->bit_index = 0x80;
        }
        accumulator <<= 1;
21089294:	8815883a 	mov	r10,r17
        if (hsd->current_byte & hsd->bit_index) {
21089298:	40000126 	beq	r8,zero,210892a0 <heatshrink_decoder_poll+0x25c>
            accumulator |= 0x01;
2108929c:	8a800054 	ori	r10,r17,1
            if (0) {
                LOG("  -- got 0, accumulator 0x%04x, bit_index 0x%02x\n",
                accumulator, hsd->bit_index);
            }
        }
        hsd->bit_index >>= 1;
210892a0:	23000305 	stb	r12,12(r4)
     * don't track how many bits of COUNT we've accumulated before suspend. */
    if (hsd->input_size == 0) {
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
    }

    for (i = 0; i < count; i++) {
210892a4:	7bc00044 	addi	r15,r15,1
210892a8:	7b811926 	beq	r15,r14,21089710 <heatshrink_decoder_poll+0x6cc>
        if (hsd->bit_index == 0x00) {
210892ac:	64403fcc 	andi	r17,r12,255
210892b0:	883ff21e 	bne	r17,zero,2108927c <__flash_rwdata_start+0xfffe7034>
            if (hsd->input_size == 0) {
210892b4:	2440000b 	ldhu	r17,0(r4)
210892b8:	883fb026 	beq	r17,zero,2108917c <__flash_rwdata_start+0xfffe6f34>
                LOG("  -- out of bits, suspending w/ accumulator of %u (0x%02x)\n",
                    accumulator, accumulator);
                return NO_BITS;
            }
            hsd->current_byte = hsd->buffers[hsd->input_index++];
210892bc:	2300008b 	ldhu	r12,2(r4)
210892c0:	623fffcc 	andi	r8,r12,65535
210892c4:	2211883a 	add	r8,r4,r8
210892c8:	42000483 	ldbu	r8,18(r8)
210892cc:	63000044 	addi	r12,r12,1
210892d0:	2300008d 	sth	r12,2(r4)
210892d4:	220002c5 	stb	r8,11(r4)
            LOG("  -- pulled byte 0x%02x\n", hsd->current_byte);
            if (hsd->input_index == hsd->input_size) {
210892d8:	633fffcc 	andi	r12,r12,65535
210892dc:	8b00cf26 	beq	r17,r12,2108961c <heatshrink_decoder_poll+0x5d8>
    if (hsd->input_size == 0) {
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
    }

    for (i = 0; i < count; i++) {
        if (hsd->bit_index == 0x00) {
210892e0:	03001004 	movi	r12,64
210892e4:	04bfe004 	movi	r18,-128
210892e8:	003fe706 	br	21089288 <__flash_rwdata_start+0xfffe7040>
    LOG("-- popping %u bit(s)\n", count);

    /* If we aren't able to get COUNT bits, suspend immediately, because we
     * don't track how many bits of COUNT we've accumulated before suspend. */
    if (hsd->input_size == 0) {
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
210892ec:	20c00303 	ldbu	r3,12(r4)
    if (count > 15) { return NO_BITS; }
    LOG("-- popping %u bit(s)\n", count);

    /* If we aren't able to get COUNT bits, suspend immediately, because we
     * don't track how many bits of COUNT we've accumulated before suspend. */
    if (hsd->input_size == 0) {
210892f0:	2300000b 	ldhu	r12,0(r4)
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
    }

    for (i = 0; i < count; i++) {
        if (hsd->bit_index == 0x00) {
210892f4:	1a003fcc 	andi	r8,r3,255
    if (count > 15) { return NO_BITS; }
    LOG("-- popping %u bit(s)\n", count);

    /* If we aren't able to get COUNT bits, suspend immediately, because we
     * don't track how many bits of COUNT we've accumulated before suspend. */
    if (hsd->input_size == 0) {
210892f8:	6000621e 	bne	r12,zero,21089484 <heatshrink_decoder_poll+0x440>
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
    }

    for (i = 0; i < count; i++) {
        if (hsd->bit_index == 0x00) {
210892fc:	40000a26 	beq	r8,zero,21089328 <heatshrink_decoder_poll+0x2e4>
21089300:	228002c3 	ldbu	r10,11(r4)
21089304:	4010d07a 	srli	r8,r8,1
                hsd->input_size = 0;
            }
            hsd->bit_index = 0x80;
        }
        accumulator <<= 1;
        if (hsd->current_byte & hsd->bit_index) {
21089308:	1a86703a 	and	r3,r3,r10
            if (0) {
                LOG("  -- got 0, accumulator 0x%04x, bit_index 0x%02x\n",
                accumulator, hsd->bit_index);
            }
        }
        hsd->bit_index >>= 1;
2108930c:	22000305 	stb	r8,12(r4)

static HSD_state st_tag_bit(heatshrink_decoder *hsd) {
    uint32_t bits = get_bits(hsd, 1);  // get tag bit
    if (bits == NO_BITS) {
        return HSDS_TAG_BIT;
    } else if (bits) {
21089310:	18c03fcc 	andi	r3,r3,255
21089314:	18006b1e 	bne	r3,zero,210894c4 <heatshrink_decoder_poll+0x480>
        return HSDS_YIELD_LITERAL;
    } else if (HEATSHRINK_DECODER_WINDOW_BITS(hsd) > 8) {
21089318:	20c00343 	ldbu	r3,13(r4)
2108931c:	80c0a22e 	bgeu	r16,r3,210895a8 <heatshrink_decoder_poll+0x564>
21089320:	00c00084 	movi	r3,2
21089324:	02000084 	movi	r8,2
        LOG("-- poll, state is %d (%s), input_size %d\n",
            hsd->state, state_names[hsd->state], hsd->input_size);
        uint8_t in_state = hsd->state;
        switch (in_state) {
        case HSDS_TAG_BIT:
            hsd->state = st_tag_bit(hsd);
21089328:	20c00285 	stb	r3,10(r4)
            return HSDR_POLL_ERROR_UNKNOWN;
        }
        
        /* If the current state cannot advance, check if input or output
         * buffer are exhausted. */
        if (hsd->state == in_state) {
2108932c:	427f5d1e 	bne	r8,r9,210890a4 <__flash_rwdata_start+0xfffe6e5c>
21089330:	003f9506 	br	21089188 <__flash_rwdata_start+0xfffe6f40>
    return HSDS_YIELD_BACKREF;
}

static HSD_state st_yield_backref(heatshrink_decoder *hsd,
        output_info *oi) {
    size_t count = oi->buf_size - *oi->output_size;
21089334:	3dc00017 	ldw	r23,0(r7)
21089338:	35ddc83a 	sub	r14,r6,r23
    if (count > 0) {
2108933c:	703f8f26 	beq	r14,zero,2108917c <__flash_rwdata_start+0xfffe6f34>
        size_t i = 0;
        if (hsd->output_count < count) count = hsd->output_count;
21089340:	2200010b 	ldhu	r8,4(r4)
21089344:	42bfffcc 	andi	r10,r8,65535
21089348:	5380a136 	bltu	r10,r14,210895d0 <heatshrink_decoder_poll+0x58c>
        uint8_t *buf = &hsd->buffers[HEATSHRINK_DECODER_INPUT_BUFFER_SIZE(hsd)];
        uint16_t mask = (1 << HEATSHRINK_DECODER_WINDOW_BITS(hsd)) - 1;
2108934c:	23c00343 	ldbu	r15,13(r4)
        output_info *oi) {
    size_t count = oi->buf_size - *oi->output_size;
    if (count > 0) {
        size_t i = 0;
        if (hsd->output_count < count) count = hsd->output_count;
        uint8_t *buf = &hsd->buffers[HEATSHRINK_DECODER_INPUT_BUFFER_SIZE(hsd)];
21089350:	2300040b 	ldhu	r12,16(r4)
        uint16_t mask = (1 << HEATSHRINK_DECODER_WINDOW_BITS(hsd)) - 1;
        uint16_t neg_offset = hsd->output_index;
21089354:	2440018b 	ldhu	r17,6(r4)
    size_t count = oi->buf_size - *oi->output_size;
    if (count > 0) {
        size_t i = 0;
        if (hsd->output_count < count) count = hsd->output_count;
        uint8_t *buf = &hsd->buffers[HEATSHRINK_DECODER_INPUT_BUFFER_SIZE(hsd)];
        uint16_t mask = (1 << HEATSHRINK_DECODER_WINDOW_BITS(hsd)) - 1;
21089358:	9bde983a 	sll	r15,r19,r15
        output_info *oi) {
    size_t count = oi->buf_size - *oi->output_size;
    if (count > 0) {
        size_t i = 0;
        if (hsd->output_count < count) count = hsd->output_count;
        uint8_t *buf = &hsd->buffers[HEATSHRINK_DECODER_INPUT_BUFFER_SIZE(hsd)];
2108935c:	2319883a 	add	r12,r4,r12
21089360:	63000484 	addi	r12,r12,18
        uint16_t mask = (1 << HEATSHRINK_DECODER_WINDOW_BITS(hsd)) - 1;
21089364:	7bffffc4 	addi	r15,r15,-1
21089368:	7825883a 	mov	r18,r15
        uint16_t neg_offset = hsd->output_index;
        LOG("-- emitting %zu bytes from -%u bytes back\n", count, neg_offset);
        ASSERT(neg_offset <= mask + 1);
        ASSERT(count <= (size_t)(1 << BACKREF_COUNT_BITS(hsd)));

        for (i=0; i<count; i++) {
2108936c:	70001926 	beq	r14,zero,210893d4 <heatshrink_decoder_poll+0x390>
21089370:	2200020b 	ldhu	r8,8(r4)
21089374:	8c7fffcc 	andi	r17,r17,65535
21089378:	7bffffcc 	andi	r15,r15,65535
2108937c:	0015883a 	mov	r10,zero
21089380:	00000106 	br	21089388 <heatshrink_decoder_poll+0x344>
21089384:	3dc00017 	ldw	r23,0(r7)
            uint8_t c = buf[(hsd->head_index - neg_offset) & mask];
21089388:	423fffcc 	andi	r8,r8,65535
2108938c:	4451c83a 	sub	r8,r8,r17
21089390:	7a10703a 	and	r8,r15,r8
21089394:	6211883a 	add	r8,r12,r8
21089398:	47000003 	ldbu	fp,0(r8)
    }
}

static void push_byte(heatshrink_decoder *hsd, output_info *oi, uint8_t byte) {
    LOG(" -- pushing byte: 0x%02x ('%c')\n", byte, isprint(byte) ? byte : '.');
    oi->buf[(*oi->output_size)++] = byte;
2108939c:	ba000044 	addi	r8,r23,1
210893a0:	3a000015 	stw	r8,0(r7)
210893a4:	2def883a 	add	r23,r5,r23
210893a8:	bf000005 	stb	fp,0(r23)
        ASSERT(count <= (size_t)(1 << BACKREF_COUNT_BITS(hsd)));

        for (i=0; i<count; i++) {
            uint8_t c = buf[(hsd->head_index - neg_offset) & mask];
            push_byte(hsd, oi, c);
            buf[hsd->head_index & mask] = c;
210893ac:	2200020b 	ldhu	r8,8(r4)
        uint16_t neg_offset = hsd->output_index;
        LOG("-- emitting %zu bytes from -%u bytes back\n", count, neg_offset);
        ASSERT(neg_offset <= mask + 1);
        ASSERT(count <= (size_t)(1 << BACKREF_COUNT_BITS(hsd)));

        for (i=0; i<count; i++) {
210893b0:	52800044 	addi	r10,r10,1
            uint8_t c = buf[(hsd->head_index - neg_offset) & mask];
            push_byte(hsd, oi, c);
            buf[hsd->head_index & mask] = c;
210893b4:	9210703a 	and	r8,r18,r8
210893b8:	6211883a 	add	r8,r12,r8
210893bc:	47000005 	stb	fp,0(r8)
            hsd->head_index++;
210893c0:	2200020b 	ldhu	r8,8(r4)
210893c4:	42000044 	addi	r8,r8,1
210893c8:	2200020d 	sth	r8,8(r4)
        uint16_t neg_offset = hsd->output_index;
        LOG("-- emitting %zu bytes from -%u bytes back\n", count, neg_offset);
        ASSERT(neg_offset <= mask + 1);
        ASSERT(count <= (size_t)(1 << BACKREF_COUNT_BITS(hsd)));

        for (i=0; i<count; i++) {
210893cc:	53bfed1e 	bne	r10,r14,21089384 <__flash_rwdata_start+0xfffe713c>
210893d0:	2200010b 	ldhu	r8,4(r4)
            push_byte(hsd, oi, c);
            buf[hsd->head_index & mask] = c;
            hsd->head_index++;
            LOG("  -- ++ 0x%02x\n", c);
        }
        hsd->output_count -= count;
210893d4:	439dc83a 	sub	r14,r8,r14
210893d8:	2380010d 	sth	r14,4(r4)
        if (hsd->output_count == 0) { return HSDS_TAG_BIT; }
210893dc:	73bfffcc 	andi	r14,r14,65535
210893e0:	703f661e 	bne	r14,zero,2108917c <__flash_rwdata_start+0xfffe6f34>
210893e4:	0007883a 	mov	r3,zero
210893e8:	003f6406 	br	2108917c <__flash_rwdata_start+0xfffe6f34>
static HSD_state st_yield_literal(heatshrink_decoder *hsd,
        output_info *oi) {
    /* Emit a repeated section from the window buffer, and add it (again)
     * to the window buffer. (Note that the repetition can include
     * itself.)*/
    if (*oi->output_size < oi->buf_size) {
210893ec:	3a000017 	ldw	r8,0(r7)
210893f0:	41bf622e 	bgeu	r8,r6,2108917c <__flash_rwdata_start+0xfffe6f34>
    LOG("-- popping %u bit(s)\n", count);

    /* If we aren't able to get COUNT bits, suspend immediately, because we
     * don't track how many bits of COUNT we've accumulated before suspend. */
    if (hsd->input_size == 0) {
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
210893f4:	22800303 	ldbu	r10,12(r4)
    if (count > 15) { return NO_BITS; }
    LOG("-- popping %u bit(s)\n", count);

    /* If we aren't able to get COUNT bits, suspend immediately, because we
     * don't track how many bits of COUNT we've accumulated before suspend. */
    if (hsd->input_size == 0) {
210893f8:	2200000b 	ldhu	r8,0(r4)
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
210893fc:	53c03fcc 	andi	r15,r10,255
    if (count > 15) { return NO_BITS; }
    LOG("-- popping %u bit(s)\n", count);

    /* If we aren't able to get COUNT bits, suspend immediately, because we
     * don't track how many bits of COUNT we've accumulated before suspend. */
    if (hsd->input_size == 0) {
21089400:	4000011e 	bne	r8,zero,21089408 <heatshrink_decoder_poll+0x3c4>
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
21089404:	b3ff5d0e 	bge	r22,r15,2108917c <__flash_rwdata_start+0xfffe6f34>
    } else if (bits) {
        return HSDS_YIELD_LITERAL;
    } else if (HEATSHRINK_DECODER_WINDOW_BITS(hsd) > 8) {
        return HSDS_BACKREF_INDEX_MSB;
    } else {
        hsd->output_index = 0;
21089408:	03800204 	movi	r14,8
2108940c:	0019883a 	mov	r12,zero
    if (hsd->input_size == 0) {
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
    }

    for (i = 0; i < count; i++) {
        if (hsd->bit_index == 0x00) {
21089410:	78000e26 	beq	r15,zero,2108944c <heatshrink_decoder_poll+0x408>
21089414:	5023883a 	mov	r17,r10
21089418:	220002c3 	ldbu	r8,11(r4)
2108941c:	7814d07a 	srli	r10,r15,1
                hsd->input_size = 0;
            }
            hsd->bit_index = 0x80;
        }
        accumulator <<= 1;
        if (hsd->current_byte & hsd->bit_index) {
21089420:	8a10703a 	and	r8,r17,r8
                hsd->input_index = 0; /* input is exhausted */
                hsd->input_size = 0;
            }
            hsd->bit_index = 0x80;
        }
        accumulator <<= 1;
21089424:	631f883a 	add	r15,r12,r12
        if (hsd->current_byte & hsd->bit_index) {
21089428:	42003fcc 	andi	r8,r8,255
                hsd->input_index = 0; /* input is exhausted */
                hsd->input_size = 0;
            }
            hsd->bit_index = 0x80;
        }
        accumulator <<= 1;
2108942c:	7819883a 	mov	r12,r15
        if (hsd->current_byte & hsd->bit_index) {
21089430:	40000126 	beq	r8,zero,21089438 <heatshrink_decoder_poll+0x3f4>
            accumulator |= 0x01;
21089434:	7b000054 	ori	r12,r15,1
            if (0) {
                LOG("  -- got 0, accumulator 0x%04x, bit_index 0x%02x\n",
                accumulator, hsd->bit_index);
            }
        }
        hsd->bit_index >>= 1;
21089438:	22800305 	stb	r10,12(r4)
2108943c:	73bfffc4 	addi	r14,r14,-1
     * don't track how many bits of COUNT we've accumulated before suspend. */
    if (hsd->input_size == 0) {
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
    }

    for (i = 0; i < count; i++) {
21089440:	70007c26 	beq	r14,zero,21089634 <heatshrink_decoder_poll+0x5f0>
21089444:	53c03fcc 	andi	r15,r10,255
        if (hsd->bit_index == 0x00) {
21089448:	783ff21e 	bne	r15,zero,21089414 <__flash_rwdata_start+0xfffe71cc>
            if (hsd->input_size == 0) {
2108944c:	23c0000b 	ldhu	r15,0(r4)
21089450:	783f4a26 	beq	r15,zero,2108917c <__flash_rwdata_start+0xfffe6f34>
                LOG("  -- out of bits, suspending w/ accumulator of %u (0x%02x)\n",
                    accumulator, accumulator);
                return NO_BITS;
            }
            hsd->current_byte = hsd->buffers[hsd->input_index++];
21089454:	2280008b 	ldhu	r10,2(r4)
21089458:	523fffcc 	andi	r8,r10,65535
2108945c:	2211883a 	add	r8,r4,r8
21089460:	42000483 	ldbu	r8,18(r8)
21089464:	52800044 	addi	r10,r10,1
21089468:	2280008d 	sth	r10,2(r4)
2108946c:	220002c5 	stb	r8,11(r4)
            LOG("  -- pulled byte 0x%02x\n", hsd->current_byte);
            if (hsd->input_index == hsd->input_size) {
21089470:	52bfffcc 	andi	r10,r10,65535
21089474:	7a806026 	beq	r15,r10,210895f8 <heatshrink_decoder_poll+0x5b4>
    if (hsd->input_size == 0) {
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
    }

    for (i = 0; i < count; i++) {
        if (hsd->bit_index == 0x00) {
21089478:	02801004 	movi	r10,64
2108947c:	047fe004 	movi	r17,-128
21089480:	003fe706 	br	21089420 <__flash_rwdata_start+0xfffe71d8>
21089484:	403f9e1e 	bne	r8,zero,21089300 <__flash_rwdata_start+0xfffe70b8>
            if (hsd->input_size == 0) {
                LOG("  -- out of bits, suspending w/ accumulator of %u (0x%02x)\n",
                    accumulator, accumulator);
                return NO_BITS;
            }
            hsd->current_byte = hsd->buffers[hsd->input_index++];
21089488:	20c0008b 	ldhu	r3,2(r4)
2108948c:	1a3fffcc 	andi	r8,r3,65535
21089490:	2211883a 	add	r8,r4,r8
21089494:	42800483 	ldbu	r10,18(r8)
21089498:	18c00044 	addi	r3,r3,1
2108949c:	20c0008d 	sth	r3,2(r4)
210894a0:	228002c5 	stb	r10,11(r4)
            LOG("  -- pulled byte 0x%02x\n", hsd->current_byte);
            if (hsd->input_index == hsd->input_size) {
210894a4:	18ffffcc 	andi	r3,r3,65535
210894a8:	60c05026 	beq	r12,r3,210895ec <heatshrink_decoder_poll+0x5a8>
210894ac:	00ffe004 	movi	r3,-128
210894b0:	02001004 	movi	r8,64
                hsd->input_size = 0;
            }
            hsd->bit_index = 0x80;
        }
        accumulator <<= 1;
        if (hsd->current_byte & hsd->bit_index) {
210894b4:	1a86703a 	and	r3,r3,r10
            if (0) {
                LOG("  -- got 0, accumulator 0x%04x, bit_index 0x%02x\n",
                accumulator, hsd->bit_index);
            }
        }
        hsd->bit_index >>= 1;
210894b8:	22000305 	stb	r8,12(r4)

static HSD_state st_tag_bit(heatshrink_decoder *hsd) {
    uint32_t bits = get_bits(hsd, 1);  // get tag bit
    if (bits == NO_BITS) {
        return HSDS_TAG_BIT;
    } else if (bits) {
210894bc:	18c03fcc 	andi	r3,r3,255
210894c0:	183f9526 	beq	r3,zero,21089318 <__flash_rwdata_start+0xfffe70d0>
210894c4:	00c00044 	movi	r3,1
210894c8:	02000044 	movi	r8,1
        LOG("-- poll, state is %d (%s), input_size %d\n",
            hsd->state, state_names[hsd->state], hsd->input_size);
        uint8_t in_state = hsd->state;
        switch (in_state) {
        case HSDS_TAG_BIT:
            hsd->state = st_tag_bit(hsd);
210894cc:	20c00285 	stb	r3,10(r4)
210894d0:	003f9606 	br	2108932c <__flash_rwdata_start+0xfffe70e4>
    if (count > 15) { return NO_BITS; }
    LOG("-- popping %u bit(s)\n", count);

    /* If we aren't able to get COUNT bits, suspend immediately, because we
     * don't track how many bits of COUNT we've accumulated before suspend. */
    if (hsd->input_size == 0) {
210894d4:	2200000b 	ldhu	r8,0(r4)
210894d8:	03c00204 	movi	r15,8
210894dc:	403f3b1e 	bne	r8,zero,210891cc <__flash_rwdata_start+0xfffe6f84>
210894e0:	00002706 	br	21089580 <heatshrink_decoder_poll+0x53c>
210894e4:	2200000b 	ldhu	r8,0(r4)
210894e8:	03c00204 	movi	r15,8
210894ec:	403efe1e 	bne	r8,zero,210890e8 <__flash_rwdata_start+0xfffe6ea0>
210894f0:	00002806 	br	21089594 <heatshrink_decoder_poll+0x550>
210894f4:	2200000b 	ldhu	r8,0(r4)
210894f8:	40003026 	beq	r8,zero,210895bc <heatshrink_decoder_poll+0x578>
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
    }

    for (i = 0; i < count; i++) {
210894fc:	70009026 	beq	r14,zero,21089740 <heatshrink_decoder_poll+0x6fc>
21089500:	23000303 	ldbu	r12,12(r4)
21089504:	001f883a 	mov	r15,zero
21089508:	0015883a 	mov	r10,zero
2108950c:	00000c06 	br	21089540 <heatshrink_decoder_poll+0x4fc>
        if (hsd->bit_index == 0x00) {
21089510:	6025883a 	mov	r18,r12
21089514:	220002c3 	ldbu	r8,11(r4)
21089518:	8818d07a 	srli	r12,r17,1
                hsd->input_size = 0;
            }
            hsd->bit_index = 0x80;
        }
        accumulator <<= 1;
        if (hsd->current_byte & hsd->bit_index) {
2108951c:	9210703a 	and	r8,r18,r8
                hsd->input_index = 0; /* input is exhausted */
                hsd->input_size = 0;
            }
            hsd->bit_index = 0x80;
        }
        accumulator <<= 1;
21089520:	52a3883a 	add	r17,r10,r10
        if (hsd->current_byte & hsd->bit_index) {
21089524:	42003fcc 	andi	r8,r8,255
                hsd->input_index = 0; /* input is exhausted */
                hsd->input_size = 0;
            }
            hsd->bit_index = 0x80;
        }
        accumulator <<= 1;
21089528:	8815883a 	mov	r10,r17
        if (hsd->current_byte & hsd->bit_index) {
2108952c:	40000126 	beq	r8,zero,21089534 <heatshrink_decoder_poll+0x4f0>
            accumulator |= 0x01;
21089530:	8a800054 	ori	r10,r17,1
            if (0) {
                LOG("  -- got 0, accumulator 0x%04x, bit_index 0x%02x\n",
                accumulator, hsd->bit_index);
            }
        }
        hsd->bit_index >>= 1;
21089534:	23000305 	stb	r12,12(r4)
     * don't track how many bits of COUNT we've accumulated before suspend. */
    if (hsd->input_size == 0) {
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
    }

    for (i = 0; i < count; i++) {
21089538:	7bc00044 	addi	r15,r15,1
2108953c:	7b806c26 	beq	r15,r14,210896f0 <heatshrink_decoder_poll+0x6ac>
        if (hsd->bit_index == 0x00) {
21089540:	64403fcc 	andi	r17,r12,255
21089544:	883ff21e 	bne	r17,zero,21089510 <__flash_rwdata_start+0xfffe72c8>
            if (hsd->input_size == 0) {
21089548:	2440000b 	ldhu	r17,0(r4)
2108954c:	883f0b26 	beq	r17,zero,2108917c <__flash_rwdata_start+0xfffe6f34>
                LOG("  -- out of bits, suspending w/ accumulator of %u (0x%02x)\n",
                    accumulator, accumulator);
                return NO_BITS;
            }
            hsd->current_byte = hsd->buffers[hsd->input_index++];
21089550:	2300008b 	ldhu	r12,2(r4)
21089554:	623fffcc 	andi	r8,r12,65535
21089558:	2211883a 	add	r8,r4,r8
2108955c:	42000483 	ldbu	r8,18(r8)
21089560:	63000044 	addi	r12,r12,1
21089564:	2300008d 	sth	r12,2(r4)
21089568:	220002c5 	stb	r8,11(r4)
            LOG("  -- pulled byte 0x%02x\n", hsd->current_byte);
            if (hsd->input_index == hsd->input_size) {
2108956c:	633fffcc 	andi	r12,r12,65535
21089570:	8b002d26 	beq	r17,r12,21089628 <heatshrink_decoder_poll+0x5e4>
    if (hsd->input_size == 0) {
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
    }

    for (i = 0; i < count; i++) {
        if (hsd->bit_index == 0x00) {
21089574:	03001004 	movi	r12,64
21089578:	04bfe004 	movi	r18,-128
2108957c:	003fe706 	br	2108951c <__flash_rwdata_start+0xfffe72d4>
    LOG("-- popping %u bit(s)\n", count);

    /* If we aren't able to get COUNT bits, suspend immediately, because we
     * don't track how many bits of COUNT we've accumulated before suspend. */
    if (hsd->input_size == 0) {
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
21089580:	7a3fffc4 	addi	r8,r15,-1
21089584:	22800303 	ldbu	r10,12(r4)
21089588:	9a10983a 	sll	r8,r19,r8
2108958c:	523efb16 	blt	r10,r8,2108917c <__flash_rwdata_start+0xfffe6f34>
21089590:	003f0e06 	br	210891cc <__flash_rwdata_start+0xfffe6f84>
21089594:	7a3fffc4 	addi	r8,r15,-1
21089598:	22800303 	ldbu	r10,12(r4)
2108959c:	9a10983a 	sll	r8,r19,r8
210895a0:	523ef616 	blt	r10,r8,2108917c <__flash_rwdata_start+0xfffe6f34>
210895a4:	003ed006 	br	210890e8 <__flash_rwdata_start+0xfffe6ea0>
    } else if (bits) {
        return HSDS_YIELD_LITERAL;
    } else if (HEATSHRINK_DECODER_WINDOW_BITS(hsd) > 8) {
        return HSDS_BACKREF_INDEX_MSB;
    } else {
        hsd->output_index = 0;
210895a8:	00c000c4 	movi	r3,3
210895ac:	2000018d 	sth	zero,6(r4)
210895b0:	020000c4 	movi	r8,3
        LOG("-- poll, state is %d (%s), input_size %d\n",
            hsd->state, state_names[hsd->state], hsd->input_size);
        uint8_t in_state = hsd->state;
        switch (in_state) {
        case HSDS_TAG_BIT:
            hsd->state = st_tag_bit(hsd);
210895b4:	20c00285 	stb	r3,10(r4)
210895b8:	003f5c06 	br	2108932c <__flash_rwdata_start+0xfffe70e4>
    LOG("-- popping %u bit(s)\n", count);

    /* If we aren't able to get COUNT bits, suspend immediately, because we
     * don't track how many bits of COUNT we've accumulated before suspend. */
    if (hsd->input_size == 0) {
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
210895bc:	723fffc4 	addi	r8,r14,-1
210895c0:	22800303 	ldbu	r10,12(r4)
210895c4:	9a10983a 	sll	r8,r19,r8
210895c8:	523eec16 	blt	r10,r8,2108917c <__flash_rwdata_start+0xfffe6f34>
210895cc:	003fcb06 	br	210894fc <__flash_rwdata_start+0xfffe72b4>
210895d0:	501d883a 	mov	r14,r10
210895d4:	003f5d06 	br	2108934c <__flash_rwdata_start+0xfffe7104>
210895d8:	723fffc4 	addi	r8,r14,-1
210895dc:	22800303 	ldbu	r10,12(r4)
210895e0:	9a10983a 	sll	r8,r19,r8
210895e4:	523ee516 	blt	r10,r8,2108917c <__flash_rwdata_start+0xfffe6f34>
210895e8:	003f1f06 	br	21089268 <__flash_rwdata_start+0xfffe7020>
                return NO_BITS;
            }
            hsd->current_byte = hsd->buffers[hsd->input_index++];
            LOG("  -- pulled byte 0x%02x\n", hsd->current_byte);
            if (hsd->input_index == hsd->input_size) {
                hsd->input_index = 0; /* input is exhausted */
210895ec:	2000008d 	sth	zero,2(r4)
                hsd->input_size = 0;
210895f0:	2000000d 	sth	zero,0(r4)
210895f4:	003fad06 	br	210894ac <__flash_rwdata_start+0xfffe7264>
                return NO_BITS;
            }
            hsd->current_byte = hsd->buffers[hsd->input_index++];
            LOG("  -- pulled byte 0x%02x\n", hsd->current_byte);
            if (hsd->input_index == hsd->input_size) {
                hsd->input_index = 0; /* input is exhausted */
210895f8:	2000008d 	sth	zero,2(r4)
                hsd->input_size = 0;
210895fc:	2000000d 	sth	zero,0(r4)
21089600:	003f9d06 	br	21089478 <__flash_rwdata_start+0xfffe7230>
                return NO_BITS;
            }
            hsd->current_byte = hsd->buffers[hsd->input_index++];
            LOG("  -- pulled byte 0x%02x\n", hsd->current_byte);
            if (hsd->input_index == hsd->input_size) {
                hsd->input_index = 0; /* input is exhausted */
21089604:	2000008d 	sth	zero,2(r4)
                hsd->input_size = 0;
21089608:	2000000d 	sth	zero,0(r4)
2108960c:	003ed406 	br	21089160 <__flash_rwdata_start+0xfffe6f18>
                return NO_BITS;
            }
            hsd->current_byte = hsd->buffers[hsd->input_index++];
            LOG("  -- pulled byte 0x%02x\n", hsd->current_byte);
            if (hsd->input_index == hsd->input_size) {
                hsd->input_index = 0; /* input is exhausted */
21089610:	2000008d 	sth	zero,2(r4)
                hsd->input_size = 0;
21089614:	2000000d 	sth	zero,0(r4)
21089618:	003f0a06 	br	21089244 <__flash_rwdata_start+0xfffe6ffc>
                return NO_BITS;
            }
            hsd->current_byte = hsd->buffers[hsd->input_index++];
            LOG("  -- pulled byte 0x%02x\n", hsd->current_byte);
            if (hsd->input_index == hsd->input_size) {
                hsd->input_index = 0; /* input is exhausted */
2108961c:	2000008d 	sth	zero,2(r4)
                hsd->input_size = 0;
21089620:	2000000d 	sth	zero,0(r4)
21089624:	003f2e06 	br	210892e0 <__flash_rwdata_start+0xfffe7098>
                return NO_BITS;
            }
            hsd->current_byte = hsd->buffers[hsd->input_index++];
            LOG("  -- pulled byte 0x%02x\n", hsd->current_byte);
            if (hsd->input_index == hsd->input_size) {
                hsd->input_index = 0; /* input is exhausted */
21089628:	2000008d 	sth	zero,2(r4)
                hsd->input_size = 0;
2108962c:	2000000d 	sth	zero,0(r4)
21089630:	003fd006 	br	21089574 <__flash_rwdata_start+0xfffe732c>
    /* Emit a repeated section from the window buffer, and add it (again)
     * to the window buffer. (Note that the repetition can include
     * itself.)*/
    if (*oi->output_size < oi->buf_size) {
        uint16_t byte = get_bits(hsd, 8);
        if (byte == NO_BITS) { return HSDS_YIELD_LITERAL; } /* out of input */
21089634:	623fffcc 	andi	r8,r12,65535
21089638:	453ed026 	beq	r8,r20,2108917c <__flash_rwdata_start+0xfffe6f34>
        uint8_t *buf = &hsd->buffers[HEATSHRINK_DECODER_INPUT_BUFFER_SIZE(hsd)];
        uint16_t mask = (1 << HEATSHRINK_DECODER_WINDOW_BITS(hsd))  - 1;
2108963c:	22800343 	ldbu	r10,13(r4)
        uint8_t c = byte & 0xFF;
        LOG("-- emitting literal byte 0x%02x ('%c')\n", c, isprint(c) ? c : '.');
        buf[hsd->head_index++ & mask] = c;
21089640:	20c0020b 	ldhu	r3,8(r4)
     * to the window buffer. (Note that the repetition can include
     * itself.)*/
    if (*oi->output_size < oi->buf_size) {
        uint16_t byte = get_bits(hsd, 8);
        if (byte == NO_BITS) { return HSDS_YIELD_LITERAL; } /* out of input */
        uint8_t *buf = &hsd->buffers[HEATSHRINK_DECODER_INPUT_BUFFER_SIZE(hsd)];
21089644:	2200040b 	ldhu	r8,16(r4)
        uint16_t mask = (1 << HEATSHRINK_DECODER_WINDOW_BITS(hsd))  - 1;
21089648:	9a94983a 	sll	r10,r19,r10
        uint8_t c = byte & 0xFF;
        LOG("-- emitting literal byte 0x%02x ('%c')\n", c, isprint(c) ? c : '.');
        buf[hsd->head_index++ & mask] = c;
2108964c:	1b800044 	addi	r14,r3,1
     * to the window buffer. (Note that the repetition can include
     * itself.)*/
    if (*oi->output_size < oi->buf_size) {
        uint16_t byte = get_bits(hsd, 8);
        if (byte == NO_BITS) { return HSDS_YIELD_LITERAL; } /* out of input */
        uint8_t *buf = &hsd->buffers[HEATSHRINK_DECODER_INPUT_BUFFER_SIZE(hsd)];
21089650:	2211883a 	add	r8,r4,r8
        uint16_t mask = (1 << HEATSHRINK_DECODER_WINDOW_BITS(hsd))  - 1;
21089654:	52bfffc4 	addi	r10,r10,-1
        uint8_t c = byte & 0xFF;
        LOG("-- emitting literal byte 0x%02x ('%c')\n", c, isprint(c) ? c : '.');
        buf[hsd->head_index++ & mask] = c;
21089658:	50c6703a 	and	r3,r10,r3
     * to the window buffer. (Note that the repetition can include
     * itself.)*/
    if (*oi->output_size < oi->buf_size) {
        uint16_t byte = get_bits(hsd, 8);
        if (byte == NO_BITS) { return HSDS_YIELD_LITERAL; } /* out of input */
        uint8_t *buf = &hsd->buffers[HEATSHRINK_DECODER_INPUT_BUFFER_SIZE(hsd)];
2108965c:	42000484 	addi	r8,r8,18
        uint16_t mask = (1 << HEATSHRINK_DECODER_WINDOW_BITS(hsd))  - 1;
        uint8_t c = byte & 0xFF;
        LOG("-- emitting literal byte 0x%02x ('%c')\n", c, isprint(c) ? c : '.');
        buf[hsd->head_index++ & mask] = c;
21089660:	18ffffcc 	andi	r3,r3,65535
21089664:	2380020d 	sth	r14,8(r4)
21089668:	40c7883a 	add	r3,r8,r3
2108966c:	1b000005 	stb	r12,0(r3)
    }
}

static void push_byte(heatshrink_decoder *hsd, output_info *oi, uint8_t byte) {
    LOG(" -- pushing byte: 0x%02x ('%c')\n", byte, isprint(byte) ? byte : '.');
    oi->buf[(*oi->output_size)++] = byte;
21089670:	3a000017 	ldw	r8,0(r7)
21089674:	0007883a 	mov	r3,zero
21089678:	42800044 	addi	r10,r8,1
2108967c:	3a800015 	stw	r10,0(r7)
21089680:	2a11883a 	add	r8,r5,r8
21089684:	43000005 	stb	r12,0(r8)
            break;
        case HSDS_BACKREF_COUNT_LSB:
            hsd->state = st_backref_count_lsb(hsd);
            break;
        case HSDS_YIELD_BACKREF:
            hsd->state = st_yield_backref(hsd, &oi);
21089688:	20c00285 	stb	r3,10(r4)
2108968c:	1a003fcc 	andi	r8,r3,255
21089690:	003ebc06 	br	21089184 <__flash_rwdata_start+0xfffe6f3c>

static HSD_state st_backref_count_lsb(heatshrink_decoder *hsd) {
    uint8_t br_bit_ct = BACKREF_COUNT_BITS(hsd);
    uint16_t bits = get_bits(hsd, br_bit_ct < 8 ? br_bit_ct : 8);
    LOG("-- backref count (lsb), got 0x%04x (+1)\n", bits);
    if (bits == NO_BITS) { return HSDS_BACKREF_COUNT_LSB; }
21089694:	623fffcc 	andi	r8,r12,65535
21089698:	453eb826 	beq	r8,r20,2108917c <__flash_rwdata_start+0xfffe6f34>
    hsd->output_count |= bits;
2108969c:	2200010b 	ldhu	r8,4(r4)
    hsd->output_count++;
210896a0:	00c00184 	movi	r3,6
            break;
        case HSDS_BACKREF_COUNT_LSB:
            hsd->state = st_backref_count_lsb(hsd);
            break;
        case HSDS_YIELD_BACKREF:
            hsd->state = st_yield_backref(hsd, &oi);
210896a4:	20c00285 	stb	r3,10(r4)
static HSD_state st_backref_count_lsb(heatshrink_decoder *hsd) {
    uint8_t br_bit_ct = BACKREF_COUNT_BITS(hsd);
    uint16_t bits = get_bits(hsd, br_bit_ct < 8 ? br_bit_ct : 8);
    LOG("-- backref count (lsb), got 0x%04x (+1)\n", bits);
    if (bits == NO_BITS) { return HSDS_BACKREF_COUNT_LSB; }
    hsd->output_count |= bits;
210896a8:	6218b03a 	or	r12,r12,r8
    hsd->output_count++;
210896ac:	63000044 	addi	r12,r12,1
210896b0:	2300010d 	sth	r12,4(r4)
210896b4:	1a003fcc 	andi	r8,r3,255
210896b8:	003eb206 	br	21089184 <__flash_rwdata_start+0xfffe6f3c>

static HSD_state st_backref_index_lsb(heatshrink_decoder *hsd) {
    uint8_t bit_ct = BACKREF_INDEX_BITS(hsd);
    uint16_t bits = get_bits(hsd, bit_ct < 8 ? bit_ct : 8);
    LOG("-- backref index (lsb), got 0x%04x (+1)\n", bits);
    if (bits == NO_BITS) { return HSDS_BACKREF_INDEX_LSB; }
210896bc:	623fffcc 	andi	r8,r12,65535
210896c0:	453eae26 	beq	r8,r20,2108917c <__flash_rwdata_start+0xfffe6f34>
    hsd->output_index |= bits;
210896c4:	20c0018b 	ldhu	r3,6(r4)
    hsd->output_index++;
    uint8_t br_bit_ct = BACKREF_COUNT_BITS(hsd);
    hsd->output_count = 0;
210896c8:	2000010d 	sth	zero,4(r4)
static HSD_state st_backref_index_lsb(heatshrink_decoder *hsd) {
    uint8_t bit_ct = BACKREF_INDEX_BITS(hsd);
    uint16_t bits = get_bits(hsd, bit_ct < 8 ? bit_ct : 8);
    LOG("-- backref index (lsb), got 0x%04x (+1)\n", bits);
    if (bits == NO_BITS) { return HSDS_BACKREF_INDEX_LSB; }
    hsd->output_index |= bits;
210896cc:	60d8b03a 	or	r12,r12,r3
    hsd->output_index++;
    uint8_t br_bit_ct = BACKREF_COUNT_BITS(hsd);
    hsd->output_count = 0;
    return (br_bit_ct > 8) ? HSDS_BACKREF_COUNT_MSB : HSDS_BACKREF_COUNT_LSB;
210896d0:	20c00383 	ldbu	r3,14(r4)
    uint8_t bit_ct = BACKREF_INDEX_BITS(hsd);
    uint16_t bits = get_bits(hsd, bit_ct < 8 ? bit_ct : 8);
    LOG("-- backref index (lsb), got 0x%04x (+1)\n", bits);
    if (bits == NO_BITS) { return HSDS_BACKREF_INDEX_LSB; }
    hsd->output_index |= bits;
    hsd->output_index++;
210896d4:	63000044 	addi	r12,r12,1
210896d8:	2300018d 	sth	r12,6(r4)
    uint8_t br_bit_ct = BACKREF_COUNT_BITS(hsd);
    hsd->output_count = 0;
    return (br_bit_ct > 8) ? HSDS_BACKREF_COUNT_MSB : HSDS_BACKREF_COUNT_LSB;
210896dc:	80c7803a 	cmpltu	r3,r16,r3
210896e0:	a8c7c83a 	sub	r3,r21,r3
            break;
        case HSDS_BACKREF_COUNT_LSB:
            hsd->state = st_backref_count_lsb(hsd);
            break;
        case HSDS_YIELD_BACKREF:
            hsd->state = st_yield_backref(hsd, &oi);
210896e4:	20c00285 	stb	r3,10(r4)
210896e8:	1a003fcc 	andi	r8,r3,255
210896ec:	003ea506 	br	21089184 <__flash_rwdata_start+0xfffe6f3c>
static HSD_state st_backref_count_msb(heatshrink_decoder *hsd) {
    uint8_t br_bit_ct = BACKREF_COUNT_BITS(hsd);
    ASSERT(br_bit_ct > 8);
    uint16_t bits = get_bits(hsd, br_bit_ct - 8);
    LOG("-- backref count (msb), got 0x%04x (+1)\n", bits);
    if (bits == NO_BITS) { return HSDS_BACKREF_COUNT_MSB; }
210896f0:	523fffcc 	andi	r8,r10,65535
210896f4:	453ea126 	beq	r8,r20,2108917c <__flash_rwdata_start+0xfffe6f34>
210896f8:	5014923a 	slli	r10,r10,8
    hsd->output_count = bits << 8;
210896fc:	00c00144 	movi	r3,5
21089700:	2280010d 	sth	r10,4(r4)
            break;
        case HSDS_BACKREF_COUNT_LSB:
            hsd->state = st_backref_count_lsb(hsd);
            break;
        case HSDS_YIELD_BACKREF:
            hsd->state = st_yield_backref(hsd, &oi);
21089704:	20c00285 	stb	r3,10(r4)
21089708:	1a003fcc 	andi	r8,r3,255
2108970c:	003e9d06 	br	21089184 <__flash_rwdata_start+0xfffe6f3c>
static HSD_state st_backref_index_msb(heatshrink_decoder *hsd) {
    uint8_t bit_ct = BACKREF_INDEX_BITS(hsd);
    ASSERT(bit_ct > 8);
    uint16_t bits = get_bits(hsd, bit_ct - 8);
    LOG("-- backref index (msb), got 0x%04x (+1)\n", bits);
    if (bits == NO_BITS) { return HSDS_BACKREF_INDEX_MSB; }
21089710:	523fffcc 	andi	r8,r10,65535
21089714:	453e9926 	beq	r8,r20,2108917c <__flash_rwdata_start+0xfffe6f34>
21089718:	5014923a 	slli	r10,r10,8
    hsd->output_index = bits << 8;
2108971c:	00c000c4 	movi	r3,3
21089720:	2280018d 	sth	r10,6(r4)
            break;
        case HSDS_BACKREF_COUNT_LSB:
            hsd->state = st_backref_count_lsb(hsd);
            break;
        case HSDS_YIELD_BACKREF:
            hsd->state = st_yield_backref(hsd, &oi);
21089724:	20c00285 	stb	r3,10(r4)
21089728:	1a003fcc 	andi	r8,r3,255
2108972c:	003e9506 	br	21089184 <__flash_rwdata_start+0xfffe6f3c>
    output_info *oi);

HSD_poll_res heatshrink_decoder_poll(heatshrink_decoder *hsd,
        uint8_t *out_buf, size_t out_buf_size, size_t *output_size) {
    if ((hsd == NULL) || (out_buf == NULL) || (output_size == NULL)) {
        return HSDR_POLL_ERROR_NULL;
21089730:	00bfffc4 	movi	r2,-1
        if (hsd->state == in_state) {
            if (*output_size == out_buf_size) { return HSDR_POLL_MORE; }
            return HSDR_POLL_EMPTY;
        }
    }
}
21089734:	f800283a 	ret
     * don't track how many bits of COUNT we've accumulated before suspend. */
    if (hsd->input_size == 0) {
        if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
    }

    for (i = 0; i < count; i++) {
21089738:	0015883a 	mov	r10,zero
2108973c:	003ff706 	br	2108971c <__flash_rwdata_start+0xfffe74d4>
21089740:	0015883a 	mov	r10,zero
21089744:	003fed06 	br	210896fc <__flash_rwdata_start+0xfffe74b4>
21089748:	0019883a 	mov	r12,zero
2108974c:	003fdd06 	br	210896c4 <__flash_rwdata_start+0xfffe747c>
21089750:	0019883a 	mov	r12,zero
21089754:	003fd106 	br	2108969c <__flash_rwdata_start+0xfffe7454>
            break;
        case HSDS_YIELD_BACKREF:
            hsd->state = st_yield_backref(hsd, &oi);
            break;
        default:
            return HSDR_POLL_ERROR_UNKNOWN;
21089758:	00bfff84 	movi	r2,-2
2108975c:	003e8c06 	br	21089190 <__flash_rwdata_start+0xfffe6f48>

21089760 <heatshrink_decoder_finish>:
    if (count > 1) { LOG("  -- accumulated %08x\n", accumulator); }
    return accumulator;
}

HSD_finish_res heatshrink_decoder_finish(heatshrink_decoder *hsd) {
    if (hsd == NULL) { return HSDR_FINISH_ERROR_NULL; }
21089760:	20000a26 	beq	r4,zero,2108978c <heatshrink_decoder_finish+0x2c>
    switch (hsd->state) {
21089764:	20c00283 	ldbu	r3,10(r4)
21089768:	00800044 	movi	r2,1
2108976c:	18800426 	beq	r3,r2,21089780 <heatshrink_decoder_finish+0x20>
21089770:	18000326 	beq	r3,zero,21089780 <heatshrink_decoder_finish+0x20>
21089774:	01400144 	movi	r5,5
21089778:	28c0012e 	bgeu	r5,r3,21089780 <heatshrink_decoder_finish+0x20>
        return hsd->input_size == 0 ? HSDR_FINISH_DONE : HSDR_FINISH_MORE;

    default:
        return HSDR_FINISH_MORE;
    }
}
2108977c:	f800283a 	ret

    /* If the output stream is padded with 0xFFs (possibly due to being in
     * flash memory), also explicitly check the input size rather than
     * uselessly returning MORE but yielding 0 bytes when polling. */
    case HSDS_YIELD_LITERAL:
        return hsd->input_size == 0 ? HSDR_FINISH_DONE : HSDR_FINISH_MORE;
21089780:	2080000b 	ldhu	r2,0(r4)
21089784:	1004c03a 	cmpne	r2,r2,zero
21089788:	f800283a 	ret
    if (count > 1) { LOG("  -- accumulated %08x\n", accumulator); }
    return accumulator;
}

HSD_finish_res heatshrink_decoder_finish(heatshrink_decoder *hsd) {
    if (hsd == NULL) { return HSDR_FINISH_ERROR_NULL; }
2108978c:	00bfffc4 	movi	r2,-1
21089790:	003ffa06 	br	2108977c <__flash_rwdata_start+0xfffe7534>

21089794 <I2C_Write>:
void i2c_start(alt_u32 clk_base, alt_u32 data_base);
void i2c_stop(alt_u32 clk_base, alt_u32 data_base);
bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data);
void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck);

bool I2C_Write(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 ControlData){
21089794:	defff504 	addi	sp,sp,-44
21089798:	ddc00815 	stw	r23,32(sp)
2108979c:	ddc00b03 	ldbu	r23,44(sp)
210897a0:	dd800715 	stw	r22,28(sp)
210897a4:	dd400615 	stw	r21,24(sp)
210897a8:	dd000515 	stw	r20,20(sp)
210897ac:	dcc00415 	stw	r19,16(sp)
210897b0:	dc000115 	stw	r16,4(sp)
210897b4:	dfc00a15 	stw	ra,40(sp)
210897b8:	df000915 	stw	fp,36(sp)
210897bc:	dc800315 	stw	r18,12(sp)
210897c0:	dc400215 	stw	r17,8(sp)
210897c4:	2829883a 	mov	r20,r5
210897c8:	2021883a 	mov	r16,r4
210897cc:	302b883a 	mov	r21,r6
210897d0:	d9c00005 	stb	r7,0(sp)

//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){

    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
210897d4:	2d800104 	addi	r22,r5,4
210897d8:	04c00044 	movi	r19,1
210897dc:	b4c00035 	stwio	r19,0(r22)

    // start condition
    SDA_HIGH(data_base); // data high
210897e0:	2cc00035 	stwio	r19,0(r5)
    SCL_HIGH(clk_base);
210897e4:	24c00035 	stwio	r19,0(r4)
    SCL_DELAY;
210897e8:	9809883a 	mov	r4,r19
210897ec:	109b8500 	call	2109b850 <usleep>

    SDA_LOW(data_base); // data low
210897f0:	a0000035 	stwio	zero,0(r20)
    SCL_DELAY;
210897f4:	9809883a 	mov	r4,r19
210897f8:	109b8500 	call	2109b850 <usleep>
    SCL_LOW(clk_base); // clock low
210897fc:	80000035 	stwio	zero,0(r16)
    SCL_DELAY;
21089800:	9809883a 	mov	r4,r19
21089804:	109b8500 	call	2109b850 <usleep>
    bool bAck;
    int i;

    // assume, SCL = 0

    SDA_DIR_OUT(data_base);  // data write mode
21089808:	b4c00035 	stwio	r19,0(r22)
2108980c:	04800204 	movi	r18,8


}

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
    alt_u8 Mask = 0x80;
21089810:	073fe004 	movi	fp,-128
21089814:	00000c06 	br	21089848 <I2C_Write+0xb4>

    for(i=0;i<8;i++){
        SCL_LOW(clk_base);  // new, make sure data change at clk low
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
            SDA_HIGH(data_base);
21089818:	a4c00035 	stwio	r19,0(r20)
        }else{
            SDA_LOW(data_base);
        }
        Mask >>= 1; // there is a delay in this command
2108981c:	e0c03fcc 	andi	r3,fp,255
21089820:	1838d07a 	srli	fp,r3,1
        // clock high
        SCL_HIGH(clk_base);
21089824:	04400044 	movi	r17,1
21089828:	84c00035 	stwio	r19,0(r16)
        SCL_DELAY;
2108982c:	8809883a 	mov	r4,r17
21089830:	109b8500 	call	2109b850 <usleep>
        SCL_LOW(clk_base);
21089834:	80000035 	stwio	zero,0(r16)
21089838:	94bfffc4 	addi	r18,r18,-1
        SCL_DELAY;
2108983c:	8809883a 	mov	r4,r17
21089840:	109b8500 	call	2109b850 <usleep>

    // assume, SCL = 0

    SDA_DIR_OUT(data_base);  // data write mode

    for(i=0;i<8;i++){
21089844:	90000626 	beq	r18,zero,21089860 <I2C_Write+0xcc>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
21089848:	80000035 	stwio	zero,0(r16)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
2108984c:	e544703a 	and	r2,fp,r21
21089850:	10803fcc 	andi	r2,r2,255
21089854:	103ff01e 	bne	r2,zero,21089818 <__flash_rwdata_start+0xfffe75d0>
            SDA_HIGH(data_base);
        }else{
            SDA_LOW(data_base);
21089858:	a0000035 	stwio	zero,0(r20)
2108985c:	003fef06 	br	2108981c <__flash_rwdata_start+0xfffe75d4>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }

    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
21089860:	b0000035 	stwio	zero,0(r22)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
21089864:	84400035 	stwio	r17,0(r16)
    SCL_DELAY;  // clock high delay
21089868:	8809883a 	mov	r4,r17
2108986c:	109b8500 	call	2109b850 <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
21089870:	a4800037 	ldwio	r18,0(r20)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low
21089874:	80000035 	stwio	zero,0(r16)
    SCL_DELAY; // clock low delay
21089878:	8809883a 	mov	r4,r17
2108987c:	109b8500 	call	2109b850 <usleep>

bool I2C_Write(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 ControlData){
    bool bSuccess = TRUE;

    i2c_start(clk_base, data_base);
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
21089880:	9000201e 	bne	r18,zero,21089904 <I2C_Write+0x170>
    bool bAck;
    int i;

    // assume, SCL = 0

    SDA_DIR_OUT(data_base);  // data write mode
21089884:	b4400035 	stwio	r17,0(r22)
21089888:	05400204 	movi	r21,8


}

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
    alt_u8 Mask = 0x80;
2108988c:	04ffe004 	movi	r19,-128
21089890:	00000c06 	br	210898c4 <I2C_Write+0x130>

    for(i=0;i<8;i++){
        SCL_LOW(clk_base);  // new, make sure data change at clk low
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
            SDA_HIGH(data_base);
21089894:	a4400035 	stwio	r17,0(r20)
        }else{
            SDA_LOW(data_base);
        }
        Mask >>= 1; // there is a delay in this command
21089898:	9cc03fcc 	andi	r19,r19,255
2108989c:	9826d07a 	srli	r19,r19,1
        // clock high
        SCL_HIGH(clk_base);
210898a0:	04800044 	movi	r18,1
210898a4:	84400035 	stwio	r17,0(r16)
        SCL_DELAY;
210898a8:	9009883a 	mov	r4,r18
210898ac:	109b8500 	call	2109b850 <usleep>
        SCL_LOW(clk_base);
210898b0:	80000035 	stwio	zero,0(r16)
210898b4:	ad7fffc4 	addi	r21,r21,-1
        SCL_DELAY;
210898b8:	9009883a 	mov	r4,r18
210898bc:	109b8500 	call	2109b850 <usleep>

    // assume, SCL = 0

    SDA_DIR_OUT(data_base);  // data write mode

    for(i=0;i<8;i++){
210898c0:	a8000726 	beq	r21,zero,210898e0 <I2C_Write+0x14c>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
210898c4:	80000035 	stwio	zero,0(r16)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
210898c8:	d8c00003 	ldbu	r3,0(sp)
210898cc:	98c4703a 	and	r2,r19,r3
210898d0:	10803fcc 	andi	r2,r2,255
210898d4:	103fef1e 	bne	r2,zero,21089894 <__flash_rwdata_start+0xfffe764c>
            SDA_HIGH(data_base);
        }else{
            SDA_LOW(data_base);
210898d8:	a0000035 	stwio	zero,0(r20)
210898dc:	003fee06 	br	21089898 <__flash_rwdata_start+0xfffe7650>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }

    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
210898e0:	b0000035 	stwio	zero,0(r22)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
210898e4:	84800035 	stwio	r18,0(r16)
    SCL_DELAY;  // clock high delay
210898e8:	9009883a 	mov	r4,r18
210898ec:	109b8500 	call	2109b850 <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
210898f0:	a4400037 	ldwio	r17,0(r20)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low
210898f4:	80000035 	stwio	zero,0(r16)
    SCL_DELAY; // clock low delay
210898f8:	9009883a 	mov	r4,r18
210898fc:	109b8500 	call	2109b850 <usleep>
    i2c_start(clk_base, data_base);
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
21089900:	88001926 	beq	r17,zero,21089968 <I2C_Write+0x1d4>


}

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
    alt_u8 Mask = 0x80;
21089904:	0025883a 	mov	r18,zero

// SDA 0->1 while SCL=1
void i2c_stop(alt_u32 clk_base, alt_u32 data_base){
    // assume SCL = 0

    SDA_DIR_OUT(data_base);  // data output enabled
21089908:	04400044 	movi	r17,1
2108990c:	b4400035 	stwio	r17,0(r22)
    SDA_LOW(data_base); // Data Low
21089910:	a0000035 	stwio	zero,0(r20)
    //SCL_DELAY;
    SCL_HIGH(clk_base);  // clock high
21089914:	84400035 	stwio	r17,0(r16)
    SCL_DELAY; // clock high long delay
21089918:	8809883a 	mov	r4,r17
2108991c:	109b8500 	call	2109b850 <usleep>
    SDA_HIGH(data_base); // data high
21089920:	a4400035 	stwio	r17,0(r20)
    SCL_DELAY; // data high delay
21089924:	8809883a 	mov	r4,r17
21089928:	109b8500 	call	2109b850 <usleep>
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: write NACK!\n"));
    }
    i2c_stop(clk_base, data_base);

    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
2108992c:	0106d604 	movi	r4,7000
21089930:	109b8500 	call	2109b850 <usleep>

    return bSuccess;


}
21089934:	9005883a 	mov	r2,r18
21089938:	dfc00a17 	ldw	ra,40(sp)
2108993c:	df000917 	ldw	fp,36(sp)
21089940:	ddc00817 	ldw	r23,32(sp)
21089944:	dd800717 	ldw	r22,28(sp)
21089948:	dd400617 	ldw	r21,24(sp)
2108994c:	dd000517 	ldw	r20,20(sp)
21089950:	dcc00417 	ldw	r19,16(sp)
21089954:	dc800317 	ldw	r18,12(sp)
21089958:	dc400217 	ldw	r17,8(sp)
2108995c:	dc000117 	ldw	r16,4(sp)
21089960:	dec00b04 	addi	sp,sp,44
21089964:	f800283a 	ret
    bool bAck;
    int i;

    // assume, SCL = 0

    SDA_DIR_OUT(data_base);  // data write mode
21089968:	b4800035 	stwio	r18,0(r22)
2108996c:	04c00204 	movi	r19,8


}

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
    alt_u8 Mask = 0x80;
21089970:	047fe004 	movi	r17,-128
21089974:	00000c06 	br	210899a8 <I2C_Write+0x214>

    for(i=0;i<8;i++){
        SCL_LOW(clk_base);  // new, make sure data change at clk low
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
            SDA_HIGH(data_base);
21089978:	a4800035 	stwio	r18,0(r20)
        }else{
            SDA_LOW(data_base);
        }
        Mask >>= 1; // there is a delay in this command
2108997c:	8c403fcc 	andi	r17,r17,255
21089980:	8822d07a 	srli	r17,r17,1
        // clock high
        SCL_HIGH(clk_base);
21089984:	05400044 	movi	r21,1
21089988:	84800035 	stwio	r18,0(r16)
        SCL_DELAY;
2108998c:	a809883a 	mov	r4,r21
21089990:	109b8500 	call	2109b850 <usleep>
        SCL_LOW(clk_base);
21089994:	80000035 	stwio	zero,0(r16)
21089998:	9cffffc4 	addi	r19,r19,-1
        SCL_DELAY;
2108999c:	a809883a 	mov	r4,r21
210899a0:	109b8500 	call	2109b850 <usleep>

    // assume, SCL = 0

    SDA_DIR_OUT(data_base);  // data write mode

    for(i=0;i<8;i++){
210899a4:	98000626 	beq	r19,zero,210899c0 <I2C_Write+0x22c>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
210899a8:	80000035 	stwio	zero,0(r16)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
210899ac:	8dc4703a 	and	r2,r17,r23
210899b0:	10803fcc 	andi	r2,r2,255
210899b4:	103ff01e 	bne	r2,zero,21089978 <__flash_rwdata_start+0xfffe7730>
            SDA_HIGH(data_base);
        }else{
            SDA_LOW(data_base);
210899b8:	a0000035 	stwio	zero,0(r20)
210899bc:	003fef06 	br	2108997c <__flash_rwdata_start+0xfffe7734>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }

    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
210899c0:	b0000035 	stwio	zero,0(r22)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
210899c4:	85400035 	stwio	r21,0(r16)
    SCL_DELAY;  // clock high delay
210899c8:	a809883a 	mov	r4,r21
210899cc:	109b8500 	call	2109b850 <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
210899d0:	a4800037 	ldwio	r18,0(r20)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low
210899d4:	80000035 	stwio	zero,0(r16)
    SCL_DELAY; // clock low delay
210899d8:	a809883a 	mov	r4,r21
210899dc:	109b8500 	call	2109b850 <usleep>
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlData)){
210899e0:	9025003a 	cmpeq	r18,r18,zero
210899e4:	003fc806 	br	21089908 <__flash_rwdata_start+0xfffe76c0>

210899e8 <I2C_Read>:
    return bSuccess;


}

bool I2C_Read(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 *pControlData){
210899e8:	defff504 	addi	sp,sp,-44
210899ec:	df000915 	stw	fp,36(sp)
210899f0:	dd800715 	stw	r22,28(sp)
210899f4:	dd000515 	stw	r20,20(sp)
210899f8:	dc800315 	stw	r18,12(sp)
210899fc:	dc000115 	stw	r16,4(sp)
21089a00:	dfc00a15 	stw	ra,40(sp)
21089a04:	ddc00815 	stw	r23,32(sp)
21089a08:	dd400615 	stw	r21,24(sp)
21089a0c:	dcc00415 	stw	r19,16(sp)
21089a10:	dc400215 	stw	r17,8(sp)
21089a14:	2825883a 	mov	r18,r5
21089a18:	2021883a 	mov	r16,r4
21089a1c:	d9800015 	stw	r6,0(sp)
21089a20:	3839883a 	mov	fp,r7

//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){

    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
21089a24:	2d800104 	addi	r22,r5,4
21089a28:	05000044 	movi	r20,1
21089a2c:	b5000035 	stwio	r20,0(r22)

    // start condition
    SDA_HIGH(data_base); // data high
21089a30:	2d000035 	stwio	r20,0(r5)
    SCL_HIGH(clk_base);
21089a34:	25000035 	stwio	r20,0(r4)
    SCL_DELAY;
21089a38:	a009883a 	mov	r4,r20
21089a3c:	109b8500 	call	2109b850 <usleep>

    SDA_LOW(data_base); // data low
21089a40:	90000035 	stwio	zero,0(r18)
    SCL_DELAY;
21089a44:	a009883a 	mov	r4,r20
21089a48:	109b8500 	call	2109b850 <usleep>
    SCL_LOW(clk_base); // clock low
21089a4c:	80000035 	stwio	zero,0(r16)
    SCL_DELAY;
21089a50:	a009883a 	mov	r4,r20
21089a54:	109b8500 	call	2109b850 <usleep>

bool I2C_Read(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 *pControlData){
    bool bSuccess = TRUE;

    i2c_start(clk_base, data_base);
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
21089a58:	d8800017 	ldw	r2,0(sp)
21089a5c:	102b883a 	mov	r21,r2
    bool bAck;
    int i;

    // assume, SCL = 0

    SDA_DIR_OUT(data_base);  // data write mode
21089a60:	b5000035 	stwio	r20,0(r22)
21089a64:	04c00204 	movi	r19,8


}

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
    alt_u8 Mask = 0x80;
21089a68:	05ffe004 	movi	r23,-128
21089a6c:	00000c06 	br	21089aa0 <I2C_Read+0xb8>

    for(i=0;i<8;i++){
        SCL_LOW(clk_base);  // new, make sure data change at clk low
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
            SDA_HIGH(data_base);
21089a70:	95000035 	stwio	r20,0(r18)
        }else{
            SDA_LOW(data_base);
        }
        Mask >>= 1; // there is a delay in this command
21089a74:	b8c03fcc 	andi	r3,r23,255
21089a78:	182ed07a 	srli	r23,r3,1
        // clock high
        SCL_HIGH(clk_base);
21089a7c:	04400044 	movi	r17,1
21089a80:	85000035 	stwio	r20,0(r16)
        SCL_DELAY;
21089a84:	8809883a 	mov	r4,r17
21089a88:	109b8500 	call	2109b850 <usleep>
        SCL_LOW(clk_base);
21089a8c:	80000035 	stwio	zero,0(r16)
21089a90:	9cffffc4 	addi	r19,r19,-1
        SCL_DELAY;
21089a94:	8809883a 	mov	r4,r17
21089a98:	109b8500 	call	2109b850 <usleep>

    // assume, SCL = 0

    SDA_DIR_OUT(data_base);  // data write mode

    for(i=0;i<8;i++){
21089a9c:	98000626 	beq	r19,zero,21089ab8 <I2C_Read+0xd0>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
21089aa0:	80000035 	stwio	zero,0(r16)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
21089aa4:	bd44703a 	and	r2,r23,r21
21089aa8:	10803fcc 	andi	r2,r2,255
21089aac:	103ff01e 	bne	r2,zero,21089a70 <__flash_rwdata_start+0xfffe7828>
            SDA_HIGH(data_base);
        }else{
            SDA_LOW(data_base);
21089ab0:	90000035 	stwio	zero,0(r18)
21089ab4:	003fef06 	br	21089a74 <__flash_rwdata_start+0xfffe782c>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }

    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
21089ab8:	b0000035 	stwio	zero,0(r22)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
21089abc:	84400035 	stwio	r17,0(r16)
    SCL_DELAY;  // clock high delay
21089ac0:	8809883a 	mov	r4,r17
21089ac4:	109b8500 	call	2109b850 <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
21089ac8:	94c00037 	ldwio	r19,0(r18)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low
21089acc:	80000035 	stwio	zero,0(r16)
    SCL_DELAY; // clock low delay
21089ad0:	8809883a 	mov	r4,r17
21089ad4:	109b8500 	call	2109b850 <usleep>

bool I2C_Read(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 *pControlData){
    bool bSuccess = TRUE;

    i2c_start(clk_base, data_base);
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
21089ad8:	98001f1e 	bne	r19,zero,21089b58 <I2C_Read+0x170>
    bool bAck;
    int i;

    // assume, SCL = 0

    SDA_DIR_OUT(data_base);  // data write mode
21089adc:	b4400035 	stwio	r17,0(r22)
21089ae0:	05400204 	movi	r21,8


}

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
    alt_u8 Mask = 0x80;
21089ae4:	053fe004 	movi	r20,-128
21089ae8:	00000c06 	br	21089b1c <I2C_Read+0x134>

    for(i=0;i<8;i++){
        SCL_LOW(clk_base);  // new, make sure data change at clk low
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
            SDA_HIGH(data_base);
21089aec:	94400035 	stwio	r17,0(r18)
        }else{
            SDA_LOW(data_base);
        }
        Mask >>= 1; // there is a delay in this command
21089af0:	a5003fcc 	andi	r20,r20,255
21089af4:	a028d07a 	srli	r20,r20,1
        // clock high
        SCL_HIGH(clk_base);
21089af8:	04c00044 	movi	r19,1
21089afc:	84400035 	stwio	r17,0(r16)
        SCL_DELAY;
21089b00:	9809883a 	mov	r4,r19
21089b04:	109b8500 	call	2109b850 <usleep>
        SCL_LOW(clk_base);
21089b08:	80000035 	stwio	zero,0(r16)
21089b0c:	ad7fffc4 	addi	r21,r21,-1
        SCL_DELAY;
21089b10:	9809883a 	mov	r4,r19
21089b14:	109b8500 	call	2109b850 <usleep>

    // assume, SCL = 0

    SDA_DIR_OUT(data_base);  // data write mode

    for(i=0;i<8;i++){
21089b18:	a8000626 	beq	r21,zero,21089b34 <I2C_Read+0x14c>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
21089b1c:	80000035 	stwio	zero,0(r16)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
21089b20:	a704703a 	and	r2,r20,fp
21089b24:	10803fcc 	andi	r2,r2,255
21089b28:	103ff01e 	bne	r2,zero,21089aec <__flash_rwdata_start+0xfffe78a4>
            SDA_HIGH(data_base);
        }else{
            SDA_LOW(data_base);
21089b2c:	90000035 	stwio	zero,0(r18)
21089b30:	003fef06 	br	21089af0 <__flash_rwdata_start+0xfffe78a8>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }

    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
21089b34:	b0000035 	stwio	zero,0(r22)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
21089b38:	84c00035 	stwio	r19,0(r16)
    SCL_DELAY;  // clock high delay
21089b3c:	9809883a 	mov	r4,r19
21089b40:	109b8500 	call	2109b850 <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
21089b44:	94400037 	ldwio	r17,0(r18)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low
21089b48:	80000035 	stwio	zero,0(r16)
    SCL_DELAY; // clock low delay
21089b4c:	9809883a 	mov	r4,r19
21089b50:	109b8500 	call	2109b850 <usleep>
    i2c_start(clk_base, data_base);
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
21089b54:	88002326 	beq	r17,zero,21089be4 <I2C_Read+0x1fc>

//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){

    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
21089b58:	04400044 	movi	r17,1
21089b5c:	b4400035 	stwio	r17,0(r22)

    // start condition
    SDA_HIGH(data_base); // data high
21089b60:	94400035 	stwio	r17,0(r18)
    SCL_HIGH(clk_base);
21089b64:	84400035 	stwio	r17,0(r16)
    SCL_DELAY;
21089b68:	8809883a 	mov	r4,r17
21089b6c:	109b8500 	call	2109b850 <usleep>

    SDA_LOW(data_base); // data low
21089b70:	90000035 	stwio	zero,0(r18)
    SCL_DELAY;
21089b74:	8809883a 	mov	r4,r17
21089b78:	109b8500 	call	2109b850 <usleep>
    SCL_LOW(clk_base); // clock low
21089b7c:	80000035 	stwio	zero,0(r16)
    SCL_DELAY;
21089b80:	8809883a 	mov	r4,r17
21089b84:	109b8500 	call	2109b850 <usleep>
    SCL_DELAY; // clock low delay
    return bAck;
}

void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck){ // return true if device response ack
    alt_u8 Data=0;
21089b88:	0027883a 	mov	r19,zero

// SDA 0->1 while SCL=1
void i2c_stop(alt_u32 clk_base, alt_u32 data_base){
    // assume SCL = 0

    SDA_DIR_OUT(data_base);  // data output enabled
21089b8c:	04400044 	movi	r17,1
21089b90:	b4400035 	stwio	r17,0(r22)
    SDA_LOW(data_base); // Data Low
21089b94:	90000035 	stwio	zero,0(r18)
    //SCL_DELAY;
    SCL_HIGH(clk_base);  // clock high
21089b98:	84400035 	stwio	r17,0(r16)
    SCL_DELAY; // clock high long delay
21089b9c:	8809883a 	mov	r4,r17
21089ba0:	109b8500 	call	2109b850 <usleep>
    SDA_HIGH(data_base); // data high
21089ba4:	94400035 	stwio	r17,0(r18)
    SCL_DELAY; // data high delay
21089ba8:	8809883a 	mov	r4,r17
21089bac:	109b8500 	call	2109b850 <usleep>
        i2c_read(clk_base, data_base, pControlData, FALSE);  // read
    }
    i2c_stop(clk_base, data_base);

    return bSuccess;
}
21089bb0:	9805883a 	mov	r2,r19
21089bb4:	dfc00a17 	ldw	ra,40(sp)
21089bb8:	df000917 	ldw	fp,36(sp)
21089bbc:	ddc00817 	ldw	r23,32(sp)
21089bc0:	dd800717 	ldw	r22,28(sp)
21089bc4:	dd400617 	ldw	r21,24(sp)
21089bc8:	dd000517 	ldw	r20,20(sp)
21089bcc:	dcc00417 	ldw	r19,16(sp)
21089bd0:	dc800317 	ldw	r18,12(sp)
21089bd4:	dc400217 	ldw	r17,8(sp)
21089bd8:	dc000117 	ldw	r16,4(sp)
21089bdc:	dec00b04 	addi	sp,sp,44
21089be0:	f800283a 	ret

//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){

    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
21089be4:	b4c00035 	stwio	r19,0(r22)

    // start condition
    SDA_HIGH(data_base); // data high
21089be8:	94c00035 	stwio	r19,0(r18)
    SCL_HIGH(clk_base);
21089bec:	84c00035 	stwio	r19,0(r16)
    SCL_DELAY;
21089bf0:	9809883a 	mov	r4,r19
21089bf4:	109b8500 	call	2109b850 <usleep>

    SDA_LOW(data_base); // data low
21089bf8:	90000035 	stwio	zero,0(r18)
    SCL_DELAY;
21089bfc:	9809883a 	mov	r4,r19
21089c00:	109b8500 	call	2109b850 <usleep>
    SCL_LOW(clk_base); // clock low
21089c04:	80000035 	stwio	zero,0(r16)
    SCL_DELAY;
21089c08:	9809883a 	mov	r4,r19
21089c0c:	109b8500 	call	2109b850 <usleep>
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }
    i2c_start(clk_base, data_base);  // restart
    DeviceAddr |= 1; // Read
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
21089c10:	d8800017 	ldw	r2,0(sp)
21089c14:	15c00054 	ori	r23,r2,1
    bool bAck;
    int i;

    // assume, SCL = 0

    SDA_DIR_OUT(data_base);  // data write mode
21089c18:	b4c00035 	stwio	r19,0(r22)
21089c1c:	05400204 	movi	r21,8


}

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
    alt_u8 Mask = 0x80;
21089c20:	047fe004 	movi	r17,-128
21089c24:	00000c06 	br	21089c58 <I2C_Read+0x270>

    for(i=0;i<8;i++){
        SCL_LOW(clk_base);  // new, make sure data change at clk low
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
            SDA_HIGH(data_base);
21089c28:	94c00035 	stwio	r19,0(r18)
        }else{
            SDA_LOW(data_base);
        }
        Mask >>= 1; // there is a delay in this command
21089c2c:	8c403fcc 	andi	r17,r17,255
21089c30:	8822d07a 	srli	r17,r17,1
        // clock high
        SCL_HIGH(clk_base);
21089c34:	05000044 	movi	r20,1
21089c38:	84c00035 	stwio	r19,0(r16)
        SCL_DELAY;
21089c3c:	a009883a 	mov	r4,r20
21089c40:	109b8500 	call	2109b850 <usleep>
        SCL_LOW(clk_base);
21089c44:	80000035 	stwio	zero,0(r16)
21089c48:	ad7fffc4 	addi	r21,r21,-1
        SCL_DELAY;
21089c4c:	a009883a 	mov	r4,r20
21089c50:	109b8500 	call	2109b850 <usleep>

    // assume, SCL = 0

    SDA_DIR_OUT(data_base);  // data write mode

    for(i=0;i<8;i++){
21089c54:	a8000626 	beq	r21,zero,21089c70 <I2C_Read+0x288>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
21089c58:	80000035 	stwio	zero,0(r16)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
21089c5c:	8dc4703a 	and	r2,r17,r23
21089c60:	10803fcc 	andi	r2,r2,255
21089c64:	103ff01e 	bne	r2,zero,21089c28 <__flash_rwdata_start+0xfffe79e0>
            SDA_HIGH(data_base);
        }else{
            SDA_LOW(data_base);
21089c68:	90000035 	stwio	zero,0(r18)
21089c6c:	003fef06 	br	21089c2c <__flash_rwdata_start+0xfffe79e4>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }

    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
21089c70:	b0000035 	stwio	zero,0(r22)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
21089c74:	85000035 	stwio	r20,0(r16)
    SCL_DELAY;  // clock high delay
21089c78:	a009883a 	mov	r4,r20
21089c7c:	109b8500 	call	2109b850 <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
21089c80:	94400037 	ldwio	r17,0(r18)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low
21089c84:	80000035 	stwio	zero,0(r16)
    SCL_DELAY; // clock low delay
21089c88:	a009883a 	mov	r4,r20
21089c8c:	109b8500 	call	2109b850 <usleep>
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }
    i2c_start(clk_base, data_base);  // restart
    DeviceAddr |= 1; // Read
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
21089c90:	883fbd1e 	bne	r17,zero,21089b88 <__flash_rwdata_start+0xfffe7940>
    alt_u8 Data=0;
    int i;

    // assume SCL = low

    SDA_DIR_IN(data_base);  // set data read mode
21089c94:	b0000035 	stwio	zero,0(r22)
    SCL_LOW(clk_base); // clock low
21089c98:	80000035 	stwio	zero,0(r16)
    SCL_DELAY; // clock low delay
21089c9c:	a009883a 	mov	r4,r20
21089ca0:	109b8500 	call	2109b850 <usleep>
21089ca4:	05400204 	movi	r21,8
    SCL_DELAY; // clock low delay
    return bAck;
}

void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck){ // return true if device response ack
    alt_u8 Data=0;
21089ca8:	0023883a 	mov	r17,zero
    SDA_DIR_IN(data_base);  // set data read mode
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
        Data <<= 1;
21089cac:	8c67883a 	add	r19,r17,r17
21089cb0:	9823883a 	mov	r17,r19
        SCL_HIGH(clk_base);  // clock high
21089cb4:	85000035 	stwio	r20,0(r16)
        SCL_DELAY;
21089cb8:	01000044 	movi	r4,1
21089cbc:	109b8500 	call	2109b850 <usleep>
        if (SDA_READ(data_base))  // read data
21089cc0:	90800037 	ldwio	r2,0(r18)
21089cc4:	10000126 	beq	r2,zero,21089ccc <I2C_Read+0x2e4>
            Data |= 0x01;
21089cc8:	9c400054 	ori	r17,r19,1
        SCL_LOW(clk_base);  // clock log
21089ccc:	80000035 	stwio	zero,0(r16)
        SCL_DELAY;
21089cd0:	04c00044 	movi	r19,1
21089cd4:	ad7fffc4 	addi	r21,r21,-1
21089cd8:	9809883a 	mov	r4,r19
21089cdc:	109b8500 	call	2109b850 <usleep>

    SDA_DIR_IN(data_base);  // set data read mode
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
21089ce0:	a83ff21e 	bne	r21,zero,21089cac <__flash_rwdata_start+0xfffe7a64>
        SCL_LOW(clk_base);  // clock log
        SCL_DELAY;
    }

    // send ACK
    SCL_LOW(clk_base);  // new, make sure data change at clk low
21089ce4:	80000035 	stwio	zero,0(r16)
    SDA_DIR_OUT(data_base);  // set data write mode
21089ce8:	b4c00035 	stwio	r19,0(r22)
    if (bAck)
        SDA_LOW(data_base);
    else
        SDA_HIGH(data_base);
21089cec:	94c00035 	stwio	r19,0(r18)
    SCL_HIGH(clk_base); // clock high
21089cf0:	84c00035 	stwio	r19,0(r16)
    SCL_DELAY; // clock high  delay
21089cf4:	9809883a 	mov	r4,r19
21089cf8:	109b8500 	call	2109b850 <usleep>
    SCL_LOW(clk_base); // clock low
21089cfc:	80000035 	stwio	zero,0(r16)
    SCL_DELAY; // clock low delay
21089d00:	9809883a 	mov	r4,r19
21089d04:	109b8500 	call	2109b850 <usleep>
    SDA_LOW(data_base);  // data low
21089d08:	90000035 	stwio	zero,0(r18)
    SCL_DELAY; // data low delay
21089d0c:	9809883a 	mov	r4,r19
21089d10:	109b8500 	call	2109b850 <usleep>
//    SDA_DIR_IN;  // set data read mode

    *pData = Data;
21089d14:	d8800b17 	ldw	r2,44(sp)
21089d18:	14400005 	stb	r17,0(r2)
21089d1c:	003f9b06 	br	21089b8c <__flash_rwdata_start+0xfffe7944>

21089d20 <i2c_start>:
///////////// Interncal function (i2cXXX) body //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////


//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){
21089d20:	defffb04 	addi	sp,sp,-20
21089d24:	dc800215 	stw	r18,8(sp)
21089d28:	dc400115 	stw	r17,4(sp)
21089d2c:	dc000015 	stw	r16,0(sp)
21089d30:	dfc00415 	stw	ra,16(sp)
21089d34:	dcc00315 	stw	r19,12(sp)
21089d38:	2025883a 	mov	r18,r4
21089d3c:	2823883a 	mov	r17,r5

    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
21089d40:	04000044 	movi	r16,1
21089d44:	2c000135 	stwio	r16,4(r5)

    // start condition
    SDA_HIGH(data_base); // data high
21089d48:	2c000035 	stwio	r16,0(r5)
    SCL_HIGH(clk_base);
21089d4c:	24000035 	stwio	r16,0(r4)
    SCL_DELAY;
21089d50:	8009883a 	mov	r4,r16
21089d54:	109b8500 	call	2109b850 <usleep>

    SDA_LOW(data_base); // data low
21089d58:	0027883a 	mov	r19,zero
21089d5c:	8cc00035 	stwio	r19,0(r17)
    SCL_DELAY;
21089d60:	8009883a 	mov	r4,r16
21089d64:	109b8500 	call	2109b850 <usleep>
    SCL_LOW(clk_base); // clock low
21089d68:	94c00035 	stwio	r19,0(r18)
    SCL_DELAY;
21089d6c:	8009883a 	mov	r4,r16
}
21089d70:	dfc00417 	ldw	ra,16(sp)
21089d74:	dcc00317 	ldw	r19,12(sp)
21089d78:	dc800217 	ldw	r18,8(sp)
21089d7c:	dc400117 	ldw	r17,4(sp)
21089d80:	dc000017 	ldw	r16,0(sp)
21089d84:	dec00504 	addi	sp,sp,20
    SCL_DELAY;

    SDA_LOW(data_base); // data low
    SCL_DELAY;
    SCL_LOW(clk_base); // clock low
    SCL_DELAY;
21089d88:	109b8501 	jmpi	2109b850 <usleep>

21089d8c <i2c_stop>:
}

// SDA 0->1 while SCL=1
void i2c_stop(alt_u32 clk_base, alt_u32 data_base){
21089d8c:	defffd04 	addi	sp,sp,-12
21089d90:	dc400115 	stw	r17,4(sp)
21089d94:	dc000015 	stw	r16,0(sp)
21089d98:	dfc00215 	stw	ra,8(sp)
21089d9c:	2823883a 	mov	r17,r5
    // assume SCL = 0

    SDA_DIR_OUT(data_base);  // data output enabled
21089da0:	04000044 	movi	r16,1
21089da4:	2c000135 	stwio	r16,4(r5)
    SDA_LOW(data_base); // Data Low
21089da8:	28000035 	stwio	zero,0(r5)
    //SCL_DELAY;
    SCL_HIGH(clk_base);  // clock high
21089dac:	24000035 	stwio	r16,0(r4)
    SCL_DELAY; // clock high long delay
21089db0:	8009883a 	mov	r4,r16
21089db4:	109b8500 	call	2109b850 <usleep>
    SDA_HIGH(data_base); // data high
21089db8:	8c000035 	stwio	r16,0(r17)
    SCL_DELAY; // data high delay
21089dbc:	8009883a 	mov	r4,r16



}
21089dc0:	dfc00217 	ldw	ra,8(sp)
21089dc4:	dc400117 	ldw	r17,4(sp)
21089dc8:	dc000017 	ldw	r16,0(sp)
21089dcc:	dec00304 	addi	sp,sp,12
    SDA_LOW(data_base); // Data Low
    //SCL_DELAY;
    SCL_HIGH(clk_base);  // clock high
    SCL_DELAY; // clock high long delay
    SDA_HIGH(data_base); // data high
    SCL_DELAY; // data high delay
21089dd0:	109b8501 	jmpi	2109b850 <usleep>

21089dd4 <i2c_write>:



}

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
21089dd4:	defff704 	addi	sp,sp,-36
21089dd8:	dd800615 	stw	r22,24(sp)
21089ddc:	dd400515 	stw	r21,20(sp)
21089de0:	dd000415 	stw	r20,16(sp)
21089de4:	dcc00315 	stw	r19,12(sp)
21089de8:	dc400115 	stw	r17,4(sp)
21089dec:	dfc00815 	stw	ra,32(sp)
21089df0:	ddc00715 	stw	r23,28(sp)
21089df4:	dc800215 	stw	r18,8(sp)
21089df8:	dc000015 	stw	r16,0(sp)
21089dfc:	2829883a 	mov	r20,r5
21089e00:	2023883a 	mov	r17,r4
21089e04:	302b883a 	mov	r21,r6
    bool bAck;
    int i;

    // assume, SCL = 0

    SDA_DIR_OUT(data_base);  // data write mode
21089e08:	2d800104 	addi	r22,r5,4
21089e0c:	04c00044 	movi	r19,1
21089e10:	b4c00035 	stwio	r19,0(r22)
21089e14:	04800204 	movi	r18,8


}

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
    alt_u8 Mask = 0x80;
21089e18:	043fe004 	movi	r16,-128
21089e1c:	00000c06 	br	21089e50 <i2c_write+0x7c>

    for(i=0;i<8;i++){
        SCL_LOW(clk_base);  // new, make sure data change at clk low
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
            SDA_HIGH(data_base);
21089e20:	a4c00035 	stwio	r19,0(r20)
        }else{
            SDA_LOW(data_base);
        }
        Mask >>= 1; // there is a delay in this command
21089e24:	84003fcc 	andi	r16,r16,255
21089e28:	8020d07a 	srli	r16,r16,1
        // clock high
        SCL_HIGH(clk_base);
21089e2c:	05c00044 	movi	r23,1
21089e30:	8cc00035 	stwio	r19,0(r17)
        SCL_DELAY;
21089e34:	b809883a 	mov	r4,r23
21089e38:	109b8500 	call	2109b850 <usleep>
        SCL_LOW(clk_base);
21089e3c:	88000035 	stwio	zero,0(r17)
21089e40:	94bfffc4 	addi	r18,r18,-1
        SCL_DELAY;
21089e44:	b809883a 	mov	r4,r23
21089e48:	109b8500 	call	2109b850 <usleep>

    // assume, SCL = 0

    SDA_DIR_OUT(data_base);  // data write mode

    for(i=0;i<8;i++){
21089e4c:	90000626 	beq	r18,zero,21089e68 <i2c_write+0x94>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
21089e50:	88000035 	stwio	zero,0(r17)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
21089e54:	8544703a 	and	r2,r16,r21
21089e58:	10803fcc 	andi	r2,r2,255
21089e5c:	103ff01e 	bne	r2,zero,21089e20 <__flash_rwdata_start+0xfffe7bd8>
            SDA_HIGH(data_base);
        }else{
            SDA_LOW(data_base);
21089e60:	a0000035 	stwio	zero,0(r20)
21089e64:	003fef06 	br	21089e24 <__flash_rwdata_start+0xfffe7bdc>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }

    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
21089e68:	b0000035 	stwio	zero,0(r22)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
21089e6c:	8dc00035 	stwio	r23,0(r17)
    SCL_DELAY;  // clock high delay
21089e70:	b809883a 	mov	r4,r23
21089e74:	109b8500 	call	2109b850 <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
21089e78:	a4000037 	ldwio	r16,0(r20)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low
21089e7c:	88000035 	stwio	zero,0(r17)
    SCL_DELAY; // clock low delay
21089e80:	b809883a 	mov	r4,r23
21089e84:	109b8500 	call	2109b850 <usleep>
    return bAck;
}
21089e88:	8005003a 	cmpeq	r2,r16,zero
21089e8c:	dfc00817 	ldw	ra,32(sp)
21089e90:	ddc00717 	ldw	r23,28(sp)
21089e94:	dd800617 	ldw	r22,24(sp)
21089e98:	dd400517 	ldw	r21,20(sp)
21089e9c:	dd000417 	ldw	r20,16(sp)
21089ea0:	dcc00317 	ldw	r19,12(sp)
21089ea4:	dc800217 	ldw	r18,8(sp)
21089ea8:	dc400117 	ldw	r17,4(sp)
21089eac:	dc000017 	ldw	r16,0(sp)
21089eb0:	dec00904 	addi	sp,sp,36
21089eb4:	f800283a 	ret

21089eb8 <i2c_read>:

void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck){ // return true if device response ack
21089eb8:	defff604 	addi	sp,sp,-40
21089ebc:	df000815 	stw	fp,32(sp)
21089ec0:	ddc00715 	stw	r23,28(sp)
21089ec4:	dd800615 	stw	r22,24(sp)
21089ec8:	dd000415 	stw	r20,16(sp)
21089ecc:	dc800215 	stw	r18,8(sp)
21089ed0:	dfc00915 	stw	ra,36(sp)
21089ed4:	dd400515 	stw	r21,20(sp)
21089ed8:	dcc00315 	stw	r19,12(sp)
21089edc:	dc400115 	stw	r17,4(sp)
21089ee0:	dc000015 	stw	r16,0(sp)
21089ee4:	2829883a 	mov	r20,r5
21089ee8:	2025883a 	mov	r18,r4
21089eec:	302f883a 	mov	r23,r6
21089ef0:	3839883a 	mov	fp,r7
    alt_u8 Data=0;
    int i;

    // assume SCL = low

    SDA_DIR_IN(data_base);  // set data read mode
21089ef4:	2d800104 	addi	r22,r5,4
21089ef8:	b0000035 	stwio	zero,0(r22)
    SCL_LOW(clk_base); // clock low
21089efc:	20000035 	stwio	zero,0(r4)
    SCL_DELAY; // clock low delay
21089f00:	01000044 	movi	r4,1
21089f04:	109b8500 	call	2109b850 <usleep>
21089f08:	04400204 	movi	r17,8
    SCL_DELAY; // clock low delay
    return bAck;
}

void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck){ // return true if device response ack
    alt_u8 Data=0;
21089f0c:	0021883a 	mov	r16,zero
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
        Data <<= 1;
        SCL_HIGH(clk_base);  // clock high
21089f10:	05400044 	movi	r21,1
    SDA_DIR_IN(data_base);  // set data read mode
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
        Data <<= 1;
21089f14:	8427883a 	add	r19,r16,r16
21089f18:	9821883a 	mov	r16,r19
        SCL_HIGH(clk_base);  // clock high
21089f1c:	95400035 	stwio	r21,0(r18)
        SCL_DELAY;
21089f20:	01000044 	movi	r4,1
21089f24:	109b8500 	call	2109b850 <usleep>
        if (SDA_READ(data_base))  // read data
21089f28:	a0800037 	ldwio	r2,0(r20)
21089f2c:	10000126 	beq	r2,zero,21089f34 <i2c_read+0x7c>
            Data |= 0x01;
21089f30:	9c000054 	ori	r16,r19,1
        SCL_LOW(clk_base);  // clock log
21089f34:	90000035 	stwio	zero,0(r18)
        SCL_DELAY;
21089f38:	04c00044 	movi	r19,1
21089f3c:	8c7fffc4 	addi	r17,r17,-1
21089f40:	9809883a 	mov	r4,r19
21089f44:	109b8500 	call	2109b850 <usleep>

    SDA_DIR_IN(data_base);  // set data read mode
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
21089f48:	883ff21e 	bne	r17,zero,21089f14 <__flash_rwdata_start+0xfffe7ccc>
        SCL_LOW(clk_base);  // clock log
        SCL_DELAY;
    }

    // send ACK
    SCL_LOW(clk_base);  // new, make sure data change at clk low
21089f4c:	90000035 	stwio	zero,0(r18)
    SDA_DIR_OUT(data_base);  // set data write mode
21089f50:	b4c00035 	stwio	r19,0(r22)
    if (bAck)
21089f54:	e000181e 	bne	fp,zero,21089fb8 <i2c_read+0x100>
        SDA_LOW(data_base);
    else
        SDA_HIGH(data_base);
21089f58:	a4c00035 	stwio	r19,0(r20)
    SCL_HIGH(clk_base); // clock high
21089f5c:	04400044 	movi	r17,1
21089f60:	94400035 	stwio	r17,0(r18)
    SCL_DELAY; // clock high  delay
21089f64:	8809883a 	mov	r4,r17
21089f68:	109b8500 	call	2109b850 <usleep>
    SCL_LOW(clk_base); // clock low
21089f6c:	90000035 	stwio	zero,0(r18)
    SCL_DELAY; // clock low delay
21089f70:	8809883a 	mov	r4,r17
21089f74:	109b8500 	call	2109b850 <usleep>
    SDA_LOW(data_base);  // data low
21089f78:	a0000035 	stwio	zero,0(r20)
    SCL_DELAY; // data low delay
21089f7c:	8809883a 	mov	r4,r17
21089f80:	109b8500 	call	2109b850 <usleep>
//    SDA_DIR_IN;  // set data read mode

    *pData = Data;
21089f84:	bc000005 	stb	r16,0(r23)
}
21089f88:	dfc00917 	ldw	ra,36(sp)
21089f8c:	df000817 	ldw	fp,32(sp)
21089f90:	ddc00717 	ldw	r23,28(sp)
21089f94:	dd800617 	ldw	r22,24(sp)
21089f98:	dd400517 	ldw	r21,20(sp)
21089f9c:	dd000417 	ldw	r20,16(sp)
21089fa0:	dcc00317 	ldw	r19,12(sp)
21089fa4:	dc800217 	ldw	r18,8(sp)
21089fa8:	dc400117 	ldw	r17,4(sp)
21089fac:	dc000017 	ldw	r16,0(sp)
21089fb0:	dec00a04 	addi	sp,sp,40
21089fb4:	f800283a 	ret

    // send ACK
    SCL_LOW(clk_base);  // new, make sure data change at clk low
    SDA_DIR_OUT(data_base);  // set data write mode
    if (bAck)
        SDA_LOW(data_base);
21089fb8:	a0000035 	stwio	zero,0(r20)
21089fbc:	003fe706 	br	21089f5c <__flash_rwdata_start+0xfffe7d14>

21089fc0 <timer_ISR>:
#define FRAME_RATE (10)

static void timer_ISR(void *context, alt_u32 id)
{
    // acknowledge the interrupt by clearing the TO bit in the status register
    IOWR(TIMER_1_BASE, 0, 0x0);
21089fc0:	00880034 	movhi	r2,8192
21089fc4:	10810004 	addi	r2,r2,1024
21089fc8:	10000035 	stwio	zero,0(r2)
    // switch frames
	if (ece423_video_display_switch_frames(state.p_display) != 0)
21089fcc:	00800034 	movhi	r2,0
21089fd0:	10987c04 	addi	r2,r2,25072
21089fd4:	11000017 	ldw	r4,0(r2)
21089fd8:	10856401 	jmpi	21085640 <ece423_video_display_switch_frames>

21089fdc <button_ISR>:
		 // printf("switch fail\n");
	}
}

static void button_ISR(void *context, alt_u32 id)
{
21089fdc:	defffe04 	addi	sp,sp,-8
21089fe0:	dc000015 	stw	r16,0(sp)
	// disable interrupts
	IOWR(KEY_BASE, 2, 0x0);
21089fe4:	04080034 	movhi	r16,8192
		 // printf("switch fail\n");
	}
}

static void button_ISR(void *context, alt_u32 id)
{
21089fe8:	dfc00115 	stw	ra,4(sp)
	// disable interrupts
	IOWR(KEY_BASE, 2, 0x0);
21089fec:	84015e04 	addi	r16,r16,1400
21089ff0:	0009883a 	mov	r4,zero
21089ff4:	81000035 	stwio	r4,0(r16)

    // get value from the edge capture register and mask off all bits except the 4 least significant
    is_pressed = IORD(KEY_BASE, 3) & 0xf;
21089ff8:	00c80034 	movhi	r3,8192
21089ffc:	18c15f04 	addi	r3,r3,1404
2108a000:	18800037 	ldwio	r2,0(r3)
2108a004:	108003cc 	andi	r2,r2,15
2108a008:	d0a01b05 	stb	r2,-32660(gp)

    // reset the edge capture register to clear the interrupt
    IOWR(KEY_BASE, 3, 0x0);
2108a00c:	19000035 	stwio	r4,0(r3)

    // ghetto debouncing
    usleep(1000);  // sleep for 1 ms
2108a010:	0100fa04 	movi	r4,1000
2108a014:	109b8500 	call	2109b850 <usleep>

    // re-enable interrupts
    IOWR(KEY_BASE, 2, 0xf);
2108a018:	008003c4 	movi	r2,15
2108a01c:	80800035 	stwio	r2,0(r16)
}
2108a020:	dfc00117 	ldw	ra,4(sp)
2108a024:	dc000017 	ldw	r16,0(sp)
2108a028:	dec00204 	addi	sp,sp,8
2108a02c:	f800283a 	ret

2108a030 <begin_file_browsing>:

static void begin_file_browsing()
{
	if (Fat_FileBrowseBegin(state.fs_handle, &state.fs_browse_handle) == FALSE)
2108a030:	01400034 	movhi	r5,0
2108a034:	29587c04 	addi	r5,r5,25072
2108a038:	29000217 	ldw	r4,8(r5)
    // re-enable interrupts
    IOWR(KEY_BASE, 2, 0xf);
}

static void begin_file_browsing()
{
2108a03c:	deffff04 	addi	sp,sp,-4
	if (Fat_FileBrowseBegin(state.fs_handle, &state.fs_browse_handle) == FALSE)
2108a040:	29400304 	addi	r5,r5,12
    // re-enable interrupts
    IOWR(KEY_BASE, 2, 0xf);
}

static void begin_file_browsing()
{
2108a044:	dfc00015 	stw	ra,0(sp)
	if (Fat_FileBrowseBegin(state.fs_handle, &state.fs_browse_handle) == FALSE)
2108a048:	1081c200 	call	21081c20 <Fat_FileBrowseBegin>
2108a04c:	10000326 	beq	r2,zero,2108a05c <begin_file_browsing+0x2c>
	{
		error_and_exit("could not browse file system");
	}
}
2108a050:	dfc00017 	ldw	ra,0(sp)
2108a054:	dec00104 	addi	sp,sp,4
2108a058:	f800283a 	ret

static void begin_file_browsing()
{
	if (Fat_FileBrowseBegin(state.fs_handle, &state.fs_browse_handle) == FALSE)
	{
		error_and_exit("could not browse file system");
2108a05c:	01000034 	movhi	r4,0
2108a060:	210e5004 	addi	r4,r4,14656
	}
}
2108a064:	dfc00017 	ldw	ra,0(sp)
2108a068:	dec00104 	addi	sp,sp,4

static void begin_file_browsing()
{
	if (Fat_FileBrowseBegin(state.fs_handle, &state.fs_browse_handle) == FALSE)
	{
		error_and_exit("could not browse file system");
2108a06c:	10801dc1 	jmpi	210801dc <error_and_exit>

2108a070 <get_next_mpeg_filename>:
	}
}

static char *get_next_mpeg_filename()
{
2108a070:	deffb404 	addi	sp,sp,-304
2108a074:	dc004a15 	stw	r16,296(sp)
2108a078:	dfc04b15 	stw	ra,300(sp)
		if (Fat_FileBrowseNext(&state.fs_browse_handle, &f_context) == FALSE)
		{
			begin_file_browsing(&state);
			Fat_FileBrowseNext(&state.fs_browse_handle, &f_context);  // or else last file is selected twice
		}
	} while (Fat_CheckExtension(&f_context, MPEG_EXTENSION) != TRUE);
2108a07c:	04000044 	movi	r16,1
2108a080:	00000506 	br	2108a098 <get_next_mpeg_filename+0x28>
2108a084:	01400034 	movhi	r5,0
2108a088:	294e5804 	addi	r5,r5,14688
2108a08c:	d809883a 	mov	r4,sp
2108a090:	10824440 	call	21082444 <Fat_CheckExtension>
2108a094:	14000d26 	beq	r2,r16,2108a0cc <get_next_mpeg_filename+0x5c>
{
	FILE_CONTEXT f_context;

	do
	{
		if (Fat_FileBrowseNext(&state.fs_browse_handle, &f_context) == FALSE)
2108a098:	01000034 	movhi	r4,0
2108a09c:	21187f04 	addi	r4,r4,25084
2108a0a0:	d80b883a 	mov	r5,sp
2108a0a4:	1081c480 	call	21081c48 <Fat_FileBrowseNext>
2108a0a8:	103ff61e 	bne	r2,zero,2108a084 <__flash_rwdata_start+0xfffe7e3c>
		{
			begin_file_browsing(&state);
2108a0ac:	01000034 	movhi	r4,0
2108a0b0:	21187c04 	addi	r4,r4,25072
2108a0b4:	108a0300 	call	2108a030 <begin_file_browsing>
			Fat_FileBrowseNext(&state.fs_browse_handle, &f_context);  // or else last file is selected twice
2108a0b8:	01000034 	movhi	r4,0
2108a0bc:	21187f04 	addi	r4,r4,25084
2108a0c0:	d80b883a 	mov	r5,sp
2108a0c4:	1081c480 	call	21081c48 <Fat_FileBrowseNext>
2108a0c8:	003fee06 	br	2108a084 <__flash_rwdata_start+0xfffe7e3c>
		}
	} while (Fat_CheckExtension(&f_context, MPEG_EXTENSION) != TRUE);

	return Fat_GetFileName(&f_context);
2108a0cc:	d809883a 	mov	r4,sp
2108a0d0:	10824a00 	call	210824a0 <Fat_GetFileName>
}
2108a0d4:	dfc04b17 	ldw	ra,300(sp)
2108a0d8:	dc004a17 	ldw	r16,296(sp)
2108a0dc:	dec04c04 	addi	sp,sp,304
2108a0e0:	f800283a 	ret

2108a0e4 <main>:
}


int main()
{
	printf("Hi, I'm CPU 0 :)\n");
2108a0e4:	01000034 	movhi	r4,0
    return;
}


int main()
{
2108a0e8:	deffba04 	addi	sp,sp,-280
	printf("Hi, I'm CPU 0 :)\n");
2108a0ec:	210e5a04 	addi	r4,r4,14696
    return;
}


int main()
{
2108a0f0:	dfc04515 	stw	ra,276(sp)
2108a0f4:	dcc04315 	stw	r19,268(sp)
2108a0f8:	dd004415 	stw	r20,272(sp)
2108a0fc:	dc804215 	stw	r18,264(sp)
2108a100:	dc404115 	stw	r17,260(sp)
2108a104:	dc004015 	stw	r16,256(sp)
	printf("Hi, I'm CPU 0 :)\n");
2108a108:	108e4c00 	call	2108e4c0 <puts>
{
	alt_u32 timerPeriod = TIMER_1_FREQ / FRAME_RATE;
	is_pressed = NONE_PRESSED;

	// display initialization
	state.p_display = ece423_video_display_init(VIDEO_DMA_CSR_NAME, WIDTH, HEIGHT, 36);
2108a10c:	01000034 	movhi	r4,0
2108a110:	01c00904 	movi	r7,36
2108a114:	210e5f04 	addi	r4,r4,14716
2108a118:	0140a004 	movi	r5,640
2108a11c:	01807804 	movi	r6,480
}

static void setup()
{
	alt_u32 timerPeriod = TIMER_1_FREQ / FRAME_RATE;
	is_pressed = NONE_PRESSED;
2108a120:	008003c4 	movi	r2,15
2108a124:	d0a01b05 	stb	r2,-32660(gp)

	// display initialization
	state.p_display = ece423_video_display_init(VIDEO_DMA_CSR_NAME, WIDTH, HEIGHT, 36);
2108a128:	10885fc0 	call	210885fc <ece423_video_display_init>
2108a12c:	04c00034 	movhi	r19,0

    // enable button interrupts
	alt_irq_register(KEY_IRQ, (void*)0, button_ISR);  // setup the interrupt vector
2108a130:	01884274 	movhi	r6,8457
{
	alt_u32 timerPeriod = TIMER_1_FREQ / FRAME_RATE;
	is_pressed = NONE_PRESSED;

	// display initialization
	state.p_display = ece423_video_display_init(VIDEO_DMA_CSR_NAME, WIDTH, HEIGHT, 36);
2108a134:	9cd87c04 	addi	r19,r19,25072

    // enable button interrupts
	alt_irq_register(KEY_IRQ, (void*)0, button_ISR);  // setup the interrupt vector
2108a138:	31a7f704 	addi	r6,r6,-24612
2108a13c:	01000084 	movi	r4,2
2108a140:	000b883a 	mov	r5,zero
{
	alt_u32 timerPeriod = TIMER_1_FREQ / FRAME_RATE;
	is_pressed = NONE_PRESSED;

	// display initialization
	state.p_display = ece423_video_display_init(VIDEO_DMA_CSR_NAME, WIDTH, HEIGHT, 36);
2108a144:	98800015 	stw	r2,0(r19)

    // enable button interrupts
	alt_irq_register(KEY_IRQ, (void*)0, button_ISR);  // setup the interrupt vector
2108a148:	109b2540 	call	2109b254 <alt_irq_register>
	IOWR(KEY_BASE, 3, 0x0);  // reset the edge capture register by writing to it (any value will do)
2108a14c:	00880034 	movhi	r2,8192
2108a150:	10815f04 	addi	r2,r2,1404
2108a154:	10000035 	stwio	zero,0(r2)
	IOWR(KEY_BASE, 2, 0xf);  // enable interrupts for all four buttons
2108a158:	00880034 	movhi	r2,8192
2108a15c:	10815e04 	addi	r2,r2,1400
2108a160:	00c003c4 	movi	r3,15
2108a164:	10c00035 	stwio	r3,0(r2)

	// enable timer interrupt
	IOWR(TIMER_1_BASE, 2, (alt_u16)timerPeriod);
2108a168:	00880034 	movhi	r2,8192
2108a16c:	10810204 	addi	r2,r2,1032
2108a170:	00ef0814 	movui	r3,48160
2108a174:	10c00035 	stwio	r3,0(r2)
	IOWR(TIMER_1_BASE, 3, (alt_u16)(timerPeriod >> 16));
2108a178:	00880034 	movhi	r2,8192
2108a17c:	10810304 	addi	r2,r2,1036
2108a180:	00c02f84 	movi	r3,190
2108a184:	10c00035 	stwio	r3,0(r2)

	alt_irq_register(TIMER_1_IRQ, (void *)0, timer_ISR);
2108a188:	01884274 	movhi	r6,8457
2108a18c:	31a7f004 	addi	r6,r6,-24640
2108a190:	01000104 	movi	r4,4
2108a194:	000b883a 	mov	r5,zero
2108a198:	109b2540 	call	2109b254 <alt_irq_register>
	IOWR(TIMER_1_BASE, 0, 0x0);
2108a19c:	00880034 	movhi	r2,8192
2108a1a0:	10810004 	addi	r2,r2,1024
2108a1a4:	10000035 	stwio	zero,0(r2)
	IOWR(TIMER_1_BASE, 1, 0x7);  // initialize timer control - start timer, run continuously, enable interrupts
2108a1a8:	00880034 	movhi	r2,8192
2108a1ac:	10810104 	addi	r2,r2,1028
2108a1b0:	00c001c4 	movi	r3,7
2108a1b4:	10c00035 	stwio	r3,0(r2)

	// initialize DMA
	state.read_dma_y = alt_msgdma_open(READ_DMA_Y_CSR_NAME);
2108a1b8:	01000034 	movhi	r4,0
2108a1bc:	210e6404 	addi	r4,r4,14736
2108a1c0:	109cff40 	call	2109cff4 <alt_msgdma_open>
	state.write_dma = alt_msgdma_open(WRITE_DMA_CSR_NAME);
2108a1c4:	01000034 	movhi	r4,0
2108a1c8:	210e6904 	addi	r4,r4,14756
	alt_irq_register(TIMER_1_IRQ, (void *)0, timer_ISR);
	IOWR(TIMER_1_BASE, 0, 0x0);
	IOWR(TIMER_1_BASE, 1, 0x7);  // initialize timer control - start timer, run continuously, enable interrupts

	// initialize DMA
	state.read_dma_y = alt_msgdma_open(READ_DMA_Y_CSR_NAME);
2108a1cc:	98800515 	stw	r2,20(r19)
	state.write_dma = alt_msgdma_open(WRITE_DMA_CSR_NAME);
2108a1d0:	109cff40 	call	2109cff4 <alt_msgdma_open>
2108a1d4:	98800615 	stw	r2,24(r19)

	if (state.read_dma_y == NULL || state.write_dma == NULL)
2108a1d8:	98800517 	ldw	r2,20(r19)
2108a1dc:	10004626 	beq	r2,zero,2108a2f8 <main+0x214>
2108a1e0:	98800617 	ldw	r2,24(r19)
2108a1e4:	10004426 	beq	r2,zero,2108a2f8 <main+0x214>
	{
		fprintf(stderr, "ERROR: Could not open DMA.\n");
	}

	// filesystem initialization
	state.fs_handle = Fat_Mount();
2108a1e8:	1081b7c0 	call	21081b7c <Fat_Mount>
	begin_file_browsing(&state);
2108a1ec:	01000034 	movhi	r4,0
2108a1f0:	21187c04 	addi	r4,r4,25072
	{
		fprintf(stderr, "ERROR: Could not open DMA.\n");
	}

	// filesystem initialization
	state.fs_handle = Fat_Mount();
2108a1f4:	98800215 	stw	r2,8(r19)
	begin_file_browsing(&state);
2108a1f8:	108a0300 	call	2108a030 <begin_file_browsing>
static void loop()
{
	// there's a memset to 0 of 256 bytes somewhere in Fat_FileOpen
	// so we need to pass in something of the same size
	char *p_filename;
	char filename[256] = {0};
2108a1fc:	01804004 	movi	r6,256
2108a200:	000b883a 	mov	r5,zero
2108a204:	d809883a 	mov	r4,sp

	p_filename = get_next_mpeg_filename(&state);
2108a208:	04400034 	movhi	r17,0
static void loop()
{
	// there's a memset to 0 of 256 bytes somewhere in Fat_FileOpen
	// so we need to pass in something of the same size
	char *p_filename;
	char filename[256] = {0};
2108a20c:	108e26c0 	call	2108e26c <memset>

	p_filename = get_next_mpeg_filename(&state);
2108a210:	8c587c04 	addi	r17,r17,25072
2108a214:	8809883a 	mov	r4,r17
2108a218:	108a0700 	call	2108a070 <get_next_mpeg_filename>
	strcpy(filename, p_filename);
2108a21c:	d809883a 	mov	r4,sp
2108a220:	100b883a 	mov	r5,r2
2108a224:	108e6900 	call	2108e690 <strcpy>

	printf("filename is: %s\n", filename);
2108a228:	01000034 	movhi	r4,0
2108a22c:	210e7504 	addi	r4,r4,14804
2108a230:	d80b883a 	mov	r5,sp

	while (TRUE)
	{
	    while (is_pressed == NONE_PRESSED) {};
2108a234:	040003c4 	movi	r16,15

	    switch(is_pressed)
2108a238:	04800044 	movi	r18,1
2108a23c:	05000084 	movi	r20,2
	char filename[256] = {0};

	p_filename = get_next_mpeg_filename(&state);
	strcpy(filename, p_filename);

	printf("filename is: %s\n", filename);
2108a240:	108e3bc0 	call	2108e3bc <printf>

	while (TRUE)
	{
	    while (is_pressed == NONE_PRESSED) {};
2108a244:	d0a01b03 	ldbu	r2,-32660(gp)
2108a248:	10803fcc 	andi	r2,r2,255
2108a24c:	143ffd26 	beq	r2,r16,2108a244 <__flash_rwdata_start+0xfffe7ffc>

	    switch(is_pressed)
2108a250:	d0a01b03 	ldbu	r2,-32660(gp)
2108a254:	10803fcc 	andi	r2,r2,255
2108a258:	14800e26 	beq	r2,r18,2108a294 <main+0x1b0>
2108a25c:	15000a1e 	bne	r2,r20,2108a288 <main+0x1a4>
	    		break;
	    	}
	    	// Skip to next file
	    	case BUTTON_1:
	    	{
	    		p_filename = get_next_mpeg_filename(&state);
2108a260:	01000034 	movhi	r4,0
2108a264:	21187c04 	addi	r4,r4,25072
2108a268:	108a0700 	call	2108a070 <get_next_mpeg_filename>
	    		strcpy(filename, p_filename);
2108a26c:	d809883a 	mov	r4,sp
2108a270:	100b883a 	mov	r5,r2
2108a274:	108e6900 	call	2108e690 <strcpy>

	    	    printf("\nNext file: %s\n", filename);
2108a278:	01000034 	movhi	r4,0
2108a27c:	210e8504 	addi	r4,r4,14868
2108a280:	d80b883a 	mov	r5,sp
2108a284:	108e3bc0 	call	2108e3bc <printf>
	    	{
	    		break;
	    	}
	    }

	    is_pressed = NONE_PRESSED;
2108a288:	008003c4 	movi	r2,15
2108a28c:	d0a01b05 	stb	r2,-32660(gp)
2108a290:	003fec06 	br	2108a244 <__flash_rwdata_start+0xfffe7ffc>
	    switch(is_pressed)
	    {
	    	// Play current file
	    	case BUTTON_0:
	    	{
				printf("Play\n");
2108a294:	01000034 	movhi	r4,0
2108a298:	210e7a04 	addi	r4,r4,14824
2108a29c:	108e4c00 	call	2108e4c0 <puts>

	    		// Decode the video
				if((state.file_handle = Fat_FileOpen(state.fs_handle, filename)) == 0)
2108a2a0:	99000217 	ldw	r4,8(r19)
2108a2a4:	d80b883a 	mov	r5,sp
2108a2a8:	10825640 	call	21082564 <Fat_FileOpen>
2108a2ac:	98800115 	stw	r2,4(r19)
2108a2b0:	10000b26 	beq	r2,zero,2108a2e0 <main+0x1fc>
				{
					printf("cannot open file: %s\n", filename);
					exit(-1);
				}
				mjpeg423_decode(state.file_handle, state.p_display, state.read_dma_y, state.write_dma);
2108a2b4:	89000117 	ldw	r4,4(r17)
2108a2b8:	89400017 	ldw	r5,0(r17)
2108a2bc:	89800517 	ldw	r6,20(r17)
2108a2c0:	89c00617 	ldw	r7,24(r17)
2108a2c4:	10810dc0 	call	210810dc <mjpeg423_decode>
	    		Fat_FileClose(state.file_handle);
2108a2c8:	89000117 	ldw	r4,4(r17)
2108a2cc:	1082aa80 	call	21082aa8 <Fat_FileClose>
	    		printf("File End\n");
2108a2d0:	01000034 	movhi	r4,0
2108a2d4:	210e8204 	addi	r4,r4,14856
2108a2d8:	108e4c00 	call	2108e4c0 <puts>
2108a2dc:	003fea06 	br	2108a288 <__flash_rwdata_start+0xfffe8040>
				printf("Play\n");

	    		// Decode the video
				if((state.file_handle = Fat_FileOpen(state.fs_handle, filename)) == 0)
				{
					printf("cannot open file: %s\n", filename);
2108a2e0:	01000034 	movhi	r4,0
2108a2e4:	210e7c04 	addi	r4,r4,14832
2108a2e8:	d80b883a 	mov	r5,sp
2108a2ec:	108e3bc0 	call	2108e3bc <printf>
					exit(-1);
2108a2f0:	013fffc4 	movi	r4,-1
2108a2f4:	108d5880 	call	2108d588 <exit>
	state.read_dma_y = alt_msgdma_open(READ_DMA_Y_CSR_NAME);
	state.write_dma = alt_msgdma_open(WRITE_DMA_CSR_NAME);

	if (state.read_dma_y == NULL || state.write_dma == NULL)
	{
		fprintf(stderr, "ERROR: Could not open DMA.\n");
2108a2f8:	00800034 	movhi	r2,0
2108a2fc:	10976b04 	addi	r2,r2,23980
2108a300:	10800017 	ldw	r2,0(r2)
2108a304:	01000034 	movhi	r4,0
2108a308:	210e6e04 	addi	r4,r4,14776
2108a30c:	11c00317 	ldw	r7,12(r2)
2108a310:	01400044 	movi	r5,1
2108a314:	018006c4 	movi	r6,27
2108a318:	108d6d80 	call	2108d6d8 <fwrite>
2108a31c:	003fb206 	br	2108a1e8 <__flash_rwdata_start+0xfffe7fa0>

2108a320 <__fixunsdfsi>:
2108a320:	defffd04 	addi	sp,sp,-12
2108a324:	000d883a 	mov	r6,zero
2108a328:	01d07834 	movhi	r7,16864
2108a32c:	dc400115 	stw	r17,4(sp)
2108a330:	dc000015 	stw	r16,0(sp)
2108a334:	dfc00215 	stw	ra,8(sp)
2108a338:	2023883a 	mov	r17,r4
2108a33c:	2821883a 	mov	r16,r5
2108a340:	108be800 	call	2108be80 <__gedf2>
2108a344:	1000080e 	bge	r2,zero,2108a368 <__fixunsdfsi+0x48>
2108a348:	8809883a 	mov	r4,r17
2108a34c:	800b883a 	mov	r5,r16
2108a350:	108cf540 	call	2108cf54 <__fixdfsi>
2108a354:	dfc00217 	ldw	ra,8(sp)
2108a358:	dc400117 	ldw	r17,4(sp)
2108a35c:	dc000017 	ldw	r16,0(sp)
2108a360:	dec00304 	addi	sp,sp,12
2108a364:	f800283a 	ret
2108a368:	000d883a 	mov	r6,zero
2108a36c:	01d07834 	movhi	r7,16864
2108a370:	8809883a 	mov	r4,r17
2108a374:	800b883a 	mov	r5,r16
2108a378:	108c6840 	call	2108c684 <__subdf3>
2108a37c:	180b883a 	mov	r5,r3
2108a380:	1009883a 	mov	r4,r2
2108a384:	108cf540 	call	2108cf54 <__fixdfsi>
2108a388:	00e00034 	movhi	r3,32768
2108a38c:	10c5883a 	add	r2,r2,r3
2108a390:	003ff006 	br	2108a354 <__flash_rwdata_start+0xfffe810c>

2108a394 <__divsf3>:
2108a394:	defff504 	addi	sp,sp,-44
2108a398:	dd000515 	stw	r20,20(sp)
2108a39c:	2028d5fa 	srli	r20,r4,23
2108a3a0:	dd400615 	stw	r21,24(sp)
2108a3a4:	202ad7fa 	srli	r21,r4,31
2108a3a8:	00c02034 	movhi	r3,128
2108a3ac:	dcc00415 	stw	r19,16(sp)
2108a3b0:	dc800315 	stw	r18,12(sp)
2108a3b4:	18ffffc4 	addi	r3,r3,-1
2108a3b8:	dfc00a15 	stw	ra,40(sp)
2108a3bc:	df000915 	stw	fp,36(sp)
2108a3c0:	ddc00815 	stw	r23,32(sp)
2108a3c4:	dd800715 	stw	r22,28(sp)
2108a3c8:	dc400215 	stw	r17,8(sp)
2108a3cc:	dc000115 	stw	r16,4(sp)
2108a3d0:	a5003fcc 	andi	r20,r20,255
2108a3d4:	1924703a 	and	r18,r3,r4
2108a3d8:	acc03fcc 	andi	r19,r21,255
2108a3dc:	a0004d26 	beq	r20,zero,2108a514 <__divsf3+0x180>
2108a3e0:	00803fc4 	movi	r2,255
2108a3e4:	a0802e26 	beq	r20,r2,2108a4a0 <__divsf3+0x10c>
2108a3e8:	91002034 	orhi	r4,r18,128
2108a3ec:	202490fa 	slli	r18,r4,3
2108a3f0:	a53fe044 	addi	r20,r20,-127
2108a3f4:	0021883a 	mov	r16,zero
2108a3f8:	002f883a 	mov	r23,zero
2108a3fc:	2804d5fa 	srli	r2,r5,23
2108a400:	282cd7fa 	srli	r22,r5,31
2108a404:	00c02034 	movhi	r3,128
2108a408:	18ffffc4 	addi	r3,r3,-1
2108a40c:	10803fcc 	andi	r2,r2,255
2108a410:	1962703a 	and	r17,r3,r5
2108a414:	b7003fcc 	andi	fp,r22,255
2108a418:	10004526 	beq	r2,zero,2108a530 <__divsf3+0x19c>
2108a41c:	00c03fc4 	movi	r3,255
2108a420:	10c04026 	beq	r2,r3,2108a524 <__divsf3+0x190>
2108a424:	88c02034 	orhi	r3,r17,128
2108a428:	182290fa 	slli	r17,r3,3
2108a42c:	10bfe044 	addi	r2,r2,-127
2108a430:	0009883a 	mov	r4,zero
2108a434:	2420b03a 	or	r16,r4,r16
2108a438:	802090ba 	slli	r16,r16,2
2108a43c:	01c84274 	movhi	r7,8457
2108a440:	39e91804 	addi	r7,r7,-23456
2108a444:	81e1883a 	add	r16,r16,r7
2108a448:	80c00017 	ldw	r3,0(r16)
2108a44c:	ad8af03a 	xor	r5,r21,r22
2108a450:	280d883a 	mov	r6,r5
2108a454:	a085c83a 	sub	r2,r20,r2
2108a458:	29403fcc 	andi	r5,r5,255
2108a45c:	1800683a 	jmp	r3
2108a460:	2108a66c 	andhi	r4,r4,8857
2108a464:	2108a614 	ori	r4,r4,8856
2108a468:	2108a638 	rdprs	r4,r4,8856
2108a46c:	2108a600 	call	22108a60 <__flash_rwdata_start+0x1066818>
2108a470:	2108a638 	rdprs	r4,r4,8856
2108a474:	2108a4b0 	cmpltui	r4,r4,8850
2108a478:	2108a638 	rdprs	r4,r4,8856
2108a47c:	2108a600 	call	22108a60 <__flash_rwdata_start+0x1066818>
2108a480:	2108a614 	ori	r4,r4,8856
2108a484:	2108a614 	ori	r4,r4,8856
2108a488:	2108a4b0 	cmpltui	r4,r4,8850
2108a48c:	2108a600 	call	22108a60 <__flash_rwdata_start+0x1066818>
2108a490:	2108a704 	addi	r4,r4,8860
2108a494:	2108a704 	addi	r4,r4,8860
2108a498:	2108a704 	addi	r4,r4,8860
2108a49c:	2108a644 	addi	r4,r4,8857
2108a4a0:	9000531e 	bne	r18,zero,2108a5f0 <__divsf3+0x25c>
2108a4a4:	04000204 	movi	r16,8
2108a4a8:	05c00084 	movi	r23,2
2108a4ac:	003fd306 	br	2108a3fc <__flash_rwdata_start+0xfffe81b4>
2108a4b0:	00c02034 	movhi	r3,128
2108a4b4:	000d883a 	mov	r6,zero
2108a4b8:	18ffffc4 	addi	r3,r3,-1
2108a4bc:	013fffc4 	movi	r4,-1
2108a4c0:	21003fcc 	andi	r4,r4,255
2108a4c4:	200895fa 	slli	r4,r4,23
2108a4c8:	30803fcc 	andi	r2,r6,255
2108a4cc:	01802034 	movhi	r6,128
2108a4d0:	31bfffc4 	addi	r6,r6,-1
2108a4d4:	100497fa 	slli	r2,r2,31
2108a4d8:	1986703a 	and	r3,r3,r6
2108a4dc:	1906b03a 	or	r3,r3,r4
2108a4e0:	1884b03a 	or	r2,r3,r2
2108a4e4:	dfc00a17 	ldw	ra,40(sp)
2108a4e8:	df000917 	ldw	fp,36(sp)
2108a4ec:	ddc00817 	ldw	r23,32(sp)
2108a4f0:	dd800717 	ldw	r22,28(sp)
2108a4f4:	dd400617 	ldw	r21,24(sp)
2108a4f8:	dd000517 	ldw	r20,20(sp)
2108a4fc:	dcc00417 	ldw	r19,16(sp)
2108a500:	dc800317 	ldw	r18,12(sp)
2108a504:	dc400217 	ldw	r17,8(sp)
2108a508:	dc000117 	ldw	r16,4(sp)
2108a50c:	dec00b04 	addi	sp,sp,44
2108a510:	f800283a 	ret
2108a514:	90002b1e 	bne	r18,zero,2108a5c4 <__divsf3+0x230>
2108a518:	04000104 	movi	r16,4
2108a51c:	05c00044 	movi	r23,1
2108a520:	003fb606 	br	2108a3fc <__flash_rwdata_start+0xfffe81b4>
2108a524:	8800251e 	bne	r17,zero,2108a5bc <__divsf3+0x228>
2108a528:	01000084 	movi	r4,2
2108a52c:	00000206 	br	2108a538 <__divsf3+0x1a4>
2108a530:	88001a1e 	bne	r17,zero,2108a59c <__divsf3+0x208>
2108a534:	01000044 	movi	r4,1
2108a538:	2420b03a 	or	r16,r4,r16
2108a53c:	802090ba 	slli	r16,r16,2
2108a540:	00c84274 	movhi	r3,8457
2108a544:	18e95704 	addi	r3,r3,-23204
2108a548:	80e1883a 	add	r16,r16,r3
2108a54c:	80c00017 	ldw	r3,0(r16)
2108a550:	ad8af03a 	xor	r5,r21,r22
2108a554:	a085c83a 	sub	r2,r20,r2
2108a558:	1800683a 	jmp	r3
2108a55c:	2108a614 	ori	r4,r4,8856
2108a560:	2108a614 	ori	r4,r4,8856
2108a564:	2108a764 	muli	r4,r4,8861
2108a568:	2108a5fc 	xorhi	r4,r4,8855
2108a56c:	2108a764 	muli	r4,r4,8861
2108a570:	2108a4b0 	cmpltui	r4,r4,8850
2108a574:	2108a764 	muli	r4,r4,8861
2108a578:	2108a5fc 	xorhi	r4,r4,8855
2108a57c:	2108a614 	ori	r4,r4,8856
2108a580:	2108a614 	ori	r4,r4,8856
2108a584:	2108a4b0 	cmpltui	r4,r4,8850
2108a588:	2108a5fc 	xorhi	r4,r4,8855
2108a58c:	2108a704 	addi	r4,r4,8860
2108a590:	2108a704 	addi	r4,r4,8860
2108a594:	2108a704 	addi	r4,r4,8860
2108a598:	2108a730 	cmpltui	r4,r4,8860
2108a59c:	8809883a 	mov	r4,r17
2108a5a0:	108d3f80 	call	2108d3f8 <__clzsi2>
2108a5a4:	10fffec4 	addi	r3,r2,-5
2108a5a8:	88e2983a 	sll	r17,r17,r3
2108a5ac:	00ffe284 	movi	r3,-118
2108a5b0:	1885c83a 	sub	r2,r3,r2
2108a5b4:	0009883a 	mov	r4,zero
2108a5b8:	003f9e06 	br	2108a434 <__flash_rwdata_start+0xfffe81ec>
2108a5bc:	010000c4 	movi	r4,3
2108a5c0:	003f9c06 	br	2108a434 <__flash_rwdata_start+0xfffe81ec>
2108a5c4:	9009883a 	mov	r4,r18
2108a5c8:	d9400015 	stw	r5,0(sp)
2108a5cc:	108d3f80 	call	2108d3f8 <__clzsi2>
2108a5d0:	10fffec4 	addi	r3,r2,-5
2108a5d4:	053fe284 	movi	r20,-118
2108a5d8:	90e4983a 	sll	r18,r18,r3
2108a5dc:	a0a9c83a 	sub	r20,r20,r2
2108a5e0:	0021883a 	mov	r16,zero
2108a5e4:	002f883a 	mov	r23,zero
2108a5e8:	d9400017 	ldw	r5,0(sp)
2108a5ec:	003f8306 	br	2108a3fc <__flash_rwdata_start+0xfffe81b4>
2108a5f0:	04000304 	movi	r16,12
2108a5f4:	05c000c4 	movi	r23,3
2108a5f8:	003f8006 	br	2108a3fc <__flash_rwdata_start+0xfffe81b4>
2108a5fc:	0023883a 	mov	r17,zero
2108a600:	e027883a 	mov	r19,fp
2108a604:	202f883a 	mov	r23,r4
2108a608:	00c00084 	movi	r3,2
2108a60c:	980b883a 	mov	r5,r19
2108a610:	b8c0501e 	bne	r23,r3,2108a754 <__divsf3+0x3c0>
2108a614:	2980004c 	andi	r6,r5,1
2108a618:	013fffc4 	movi	r4,-1
2108a61c:	0007883a 	mov	r3,zero
2108a620:	003fa706 	br	2108a4c0 <__flash_rwdata_start+0xfffe8278>
2108a624:	013fe084 	movi	r4,-126
2108a628:	2089c83a 	sub	r4,r4,r2
2108a62c:	00c006c4 	movi	r3,27
2108a630:	1900500e 	bge	r3,r4,2108a774 <__divsf3+0x3e0>
2108a634:	9980004c 	andi	r6,r19,1
2108a638:	0009883a 	mov	r4,zero
2108a63c:	0007883a 	mov	r3,zero
2108a640:	003f9f06 	br	2108a4c0 <__flash_rwdata_start+0xfffe8278>
2108a644:	9080102c 	andhi	r2,r18,64
2108a648:	10000226 	beq	r2,zero,2108a654 <__divsf3+0x2c0>
2108a64c:	8880102c 	andhi	r2,r17,64
2108a650:	10003a26 	beq	r2,zero,2108a73c <__divsf3+0x3a8>
2108a654:	00802034 	movhi	r2,128
2108a658:	90c01034 	orhi	r3,r18,64
2108a65c:	10bfffc4 	addi	r2,r2,-1
2108a660:	a80d883a 	mov	r6,r21
2108a664:	1886703a 	and	r3,r3,r2
2108a668:	003f9406 	br	2108a4bc <__flash_rwdata_start+0xfffe8274>
2108a66c:	9006917a 	slli	r3,r18,5
2108a670:	8822917a 	slli	r17,r17,5
2108a674:	1c402936 	bltu	r3,r17,2108a71c <__divsf3+0x388>
2108a678:	1c47c83a 	sub	r3,r3,r17
2108a67c:	2827883a 	mov	r19,r5
2108a680:	01800684 	movi	r6,26
2108a684:	01000044 	movi	r4,1
2108a688:	180f883a 	mov	r7,r3
2108a68c:	2109883a 	add	r4,r4,r4
2108a690:	18c7883a 	add	r3,r3,r3
2108a694:	38000116 	blt	r7,zero,2108a69c <__divsf3+0x308>
2108a698:	1c400236 	bltu	r3,r17,2108a6a4 <__divsf3+0x310>
2108a69c:	1c47c83a 	sub	r3,r3,r17
2108a6a0:	21000054 	ori	r4,r4,1
2108a6a4:	31bfffc4 	addi	r6,r6,-1
2108a6a8:	303ff71e 	bne	r6,zero,2108a688 <__flash_rwdata_start+0xfffe8440>
2108a6ac:	1806c03a 	cmpne	r3,r3,zero
2108a6b0:	1922b03a 	or	r17,r3,r4
2108a6b4:	11001fc4 	addi	r4,r2,127
2108a6b8:	013fda0e 	bge	zero,r4,2108a624 <__flash_rwdata_start+0xfffe83dc>
2108a6bc:	88c001cc 	andi	r3,r17,7
2108a6c0:	18000426 	beq	r3,zero,2108a6d4 <__divsf3+0x340>
2108a6c4:	894003cc 	andi	r5,r17,15
2108a6c8:	00c00104 	movi	r3,4
2108a6cc:	28c00126 	beq	r5,r3,2108a6d4 <__divsf3+0x340>
2108a6d0:	88e3883a 	add	r17,r17,r3
2108a6d4:	88c2002c 	andhi	r3,r17,2048
2108a6d8:	18000426 	beq	r3,zero,2108a6ec <__divsf3+0x358>
2108a6dc:	11002004 	addi	r4,r2,128
2108a6e0:	00be0034 	movhi	r2,63488
2108a6e4:	10bfffc4 	addi	r2,r2,-1
2108a6e8:	88a2703a 	and	r17,r17,r2
2108a6ec:	00803f84 	movi	r2,254
2108a6f0:	1100060e 	bge	r2,r4,2108a70c <__divsf3+0x378>
2108a6f4:	9980004c 	andi	r6,r19,1
2108a6f8:	013fffc4 	movi	r4,-1
2108a6fc:	0007883a 	mov	r3,zero
2108a700:	003f6f06 	br	2108a4c0 <__flash_rwdata_start+0xfffe8278>
2108a704:	9023883a 	mov	r17,r18
2108a708:	003fbf06 	br	2108a608 <__flash_rwdata_start+0xfffe83c0>
2108a70c:	880691ba 	slli	r3,r17,6
2108a710:	9980004c 	andi	r6,r19,1
2108a714:	1806d27a 	srli	r3,r3,9
2108a718:	003f6906 	br	2108a4c0 <__flash_rwdata_start+0xfffe8278>
2108a71c:	10bfffc4 	addi	r2,r2,-1
2108a720:	2827883a 	mov	r19,r5
2108a724:	018006c4 	movi	r6,27
2108a728:	0009883a 	mov	r4,zero
2108a72c:	003fd606 	br	2108a688 <__flash_rwdata_start+0xfffe8440>
2108a730:	9080102c 	andhi	r2,r18,64
2108a734:	0023883a 	mov	r17,zero
2108a738:	103fc626 	beq	r2,zero,2108a654 <__flash_rwdata_start+0xfffe840c>
2108a73c:	00802034 	movhi	r2,128
2108a740:	88c01034 	orhi	r3,r17,64
2108a744:	10bfffc4 	addi	r2,r2,-1
2108a748:	b00d883a 	mov	r6,r22
2108a74c:	1886703a 	and	r3,r3,r2
2108a750:	003f5a06 	br	2108a4bc <__flash_rwdata_start+0xfffe8274>
2108a754:	00c000c4 	movi	r3,3
2108a758:	b8c01c26 	beq	r23,r3,2108a7cc <__divsf3+0x438>
2108a75c:	00c00044 	movi	r3,1
2108a760:	b8ffd41e 	bne	r23,r3,2108a6b4 <__flash_rwdata_start+0xfffe846c>
2108a764:	2980004c 	andi	r6,r5,1
2108a768:	0009883a 	mov	r4,zero
2108a76c:	0007883a 	mov	r3,zero
2108a770:	003f5306 	br	2108a4c0 <__flash_rwdata_start+0xfffe8278>
2108a774:	10802784 	addi	r2,r2,158
2108a778:	8884983a 	sll	r2,r17,r2
2108a77c:	8908d83a 	srl	r4,r17,r4
2108a780:	1022c03a 	cmpne	r17,r2,zero
2108a784:	8908b03a 	or	r4,r17,r4
2108a788:	208001cc 	andi	r2,r4,7
2108a78c:	10000426 	beq	r2,zero,2108a7a0 <__divsf3+0x40c>
2108a790:	20c003cc 	andi	r3,r4,15
2108a794:	00800104 	movi	r2,4
2108a798:	18800126 	beq	r3,r2,2108a7a0 <__divsf3+0x40c>
2108a79c:	2089883a 	add	r4,r4,r2
2108a7a0:	2081002c 	andhi	r2,r4,1024
2108a7a4:	10000426 	beq	r2,zero,2108a7b8 <__divsf3+0x424>
2108a7a8:	9980004c 	andi	r6,r19,1
2108a7ac:	01000044 	movi	r4,1
2108a7b0:	0007883a 	mov	r3,zero
2108a7b4:	003f4206 	br	2108a4c0 <__flash_rwdata_start+0xfffe8278>
2108a7b8:	200691ba 	slli	r3,r4,6
2108a7bc:	9980004c 	andi	r6,r19,1
2108a7c0:	0009883a 	mov	r4,zero
2108a7c4:	1806d27a 	srli	r3,r3,9
2108a7c8:	003f3d06 	br	2108a4c0 <__flash_rwdata_start+0xfffe8278>
2108a7cc:	00802034 	movhi	r2,128
2108a7d0:	88c01034 	orhi	r3,r17,64
2108a7d4:	10bfffc4 	addi	r2,r2,-1
2108a7d8:	9980004c 	andi	r6,r19,1
2108a7dc:	1886703a 	and	r3,r3,r2
2108a7e0:	003f3606 	br	2108a4bc <__flash_rwdata_start+0xfffe8274>

2108a7e4 <__mulsf3>:
2108a7e4:	defff504 	addi	sp,sp,-44
2108a7e8:	dc400215 	stw	r17,8(sp)
2108a7ec:	2022d5fa 	srli	r17,r4,23
2108a7f0:	dd400615 	stw	r21,24(sp)
2108a7f4:	202ad7fa 	srli	r21,r4,31
2108a7f8:	dc000115 	stw	r16,4(sp)
2108a7fc:	04002034 	movhi	r16,128
2108a800:	df000915 	stw	fp,36(sp)
2108a804:	dd000515 	stw	r20,20(sp)
2108a808:	843fffc4 	addi	r16,r16,-1
2108a80c:	dfc00a15 	stw	ra,40(sp)
2108a810:	ddc00815 	stw	r23,32(sp)
2108a814:	dd800715 	stw	r22,28(sp)
2108a818:	dcc00415 	stw	r19,16(sp)
2108a81c:	dc800315 	stw	r18,12(sp)
2108a820:	8c403fcc 	andi	r17,r17,255
2108a824:	8120703a 	and	r16,r16,r4
2108a828:	a829883a 	mov	r20,r21
2108a82c:	af003fcc 	andi	fp,r21,255
2108a830:	88005026 	beq	r17,zero,2108a974 <__mulsf3+0x190>
2108a834:	00803fc4 	movi	r2,255
2108a838:	88802f26 	beq	r17,r2,2108a8f8 <__mulsf3+0x114>
2108a83c:	84002034 	orhi	r16,r16,128
2108a840:	802090fa 	slli	r16,r16,3
2108a844:	8c7fe044 	addi	r17,r17,-127
2108a848:	0025883a 	mov	r18,zero
2108a84c:	002f883a 	mov	r23,zero
2108a850:	2804d5fa 	srli	r2,r5,23
2108a854:	282cd7fa 	srli	r22,r5,31
2108a858:	01002034 	movhi	r4,128
2108a85c:	213fffc4 	addi	r4,r4,-1
2108a860:	10803fcc 	andi	r2,r2,255
2108a864:	2166703a 	and	r19,r4,r5
2108a868:	b1803fcc 	andi	r6,r22,255
2108a86c:	10004926 	beq	r2,zero,2108a994 <__mulsf3+0x1b0>
2108a870:	00c03fc4 	movi	r3,255
2108a874:	10c04326 	beq	r2,r3,2108a984 <__mulsf3+0x1a0>
2108a878:	99402034 	orhi	r5,r19,128
2108a87c:	282690fa 	slli	r19,r5,3
2108a880:	10bfe044 	addi	r2,r2,-127
2108a884:	000b883a 	mov	r5,zero
2108a888:	8885883a 	add	r2,r17,r2
2108a88c:	2c86b03a 	or	r3,r5,r18
2108a890:	010003c4 	movi	r4,15
2108a894:	adaaf03a 	xor	r21,r21,r22
2108a898:	12000044 	addi	r8,r2,1
2108a89c:	20c06536 	bltu	r4,r3,2108aa34 <__mulsf3+0x250>
2108a8a0:	180690ba 	slli	r3,r3,2
2108a8a4:	01084274 	movhi	r4,8457
2108a8a8:	212a2e04 	addi	r4,r4,-22344
2108a8ac:	1907883a 	add	r3,r3,r4
2108a8b0:	18c00017 	ldw	r3,0(r3)
2108a8b4:	1800683a 	jmp	r3
2108a8b8:	2108aa34 	orhi	r4,r4,8872
2108a8bc:	2108ab00 	call	22108ab0 <__flash_rwdata_start+0x1066868>
2108a8c0:	2108ab00 	call	22108ab0 <__flash_rwdata_start+0x1066868>
2108a8c4:	2108ab10 	cmplti	r4,r4,8876
2108a8c8:	2108a908 	cmpgei	r4,r4,8868
2108a8cc:	2108a908 	cmpgei	r4,r4,8868
2108a8d0:	2108aa20 	cmpeqi	r4,r4,8872
2108a8d4:	2108ab10 	cmplti	r4,r4,8876
2108a8d8:	2108a908 	cmpgei	r4,r4,8868
2108a8dc:	2108aa20 	cmpeqi	r4,r4,8872
2108a8e0:	2108a908 	cmpgei	r4,r4,8868
2108a8e4:	2108ab10 	cmplti	r4,r4,8876
2108a8e8:	2108a90c 	andi	r4,r4,8868
2108a8ec:	2108a90c 	andi	r4,r4,8868
2108a8f0:	2108a90c 	andi	r4,r4,8868
2108a8f4:	2108ab20 	cmpeqi	r4,r4,8876
2108a8f8:	8000311e 	bne	r16,zero,2108a9c0 <__mulsf3+0x1dc>
2108a8fc:	04800204 	movi	r18,8
2108a900:	05c00084 	movi	r23,2
2108a904:	003fd206 	br	2108a850 <__flash_rwdata_start+0xfffe8608>
2108a908:	a839883a 	mov	fp,r21
2108a90c:	00800084 	movi	r2,2
2108a910:	b880231e 	bne	r23,r2,2108a9a0 <__mulsf3+0x1bc>
2108a914:	e500004c 	andi	r20,fp,1
2108a918:	00ffffc4 	movi	r3,-1
2108a91c:	0009883a 	mov	r4,zero
2108a920:	18c03fcc 	andi	r3,r3,255
2108a924:	180695fa 	slli	r3,r3,23
2108a928:	a0803fcc 	andi	r2,r20,255
2108a92c:	04002034 	movhi	r16,128
2108a930:	100497fa 	slli	r2,r2,31
2108a934:	843fffc4 	addi	r16,r16,-1
2108a938:	2420703a 	and	r16,r4,r16
2108a93c:	80e0b03a 	or	r16,r16,r3
2108a940:	8084b03a 	or	r2,r16,r2
2108a944:	dfc00a17 	ldw	ra,40(sp)
2108a948:	df000917 	ldw	fp,36(sp)
2108a94c:	ddc00817 	ldw	r23,32(sp)
2108a950:	dd800717 	ldw	r22,28(sp)
2108a954:	dd400617 	ldw	r21,24(sp)
2108a958:	dd000517 	ldw	r20,20(sp)
2108a95c:	dcc00417 	ldw	r19,16(sp)
2108a960:	dc800317 	ldw	r18,12(sp)
2108a964:	dc400217 	ldw	r17,8(sp)
2108a968:	dc000117 	ldw	r16,4(sp)
2108a96c:	dec00b04 	addi	sp,sp,44
2108a970:	f800283a 	ret
2108a974:	8000151e 	bne	r16,zero,2108a9cc <__mulsf3+0x1e8>
2108a978:	04800104 	movi	r18,4
2108a97c:	05c00044 	movi	r23,1
2108a980:	003fb306 	br	2108a850 <__flash_rwdata_start+0xfffe8608>
2108a984:	980b003a 	cmpeq	r5,r19,zero
2108a988:	00c000c4 	movi	r3,3
2108a98c:	194bc83a 	sub	r5,r3,r5
2108a990:	003fbd06 	br	2108a888 <__flash_rwdata_start+0xfffe8640>
2108a994:	9800181e 	bne	r19,zero,2108a9f8 <__mulsf3+0x214>
2108a998:	01400044 	movi	r5,1
2108a99c:	003fba06 	br	2108a888 <__flash_rwdata_start+0xfffe8640>
2108a9a0:	008000c4 	movi	r2,3
2108a9a4:	b8809226 	beq	r23,r2,2108abf0 <__mulsf3+0x40c>
2108a9a8:	00800044 	movi	r2,1
2108a9ac:	b880771e 	bne	r23,r2,2108ab8c <__mulsf3+0x3a8>
2108a9b0:	e0a8703a 	and	r20,fp,r2
2108a9b4:	0007883a 	mov	r3,zero
2108a9b8:	0009883a 	mov	r4,zero
2108a9bc:	003fd806 	br	2108a920 <__flash_rwdata_start+0xfffe86d8>
2108a9c0:	04800304 	movi	r18,12
2108a9c4:	05c000c4 	movi	r23,3
2108a9c8:	003fa106 	br	2108a850 <__flash_rwdata_start+0xfffe8608>
2108a9cc:	8009883a 	mov	r4,r16
2108a9d0:	d9400015 	stw	r5,0(sp)
2108a9d4:	108d3f80 	call	2108d3f8 <__clzsi2>
2108a9d8:	10fffec4 	addi	r3,r2,-5
2108a9dc:	047fe284 	movi	r17,-118
2108a9e0:	80e0983a 	sll	r16,r16,r3
2108a9e4:	88a3c83a 	sub	r17,r17,r2
2108a9e8:	0025883a 	mov	r18,zero
2108a9ec:	002f883a 	mov	r23,zero
2108a9f0:	d9400017 	ldw	r5,0(sp)
2108a9f4:	003f9606 	br	2108a850 <__flash_rwdata_start+0xfffe8608>
2108a9f8:	9809883a 	mov	r4,r19
2108a9fc:	d9800015 	stw	r6,0(sp)
2108aa00:	108d3f80 	call	2108d3f8 <__clzsi2>
2108aa04:	10fffec4 	addi	r3,r2,-5
2108aa08:	98e6983a 	sll	r19,r19,r3
2108aa0c:	00ffe284 	movi	r3,-118
2108aa10:	1885c83a 	sub	r2,r3,r2
2108aa14:	000b883a 	mov	r5,zero
2108aa18:	d9800017 	ldw	r6,0(sp)
2108aa1c:	003f9a06 	br	2108a888 <__flash_rwdata_start+0xfffe8640>
2108aa20:	01002034 	movhi	r4,128
2108aa24:	0029883a 	mov	r20,zero
2108aa28:	213fffc4 	addi	r4,r4,-1
2108aa2c:	00ffffc4 	movi	r3,-1
2108aa30:	003fbb06 	br	2108a920 <__flash_rwdata_start+0xfffe86d8>
2108aa34:	8006d43a 	srli	r3,r16,16
2108aa38:	9812d43a 	srli	r9,r19,16
2108aa3c:	843fffcc 	andi	r16,r16,65535
2108aa40:	997fffcc 	andi	r5,r19,65535
2108aa44:	2c0f383a 	mul	r7,r5,r16
2108aa48:	28cb383a 	mul	r5,r5,r3
2108aa4c:	4c21383a 	mul	r16,r9,r16
2108aa50:	380cd43a 	srli	r6,r7,16
2108aa54:	48d3383a 	mul	r9,r9,r3
2108aa58:	2c21883a 	add	r16,r5,r16
2108aa5c:	8187883a 	add	r3,r16,r6
2108aa60:	1940022e 	bgeu	r3,r5,2108aa6c <__mulsf3+0x288>
2108aa64:	01000074 	movhi	r4,1
2108aa68:	4913883a 	add	r9,r9,r4
2108aa6c:	1808943a 	slli	r4,r3,16
2108aa70:	39ffffcc 	andi	r7,r7,65535
2108aa74:	1806d43a 	srli	r3,r3,16
2108aa78:	21c9883a 	add	r4,r4,r7
2108aa7c:	202091ba 	slli	r16,r4,6
2108aa80:	48c7883a 	add	r3,r9,r3
2108aa84:	2008d6ba 	srli	r4,r4,26
2108aa88:	180691ba 	slli	r3,r3,6
2108aa8c:	8020c03a 	cmpne	r16,r16,zero
2108aa90:	8120b03a 	or	r16,r16,r4
2108aa94:	80e0b03a 	or	r16,r16,r3
2108aa98:	80c2002c 	andhi	r3,r16,2048
2108aa9c:	18000426 	beq	r3,zero,2108aab0 <__mulsf3+0x2cc>
2108aaa0:	8006d07a 	srli	r3,r16,1
2108aaa4:	8400004c 	andi	r16,r16,1
2108aaa8:	4005883a 	mov	r2,r8
2108aaac:	80e0b03a 	or	r16,r16,r3
2108aab0:	10c01fc4 	addi	r3,r2,127
2108aab4:	00c02d0e 	bge	zero,r3,2108ab6c <__mulsf3+0x388>
2108aab8:	810001cc 	andi	r4,r16,7
2108aabc:	20000426 	beq	r4,zero,2108aad0 <__mulsf3+0x2ec>
2108aac0:	814003cc 	andi	r5,r16,15
2108aac4:	01000104 	movi	r4,4
2108aac8:	29000126 	beq	r5,r4,2108aad0 <__mulsf3+0x2ec>
2108aacc:	8121883a 	add	r16,r16,r4
2108aad0:	8102002c 	andhi	r4,r16,2048
2108aad4:	20000426 	beq	r4,zero,2108aae8 <__mulsf3+0x304>
2108aad8:	10c02004 	addi	r3,r2,128
2108aadc:	00be0034 	movhi	r2,63488
2108aae0:	10bfffc4 	addi	r2,r2,-1
2108aae4:	80a0703a 	and	r16,r16,r2
2108aae8:	00803f84 	movi	r2,254
2108aaec:	10c01b0e 	bge	r2,r3,2108ab5c <__mulsf3+0x378>
2108aaf0:	ad00004c 	andi	r20,r21,1
2108aaf4:	00ffffc4 	movi	r3,-1
2108aaf8:	0009883a 	mov	r4,zero
2108aafc:	003f8806 	br	2108a920 <__flash_rwdata_start+0xfffe86d8>
2108ab00:	9821883a 	mov	r16,r19
2108ab04:	a839883a 	mov	fp,r21
2108ab08:	282f883a 	mov	r23,r5
2108ab0c:	003f7f06 	br	2108a90c <__flash_rwdata_start+0xfffe86c4>
2108ab10:	9821883a 	mov	r16,r19
2108ab14:	3039883a 	mov	fp,r6
2108ab18:	282f883a 	mov	r23,r5
2108ab1c:	003f7b06 	br	2108a90c <__flash_rwdata_start+0xfffe86c4>
2108ab20:	8080102c 	andhi	r2,r16,64
2108ab24:	10000826 	beq	r2,zero,2108ab48 <__mulsf3+0x364>
2108ab28:	9880102c 	andhi	r2,r19,64
2108ab2c:	1000061e 	bne	r2,zero,2108ab48 <__mulsf3+0x364>
2108ab30:	00802034 	movhi	r2,128
2108ab34:	99001034 	orhi	r4,r19,64
2108ab38:	10bfffc4 	addi	r2,r2,-1
2108ab3c:	b029883a 	mov	r20,r22
2108ab40:	2088703a 	and	r4,r4,r2
2108ab44:	003fb906 	br	2108aa2c <__flash_rwdata_start+0xfffe87e4>
2108ab48:	00802034 	movhi	r2,128
2108ab4c:	81001034 	orhi	r4,r16,64
2108ab50:	10bfffc4 	addi	r2,r2,-1
2108ab54:	2088703a 	and	r4,r4,r2
2108ab58:	003fb406 	br	2108aa2c <__flash_rwdata_start+0xfffe87e4>
2108ab5c:	802091ba 	slli	r16,r16,6
2108ab60:	ad00004c 	andi	r20,r21,1
2108ab64:	8008d27a 	srli	r4,r16,9
2108ab68:	003f6d06 	br	2108a920 <__flash_rwdata_start+0xfffe86d8>
2108ab6c:	00ffe084 	movi	r3,-126
2108ab70:	1887c83a 	sub	r3,r3,r2
2108ab74:	010006c4 	movi	r4,27
2108ab78:	20c0070e 	bge	r4,r3,2108ab98 <__mulsf3+0x3b4>
2108ab7c:	ad00004c 	andi	r20,r21,1
2108ab80:	0007883a 	mov	r3,zero
2108ab84:	0009883a 	mov	r4,zero
2108ab88:	003f6506 	br	2108a920 <__flash_rwdata_start+0xfffe86d8>
2108ab8c:	4005883a 	mov	r2,r8
2108ab90:	e02b883a 	mov	r21,fp
2108ab94:	003fc606 	br	2108aab0 <__flash_rwdata_start+0xfffe8868>
2108ab98:	10802784 	addi	r2,r2,158
2108ab9c:	8084983a 	sll	r2,r16,r2
2108aba0:	80e0d83a 	srl	r16,r16,r3
2108aba4:	1004c03a 	cmpne	r2,r2,zero
2108aba8:	1404b03a 	or	r2,r2,r16
2108abac:	10c001cc 	andi	r3,r2,7
2108abb0:	18000426 	beq	r3,zero,2108abc4 <__mulsf3+0x3e0>
2108abb4:	110003cc 	andi	r4,r2,15
2108abb8:	00c00104 	movi	r3,4
2108abbc:	20c00126 	beq	r4,r3,2108abc4 <__mulsf3+0x3e0>
2108abc0:	10c5883a 	add	r2,r2,r3
2108abc4:	10c1002c 	andhi	r3,r2,1024
2108abc8:	18000426 	beq	r3,zero,2108abdc <__mulsf3+0x3f8>
2108abcc:	ad00004c 	andi	r20,r21,1
2108abd0:	00c00044 	movi	r3,1
2108abd4:	0009883a 	mov	r4,zero
2108abd8:	003f5106 	br	2108a920 <__flash_rwdata_start+0xfffe86d8>
2108abdc:	100491ba 	slli	r2,r2,6
2108abe0:	ad00004c 	andi	r20,r21,1
2108abe4:	0007883a 	mov	r3,zero
2108abe8:	1008d27a 	srli	r4,r2,9
2108abec:	003f4c06 	br	2108a920 <__flash_rwdata_start+0xfffe86d8>
2108abf0:	00802034 	movhi	r2,128
2108abf4:	81001034 	orhi	r4,r16,64
2108abf8:	10bfffc4 	addi	r2,r2,-1
2108abfc:	e500004c 	andi	r20,fp,1
2108ac00:	2088703a 	and	r4,r4,r2
2108ac04:	003f8906 	br	2108aa2c <__flash_rwdata_start+0xfffe87e4>

2108ac08 <__floatunsisf>:
2108ac08:	defffe04 	addi	sp,sp,-8
2108ac0c:	dc000015 	stw	r16,0(sp)
2108ac10:	dfc00115 	stw	ra,4(sp)
2108ac14:	2021883a 	mov	r16,r4
2108ac18:	20002626 	beq	r4,zero,2108acb4 <__floatunsisf+0xac>
2108ac1c:	108d3f80 	call	2108d3f8 <__clzsi2>
2108ac20:	00c02784 	movi	r3,158
2108ac24:	1887c83a 	sub	r3,r3,r2
2108ac28:	01002584 	movi	r4,150
2108ac2c:	20c00816 	blt	r4,r3,2108ac50 <__floatunsisf+0x48>
2108ac30:	01000204 	movi	r4,8
2108ac34:	2080340e 	bge	r4,r2,2108ad08 <__floatunsisf+0x100>
2108ac38:	10bffe04 	addi	r2,r2,-8
2108ac3c:	8088983a 	sll	r4,r16,r2
2108ac40:	00802034 	movhi	r2,128
2108ac44:	10bfffc4 	addi	r2,r2,-1
2108ac48:	2088703a 	and	r4,r4,r2
2108ac4c:	00001b06 	br	2108acbc <__floatunsisf+0xb4>
2108ac50:	01002644 	movi	r4,153
2108ac54:	20c02316 	blt	r4,r3,2108ace4 <__floatunsisf+0xdc>
2108ac58:	01000144 	movi	r4,5
2108ac5c:	2080020e 	bge	r4,r2,2108ac68 <__floatunsisf+0x60>
2108ac60:	113ffec4 	addi	r4,r2,-5
2108ac64:	8120983a 	sll	r16,r16,r4
2108ac68:	017f0034 	movhi	r5,64512
2108ac6c:	297fffc4 	addi	r5,r5,-1
2108ac70:	810001cc 	andi	r4,r16,7
2108ac74:	814a703a 	and	r5,r16,r5
2108ac78:	20000426 	beq	r4,zero,2108ac8c <__floatunsisf+0x84>
2108ac7c:	840003cc 	andi	r16,r16,15
2108ac80:	01000104 	movi	r4,4
2108ac84:	81000126 	beq	r16,r4,2108ac8c <__floatunsisf+0x84>
2108ac88:	290b883a 	add	r5,r5,r4
2108ac8c:	2901002c 	andhi	r4,r5,1024
2108ac90:	20000526 	beq	r4,zero,2108aca8 <__floatunsisf+0xa0>
2108ac94:	00c027c4 	movi	r3,159
2108ac98:	1887c83a 	sub	r3,r3,r2
2108ac9c:	00bf0034 	movhi	r2,64512
2108aca0:	10bfffc4 	addi	r2,r2,-1
2108aca4:	288a703a 	and	r5,r5,r2
2108aca8:	280891ba 	slli	r4,r5,6
2108acac:	2008d27a 	srli	r4,r4,9
2108acb0:	00000206 	br	2108acbc <__floatunsisf+0xb4>
2108acb4:	0007883a 	mov	r3,zero
2108acb8:	0009883a 	mov	r4,zero
2108acbc:	18c03fcc 	andi	r3,r3,255
2108acc0:	180695fa 	slli	r3,r3,23
2108acc4:	00802034 	movhi	r2,128
2108acc8:	10bfffc4 	addi	r2,r2,-1
2108accc:	2084703a 	and	r2,r4,r2
2108acd0:	10c4b03a 	or	r2,r2,r3
2108acd4:	dfc00117 	ldw	ra,4(sp)
2108acd8:	dc000017 	ldw	r16,0(sp)
2108acdc:	dec00204 	addi	sp,sp,8
2108ace0:	f800283a 	ret
2108ace4:	01400144 	movi	r5,5
2108ace8:	110006c4 	addi	r4,r2,27
2108acec:	8108983a 	sll	r4,r16,r4
2108acf0:	288dc83a 	sub	r6,r5,r2
2108acf4:	81a0d83a 	srl	r16,r16,r6
2108acf8:	2008c03a 	cmpne	r4,r4,zero
2108acfc:	2420b03a 	or	r16,r4,r16
2108ad00:	28bfd90e 	bge	r5,r2,2108ac68 <__flash_rwdata_start+0xfffe8a20>
2108ad04:	003fd606 	br	2108ac60 <__flash_rwdata_start+0xfffe8a18>
2108ad08:	01402034 	movhi	r5,128
2108ad0c:	297fffc4 	addi	r5,r5,-1
2108ad10:	8148703a 	and	r4,r16,r5
2108ad14:	003fe906 	br	2108acbc <__flash_rwdata_start+0xfffe8a74>

2108ad18 <__adddf3>:
2108ad18:	02000434 	movhi	r8,16
2108ad1c:	423fffc4 	addi	r8,r8,-1
2108ad20:	defffb04 	addi	sp,sp,-20
2108ad24:	2a12703a 	and	r9,r5,r8
2108ad28:	2806d7fa 	srli	r3,r5,31
2108ad2c:	3a10703a 	and	r8,r7,r8
2108ad30:	3804d53a 	srli	r2,r7,20
2108ad34:	3014d77a 	srli	r10,r6,29
2108ad38:	dc000015 	stw	r16,0(sp)
2108ad3c:	481290fa 	slli	r9,r9,3
2108ad40:	2820d53a 	srli	r16,r5,20
2108ad44:	401090fa 	slli	r8,r8,3
2108ad48:	200ad77a 	srli	r5,r4,29
2108ad4c:	380ed7fa 	srli	r7,r7,31
2108ad50:	dc800215 	stw	r18,8(sp)
2108ad54:	dc400115 	stw	r17,4(sp)
2108ad58:	dfc00415 	stw	ra,16(sp)
2108ad5c:	dcc00315 	stw	r19,12(sp)
2108ad60:	1c803fcc 	andi	r18,r3,255
2108ad64:	8401ffcc 	andi	r16,r16,2047
2108ad68:	494ab03a 	or	r5,r9,r5
2108ad6c:	202290fa 	slli	r17,r4,3
2108ad70:	1081ffcc 	andi	r2,r2,2047
2108ad74:	4290b03a 	or	r8,r8,r10
2108ad78:	300c90fa 	slli	r6,r6,3
2108ad7c:	91c07026 	beq	r18,r7,2108af40 <__adddf3+0x228>
2108ad80:	8087c83a 	sub	r3,r16,r2
2108ad84:	00c0b30e 	bge	zero,r3,2108b054 <__adddf3+0x33c>
2108ad88:	10002a1e 	bne	r2,zero,2108ae34 <__adddf3+0x11c>
2108ad8c:	4184b03a 	or	r2,r8,r6
2108ad90:	1000991e 	bne	r2,zero,2108aff8 <__adddf3+0x2e0>
2108ad94:	888001cc 	andi	r2,r17,7
2108ad98:	10005b26 	beq	r2,zero,2108af08 <__adddf3+0x1f0>
2108ad9c:	88c003cc 	andi	r3,r17,15
2108ada0:	00800104 	movi	r2,4
2108ada4:	18805826 	beq	r3,r2,2108af08 <__adddf3+0x1f0>
2108ada8:	89800104 	addi	r6,r17,4
2108adac:	3463803a 	cmpltu	r17,r6,r17
2108adb0:	2c4b883a 	add	r5,r5,r17
2108adb4:	2880202c 	andhi	r2,r5,128
2108adb8:	9007883a 	mov	r3,r18
2108adbc:	3023883a 	mov	r17,r6
2108adc0:	10005426 	beq	r2,zero,2108af14 <__adddf3+0x1fc>
2108adc4:	84000044 	addi	r16,r16,1
2108adc8:	0081ffc4 	movi	r2,2047
2108adcc:	8080c126 	beq	r16,r2,2108b0d4 <__adddf3+0x3bc>
2108add0:	013fe034 	movhi	r4,65408
2108add4:	213fffc4 	addi	r4,r4,-1
2108add8:	290a703a 	and	r5,r5,r4
2108addc:	2804977a 	slli	r2,r5,29
2108ade0:	280a927a 	slli	r5,r5,9
2108ade4:	8822d0fa 	srli	r17,r17,3
2108ade8:	8401ffcc 	andi	r16,r16,2047
2108adec:	2808d33a 	srli	r4,r5,12
2108adf0:	1444b03a 	or	r2,r2,r17
2108adf4:	8401ffcc 	andi	r16,r16,2047
2108adf8:	800a953a 	slli	r5,r16,20
2108adfc:	18c03fcc 	andi	r3,r3,255
2108ae00:	04000434 	movhi	r16,16
2108ae04:	180697fa 	slli	r3,r3,31
2108ae08:	843fffc4 	addi	r16,r16,-1
2108ae0c:	2420703a 	and	r16,r4,r16
2108ae10:	8160b03a 	or	r16,r16,r5
2108ae14:	80c6b03a 	or	r3,r16,r3
2108ae18:	dfc00417 	ldw	ra,16(sp)
2108ae1c:	dcc00317 	ldw	r19,12(sp)
2108ae20:	dc800217 	ldw	r18,8(sp)
2108ae24:	dc400117 	ldw	r17,4(sp)
2108ae28:	dc000017 	ldw	r16,0(sp)
2108ae2c:	dec00504 	addi	sp,sp,20
2108ae30:	f800283a 	ret
2108ae34:	0081ffc4 	movi	r2,2047
2108ae38:	80bfd626 	beq	r16,r2,2108ad94 <__flash_rwdata_start+0xfffe8b4c>
2108ae3c:	42002034 	orhi	r8,r8,128
2108ae40:	00800e04 	movi	r2,56
2108ae44:	10c0a616 	blt	r2,r3,2108b0e0 <__adddf3+0x3c8>
2108ae48:	008007c4 	movi	r2,31
2108ae4c:	10c0c916 	blt	r2,r3,2108b174 <__adddf3+0x45c>
2108ae50:	00800804 	movi	r2,32
2108ae54:	10c5c83a 	sub	r2,r2,r3
2108ae58:	408e983a 	sll	r7,r8,r2
2108ae5c:	30c8d83a 	srl	r4,r6,r3
2108ae60:	3084983a 	sll	r2,r6,r2
2108ae64:	40c6d83a 	srl	r3,r8,r3
2108ae68:	390cb03a 	or	r6,r7,r4
2108ae6c:	1004c03a 	cmpne	r2,r2,zero
2108ae70:	308cb03a 	or	r6,r6,r2
2108ae74:	898dc83a 	sub	r6,r17,r6
2108ae78:	89a3803a 	cmpltu	r17,r17,r6
2108ae7c:	28cbc83a 	sub	r5,r5,r3
2108ae80:	2c4bc83a 	sub	r5,r5,r17
2108ae84:	3023883a 	mov	r17,r6
2108ae88:	2880202c 	andhi	r2,r5,128
2108ae8c:	10006d26 	beq	r2,zero,2108b044 <__adddf3+0x32c>
2108ae90:	04c02034 	movhi	r19,128
2108ae94:	9cffffc4 	addi	r19,r19,-1
2108ae98:	2ce6703a 	and	r19,r5,r19
2108ae9c:	98007e26 	beq	r19,zero,2108b098 <__adddf3+0x380>
2108aea0:	9809883a 	mov	r4,r19
2108aea4:	108d3f80 	call	2108d3f8 <__clzsi2>
2108aea8:	10fffe04 	addi	r3,r2,-8
2108aeac:	010007c4 	movi	r4,31
2108aeb0:	20c07f16 	blt	r4,r3,2108b0b0 <__adddf3+0x398>
2108aeb4:	01400a04 	movi	r5,40
2108aeb8:	2885c83a 	sub	r2,r5,r2
2108aebc:	888ad83a 	srl	r5,r17,r2
2108aec0:	98e6983a 	sll	r19,r19,r3
2108aec4:	88e2983a 	sll	r17,r17,r3
2108aec8:	2ce6b03a 	or	r19,r5,r19
2108aecc:	1c007c16 	blt	r3,r16,2108b0c0 <__adddf3+0x3a8>
2108aed0:	1c21c83a 	sub	r16,r3,r16
2108aed4:	81400044 	addi	r5,r16,1
2108aed8:	00c007c4 	movi	r3,31
2108aedc:	19409816 	blt	r3,r5,2108b140 <__adddf3+0x428>
2108aee0:	1c21c83a 	sub	r16,r3,r16
2108aee4:	8c08983a 	sll	r4,r17,r16
2108aee8:	8946d83a 	srl	r3,r17,r5
2108aeec:	9c20983a 	sll	r16,r19,r16
2108aef0:	2008c03a 	cmpne	r4,r4,zero
2108aef4:	994ad83a 	srl	r5,r19,r5
2108aef8:	1c06b03a 	or	r3,r3,r16
2108aefc:	1922b03a 	or	r17,r3,r4
2108af00:	0021883a 	mov	r16,zero
2108af04:	003fa306 	br	2108ad94 <__flash_rwdata_start+0xfffe8b4c>
2108af08:	2880202c 	andhi	r2,r5,128
2108af0c:	9007883a 	mov	r3,r18
2108af10:	103fac1e 	bne	r2,zero,2108adc4 <__flash_rwdata_start+0xfffe8b7c>
2108af14:	2804977a 	slli	r2,r5,29
2108af18:	8822d0fa 	srli	r17,r17,3
2108af1c:	0101ffc4 	movi	r4,2047
2108af20:	280ad0fa 	srli	r5,r5,3
2108af24:	1444b03a 	or	r2,r2,r17
2108af28:	81002c26 	beq	r16,r4,2108afdc <__adddf3+0x2c4>
2108af2c:	8120703a 	and	r16,r16,r4
2108af30:	01000434 	movhi	r4,16
2108af34:	213fffc4 	addi	r4,r4,-1
2108af38:	2908703a 	and	r4,r5,r4
2108af3c:	003fad06 	br	2108adf4 <__flash_rwdata_start+0xfffe8bac>
2108af40:	8089c83a 	sub	r4,r16,r2
2108af44:	01006a0e 	bge	zero,r4,2108b0f0 <__adddf3+0x3d8>
2108af48:	10003326 	beq	r2,zero,2108b018 <__adddf3+0x300>
2108af4c:	0081ffc4 	movi	r2,2047
2108af50:	80bf9026 	beq	r16,r2,2108ad94 <__flash_rwdata_start+0xfffe8b4c>
2108af54:	42002034 	orhi	r8,r8,128
2108af58:	00800e04 	movi	r2,56
2108af5c:	1100b116 	blt	r2,r4,2108b224 <__adddf3+0x50c>
2108af60:	008007c4 	movi	r2,31
2108af64:	1100e216 	blt	r2,r4,2108b2f0 <__adddf3+0x5d8>
2108af68:	00800804 	movi	r2,32
2108af6c:	1105c83a 	sub	r2,r2,r4
2108af70:	4092983a 	sll	r9,r8,r2
2108af74:	310ed83a 	srl	r7,r6,r4
2108af78:	3084983a 	sll	r2,r6,r2
2108af7c:	4110d83a 	srl	r8,r8,r4
2108af80:	49ccb03a 	or	r6,r9,r7
2108af84:	1004c03a 	cmpne	r2,r2,zero
2108af88:	308cb03a 	or	r6,r6,r2
2108af8c:	344d883a 	add	r6,r6,r17
2108af90:	3463803a 	cmpltu	r17,r6,r17
2108af94:	414b883a 	add	r5,r8,r5
2108af98:	2c4b883a 	add	r5,r5,r17
2108af9c:	3023883a 	mov	r17,r6
2108afa0:	2880202c 	andhi	r2,r5,128
2108afa4:	10002726 	beq	r2,zero,2108b044 <__adddf3+0x32c>
2108afa8:	84000044 	addi	r16,r16,1
2108afac:	0081ffc4 	movi	r2,2047
2108afb0:	8080ae26 	beq	r16,r2,2108b26c <__adddf3+0x554>
2108afb4:	00bfe034 	movhi	r2,65408
2108afb8:	10bfffc4 	addi	r2,r2,-1
2108afbc:	288a703a 	and	r5,r5,r2
2108afc0:	880cd07a 	srli	r6,r17,1
2108afc4:	280897fa 	slli	r4,r5,31
2108afc8:	88c0004c 	andi	r3,r17,1
2108afcc:	30e2b03a 	or	r17,r6,r3
2108afd0:	280ad07a 	srli	r5,r5,1
2108afd4:	8922b03a 	or	r17,r17,r4
2108afd8:	003f6e06 	br	2108ad94 <__flash_rwdata_start+0xfffe8b4c>
2108afdc:	1148b03a 	or	r4,r2,r5
2108afe0:	20003c26 	beq	r4,zero,2108b0d4 <__adddf3+0x3bc>
2108afe4:	29000234 	orhi	r4,r5,8
2108afe8:	01400434 	movhi	r5,16
2108afec:	297fffc4 	addi	r5,r5,-1
2108aff0:	2148703a 	and	r4,r4,r5
2108aff4:	003f7f06 	br	2108adf4 <__flash_rwdata_start+0xfffe8bac>
2108aff8:	18ffffc4 	addi	r3,r3,-1
2108affc:	18004d1e 	bne	r3,zero,2108b134 <__adddf3+0x41c>
2108b000:	898dc83a 	sub	r6,r17,r6
2108b004:	89a3803a 	cmpltu	r17,r17,r6
2108b008:	2a0bc83a 	sub	r5,r5,r8
2108b00c:	2c4bc83a 	sub	r5,r5,r17
2108b010:	3023883a 	mov	r17,r6
2108b014:	003f9c06 	br	2108ae88 <__flash_rwdata_start+0xfffe8c40>
2108b018:	4184b03a 	or	r2,r8,r6
2108b01c:	103f5d26 	beq	r2,zero,2108ad94 <__flash_rwdata_start+0xfffe8b4c>
2108b020:	213fffc4 	addi	r4,r4,-1
2108b024:	203fd926 	beq	r4,zero,2108af8c <__flash_rwdata_start+0xfffe8d44>
2108b028:	0081ffc4 	movi	r2,2047
2108b02c:	80bfca1e 	bne	r16,r2,2108af58 <__flash_rwdata_start+0xfffe8d10>
2108b030:	003f5806 	br	2108ad94 <__flash_rwdata_start+0xfffe8b4c>
2108b034:	10c8b03a 	or	r4,r2,r3
2108b038:	20008b26 	beq	r4,zero,2108b268 <__adddf3+0x550>
2108b03c:	100b883a 	mov	r5,r2
2108b040:	1823883a 	mov	r17,r3
2108b044:	888001cc 	andi	r2,r17,7
2108b048:	103f541e 	bne	r2,zero,2108ad9c <__flash_rwdata_start+0xfffe8b54>
2108b04c:	9007883a 	mov	r3,r18
2108b050:	003fb006 	br	2108af14 <__flash_rwdata_start+0xfffe8ccc>
2108b054:	1800531e 	bne	r3,zero,2108b1a4 <__adddf3+0x48c>
2108b058:	80800044 	addi	r2,r16,1
2108b05c:	1081ffcc 	andi	r2,r2,2047
2108b060:	00c00044 	movi	r3,1
2108b064:	1880990e 	bge	r3,r2,2108b2cc <__adddf3+0x5b4>
2108b068:	8985c83a 	sub	r2,r17,r6
2108b06c:	8887803a 	cmpltu	r3,r17,r2
2108b070:	2a27c83a 	sub	r19,r5,r8
2108b074:	98e7c83a 	sub	r19,r19,r3
2108b078:	98c0202c 	andhi	r3,r19,128
2108b07c:	18006226 	beq	r3,zero,2108b208 <__adddf3+0x4f0>
2108b080:	3463c83a 	sub	r17,r6,r17
2108b084:	4151c83a 	sub	r8,r8,r5
2108b088:	344d803a 	cmpltu	r6,r6,r17
2108b08c:	41a7c83a 	sub	r19,r8,r6
2108b090:	3825883a 	mov	r18,r7
2108b094:	983f821e 	bne	r19,zero,2108aea0 <__flash_rwdata_start+0xfffe8c58>
2108b098:	8809883a 	mov	r4,r17
2108b09c:	108d3f80 	call	2108d3f8 <__clzsi2>
2108b0a0:	10800804 	addi	r2,r2,32
2108b0a4:	10fffe04 	addi	r3,r2,-8
2108b0a8:	010007c4 	movi	r4,31
2108b0ac:	20ff810e 	bge	r4,r3,2108aeb4 <__flash_rwdata_start+0xfffe8c6c>
2108b0b0:	14fff604 	addi	r19,r2,-40
2108b0b4:	8ce6983a 	sll	r19,r17,r19
2108b0b8:	0023883a 	mov	r17,zero
2108b0bc:	1c3f840e 	bge	r3,r16,2108aed0 <__flash_rwdata_start+0xfffe8c88>
2108b0c0:	017fe034 	movhi	r5,65408
2108b0c4:	297fffc4 	addi	r5,r5,-1
2108b0c8:	80e1c83a 	sub	r16,r16,r3
2108b0cc:	994a703a 	and	r5,r19,r5
2108b0d0:	003f3006 	br	2108ad94 <__flash_rwdata_start+0xfffe8b4c>
2108b0d4:	0009883a 	mov	r4,zero
2108b0d8:	0005883a 	mov	r2,zero
2108b0dc:	003f4506 	br	2108adf4 <__flash_rwdata_start+0xfffe8bac>
2108b0e0:	418cb03a 	or	r6,r8,r6
2108b0e4:	300cc03a 	cmpne	r6,r6,zero
2108b0e8:	0007883a 	mov	r3,zero
2108b0ec:	003f6106 	br	2108ae74 <__flash_rwdata_start+0xfffe8c2c>
2108b0f0:	2000921e 	bne	r4,zero,2108b33c <__adddf3+0x624>
2108b0f4:	80800044 	addi	r2,r16,1
2108b0f8:	11c1ffcc 	andi	r7,r2,2047
2108b0fc:	01000044 	movi	r4,1
2108b100:	21c0610e 	bge	r4,r7,2108b288 <__adddf3+0x570>
2108b104:	0101ffc4 	movi	r4,2047
2108b108:	1100a326 	beq	r2,r4,2108b398 <__adddf3+0x680>
2108b10c:	344d883a 	add	r6,r6,r17
2108b110:	3463803a 	cmpltu	r17,r6,r17
2108b114:	414b883a 	add	r5,r8,r5
2108b118:	2c4b883a 	add	r5,r5,r17
2108b11c:	282297fa 	slli	r17,r5,31
2108b120:	300cd07a 	srli	r6,r6,1
2108b124:	280ad07a 	srli	r5,r5,1
2108b128:	1021883a 	mov	r16,r2
2108b12c:	89a2b03a 	or	r17,r17,r6
2108b130:	003f1806 	br	2108ad94 <__flash_rwdata_start+0xfffe8b4c>
2108b134:	0081ffc4 	movi	r2,2047
2108b138:	80bf411e 	bne	r16,r2,2108ae40 <__flash_rwdata_start+0xfffe8bf8>
2108b13c:	003f1506 	br	2108ad94 <__flash_rwdata_start+0xfffe8b4c>
2108b140:	80bff844 	addi	r2,r16,-31
2108b144:	00c00804 	movi	r3,32
2108b148:	9884d83a 	srl	r2,r19,r2
2108b14c:	28c04a26 	beq	r5,r3,2108b278 <__adddf3+0x560>
2108b150:	00c00fc4 	movi	r3,63
2108b154:	1c21c83a 	sub	r16,r3,r16
2108b158:	9c26983a 	sll	r19,r19,r16
2108b15c:	9c62b03a 	or	r17,r19,r17
2108b160:	8822c03a 	cmpne	r17,r17,zero
2108b164:	88a2b03a 	or	r17,r17,r2
2108b168:	000b883a 	mov	r5,zero
2108b16c:	0021883a 	mov	r16,zero
2108b170:	003fb406 	br	2108b044 <__flash_rwdata_start+0xfffe8dfc>
2108b174:	18bff804 	addi	r2,r3,-32
2108b178:	01000804 	movi	r4,32
2108b17c:	4084d83a 	srl	r2,r8,r2
2108b180:	19003f26 	beq	r3,r4,2108b280 <__adddf3+0x568>
2108b184:	01001004 	movi	r4,64
2108b188:	20c7c83a 	sub	r3,r4,r3
2108b18c:	40d0983a 	sll	r8,r8,r3
2108b190:	418cb03a 	or	r6,r8,r6
2108b194:	300cc03a 	cmpne	r6,r6,zero
2108b198:	308cb03a 	or	r6,r6,r2
2108b19c:	0007883a 	mov	r3,zero
2108b1a0:	003f3406 	br	2108ae74 <__flash_rwdata_start+0xfffe8c2c>
2108b1a4:	80002326 	beq	r16,zero,2108b234 <__adddf3+0x51c>
2108b1a8:	0101ffc4 	movi	r4,2047
2108b1ac:	11005e26 	beq	r2,r4,2108b328 <__adddf3+0x610>
2108b1b0:	00c7c83a 	sub	r3,zero,r3
2108b1b4:	29402034 	orhi	r5,r5,128
2108b1b8:	01000e04 	movi	r4,56
2108b1bc:	20c07216 	blt	r4,r3,2108b388 <__adddf3+0x670>
2108b1c0:	010007c4 	movi	r4,31
2108b1c4:	20c0ce16 	blt	r4,r3,2108b500 <__adddf3+0x7e8>
2108b1c8:	01000804 	movi	r4,32
2108b1cc:	20c9c83a 	sub	r4,r4,r3
2108b1d0:	2914983a 	sll	r10,r5,r4
2108b1d4:	88d2d83a 	srl	r9,r17,r3
2108b1d8:	8908983a 	sll	r4,r17,r4
2108b1dc:	28c6d83a 	srl	r3,r5,r3
2108b1e0:	5262b03a 	or	r17,r10,r9
2108b1e4:	2008c03a 	cmpne	r4,r4,zero
2108b1e8:	8922b03a 	or	r17,r17,r4
2108b1ec:	3463c83a 	sub	r17,r6,r17
2108b1f0:	40c7c83a 	sub	r3,r8,r3
2108b1f4:	344d803a 	cmpltu	r6,r6,r17
2108b1f8:	198bc83a 	sub	r5,r3,r6
2108b1fc:	1021883a 	mov	r16,r2
2108b200:	3825883a 	mov	r18,r7
2108b204:	003f2006 	br	2108ae88 <__flash_rwdata_start+0xfffe8c40>
2108b208:	9886b03a 	or	r3,r19,r2
2108b20c:	1800141e 	bne	r3,zero,2108b260 <__adddf3+0x548>
2108b210:	0007883a 	mov	r3,zero
2108b214:	000b883a 	mov	r5,zero
2108b218:	0023883a 	mov	r17,zero
2108b21c:	0021883a 	mov	r16,zero
2108b220:	003f3c06 	br	2108af14 <__flash_rwdata_start+0xfffe8ccc>
2108b224:	418cb03a 	or	r6,r8,r6
2108b228:	300cc03a 	cmpne	r6,r6,zero
2108b22c:	0011883a 	mov	r8,zero
2108b230:	003f5606 	br	2108af8c <__flash_rwdata_start+0xfffe8d44>
2108b234:	2c48b03a 	or	r4,r5,r17
2108b238:	20003b26 	beq	r4,zero,2108b328 <__adddf3+0x610>
2108b23c:	00c6303a 	nor	r3,zero,r3
2108b240:	1800371e 	bne	r3,zero,2108b320 <__adddf3+0x608>
2108b244:	3463c83a 	sub	r17,r6,r17
2108b248:	414bc83a 	sub	r5,r8,r5
2108b24c:	344d803a 	cmpltu	r6,r6,r17
2108b250:	298bc83a 	sub	r5,r5,r6
2108b254:	1021883a 	mov	r16,r2
2108b258:	3825883a 	mov	r18,r7
2108b25c:	003f0a06 	br	2108ae88 <__flash_rwdata_start+0xfffe8c40>
2108b260:	1023883a 	mov	r17,r2
2108b264:	003f0d06 	br	2108ae9c <__flash_rwdata_start+0xfffe8c54>
2108b268:	0007883a 	mov	r3,zero
2108b26c:	000b883a 	mov	r5,zero
2108b270:	0023883a 	mov	r17,zero
2108b274:	003f2706 	br	2108af14 <__flash_rwdata_start+0xfffe8ccc>
2108b278:	0027883a 	mov	r19,zero
2108b27c:	003fb706 	br	2108b15c <__flash_rwdata_start+0xfffe8f14>
2108b280:	0011883a 	mov	r8,zero
2108b284:	003fc206 	br	2108b190 <__flash_rwdata_start+0xfffe8f48>
2108b288:	2c44b03a 	or	r2,r5,r17
2108b28c:	8000871e 	bne	r16,zero,2108b4ac <__adddf3+0x794>
2108b290:	1000b126 	beq	r2,zero,2108b558 <__adddf3+0x840>
2108b294:	4184b03a 	or	r2,r8,r6
2108b298:	103ebe26 	beq	r2,zero,2108ad94 <__flash_rwdata_start+0xfffe8b4c>
2108b29c:	3445883a 	add	r2,r6,r17
2108b2a0:	1463803a 	cmpltu	r17,r2,r17
2108b2a4:	414b883a 	add	r5,r8,r5
2108b2a8:	2c4b883a 	add	r5,r5,r17
2108b2ac:	28c0202c 	andhi	r3,r5,128
2108b2b0:	1023883a 	mov	r17,r2
2108b2b4:	183f6326 	beq	r3,zero,2108b044 <__flash_rwdata_start+0xfffe8dfc>
2108b2b8:	00bfe034 	movhi	r2,65408
2108b2bc:	10bfffc4 	addi	r2,r2,-1
2108b2c0:	2021883a 	mov	r16,r4
2108b2c4:	288a703a 	and	r5,r5,r2
2108b2c8:	003eb206 	br	2108ad94 <__flash_rwdata_start+0xfffe8b4c>
2108b2cc:	2c44b03a 	or	r2,r5,r17
2108b2d0:	8000251e 	bne	r16,zero,2108b368 <__adddf3+0x650>
2108b2d4:	10004b1e 	bne	r2,zero,2108b404 <__adddf3+0x6ec>
2108b2d8:	4184b03a 	or	r2,r8,r6
2108b2dc:	103fe226 	beq	r2,zero,2108b268 <__flash_rwdata_start+0xfffe9020>
2108b2e0:	400b883a 	mov	r5,r8
2108b2e4:	3023883a 	mov	r17,r6
2108b2e8:	3825883a 	mov	r18,r7
2108b2ec:	003ea906 	br	2108ad94 <__flash_rwdata_start+0xfffe8b4c>
2108b2f0:	20bff804 	addi	r2,r4,-32
2108b2f4:	01c00804 	movi	r7,32
2108b2f8:	4084d83a 	srl	r2,r8,r2
2108b2fc:	21c07e26 	beq	r4,r7,2108b4f8 <__adddf3+0x7e0>
2108b300:	01c01004 	movi	r7,64
2108b304:	3909c83a 	sub	r4,r7,r4
2108b308:	4110983a 	sll	r8,r8,r4
2108b30c:	418cb03a 	or	r6,r8,r6
2108b310:	300cc03a 	cmpne	r6,r6,zero
2108b314:	308cb03a 	or	r6,r6,r2
2108b318:	0011883a 	mov	r8,zero
2108b31c:	003f1b06 	br	2108af8c <__flash_rwdata_start+0xfffe8d44>
2108b320:	0101ffc4 	movi	r4,2047
2108b324:	113fa41e 	bne	r2,r4,2108b1b8 <__flash_rwdata_start+0xfffe8f70>
2108b328:	400b883a 	mov	r5,r8
2108b32c:	3023883a 	mov	r17,r6
2108b330:	1021883a 	mov	r16,r2
2108b334:	3825883a 	mov	r18,r7
2108b338:	003e9606 	br	2108ad94 <__flash_rwdata_start+0xfffe8b4c>
2108b33c:	80001a1e 	bne	r16,zero,2108b3a8 <__adddf3+0x690>
2108b340:	2c4eb03a 	or	r7,r5,r17
2108b344:	38005526 	beq	r7,zero,2108b49c <__adddf3+0x784>
2108b348:	0108303a 	nor	r4,zero,r4
2108b34c:	2000511e 	bne	r4,zero,2108b494 <__adddf3+0x77c>
2108b350:	89a3883a 	add	r17,r17,r6
2108b354:	414b883a 	add	r5,r8,r5
2108b358:	898d803a 	cmpltu	r6,r17,r6
2108b35c:	298b883a 	add	r5,r5,r6
2108b360:	1021883a 	mov	r16,r2
2108b364:	003f0e06 	br	2108afa0 <__flash_rwdata_start+0xfffe8d58>
2108b368:	1000341e 	bne	r2,zero,2108b43c <__adddf3+0x724>
2108b36c:	4184b03a 	or	r2,r8,r6
2108b370:	10006f26 	beq	r2,zero,2108b530 <__adddf3+0x818>
2108b374:	400b883a 	mov	r5,r8
2108b378:	3023883a 	mov	r17,r6
2108b37c:	3825883a 	mov	r18,r7
2108b380:	0401ffc4 	movi	r16,2047
2108b384:	003e8306 	br	2108ad94 <__flash_rwdata_start+0xfffe8b4c>
2108b388:	2c62b03a 	or	r17,r5,r17
2108b38c:	8822c03a 	cmpne	r17,r17,zero
2108b390:	0007883a 	mov	r3,zero
2108b394:	003f9506 	br	2108b1ec <__flash_rwdata_start+0xfffe8fa4>
2108b398:	1021883a 	mov	r16,r2
2108b39c:	000b883a 	mov	r5,zero
2108b3a0:	0023883a 	mov	r17,zero
2108b3a4:	003edb06 	br	2108af14 <__flash_rwdata_start+0xfffe8ccc>
2108b3a8:	01c1ffc4 	movi	r7,2047
2108b3ac:	11c03b26 	beq	r2,r7,2108b49c <__adddf3+0x784>
2108b3b0:	0109c83a 	sub	r4,zero,r4
2108b3b4:	29402034 	orhi	r5,r5,128
2108b3b8:	01c00e04 	movi	r7,56
2108b3bc:	39006216 	blt	r7,r4,2108b548 <__adddf3+0x830>
2108b3c0:	01c007c4 	movi	r7,31
2108b3c4:	39006b16 	blt	r7,r4,2108b574 <__adddf3+0x85c>
2108b3c8:	01c00804 	movi	r7,32
2108b3cc:	390fc83a 	sub	r7,r7,r4
2108b3d0:	29d4983a 	sll	r10,r5,r7
2108b3d4:	8912d83a 	srl	r9,r17,r4
2108b3d8:	89ce983a 	sll	r7,r17,r7
2108b3dc:	2908d83a 	srl	r4,r5,r4
2108b3e0:	5262b03a 	or	r17,r10,r9
2108b3e4:	380ac03a 	cmpne	r5,r7,zero
2108b3e8:	8962b03a 	or	r17,r17,r5
2108b3ec:	89a3883a 	add	r17,r17,r6
2108b3f0:	2211883a 	add	r8,r4,r8
2108b3f4:	898d803a 	cmpltu	r6,r17,r6
2108b3f8:	418b883a 	add	r5,r8,r6
2108b3fc:	1021883a 	mov	r16,r2
2108b400:	003ee706 	br	2108afa0 <__flash_rwdata_start+0xfffe8d58>
2108b404:	4184b03a 	or	r2,r8,r6
2108b408:	103e6226 	beq	r2,zero,2108ad94 <__flash_rwdata_start+0xfffe8b4c>
2108b40c:	8987c83a 	sub	r3,r17,r6
2108b410:	88c9803a 	cmpltu	r4,r17,r3
2108b414:	2a05c83a 	sub	r2,r5,r8
2108b418:	1105c83a 	sub	r2,r2,r4
2108b41c:	1100202c 	andhi	r4,r2,128
2108b420:	203f0426 	beq	r4,zero,2108b034 <__flash_rwdata_start+0xfffe8dec>
2108b424:	3463c83a 	sub	r17,r6,r17
2108b428:	414bc83a 	sub	r5,r8,r5
2108b42c:	344d803a 	cmpltu	r6,r6,r17
2108b430:	298bc83a 	sub	r5,r5,r6
2108b434:	3825883a 	mov	r18,r7
2108b438:	003e5606 	br	2108ad94 <__flash_rwdata_start+0xfffe8b4c>
2108b43c:	4184b03a 	or	r2,r8,r6
2108b440:	10002b26 	beq	r2,zero,2108b4f0 <__adddf3+0x7d8>
2108b444:	2804d0fa 	srli	r2,r5,3
2108b448:	8822d0fa 	srli	r17,r17,3
2108b44c:	280a977a 	slli	r5,r5,29
2108b450:	10c0022c 	andhi	r3,r2,8
2108b454:	2c62b03a 	or	r17,r5,r17
2108b458:	18000826 	beq	r3,zero,2108b47c <__adddf3+0x764>
2108b45c:	4008d0fa 	srli	r4,r8,3
2108b460:	20c0022c 	andhi	r3,r4,8
2108b464:	1800051e 	bne	r3,zero,2108b47c <__adddf3+0x764>
2108b468:	300cd0fa 	srli	r6,r6,3
2108b46c:	4010977a 	slli	r8,r8,29
2108b470:	2005883a 	mov	r2,r4
2108b474:	3825883a 	mov	r18,r7
2108b478:	41a2b03a 	or	r17,r8,r6
2108b47c:	880ad77a 	srli	r5,r17,29
2108b480:	100490fa 	slli	r2,r2,3
2108b484:	882290fa 	slli	r17,r17,3
2108b488:	0401ffc4 	movi	r16,2047
2108b48c:	288ab03a 	or	r5,r5,r2
2108b490:	003e4006 	br	2108ad94 <__flash_rwdata_start+0xfffe8b4c>
2108b494:	01c1ffc4 	movi	r7,2047
2108b498:	11ffc71e 	bne	r2,r7,2108b3b8 <__flash_rwdata_start+0xfffe9170>
2108b49c:	400b883a 	mov	r5,r8
2108b4a0:	3023883a 	mov	r17,r6
2108b4a4:	1021883a 	mov	r16,r2
2108b4a8:	003e3a06 	br	2108ad94 <__flash_rwdata_start+0xfffe8b4c>
2108b4ac:	10002d26 	beq	r2,zero,2108b564 <__adddf3+0x84c>
2108b4b0:	4184b03a 	or	r2,r8,r6
2108b4b4:	10000e26 	beq	r2,zero,2108b4f0 <__adddf3+0x7d8>
2108b4b8:	2804d0fa 	srli	r2,r5,3
2108b4bc:	8822d0fa 	srli	r17,r17,3
2108b4c0:	280a977a 	slli	r5,r5,29
2108b4c4:	10c0022c 	andhi	r3,r2,8
2108b4c8:	2c62b03a 	or	r17,r5,r17
2108b4cc:	183feb26 	beq	r3,zero,2108b47c <__flash_rwdata_start+0xfffe9234>
2108b4d0:	4008d0fa 	srli	r4,r8,3
2108b4d4:	20c0022c 	andhi	r3,r4,8
2108b4d8:	183fe81e 	bne	r3,zero,2108b47c <__flash_rwdata_start+0xfffe9234>
2108b4dc:	300cd0fa 	srli	r6,r6,3
2108b4e0:	4010977a 	slli	r8,r8,29
2108b4e4:	2005883a 	mov	r2,r4
2108b4e8:	41a2b03a 	or	r17,r8,r6
2108b4ec:	003fe306 	br	2108b47c <__flash_rwdata_start+0xfffe9234>
2108b4f0:	0401ffc4 	movi	r16,2047
2108b4f4:	003e2706 	br	2108ad94 <__flash_rwdata_start+0xfffe8b4c>
2108b4f8:	0011883a 	mov	r8,zero
2108b4fc:	003f8306 	br	2108b30c <__flash_rwdata_start+0xfffe90c4>
2108b500:	193ff804 	addi	r4,r3,-32
2108b504:	02400804 	movi	r9,32
2108b508:	2908d83a 	srl	r4,r5,r4
2108b50c:	1a402526 	beq	r3,r9,2108b5a4 <__adddf3+0x88c>
2108b510:	02401004 	movi	r9,64
2108b514:	48c7c83a 	sub	r3,r9,r3
2108b518:	28ca983a 	sll	r5,r5,r3
2108b51c:	2c62b03a 	or	r17,r5,r17
2108b520:	8822c03a 	cmpne	r17,r17,zero
2108b524:	8922b03a 	or	r17,r17,r4
2108b528:	0007883a 	mov	r3,zero
2108b52c:	003f2f06 	br	2108b1ec <__flash_rwdata_start+0xfffe8fa4>
2108b530:	01402034 	movhi	r5,128
2108b534:	0007883a 	mov	r3,zero
2108b538:	297fffc4 	addi	r5,r5,-1
2108b53c:	047ffe04 	movi	r17,-8
2108b540:	0401ffc4 	movi	r16,2047
2108b544:	003e7306 	br	2108af14 <__flash_rwdata_start+0xfffe8ccc>
2108b548:	2c62b03a 	or	r17,r5,r17
2108b54c:	8822c03a 	cmpne	r17,r17,zero
2108b550:	0009883a 	mov	r4,zero
2108b554:	003fa506 	br	2108b3ec <__flash_rwdata_start+0xfffe91a4>
2108b558:	400b883a 	mov	r5,r8
2108b55c:	3023883a 	mov	r17,r6
2108b560:	003e0c06 	br	2108ad94 <__flash_rwdata_start+0xfffe8b4c>
2108b564:	400b883a 	mov	r5,r8
2108b568:	3023883a 	mov	r17,r6
2108b56c:	0401ffc4 	movi	r16,2047
2108b570:	003e0806 	br	2108ad94 <__flash_rwdata_start+0xfffe8b4c>
2108b574:	21fff804 	addi	r7,r4,-32
2108b578:	02400804 	movi	r9,32
2108b57c:	29ced83a 	srl	r7,r5,r7
2108b580:	22400a26 	beq	r4,r9,2108b5ac <__adddf3+0x894>
2108b584:	02401004 	movi	r9,64
2108b588:	4909c83a 	sub	r4,r9,r4
2108b58c:	290a983a 	sll	r5,r5,r4
2108b590:	2c62b03a 	or	r17,r5,r17
2108b594:	8822c03a 	cmpne	r17,r17,zero
2108b598:	89e2b03a 	or	r17,r17,r7
2108b59c:	0009883a 	mov	r4,zero
2108b5a0:	003f9206 	br	2108b3ec <__flash_rwdata_start+0xfffe91a4>
2108b5a4:	000b883a 	mov	r5,zero
2108b5a8:	003fdc06 	br	2108b51c <__flash_rwdata_start+0xfffe92d4>
2108b5ac:	000b883a 	mov	r5,zero
2108b5b0:	003ff706 	br	2108b590 <__flash_rwdata_start+0xfffe9348>

2108b5b4 <__divdf3>:
2108b5b4:	defff204 	addi	sp,sp,-56
2108b5b8:	dd000815 	stw	r20,32(sp)
2108b5bc:	2828d53a 	srli	r20,r5,20
2108b5c0:	dd800a15 	stw	r22,40(sp)
2108b5c4:	282cd7fa 	srli	r22,r5,31
2108b5c8:	dc000415 	stw	r16,16(sp)
2108b5cc:	04000434 	movhi	r16,16
2108b5d0:	df000c15 	stw	fp,48(sp)
2108b5d4:	dcc00715 	stw	r19,28(sp)
2108b5d8:	dc800615 	stw	r18,24(sp)
2108b5dc:	dc400515 	stw	r17,20(sp)
2108b5e0:	843fffc4 	addi	r16,r16,-1
2108b5e4:	dfc00d15 	stw	ra,52(sp)
2108b5e8:	ddc00b15 	stw	r23,44(sp)
2108b5ec:	dd400915 	stw	r21,36(sp)
2108b5f0:	a501ffcc 	andi	r20,r20,2047
2108b5f4:	2025883a 	mov	r18,r4
2108b5f8:	2027883a 	mov	r19,r4
2108b5fc:	2c22703a 	and	r17,r5,r16
2108b600:	b7003fcc 	andi	fp,r22,255
2108b604:	a0005e26 	beq	r20,zero,2108b780 <__divdf3+0x1cc>
2108b608:	0081ffc4 	movi	r2,2047
2108b60c:	a0803526 	beq	r20,r2,2108b6e4 <__divdf3+0x130>
2108b610:	8c000434 	orhi	r16,r17,16
2108b614:	2004d77a 	srli	r2,r4,29
2108b618:	802090fa 	slli	r16,r16,3
2108b61c:	202690fa 	slli	r19,r4,3
2108b620:	a53f0044 	addi	r20,r20,-1023
2108b624:	80a2b03a 	or	r17,r16,r2
2108b628:	0025883a 	mov	r18,zero
2108b62c:	0011883a 	mov	r8,zero
2108b630:	380ad53a 	srli	r5,r7,20
2108b634:	382ed7fa 	srli	r23,r7,31
2108b638:	04000434 	movhi	r16,16
2108b63c:	843fffc4 	addi	r16,r16,-1
2108b640:	2941ffcc 	andi	r5,r5,2047
2108b644:	302b883a 	mov	r21,r6
2108b648:	3c20703a 	and	r16,r7,r16
2108b64c:	ba403fcc 	andi	r9,r23,255
2108b650:	28006726 	beq	r5,zero,2108b7f0 <__divdf3+0x23c>
2108b654:	0081ffc4 	movi	r2,2047
2108b658:	28805f26 	beq	r5,r2,2108b7d8 <__divdf3+0x224>
2108b65c:	84000434 	orhi	r16,r16,16
2108b660:	3004d77a 	srli	r2,r6,29
2108b664:	802090fa 	slli	r16,r16,3
2108b668:	302a90fa 	slli	r21,r6,3
2108b66c:	297f0044 	addi	r5,r5,-1023
2108b670:	80a0b03a 	or	r16,r16,r2
2108b674:	000f883a 	mov	r7,zero
2108b678:	3c86b03a 	or	r3,r7,r18
2108b67c:	180690ba 	slli	r3,r3,2
2108b680:	00884274 	movhi	r2,8457
2108b684:	10ada904 	addi	r2,r2,-18780
2108b688:	1887883a 	add	r3,r3,r2
2108b68c:	18c00017 	ldw	r3,0(r3)
2108b690:	b5c8f03a 	xor	r4,r22,r23
2108b694:	200d883a 	mov	r6,r4
2108b698:	24803fcc 	andi	r18,r4,255
2108b69c:	a169c83a 	sub	r20,r20,r5
2108b6a0:	1800683a 	jmp	r3
2108b6a4:	2108b8ec 	andhi	r4,r4,8931
2108b6a8:	2108b71c 	xori	r4,r4,8924
2108b6ac:	2108b8b0 	cmpltui	r4,r4,8930
2108b6b0:	2108b700 	call	22108b70 <__flash_rwdata_start+0x1066928>
2108b6b4:	2108b8b0 	cmpltui	r4,r4,8930
2108b6b8:	2108b884 	addi	r4,r4,8930
2108b6bc:	2108b8b0 	cmpltui	r4,r4,8930
2108b6c0:	2108b700 	call	22108b70 <__flash_rwdata_start+0x1066928>
2108b6c4:	2108b71c 	xori	r4,r4,8924
2108b6c8:	2108b71c 	xori	r4,r4,8924
2108b6cc:	2108b884 	addi	r4,r4,8930
2108b6d0:	2108b700 	call	22108b70 <__flash_rwdata_start+0x1066928>
2108b6d4:	2108b710 	cmplti	r4,r4,8924
2108b6d8:	2108b710 	cmplti	r4,r4,8924
2108b6dc:	2108b710 	cmplti	r4,r4,8924
2108b6e0:	2108b8c0 	call	22108b8c <__flash_rwdata_start+0x1066944>
2108b6e4:	8904b03a 	or	r2,r17,r4
2108b6e8:	1000631e 	bne	r2,zero,2108b878 <__divdf3+0x2c4>
2108b6ec:	04800204 	movi	r18,8
2108b6f0:	0023883a 	mov	r17,zero
2108b6f4:	0027883a 	mov	r19,zero
2108b6f8:	02000084 	movi	r8,2
2108b6fc:	003fcc06 	br	2108b630 <__flash_rwdata_start+0xfffe93e8>
2108b700:	8023883a 	mov	r17,r16
2108b704:	a827883a 	mov	r19,r21
2108b708:	4839883a 	mov	fp,r9
2108b70c:	3811883a 	mov	r8,r7
2108b710:	00800084 	movi	r2,2
2108b714:	40812a1e 	bne	r8,r2,2108bbc0 <__divdf3+0x60c>
2108b718:	e025883a 	mov	r18,fp
2108b71c:	9180004c 	andi	r6,r18,1
2108b720:	0101ffc4 	movi	r4,2047
2108b724:	000b883a 	mov	r5,zero
2108b728:	0027883a 	mov	r19,zero
2108b72c:	2008953a 	slli	r4,r4,20
2108b730:	30c03fcc 	andi	r3,r6,255
2108b734:	04000434 	movhi	r16,16
2108b738:	180697fa 	slli	r3,r3,31
2108b73c:	843fffc4 	addi	r16,r16,-1
2108b740:	2c20703a 	and	r16,r5,r16
2108b744:	8120b03a 	or	r16,r16,r4
2108b748:	80c6b03a 	or	r3,r16,r3
2108b74c:	9805883a 	mov	r2,r19
2108b750:	dfc00d17 	ldw	ra,52(sp)
2108b754:	df000c17 	ldw	fp,48(sp)
2108b758:	ddc00b17 	ldw	r23,44(sp)
2108b75c:	dd800a17 	ldw	r22,40(sp)
2108b760:	dd400917 	ldw	r21,36(sp)
2108b764:	dd000817 	ldw	r20,32(sp)
2108b768:	dcc00717 	ldw	r19,28(sp)
2108b76c:	dc800617 	ldw	r18,24(sp)
2108b770:	dc400517 	ldw	r17,20(sp)
2108b774:	dc000417 	ldw	r16,16(sp)
2108b778:	dec00e04 	addi	sp,sp,56
2108b77c:	f800283a 	ret
2108b780:	8904b03a 	or	r2,r17,r4
2108b784:	10003726 	beq	r2,zero,2108b864 <__divdf3+0x2b0>
2108b788:	88011c26 	beq	r17,zero,2108bbfc <__divdf3+0x648>
2108b78c:	8809883a 	mov	r4,r17
2108b790:	d9800315 	stw	r6,12(sp)
2108b794:	d9c00115 	stw	r7,4(sp)
2108b798:	108d3f80 	call	2108d3f8 <__clzsi2>
2108b79c:	d9800317 	ldw	r6,12(sp)
2108b7a0:	d9c00117 	ldw	r7,4(sp)
2108b7a4:	1007883a 	mov	r3,r2
2108b7a8:	01000a04 	movi	r4,40
2108b7ac:	1cfffe04 	addi	r19,r3,-8
2108b7b0:	20c9c83a 	sub	r4,r4,r3
2108b7b4:	8cca983a 	sll	r5,r17,r19
2108b7b8:	9108d83a 	srl	r4,r18,r4
2108b7bc:	94e6983a 	sll	r19,r18,r19
2108b7c0:	2162b03a 	or	r17,r4,r5
2108b7c4:	053f0344 	movi	r20,-1011
2108b7c8:	a0e9c83a 	sub	r20,r20,r3
2108b7cc:	0025883a 	mov	r18,zero
2108b7d0:	0011883a 	mov	r8,zero
2108b7d4:	003f9606 	br	2108b630 <__flash_rwdata_start+0xfffe93e8>
2108b7d8:	8184b03a 	or	r2,r16,r6
2108b7dc:	10001f1e 	bne	r2,zero,2108b85c <__divdf3+0x2a8>
2108b7e0:	0021883a 	mov	r16,zero
2108b7e4:	002b883a 	mov	r21,zero
2108b7e8:	01c00084 	movi	r7,2
2108b7ec:	003fa206 	br	2108b678 <__flash_rwdata_start+0xfffe9430>
2108b7f0:	8184b03a 	or	r2,r16,r6
2108b7f4:	10001526 	beq	r2,zero,2108b84c <__divdf3+0x298>
2108b7f8:	80010c26 	beq	r16,zero,2108bc2c <__divdf3+0x678>
2108b7fc:	8009883a 	mov	r4,r16
2108b800:	d9800315 	stw	r6,12(sp)
2108b804:	da000215 	stw	r8,8(sp)
2108b808:	da400015 	stw	r9,0(sp)
2108b80c:	108d3f80 	call	2108d3f8 <__clzsi2>
2108b810:	d9800317 	ldw	r6,12(sp)
2108b814:	da000217 	ldw	r8,8(sp)
2108b818:	da400017 	ldw	r9,0(sp)
2108b81c:	1007883a 	mov	r3,r2
2108b820:	01000a04 	movi	r4,40
2108b824:	1d7ffe04 	addi	r21,r3,-8
2108b828:	20c9c83a 	sub	r4,r4,r3
2108b82c:	8560983a 	sll	r16,r16,r21
2108b830:	3108d83a 	srl	r4,r6,r4
2108b834:	356a983a 	sll	r21,r6,r21
2108b838:	2420b03a 	or	r16,r4,r16
2108b83c:	017f0344 	movi	r5,-1011
2108b840:	28cbc83a 	sub	r5,r5,r3
2108b844:	000f883a 	mov	r7,zero
2108b848:	003f8b06 	br	2108b678 <__flash_rwdata_start+0xfffe9430>
2108b84c:	0021883a 	mov	r16,zero
2108b850:	002b883a 	mov	r21,zero
2108b854:	01c00044 	movi	r7,1
2108b858:	003f8706 	br	2108b678 <__flash_rwdata_start+0xfffe9430>
2108b85c:	01c000c4 	movi	r7,3
2108b860:	003f8506 	br	2108b678 <__flash_rwdata_start+0xfffe9430>
2108b864:	04800104 	movi	r18,4
2108b868:	0023883a 	mov	r17,zero
2108b86c:	0027883a 	mov	r19,zero
2108b870:	02000044 	movi	r8,1
2108b874:	003f6e06 	br	2108b630 <__flash_rwdata_start+0xfffe93e8>
2108b878:	04800304 	movi	r18,12
2108b87c:	020000c4 	movi	r8,3
2108b880:	003f6b06 	br	2108b630 <__flash_rwdata_start+0xfffe93e8>
2108b884:	01400434 	movhi	r5,16
2108b888:	000d883a 	mov	r6,zero
2108b88c:	297fffc4 	addi	r5,r5,-1
2108b890:	04ffffc4 	movi	r19,-1
2108b894:	0101ffc4 	movi	r4,2047
2108b898:	003fa406 	br	2108b72c <__flash_rwdata_start+0xfffe94e4>
2108b89c:	043f0084 	movi	r16,-1022
2108b8a0:	8521c83a 	sub	r16,r16,r20
2108b8a4:	00800e04 	movi	r2,56
2108b8a8:	1401200e 	bge	r2,r16,2108bd2c <__divdf3+0x778>
2108b8ac:	9180004c 	andi	r6,r18,1
2108b8b0:	0009883a 	mov	r4,zero
2108b8b4:	000b883a 	mov	r5,zero
2108b8b8:	0027883a 	mov	r19,zero
2108b8bc:	003f9b06 	br	2108b72c <__flash_rwdata_start+0xfffe94e4>
2108b8c0:	8880022c 	andhi	r2,r17,8
2108b8c4:	1000c726 	beq	r2,zero,2108bbe4 <__divdf3+0x630>
2108b8c8:	8080022c 	andhi	r2,r16,8
2108b8cc:	1000c51e 	bne	r2,zero,2108bbe4 <__divdf3+0x630>
2108b8d0:	00800434 	movhi	r2,16
2108b8d4:	81400234 	orhi	r5,r16,8
2108b8d8:	10bfffc4 	addi	r2,r2,-1
2108b8dc:	b80d883a 	mov	r6,r23
2108b8e0:	288a703a 	and	r5,r5,r2
2108b8e4:	a827883a 	mov	r19,r21
2108b8e8:	003fea06 	br	2108b894 <__flash_rwdata_start+0xfffe964c>
2108b8ec:	8440ea36 	bltu	r16,r17,2108bc98 <__divdf3+0x6e4>
2108b8f0:	8c00e826 	beq	r17,r16,2108bc94 <__divdf3+0x6e0>
2108b8f4:	a53fffc4 	addi	r20,r20,-1
2108b8f8:	882d883a 	mov	r22,r17
2108b8fc:	000d883a 	mov	r6,zero
2108b900:	a804d63a 	srli	r2,r21,24
2108b904:	8020923a 	slli	r16,r16,8
2108b908:	b009883a 	mov	r4,r22
2108b90c:	d9800315 	stw	r6,12(sp)
2108b910:	1420b03a 	or	r16,r2,r16
2108b914:	802ed43a 	srli	r23,r16,16
2108b918:	873fffcc 	andi	fp,r16,65535
2108b91c:	a82a923a 	slli	r21,r21,8
2108b920:	b80b883a 	mov	r5,r23
2108b924:	108d5780 	call	2108d578 <__udivsi3>
2108b928:	b009883a 	mov	r4,r22
2108b92c:	b80b883a 	mov	r5,r23
2108b930:	1023883a 	mov	r17,r2
2108b934:	108d5800 	call	2108d580 <__umodsi3>
2108b938:	1004943a 	slli	r2,r2,16
2108b93c:	9808d43a 	srli	r4,r19,16
2108b940:	8f2d383a 	mul	r22,r17,fp
2108b944:	d9800317 	ldw	r6,12(sp)
2108b948:	1106b03a 	or	r3,r2,r4
2108b94c:	1d80062e 	bgeu	r3,r22,2108b968 <__divdf3+0x3b4>
2108b950:	1c07883a 	add	r3,r3,r16
2108b954:	88bfffc4 	addi	r2,r17,-1
2108b958:	1c00dc36 	bltu	r3,r16,2108bccc <__divdf3+0x718>
2108b95c:	1d80db2e 	bgeu	r3,r22,2108bccc <__divdf3+0x718>
2108b960:	8c7fff84 	addi	r17,r17,-2
2108b964:	1c07883a 	add	r3,r3,r16
2108b968:	1dadc83a 	sub	r22,r3,r22
2108b96c:	b009883a 	mov	r4,r22
2108b970:	b80b883a 	mov	r5,r23
2108b974:	d9800315 	stw	r6,12(sp)
2108b978:	108d5780 	call	2108d578 <__udivsi3>
2108b97c:	b009883a 	mov	r4,r22
2108b980:	b80b883a 	mov	r5,r23
2108b984:	d8800015 	stw	r2,0(sp)
2108b988:	108d5800 	call	2108d580 <__umodsi3>
2108b98c:	da400017 	ldw	r9,0(sp)
2108b990:	1004943a 	slli	r2,r2,16
2108b994:	9cffffcc 	andi	r19,r19,65535
2108b998:	4f07383a 	mul	r3,r9,fp
2108b99c:	14c8b03a 	or	r4,r2,r19
2108b9a0:	d9800317 	ldw	r6,12(sp)
2108b9a4:	20c0062e 	bgeu	r4,r3,2108b9c0 <__divdf3+0x40c>
2108b9a8:	2409883a 	add	r4,r4,r16
2108b9ac:	48bfffc4 	addi	r2,r9,-1
2108b9b0:	2400c436 	bltu	r4,r16,2108bcc4 <__divdf3+0x710>
2108b9b4:	20c0c32e 	bgeu	r4,r3,2108bcc4 <__divdf3+0x710>
2108b9b8:	4a7fff84 	addi	r9,r9,-2
2108b9bc:	2409883a 	add	r4,r4,r16
2108b9c0:	8822943a 	slli	r17,r17,16
2108b9c4:	a80ed43a 	srli	r7,r21,16
2108b9c8:	aa3fffcc 	andi	r8,r21,65535
2108b9cc:	4c62b03a 	or	r17,r9,r17
2108b9d0:	8816d43a 	srli	r11,r17,16
2108b9d4:	897fffcc 	andi	r5,r17,65535
2108b9d8:	2a15383a 	mul	r10,r5,r8
2108b9dc:	5a19383a 	mul	r12,r11,r8
2108b9e0:	29cb383a 	mul	r5,r5,r7
2108b9e4:	5012d43a 	srli	r9,r10,16
2108b9e8:	20c5c83a 	sub	r2,r4,r3
2108b9ec:	614b883a 	add	r5,r12,r5
2108b9f0:	2a4b883a 	add	r5,r5,r9
2108b9f4:	59c7383a 	mul	r3,r11,r7
2108b9f8:	2b00022e 	bgeu	r5,r12,2108ba04 <__divdf3+0x450>
2108b9fc:	01000074 	movhi	r4,1
2108ba00:	1907883a 	add	r3,r3,r4
2108ba04:	2808d43a 	srli	r4,r5,16
2108ba08:	280a943a 	slli	r5,r5,16
2108ba0c:	54ffffcc 	andi	r19,r10,65535
2108ba10:	1907883a 	add	r3,r3,r4
2108ba14:	2ccb883a 	add	r5,r5,r19
2108ba18:	10c09336 	bltu	r2,r3,2108bc68 <__divdf3+0x6b4>
2108ba1c:	10c0ad26 	beq	r2,r3,2108bcd4 <__divdf3+0x720>
2108ba20:	10c7c83a 	sub	r3,r2,r3
2108ba24:	3167c83a 	sub	r19,r6,r5
2108ba28:	34ed803a 	cmpltu	r22,r6,r19
2108ba2c:	1dadc83a 	sub	r22,r3,r22
2108ba30:	b400b226 	beq	r22,r16,2108bcfc <__divdf3+0x748>
2108ba34:	b009883a 	mov	r4,r22
2108ba38:	b80b883a 	mov	r5,r23
2108ba3c:	d9c00115 	stw	r7,4(sp)
2108ba40:	da000215 	stw	r8,8(sp)
2108ba44:	108d5780 	call	2108d578 <__udivsi3>
2108ba48:	b009883a 	mov	r4,r22
2108ba4c:	b80b883a 	mov	r5,r23
2108ba50:	d8800315 	stw	r2,12(sp)
2108ba54:	108d5800 	call	2108d580 <__umodsi3>
2108ba58:	d9800317 	ldw	r6,12(sp)
2108ba5c:	1004943a 	slli	r2,r2,16
2108ba60:	9808d43a 	srli	r4,r19,16
2108ba64:	372d383a 	mul	r22,r6,fp
2108ba68:	d9c00117 	ldw	r7,4(sp)
2108ba6c:	1106b03a 	or	r3,r2,r4
2108ba70:	da000217 	ldw	r8,8(sp)
2108ba74:	1d80062e 	bgeu	r3,r22,2108ba90 <__divdf3+0x4dc>
2108ba78:	1c07883a 	add	r3,r3,r16
2108ba7c:	30bfffc4 	addi	r2,r6,-1
2108ba80:	1c00a036 	bltu	r3,r16,2108bd04 <__divdf3+0x750>
2108ba84:	1d809f2e 	bgeu	r3,r22,2108bd04 <__divdf3+0x750>
2108ba88:	31bfff84 	addi	r6,r6,-2
2108ba8c:	1c07883a 	add	r3,r3,r16
2108ba90:	1dadc83a 	sub	r22,r3,r22
2108ba94:	b009883a 	mov	r4,r22
2108ba98:	b80b883a 	mov	r5,r23
2108ba9c:	d9800315 	stw	r6,12(sp)
2108baa0:	d9c00115 	stw	r7,4(sp)
2108baa4:	da000215 	stw	r8,8(sp)
2108baa8:	108d5780 	call	2108d578 <__udivsi3>
2108baac:	b009883a 	mov	r4,r22
2108bab0:	b80b883a 	mov	r5,r23
2108bab4:	d8800015 	stw	r2,0(sp)
2108bab8:	108d5800 	call	2108d580 <__umodsi3>
2108babc:	da400017 	ldw	r9,0(sp)
2108bac0:	1004943a 	slli	r2,r2,16
2108bac4:	993fffcc 	andi	r4,r19,65535
2108bac8:	4f39383a 	mul	fp,r9,fp
2108bacc:	1106b03a 	or	r3,r2,r4
2108bad0:	d9800317 	ldw	r6,12(sp)
2108bad4:	d9c00117 	ldw	r7,4(sp)
2108bad8:	da000217 	ldw	r8,8(sp)
2108badc:	1f00062e 	bgeu	r3,fp,2108baf8 <__divdf3+0x544>
2108bae0:	1c07883a 	add	r3,r3,r16
2108bae4:	48bfffc4 	addi	r2,r9,-1
2108bae8:	1c008836 	bltu	r3,r16,2108bd0c <__divdf3+0x758>
2108baec:	1f00872e 	bgeu	r3,fp,2108bd0c <__divdf3+0x758>
2108baf0:	4a7fff84 	addi	r9,r9,-2
2108baf4:	1c07883a 	add	r3,r3,r16
2108baf8:	3008943a 	slli	r4,r6,16
2108bafc:	1f07c83a 	sub	r3,r3,fp
2108bb00:	4926b03a 	or	r19,r9,r4
2108bb04:	993fffcc 	andi	r4,r19,65535
2108bb08:	980cd43a 	srli	r6,r19,16
2108bb0c:	220b383a 	mul	r5,r4,r8
2108bb10:	21c5383a 	mul	r2,r4,r7
2108bb14:	3211383a 	mul	r8,r6,r8
2108bb18:	2808d43a 	srli	r4,r5,16
2108bb1c:	31cf383a 	mul	r7,r6,r7
2108bb20:	4085883a 	add	r2,r8,r2
2108bb24:	1105883a 	add	r2,r2,r4
2108bb28:	1200022e 	bgeu	r2,r8,2108bb34 <__divdf3+0x580>
2108bb2c:	01000074 	movhi	r4,1
2108bb30:	390f883a 	add	r7,r7,r4
2108bb34:	1008d43a 	srli	r4,r2,16
2108bb38:	1004943a 	slli	r2,r2,16
2108bb3c:	297fffcc 	andi	r5,r5,65535
2108bb40:	390f883a 	add	r7,r7,r4
2108bb44:	1145883a 	add	r2,r2,r5
2108bb48:	19c06536 	bltu	r3,r7,2108bce0 <__divdf3+0x72c>
2108bb4c:	19c09f26 	beq	r3,r7,2108bdcc <__divdf3+0x818>
2108bb50:	9cc00054 	ori	r19,r19,1
2108bb54:	a100ffc4 	addi	r4,r20,1023
2108bb58:	013f500e 	bge	zero,r4,2108b89c <__flash_rwdata_start+0xfffe9654>
2108bb5c:	988001cc 	andi	r2,r19,7
2108bb60:	10000726 	beq	r2,zero,2108bb80 <__divdf3+0x5cc>
2108bb64:	98c003cc 	andi	r3,r19,15
2108bb68:	00800104 	movi	r2,4
2108bb6c:	18800426 	beq	r3,r2,2108bb80 <__divdf3+0x5cc>
2108bb70:	9885883a 	add	r2,r19,r2
2108bb74:	14e1803a 	cmpltu	r16,r2,r19
2108bb78:	8c23883a 	add	r17,r17,r16
2108bb7c:	1027883a 	mov	r19,r2
2108bb80:	8880402c 	andhi	r2,r17,256
2108bb84:	10000426 	beq	r2,zero,2108bb98 <__divdf3+0x5e4>
2108bb88:	00bfc034 	movhi	r2,65280
2108bb8c:	10bfffc4 	addi	r2,r2,-1
2108bb90:	a1010004 	addi	r4,r20,1024
2108bb94:	88a2703a 	and	r17,r17,r2
2108bb98:	0081ff84 	movi	r2,2046
2108bb9c:	113edf16 	blt	r2,r4,2108b71c <__flash_rwdata_start+0xfffe94d4>
2108bba0:	9826d0fa 	srli	r19,r19,3
2108bba4:	8804977a 	slli	r2,r17,29
2108bba8:	8820927a 	slli	r16,r17,9
2108bbac:	2101ffcc 	andi	r4,r4,2047
2108bbb0:	14e6b03a 	or	r19,r2,r19
2108bbb4:	800ad33a 	srli	r5,r16,12
2108bbb8:	9180004c 	andi	r6,r18,1
2108bbbc:	003edb06 	br	2108b72c <__flash_rwdata_start+0xfffe94e4>
2108bbc0:	008000c4 	movi	r2,3
2108bbc4:	4080a826 	beq	r8,r2,2108be68 <__divdf3+0x8b4>
2108bbc8:	00800044 	movi	r2,1
2108bbcc:	4080551e 	bne	r8,r2,2108bd24 <__divdf3+0x770>
2108bbd0:	e00d883a 	mov	r6,fp
2108bbd4:	0009883a 	mov	r4,zero
2108bbd8:	000b883a 	mov	r5,zero
2108bbdc:	0027883a 	mov	r19,zero
2108bbe0:	003ed206 	br	2108b72c <__flash_rwdata_start+0xfffe94e4>
2108bbe4:	00800434 	movhi	r2,16
2108bbe8:	89400234 	orhi	r5,r17,8
2108bbec:	10bfffc4 	addi	r2,r2,-1
2108bbf0:	b00d883a 	mov	r6,r22
2108bbf4:	288a703a 	and	r5,r5,r2
2108bbf8:	003f2606 	br	2108b894 <__flash_rwdata_start+0xfffe964c>
2108bbfc:	d9800315 	stw	r6,12(sp)
2108bc00:	d9c00115 	stw	r7,4(sp)
2108bc04:	108d3f80 	call	2108d3f8 <__clzsi2>
2108bc08:	10c00804 	addi	r3,r2,32
2108bc0c:	010009c4 	movi	r4,39
2108bc10:	d9800317 	ldw	r6,12(sp)
2108bc14:	d9c00117 	ldw	r7,4(sp)
2108bc18:	20fee30e 	bge	r4,r3,2108b7a8 <__flash_rwdata_start+0xfffe9560>
2108bc1c:	117ffe04 	addi	r5,r2,-8
2108bc20:	9162983a 	sll	r17,r18,r5
2108bc24:	0027883a 	mov	r19,zero
2108bc28:	003ee606 	br	2108b7c4 <__flash_rwdata_start+0xfffe957c>
2108bc2c:	3009883a 	mov	r4,r6
2108bc30:	d9800315 	stw	r6,12(sp)
2108bc34:	da000215 	stw	r8,8(sp)
2108bc38:	da400015 	stw	r9,0(sp)
2108bc3c:	108d3f80 	call	2108d3f8 <__clzsi2>
2108bc40:	10c00804 	addi	r3,r2,32
2108bc44:	010009c4 	movi	r4,39
2108bc48:	d9800317 	ldw	r6,12(sp)
2108bc4c:	da000217 	ldw	r8,8(sp)
2108bc50:	da400017 	ldw	r9,0(sp)
2108bc54:	20fef20e 	bge	r4,r3,2108b820 <__flash_rwdata_start+0xfffe95d8>
2108bc58:	10bffe04 	addi	r2,r2,-8
2108bc5c:	a8a0983a 	sll	r16,r21,r2
2108bc60:	002b883a 	mov	r21,zero
2108bc64:	003ef506 	br	2108b83c <__flash_rwdata_start+0xfffe95f4>
2108bc68:	354d883a 	add	r6,r6,r21
2108bc6c:	3549803a 	cmpltu	r4,r6,r21
2108bc70:	2409883a 	add	r4,r4,r16
2108bc74:	2089883a 	add	r4,r4,r2
2108bc78:	88bfffc4 	addi	r2,r17,-1
2108bc7c:	81000c2e 	bgeu	r16,r4,2108bcb0 <__divdf3+0x6fc>
2108bc80:	20c04436 	bltu	r4,r3,2108bd94 <__divdf3+0x7e0>
2108bc84:	19006f26 	beq	r3,r4,2108be44 <__divdf3+0x890>
2108bc88:	20c7c83a 	sub	r3,r4,r3
2108bc8c:	1023883a 	mov	r17,r2
2108bc90:	003f6406 	br	2108ba24 <__flash_rwdata_start+0xfffe97dc>
2108bc94:	9d7f1736 	bltu	r19,r21,2108b8f4 <__flash_rwdata_start+0xfffe96ac>
2108bc98:	9806d07a 	srli	r3,r19,1
2108bc9c:	880497fa 	slli	r2,r17,31
2108bca0:	980c97fa 	slli	r6,r19,31
2108bca4:	882cd07a 	srli	r22,r17,1
2108bca8:	18a6b03a 	or	r19,r3,r2
2108bcac:	003f1406 	br	2108b900 <__flash_rwdata_start+0xfffe96b8>
2108bcb0:	243ff51e 	bne	r4,r16,2108bc88 <__flash_rwdata_start+0xfffe9a40>
2108bcb4:	357ff22e 	bgeu	r6,r21,2108bc80 <__flash_rwdata_start+0xfffe9a38>
2108bcb8:	80c7c83a 	sub	r3,r16,r3
2108bcbc:	1023883a 	mov	r17,r2
2108bcc0:	003f5806 	br	2108ba24 <__flash_rwdata_start+0xfffe97dc>
2108bcc4:	1013883a 	mov	r9,r2
2108bcc8:	003f3d06 	br	2108b9c0 <__flash_rwdata_start+0xfffe9778>
2108bccc:	1023883a 	mov	r17,r2
2108bcd0:	003f2506 	br	2108b968 <__flash_rwdata_start+0xfffe9720>
2108bcd4:	317fe436 	bltu	r6,r5,2108bc68 <__flash_rwdata_start+0xfffe9a20>
2108bcd8:	0007883a 	mov	r3,zero
2108bcdc:	003f5106 	br	2108ba24 <__flash_rwdata_start+0xfffe97dc>
2108bce0:	1c07883a 	add	r3,r3,r16
2108bce4:	993fffc4 	addi	r4,r19,-1
2108bce8:	1c000a2e 	bgeu	r3,r16,2108bd14 <__divdf3+0x760>
2108bcec:	2027883a 	mov	r19,r4
2108bcf0:	19ff971e 	bne	r3,r7,2108bb50 <__flash_rwdata_start+0xfffe9908>
2108bcf4:	a8bf961e 	bne	r21,r2,2108bb50 <__flash_rwdata_start+0xfffe9908>
2108bcf8:	003f9606 	br	2108bb54 <__flash_rwdata_start+0xfffe990c>
2108bcfc:	04ffffc4 	movi	r19,-1
2108bd00:	003f9406 	br	2108bb54 <__flash_rwdata_start+0xfffe990c>
2108bd04:	100d883a 	mov	r6,r2
2108bd08:	003f6106 	br	2108ba90 <__flash_rwdata_start+0xfffe9848>
2108bd0c:	1013883a 	mov	r9,r2
2108bd10:	003f7906 	br	2108baf8 <__flash_rwdata_start+0xfffe98b0>
2108bd14:	19c02636 	bltu	r3,r7,2108bdb0 <__divdf3+0x7fc>
2108bd18:	38c04d26 	beq	r7,r3,2108be50 <__divdf3+0x89c>
2108bd1c:	2027883a 	mov	r19,r4
2108bd20:	003f8b06 	br	2108bb50 <__flash_rwdata_start+0xfffe9908>
2108bd24:	e025883a 	mov	r18,fp
2108bd28:	003f8a06 	br	2108bb54 <__flash_rwdata_start+0xfffe990c>
2108bd2c:	008007c4 	movi	r2,31
2108bd30:	14002a16 	blt	r2,r16,2108bddc <__divdf3+0x828>
2108bd34:	a5010784 	addi	r20,r20,1054
2108bd38:	8d04983a 	sll	r2,r17,r20
2108bd3c:	9c06d83a 	srl	r3,r19,r16
2108bd40:	9d28983a 	sll	r20,r19,r20
2108bd44:	8c20d83a 	srl	r16,r17,r16
2108bd48:	1886b03a 	or	r3,r3,r2
2108bd4c:	a004c03a 	cmpne	r2,r20,zero
2108bd50:	1884b03a 	or	r2,r3,r2
2108bd54:	10c001cc 	andi	r3,r2,7
2108bd58:	18000726 	beq	r3,zero,2108bd78 <__divdf3+0x7c4>
2108bd5c:	110003cc 	andi	r4,r2,15
2108bd60:	00c00104 	movi	r3,4
2108bd64:	20c00426 	beq	r4,r3,2108bd78 <__divdf3+0x7c4>
2108bd68:	10c00104 	addi	r3,r2,4
2108bd6c:	1885803a 	cmpltu	r2,r3,r2
2108bd70:	80a1883a 	add	r16,r16,r2
2108bd74:	1805883a 	mov	r2,r3
2108bd78:	80c0202c 	andhi	r3,r16,128
2108bd7c:	18002d26 	beq	r3,zero,2108be34 <__divdf3+0x880>
2108bd80:	9180004c 	andi	r6,r18,1
2108bd84:	01000044 	movi	r4,1
2108bd88:	000b883a 	mov	r5,zero
2108bd8c:	0027883a 	mov	r19,zero
2108bd90:	003e6606 	br	2108b72c <__flash_rwdata_start+0xfffe94e4>
2108bd94:	354d883a 	add	r6,r6,r21
2108bd98:	356d803a 	cmpltu	r22,r6,r21
2108bd9c:	b42d883a 	add	r22,r22,r16
2108bda0:	b12d883a 	add	r22,r22,r4
2108bda4:	8c7fff84 	addi	r17,r17,-2
2108bda8:	b0c7c83a 	sub	r3,r22,r3
2108bdac:	003f1d06 	br	2108ba24 <__flash_rwdata_start+0xfffe97dc>
2108bdb0:	ad4b883a 	add	r5,r21,r21
2108bdb4:	2d6b803a 	cmpltu	r21,r5,r21
2108bdb8:	ac2b883a 	add	r21,r21,r16
2108bdbc:	1d47883a 	add	r3,r3,r21
2108bdc0:	993fff84 	addi	r4,r19,-2
2108bdc4:	282b883a 	mov	r21,r5
2108bdc8:	003fc806 	br	2108bcec <__flash_rwdata_start+0xfffe9aa4>
2108bdcc:	103fc41e 	bne	r2,zero,2108bce0 <__flash_rwdata_start+0xfffe9a98>
2108bdd0:	002b883a 	mov	r21,zero
2108bdd4:	a8bf5e1e 	bne	r21,r2,2108bb50 <__flash_rwdata_start+0xfffe9908>
2108bdd8:	003f5e06 	br	2108bb54 <__flash_rwdata_start+0xfffe990c>
2108bddc:	00bef884 	movi	r2,-1054
2108bde0:	1505c83a 	sub	r2,r2,r20
2108bde4:	00c00804 	movi	r3,32
2108bde8:	8884d83a 	srl	r2,r17,r2
2108bdec:	80c01c26 	beq	r16,r3,2108be60 <__divdf3+0x8ac>
2108bdf0:	a0c10f84 	addi	r3,r20,1086
2108bdf4:	88c6983a 	sll	r3,r17,r3
2108bdf8:	1cc6b03a 	or	r3,r3,r19
2108bdfc:	1806c03a 	cmpne	r3,r3,zero
2108be00:	1884b03a 	or	r2,r3,r2
2108be04:	140001cc 	andi	r16,r2,7
2108be08:	8000061e 	bne	r16,zero,2108be24 <__divdf3+0x870>
2108be0c:	000b883a 	mov	r5,zero
2108be10:	1004d0fa 	srli	r2,r2,3
2108be14:	9180004c 	andi	r6,r18,1
2108be18:	0009883a 	mov	r4,zero
2108be1c:	1426b03a 	or	r19,r2,r16
2108be20:	003e4206 	br	2108b72c <__flash_rwdata_start+0xfffe94e4>
2108be24:	110003cc 	andi	r4,r2,15
2108be28:	00c00104 	movi	r3,4
2108be2c:	0021883a 	mov	r16,zero
2108be30:	20ffcd1e 	bne	r4,r3,2108bd68 <__flash_rwdata_start+0xfffe9b20>
2108be34:	800a927a 	slli	r5,r16,9
2108be38:	8020977a 	slli	r16,r16,29
2108be3c:	280ad33a 	srli	r5,r5,12
2108be40:	003ff306 	br	2108be10 <__flash_rwdata_start+0xfffe9bc8>
2108be44:	317fd336 	bltu	r6,r5,2108bd94 <__flash_rwdata_start+0xfffe9b4c>
2108be48:	1023883a 	mov	r17,r2
2108be4c:	003fa206 	br	2108bcd8 <__flash_rwdata_start+0xfffe9a90>
2108be50:	a8bfd736 	bltu	r21,r2,2108bdb0 <__flash_rwdata_start+0xfffe9b68>
2108be54:	2027883a 	mov	r19,r4
2108be58:	a8bf3d1e 	bne	r21,r2,2108bb50 <__flash_rwdata_start+0xfffe9908>
2108be5c:	003f3d06 	br	2108bb54 <__flash_rwdata_start+0xfffe990c>
2108be60:	0007883a 	mov	r3,zero
2108be64:	003fe406 	br	2108bdf8 <__flash_rwdata_start+0xfffe9bb0>
2108be68:	00800434 	movhi	r2,16
2108be6c:	89400234 	orhi	r5,r17,8
2108be70:	10bfffc4 	addi	r2,r2,-1
2108be74:	e00d883a 	mov	r6,fp
2108be78:	288a703a 	and	r5,r5,r2
2108be7c:	003e8506 	br	2108b894 <__flash_rwdata_start+0xfffe964c>

2108be80 <__gedf2>:
2108be80:	2804d53a 	srli	r2,r5,20
2108be84:	3806d53a 	srli	r3,r7,20
2108be88:	02000434 	movhi	r8,16
2108be8c:	423fffc4 	addi	r8,r8,-1
2108be90:	0241ffc4 	movi	r9,2047
2108be94:	1081ffcc 	andi	r2,r2,2047
2108be98:	2a14703a 	and	r10,r5,r8
2108be9c:	1a46703a 	and	r3,r3,r9
2108bea0:	3a10703a 	and	r8,r7,r8
2108bea4:	280ad7fa 	srli	r5,r5,31
2108bea8:	380ed7fa 	srli	r7,r7,31
2108beac:	12400b26 	beq	r2,r9,2108bedc <__gedf2+0x5c>
2108beb0:	1a401626 	beq	r3,r9,2108bf0c <__gedf2+0x8c>
2108beb4:	10000c1e 	bne	r2,zero,2108bee8 <__gedf2+0x68>
2108beb8:	5112b03a 	or	r9,r10,r4
2108bebc:	4813003a 	cmpeq	r9,r9,zero
2108bec0:	4817883a 	mov	r11,r9
2108bec4:	18000c1e 	bne	r3,zero,2108bef8 <__gedf2+0x78>
2108bec8:	4198b03a 	or	r12,r8,r6
2108becc:	60000a1e 	bne	r12,zero,2108bef8 <__gedf2+0x78>
2108bed0:	48001326 	beq	r9,zero,2108bf20 <__gedf2+0xa0>
2108bed4:	0005883a 	mov	r2,zero
2108bed8:	f800283a 	ret
2108bedc:	5112b03a 	or	r9,r10,r4
2108bee0:	4800191e 	bne	r9,zero,2108bf48 <__gedf2+0xc8>
2108bee4:	18800926 	beq	r3,r2,2108bf0c <__gedf2+0x8c>
2108bee8:	18000b1e 	bne	r3,zero,2108bf18 <__gedf2+0x98>
2108beec:	4192b03a 	or	r9,r8,r6
2108bef0:	0017883a 	mov	r11,zero
2108bef4:	48000a26 	beq	r9,zero,2108bf20 <__gedf2+0xa0>
2108bef8:	39c03fcc 	andi	r7,r7,255
2108befc:	58000726 	beq	r11,zero,2108bf1c <__gedf2+0x9c>
2108bf00:	3800081e 	bne	r7,zero,2108bf24 <__gedf2+0xa4>
2108bf04:	00bfffc4 	movi	r2,-1
2108bf08:	f800283a 	ret
2108bf0c:	4192b03a 	or	r9,r8,r6
2108bf10:	48000d1e 	bne	r9,zero,2108bf48 <__gedf2+0xc8>
2108bf14:	103fe826 	beq	r2,zero,2108beb8 <__flash_rwdata_start+0xfffe9c70>
2108bf18:	39c03fcc 	andi	r7,r7,255
2108bf1c:	29c00326 	beq	r5,r7,2108bf2c <__gedf2+0xac>
2108bf20:	283ff81e 	bne	r5,zero,2108bf04 <__flash_rwdata_start+0xfffe9cbc>
2108bf24:	00800044 	movi	r2,1
2108bf28:	f800283a 	ret
2108bf2c:	18bffc16 	blt	r3,r2,2108bf20 <__flash_rwdata_start+0xfffe9cd8>
2108bf30:	10c00316 	blt	r2,r3,2108bf40 <__gedf2+0xc0>
2108bf34:	42bffa36 	bltu	r8,r10,2108bf20 <__flash_rwdata_start+0xfffe9cd8>
2108bf38:	52000526 	beq	r10,r8,2108bf50 <__gedf2+0xd0>
2108bf3c:	523fe52e 	bgeu	r10,r8,2108bed4 <__flash_rwdata_start+0xfffe9c8c>
2108bf40:	283ff026 	beq	r5,zero,2108bf04 <__flash_rwdata_start+0xfffe9cbc>
2108bf44:	003ff706 	br	2108bf24 <__flash_rwdata_start+0xfffe9cdc>
2108bf48:	00bfff84 	movi	r2,-2
2108bf4c:	f800283a 	ret
2108bf50:	313ff336 	bltu	r6,r4,2108bf20 <__flash_rwdata_start+0xfffe9cd8>
2108bf54:	21bfdf2e 	bgeu	r4,r6,2108bed4 <__flash_rwdata_start+0xfffe9c8c>
2108bf58:	283fea26 	beq	r5,zero,2108bf04 <__flash_rwdata_start+0xfffe9cbc>
2108bf5c:	003ff106 	br	2108bf24 <__flash_rwdata_start+0xfffe9cdc>

2108bf60 <__muldf3>:
2108bf60:	defff204 	addi	sp,sp,-56
2108bf64:	2804d53a 	srli	r2,r5,20
2108bf68:	dd800a15 	stw	r22,40(sp)
2108bf6c:	282cd7fa 	srli	r22,r5,31
2108bf70:	dc000415 	stw	r16,16(sp)
2108bf74:	04000434 	movhi	r16,16
2108bf78:	df000c15 	stw	fp,48(sp)
2108bf7c:	dd000815 	stw	r20,32(sp)
2108bf80:	dcc00715 	stw	r19,28(sp)
2108bf84:	dc800615 	stw	r18,24(sp)
2108bf88:	dc400515 	stw	r17,20(sp)
2108bf8c:	843fffc4 	addi	r16,r16,-1
2108bf90:	dfc00d15 	stw	ra,52(sp)
2108bf94:	ddc00b15 	stw	r23,44(sp)
2108bf98:	dd400915 	stw	r21,36(sp)
2108bf9c:	1501ffcc 	andi	r20,r2,2047
2108bfa0:	2023883a 	mov	r17,r4
2108bfa4:	2025883a 	mov	r18,r4
2108bfa8:	2c20703a 	and	r16,r5,r16
2108bfac:	b027883a 	mov	r19,r22
2108bfb0:	b7003fcc 	andi	fp,r22,255
2108bfb4:	a0005926 	beq	r20,zero,2108c11c <__muldf3+0x1bc>
2108bfb8:	0081ffc4 	movi	r2,2047
2108bfbc:	a0803426 	beq	r20,r2,2108c090 <__muldf3+0x130>
2108bfc0:	84000434 	orhi	r16,r16,16
2108bfc4:	2004d77a 	srli	r2,r4,29
2108bfc8:	802090fa 	slli	r16,r16,3
2108bfcc:	202490fa 	slli	r18,r4,3
2108bfd0:	a53f0044 	addi	r20,r20,-1023
2108bfd4:	80a0b03a 	or	r16,r16,r2
2108bfd8:	002b883a 	mov	r21,zero
2108bfdc:	0015883a 	mov	r10,zero
2108bfe0:	3812d53a 	srli	r9,r7,20
2108bfe4:	3806d7fa 	srli	r3,r7,31
2108bfe8:	02000434 	movhi	r8,16
2108bfec:	423fffc4 	addi	r8,r8,-1
2108bff0:	4941ffcc 	andi	r5,r9,2047
2108bff4:	302f883a 	mov	r23,r6
2108bff8:	3a22703a 	and	r17,r7,r8
2108bffc:	1ac03fcc 	andi	r11,r3,255
2108c000:	28006226 	beq	r5,zero,2108c18c <__muldf3+0x22c>
2108c004:	0081ffc4 	movi	r2,2047
2108c008:	28805a26 	beq	r5,r2,2108c174 <__muldf3+0x214>
2108c00c:	8a000434 	orhi	r8,r17,16
2108c010:	3004d77a 	srli	r2,r6,29
2108c014:	401090fa 	slli	r8,r8,3
2108c018:	302e90fa 	slli	r23,r6,3
2108c01c:	297f0044 	addi	r5,r5,-1023
2108c020:	40a2b03a 	or	r17,r8,r2
2108c024:	0013883a 	mov	r9,zero
2108c028:	4d4cb03a 	or	r6,r9,r21
2108c02c:	300c90ba 	slli	r6,r6,2
2108c030:	02084274 	movhi	r8,8457
2108c034:	42301404 	addi	r8,r8,-16304
2108c038:	320d883a 	add	r6,r6,r8
2108c03c:	31800017 	ldw	r6,0(r6)
2108c040:	a14b883a 	add	r5,r20,r5
2108c044:	1dacf03a 	xor	r22,r3,r22
2108c048:	2b000044 	addi	r12,r5,1
2108c04c:	3000683a 	jmp	r6
2108c050:	2108c28c 	andi	r4,r4,8970
2108c054:	2108c278 	rdprs	r4,r4,8969
2108c058:	2108c278 	rdprs	r4,r4,8969
2108c05c:	2108c264 	muli	r4,r4,8969
2108c060:	2108c0ac 	andhi	r4,r4,8962
2108c064:	2108c0ac 	andhi	r4,r4,8962
2108c068:	2108c24c 	andi	r4,r4,8969
2108c06c:	2108c264 	muli	r4,r4,8969
2108c070:	2108c0ac 	andhi	r4,r4,8962
2108c074:	2108c24c 	andi	r4,r4,8969
2108c078:	2108c0ac 	andhi	r4,r4,8962
2108c07c:	2108c264 	muli	r4,r4,8969
2108c080:	2108c0b0 	cmpltui	r4,r4,8962
2108c084:	2108c0b0 	cmpltui	r4,r4,8962
2108c088:	2108c0b0 	cmpltui	r4,r4,8962
2108c08c:	2108c488 	cmpgei	r4,r4,8978
2108c090:	8104b03a 	or	r2,r16,r4
2108c094:	10006a1e 	bne	r2,zero,2108c240 <__muldf3+0x2e0>
2108c098:	05400204 	movi	r21,8
2108c09c:	0021883a 	mov	r16,zero
2108c0a0:	0025883a 	mov	r18,zero
2108c0a4:	02800084 	movi	r10,2
2108c0a8:	003fcd06 	br	2108bfe0 <__flash_rwdata_start+0xfffe9d98>
2108c0ac:	b039883a 	mov	fp,r22
2108c0b0:	00800084 	movi	r2,2
2108c0b4:	50804e1e 	bne	r10,r2,2108c1f0 <__muldf3+0x290>
2108c0b8:	e4c0004c 	andi	r19,fp,1
2108c0bc:	0101ffc4 	movi	r4,2047
2108c0c0:	0021883a 	mov	r16,zero
2108c0c4:	0025883a 	mov	r18,zero
2108c0c8:	2008953a 	slli	r4,r4,20
2108c0cc:	98c03fcc 	andi	r3,r19,255
2108c0d0:	01400434 	movhi	r5,16
2108c0d4:	297fffc4 	addi	r5,r5,-1
2108c0d8:	180697fa 	slli	r3,r3,31
2108c0dc:	8160703a 	and	r16,r16,r5
2108c0e0:	8120b03a 	or	r16,r16,r4
2108c0e4:	80c6b03a 	or	r3,r16,r3
2108c0e8:	9005883a 	mov	r2,r18
2108c0ec:	dfc00d17 	ldw	ra,52(sp)
2108c0f0:	df000c17 	ldw	fp,48(sp)
2108c0f4:	ddc00b17 	ldw	r23,44(sp)
2108c0f8:	dd800a17 	ldw	r22,40(sp)
2108c0fc:	dd400917 	ldw	r21,36(sp)
2108c100:	dd000817 	ldw	r20,32(sp)
2108c104:	dcc00717 	ldw	r19,28(sp)
2108c108:	dc800617 	ldw	r18,24(sp)
2108c10c:	dc400517 	ldw	r17,20(sp)
2108c110:	dc000417 	ldw	r16,16(sp)
2108c114:	dec00e04 	addi	sp,sp,56
2108c118:	f800283a 	ret
2108c11c:	8104b03a 	or	r2,r16,r4
2108c120:	10004226 	beq	r2,zero,2108c22c <__muldf3+0x2cc>
2108c124:	8000f926 	beq	r16,zero,2108c50c <__muldf3+0x5ac>
2108c128:	8009883a 	mov	r4,r16
2108c12c:	d9800315 	stw	r6,12(sp)
2108c130:	d9c00015 	stw	r7,0(sp)
2108c134:	108d3f80 	call	2108d3f8 <__clzsi2>
2108c138:	d9800317 	ldw	r6,12(sp)
2108c13c:	d9c00017 	ldw	r7,0(sp)
2108c140:	1007883a 	mov	r3,r2
2108c144:	01000a04 	movi	r4,40
2108c148:	18bffe04 	addi	r2,r3,-8
2108c14c:	20c9c83a 	sub	r4,r4,r3
2108c150:	80a0983a 	sll	r16,r16,r2
2108c154:	8908d83a 	srl	r4,r17,r4
2108c158:	88a4983a 	sll	r18,r17,r2
2108c15c:	2420b03a 	or	r16,r4,r16
2108c160:	017f0344 	movi	r5,-1011
2108c164:	28e9c83a 	sub	r20,r5,r3
2108c168:	002b883a 	mov	r21,zero
2108c16c:	0015883a 	mov	r10,zero
2108c170:	003f9b06 	br	2108bfe0 <__flash_rwdata_start+0xfffe9d98>
2108c174:	8984b03a 	or	r2,r17,r6
2108c178:	10002a1e 	bne	r2,zero,2108c224 <__muldf3+0x2c4>
2108c17c:	0023883a 	mov	r17,zero
2108c180:	002f883a 	mov	r23,zero
2108c184:	02400084 	movi	r9,2
2108c188:	003fa706 	br	2108c028 <__flash_rwdata_start+0xfffe9de0>
2108c18c:	8984b03a 	or	r2,r17,r6
2108c190:	10002026 	beq	r2,zero,2108c214 <__muldf3+0x2b4>
2108c194:	8800cc26 	beq	r17,zero,2108c4c8 <__muldf3+0x568>
2108c198:	8809883a 	mov	r4,r17
2108c19c:	d8c00215 	stw	r3,8(sp)
2108c1a0:	d9800315 	stw	r6,12(sp)
2108c1a4:	da800015 	stw	r10,0(sp)
2108c1a8:	dac00115 	stw	r11,4(sp)
2108c1ac:	108d3f80 	call	2108d3f8 <__clzsi2>
2108c1b0:	d8c00217 	ldw	r3,8(sp)
2108c1b4:	d9800317 	ldw	r6,12(sp)
2108c1b8:	da800017 	ldw	r10,0(sp)
2108c1bc:	dac00117 	ldw	r11,4(sp)
2108c1c0:	1009883a 	mov	r4,r2
2108c1c4:	01400a04 	movi	r5,40
2108c1c8:	25fffe04 	addi	r23,r4,-8
2108c1cc:	290bc83a 	sub	r5,r5,r4
2108c1d0:	8dd0983a 	sll	r8,r17,r23
2108c1d4:	314ad83a 	srl	r5,r6,r5
2108c1d8:	35ee983a 	sll	r23,r6,r23
2108c1dc:	2a22b03a 	or	r17,r5,r8
2108c1e0:	017f0344 	movi	r5,-1011
2108c1e4:	290bc83a 	sub	r5,r5,r4
2108c1e8:	0013883a 	mov	r9,zero
2108c1ec:	003f8e06 	br	2108c028 <__flash_rwdata_start+0xfffe9de0>
2108c1f0:	008000c4 	movi	r2,3
2108c1f4:	50811d26 	beq	r10,r2,2108c66c <__muldf3+0x70c>
2108c1f8:	00800044 	movi	r2,1
2108c1fc:	5080e01e 	bne	r10,r2,2108c580 <__muldf3+0x620>
2108c200:	e0a6703a 	and	r19,fp,r2
2108c204:	0009883a 	mov	r4,zero
2108c208:	0021883a 	mov	r16,zero
2108c20c:	0025883a 	mov	r18,zero
2108c210:	003fad06 	br	2108c0c8 <__flash_rwdata_start+0xfffe9e80>
2108c214:	0023883a 	mov	r17,zero
2108c218:	002f883a 	mov	r23,zero
2108c21c:	02400044 	movi	r9,1
2108c220:	003f8106 	br	2108c028 <__flash_rwdata_start+0xfffe9de0>
2108c224:	024000c4 	movi	r9,3
2108c228:	003f7f06 	br	2108c028 <__flash_rwdata_start+0xfffe9de0>
2108c22c:	05400104 	movi	r21,4
2108c230:	0021883a 	mov	r16,zero
2108c234:	0025883a 	mov	r18,zero
2108c238:	02800044 	movi	r10,1
2108c23c:	003f6806 	br	2108bfe0 <__flash_rwdata_start+0xfffe9d98>
2108c240:	05400304 	movi	r21,12
2108c244:	028000c4 	movi	r10,3
2108c248:	003f6506 	br	2108bfe0 <__flash_rwdata_start+0xfffe9d98>
2108c24c:	04000434 	movhi	r16,16
2108c250:	0027883a 	mov	r19,zero
2108c254:	843fffc4 	addi	r16,r16,-1
2108c258:	04bfffc4 	movi	r18,-1
2108c25c:	0101ffc4 	movi	r4,2047
2108c260:	003f9906 	br	2108c0c8 <__flash_rwdata_start+0xfffe9e80>
2108c264:	8821883a 	mov	r16,r17
2108c268:	b825883a 	mov	r18,r23
2108c26c:	5839883a 	mov	fp,r11
2108c270:	4815883a 	mov	r10,r9
2108c274:	003f8e06 	br	2108c0b0 <__flash_rwdata_start+0xfffe9e68>
2108c278:	8821883a 	mov	r16,r17
2108c27c:	b825883a 	mov	r18,r23
2108c280:	b039883a 	mov	fp,r22
2108c284:	4815883a 	mov	r10,r9
2108c288:	003f8906 	br	2108c0b0 <__flash_rwdata_start+0xfffe9e68>
2108c28c:	b80cd43a 	srli	r6,r23,16
2108c290:	9006d43a 	srli	r3,r18,16
2108c294:	90bfffcc 	andi	r2,r18,65535
2108c298:	bdffffcc 	andi	r23,r23,65535
2108c29c:	b891383a 	mul	r8,r23,r2
2108c2a0:	b8c9383a 	mul	r4,r23,r3
2108c2a4:	309b383a 	mul	r13,r6,r2
2108c2a8:	400ed43a 	srli	r7,r8,16
2108c2ac:	30df383a 	mul	r15,r6,r3
2108c2b0:	235b883a 	add	r13,r4,r13
2108c2b4:	69db883a 	add	r13,r13,r7
2108c2b8:	6900022e 	bgeu	r13,r4,2108c2c4 <__muldf3+0x364>
2108c2bc:	01000074 	movhi	r4,1
2108c2c0:	791f883a 	add	r15,r15,r4
2108c2c4:	8828d43a 	srli	r20,r17,16
2108c2c8:	8c7fffcc 	andi	r17,r17,65535
2108c2cc:	888f383a 	mul	r7,r17,r2
2108c2d0:	88d3383a 	mul	r9,r17,r3
2108c2d4:	a0a5383a 	mul	r18,r20,r2
2108c2d8:	3816d43a 	srli	r11,r7,16
2108c2dc:	6814943a 	slli	r10,r13,16
2108c2e0:	4ca5883a 	add	r18,r9,r18
2108c2e4:	423fffcc 	andi	r8,r8,65535
2108c2e8:	92e5883a 	add	r18,r18,r11
2108c2ec:	6808d43a 	srli	r4,r13,16
2108c2f0:	5215883a 	add	r10,r10,r8
2108c2f4:	a0c7383a 	mul	r3,r20,r3
2108c2f8:	9240022e 	bgeu	r18,r9,2108c304 <__muldf3+0x3a4>
2108c2fc:	00800074 	movhi	r2,1
2108c300:	1887883a 	add	r3,r3,r2
2108c304:	802ad43a 	srli	r21,r16,16
2108c308:	80bfffcc 	andi	r2,r16,65535
2108c30c:	b893383a 	mul	r9,r23,r2
2108c310:	3091383a 	mul	r8,r6,r2
2108c314:	bd6f383a 	mul	r23,r23,r21
2108c318:	9026943a 	slli	r19,r18,16
2108c31c:	481ad43a 	srli	r13,r9,16
2108c320:	9024d43a 	srli	r18,r18,16
2108c324:	39ffffcc 	andi	r7,r7,65535
2108c328:	ba11883a 	add	r8,r23,r8
2108c32c:	99e7883a 	add	r19,r19,r7
2108c330:	4351883a 	add	r8,r8,r13
2108c334:	1c97883a 	add	r11,r3,r18
2108c338:	354d383a 	mul	r6,r6,r21
2108c33c:	9925883a 	add	r18,r19,r4
2108c340:	45c0022e 	bgeu	r8,r23,2108c34c <__muldf3+0x3ec>
2108c344:	00c00074 	movhi	r3,1
2108c348:	30cd883a 	add	r6,r6,r3
2108c34c:	8889383a 	mul	r4,r17,r2
2108c350:	8d63383a 	mul	r17,r17,r21
2108c354:	a085383a 	mul	r2,r20,r2
2108c358:	200ed43a 	srli	r7,r4,16
2108c35c:	401cd43a 	srli	r14,r8,16
2108c360:	401a943a 	slli	r13,r8,16
2108c364:	8885883a 	add	r2,r17,r2
2108c368:	4a3fffcc 	andi	r8,r9,65535
2108c36c:	11c5883a 	add	r2,r2,r7
2108c370:	339d883a 	add	r14,r6,r14
2108c374:	6a11883a 	add	r8,r13,r8
2108c378:	a561383a 	mul	r16,r20,r21
2108c37c:	1440022e 	bgeu	r2,r17,2108c388 <__muldf3+0x428>
2108c380:	00c00074 	movhi	r3,1
2108c384:	80e1883a 	add	r16,r16,r3
2108c388:	1006943a 	slli	r3,r2,16
2108c38c:	213fffcc 	andi	r4,r4,65535
2108c390:	93db883a 	add	r13,r18,r15
2108c394:	1909883a 	add	r4,r3,r4
2108c398:	22c7883a 	add	r3,r4,r11
2108c39c:	6cd3803a 	cmpltu	r9,r13,r19
2108c3a0:	6a09883a 	add	r4,r13,r8
2108c3a4:	1a5b883a 	add	r13,r3,r9
2108c3a8:	2211803a 	cmpltu	r8,r4,r8
2108c3ac:	734d883a 	add	r6,r14,r13
2108c3b0:	100ed43a 	srli	r7,r2,16
2108c3b4:	6a53803a 	cmpltu	r9,r13,r9
2108c3b8:	3205883a 	add	r2,r6,r8
2108c3bc:	1ac7803a 	cmpltu	r3,r3,r11
2108c3c0:	1211803a 	cmpltu	r8,r2,r8
2108c3c4:	48c6b03a 	or	r3,r9,r3
2108c3c8:	338d803a 	cmpltu	r6,r6,r14
2108c3cc:	19c7883a 	add	r3,r3,r7
2108c3d0:	418cb03a 	or	r6,r8,r6
2108c3d4:	1987883a 	add	r3,r3,r6
2108c3d8:	2024927a 	slli	r18,r4,9
2108c3dc:	1c07883a 	add	r3,r3,r16
2108c3e0:	1806927a 	slli	r3,r3,9
2108c3e4:	1020d5fa 	srli	r16,r2,23
2108c3e8:	2008d5fa 	srli	r4,r4,23
2108c3ec:	9294b03a 	or	r10,r18,r10
2108c3f0:	1004927a 	slli	r2,r2,9
2108c3f4:	5024c03a 	cmpne	r18,r10,zero
2108c3f8:	1c20b03a 	or	r16,r3,r16
2108c3fc:	9108b03a 	or	r4,r18,r4
2108c400:	80c0402c 	andhi	r3,r16,256
2108c404:	20a4b03a 	or	r18,r4,r2
2108c408:	18000726 	beq	r3,zero,2108c428 <__muldf3+0x4c8>
2108c40c:	9006d07a 	srli	r3,r18,1
2108c410:	800897fa 	slli	r4,r16,31
2108c414:	9080004c 	andi	r2,r18,1
2108c418:	8020d07a 	srli	r16,r16,1
2108c41c:	10c4b03a 	or	r2,r2,r3
2108c420:	1124b03a 	or	r18,r2,r4
2108c424:	600b883a 	mov	r5,r12
2108c428:	2900ffc4 	addi	r4,r5,1023
2108c42c:	01004b0e 	bge	zero,r4,2108c55c <__muldf3+0x5fc>
2108c430:	908001cc 	andi	r2,r18,7
2108c434:	10000726 	beq	r2,zero,2108c454 <__muldf3+0x4f4>
2108c438:	90c003cc 	andi	r3,r18,15
2108c43c:	00800104 	movi	r2,4
2108c440:	18800426 	beq	r3,r2,2108c454 <__muldf3+0x4f4>
2108c444:	9087883a 	add	r3,r18,r2
2108c448:	1c85803a 	cmpltu	r2,r3,r18
2108c44c:	80a1883a 	add	r16,r16,r2
2108c450:	1825883a 	mov	r18,r3
2108c454:	8080402c 	andhi	r2,r16,256
2108c458:	10000426 	beq	r2,zero,2108c46c <__muldf3+0x50c>
2108c45c:	00bfc034 	movhi	r2,65280
2108c460:	10bfffc4 	addi	r2,r2,-1
2108c464:	29010004 	addi	r4,r5,1024
2108c468:	80a0703a 	and	r16,r16,r2
2108c46c:	0081ff84 	movi	r2,2046
2108c470:	1100320e 	bge	r2,r4,2108c53c <__muldf3+0x5dc>
2108c474:	b4c0004c 	andi	r19,r22,1
2108c478:	0101ffc4 	movi	r4,2047
2108c47c:	0021883a 	mov	r16,zero
2108c480:	0025883a 	mov	r18,zero
2108c484:	003f1006 	br	2108c0c8 <__flash_rwdata_start+0xfffe9e80>
2108c488:	8080022c 	andhi	r2,r16,8
2108c48c:	10000926 	beq	r2,zero,2108c4b4 <__muldf3+0x554>
2108c490:	8880022c 	andhi	r2,r17,8
2108c494:	1000071e 	bne	r2,zero,2108c4b4 <__muldf3+0x554>
2108c498:	00800434 	movhi	r2,16
2108c49c:	8c000234 	orhi	r16,r17,8
2108c4a0:	10bfffc4 	addi	r2,r2,-1
2108c4a4:	1827883a 	mov	r19,r3
2108c4a8:	80a0703a 	and	r16,r16,r2
2108c4ac:	b825883a 	mov	r18,r23
2108c4b0:	003f6a06 	br	2108c25c <__flash_rwdata_start+0xfffea014>
2108c4b4:	00800434 	movhi	r2,16
2108c4b8:	84000234 	orhi	r16,r16,8
2108c4bc:	10bfffc4 	addi	r2,r2,-1
2108c4c0:	80a0703a 	and	r16,r16,r2
2108c4c4:	003f6506 	br	2108c25c <__flash_rwdata_start+0xfffea014>
2108c4c8:	3009883a 	mov	r4,r6
2108c4cc:	d8c00215 	stw	r3,8(sp)
2108c4d0:	d9800315 	stw	r6,12(sp)
2108c4d4:	da800015 	stw	r10,0(sp)
2108c4d8:	dac00115 	stw	r11,4(sp)
2108c4dc:	108d3f80 	call	2108d3f8 <__clzsi2>
2108c4e0:	11000804 	addi	r4,r2,32
2108c4e4:	014009c4 	movi	r5,39
2108c4e8:	d8c00217 	ldw	r3,8(sp)
2108c4ec:	d9800317 	ldw	r6,12(sp)
2108c4f0:	da800017 	ldw	r10,0(sp)
2108c4f4:	dac00117 	ldw	r11,4(sp)
2108c4f8:	293f320e 	bge	r5,r4,2108c1c4 <__flash_rwdata_start+0xfffe9f7c>
2108c4fc:	10bffe04 	addi	r2,r2,-8
2108c500:	b8a2983a 	sll	r17,r23,r2
2108c504:	002f883a 	mov	r23,zero
2108c508:	003f3506 	br	2108c1e0 <__flash_rwdata_start+0xfffe9f98>
2108c50c:	d9800315 	stw	r6,12(sp)
2108c510:	d9c00015 	stw	r7,0(sp)
2108c514:	108d3f80 	call	2108d3f8 <__clzsi2>
2108c518:	10c00804 	addi	r3,r2,32
2108c51c:	010009c4 	movi	r4,39
2108c520:	d9800317 	ldw	r6,12(sp)
2108c524:	d9c00017 	ldw	r7,0(sp)
2108c528:	20ff060e 	bge	r4,r3,2108c144 <__flash_rwdata_start+0xfffe9efc>
2108c52c:	10bffe04 	addi	r2,r2,-8
2108c530:	88a0983a 	sll	r16,r17,r2
2108c534:	0025883a 	mov	r18,zero
2108c538:	003f0906 	br	2108c160 <__flash_rwdata_start+0xfffe9f18>
2108c53c:	9004d0fa 	srli	r2,r18,3
2108c540:	8024977a 	slli	r18,r16,29
2108c544:	8020927a 	slli	r16,r16,9
2108c548:	2101ffcc 	andi	r4,r4,2047
2108c54c:	90a4b03a 	or	r18,r18,r2
2108c550:	8020d33a 	srli	r16,r16,12
2108c554:	b4c0004c 	andi	r19,r22,1
2108c558:	003edb06 	br	2108c0c8 <__flash_rwdata_start+0xfffe9e80>
2108c55c:	00ff0084 	movi	r3,-1022
2108c560:	1947c83a 	sub	r3,r3,r5
2108c564:	00800e04 	movi	r2,56
2108c568:	10c0080e 	bge	r2,r3,2108c58c <__muldf3+0x62c>
2108c56c:	b4c0004c 	andi	r19,r22,1
2108c570:	0009883a 	mov	r4,zero
2108c574:	0021883a 	mov	r16,zero
2108c578:	0025883a 	mov	r18,zero
2108c57c:	003ed206 	br	2108c0c8 <__flash_rwdata_start+0xfffe9e80>
2108c580:	600b883a 	mov	r5,r12
2108c584:	e02d883a 	mov	r22,fp
2108c588:	003fa706 	br	2108c428 <__flash_rwdata_start+0xfffea1e0>
2108c58c:	008007c4 	movi	r2,31
2108c590:	10c01816 	blt	r2,r3,2108c5f4 <__muldf3+0x694>
2108c594:	29410784 	addi	r5,r5,1054
2108c598:	8144983a 	sll	r2,r16,r5
2108c59c:	90c8d83a 	srl	r4,r18,r3
2108c5a0:	914a983a 	sll	r5,r18,r5
2108c5a4:	80c6d83a 	srl	r3,r16,r3
2108c5a8:	2088b03a 	or	r4,r4,r2
2108c5ac:	2804c03a 	cmpne	r2,r5,zero
2108c5b0:	2084b03a 	or	r2,r4,r2
2108c5b4:	110001cc 	andi	r4,r2,7
2108c5b8:	20000726 	beq	r4,zero,2108c5d8 <__muldf3+0x678>
2108c5bc:	114003cc 	andi	r5,r2,15
2108c5c0:	01000104 	movi	r4,4
2108c5c4:	29000426 	beq	r5,r4,2108c5d8 <__muldf3+0x678>
2108c5c8:	11000104 	addi	r4,r2,4
2108c5cc:	2085803a 	cmpltu	r2,r4,r2
2108c5d0:	1887883a 	add	r3,r3,r2
2108c5d4:	2005883a 	mov	r2,r4
2108c5d8:	1900202c 	andhi	r4,r3,128
2108c5dc:	20001826 	beq	r4,zero,2108c640 <__muldf3+0x6e0>
2108c5e0:	b4c0004c 	andi	r19,r22,1
2108c5e4:	01000044 	movi	r4,1
2108c5e8:	0021883a 	mov	r16,zero
2108c5ec:	0025883a 	mov	r18,zero
2108c5f0:	003eb506 	br	2108c0c8 <__flash_rwdata_start+0xfffe9e80>
2108c5f4:	00bef884 	movi	r2,-1054
2108c5f8:	1145c83a 	sub	r2,r2,r5
2108c5fc:	8088d83a 	srl	r4,r16,r2
2108c600:	00800804 	movi	r2,32
2108c604:	18801726 	beq	r3,r2,2108c664 <__muldf3+0x704>
2108c608:	28810f84 	addi	r2,r5,1086
2108c60c:	8084983a 	sll	r2,r16,r2
2108c610:	1484b03a 	or	r2,r2,r18
2108c614:	1004c03a 	cmpne	r2,r2,zero
2108c618:	1104b03a 	or	r2,r2,r4
2108c61c:	10c001cc 	andi	r3,r2,7
2108c620:	18000b1e 	bne	r3,zero,2108c650 <__muldf3+0x6f0>
2108c624:	0021883a 	mov	r16,zero
2108c628:	1004d0fa 	srli	r2,r2,3
2108c62c:	b4c0004c 	andi	r19,r22,1
2108c630:	0009883a 	mov	r4,zero
2108c634:	10e4b03a 	or	r18,r2,r3
2108c638:	003ea306 	br	2108c0c8 <__flash_rwdata_start+0xfffe9e80>
2108c63c:	0007883a 	mov	r3,zero
2108c640:	1820927a 	slli	r16,r3,9
2108c644:	1806977a 	slli	r3,r3,29
2108c648:	8020d33a 	srli	r16,r16,12
2108c64c:	003ff606 	br	2108c628 <__flash_rwdata_start+0xfffea3e0>
2108c650:	110003cc 	andi	r4,r2,15
2108c654:	00c00104 	movi	r3,4
2108c658:	20fff826 	beq	r4,r3,2108c63c <__flash_rwdata_start+0xfffea3f4>
2108c65c:	0007883a 	mov	r3,zero
2108c660:	003fd906 	br	2108c5c8 <__flash_rwdata_start+0xfffea380>
2108c664:	0005883a 	mov	r2,zero
2108c668:	003fe906 	br	2108c610 <__flash_rwdata_start+0xfffea3c8>
2108c66c:	00800434 	movhi	r2,16
2108c670:	84000234 	orhi	r16,r16,8
2108c674:	10bfffc4 	addi	r2,r2,-1
2108c678:	e4c0004c 	andi	r19,fp,1
2108c67c:	80a0703a 	and	r16,r16,r2
2108c680:	003ef606 	br	2108c25c <__flash_rwdata_start+0xfffea014>

2108c684 <__subdf3>:
2108c684:	00c00434 	movhi	r3,16
2108c688:	18ffffc4 	addi	r3,r3,-1
2108c68c:	defffb04 	addi	sp,sp,-20
2108c690:	28d2703a 	and	r9,r5,r3
2108c694:	3814d53a 	srli	r10,r7,20
2108c698:	38c6703a 	and	r3,r7,r3
2108c69c:	3004d77a 	srli	r2,r6,29
2108c6a0:	dc800215 	stw	r18,8(sp)
2108c6a4:	dc000015 	stw	r16,0(sp)
2108c6a8:	2824d7fa 	srli	r18,r5,31
2108c6ac:	2820d53a 	srli	r16,r5,20
2108c6b0:	481290fa 	slli	r9,r9,3
2108c6b4:	200ad77a 	srli	r5,r4,29
2108c6b8:	180690fa 	slli	r3,r3,3
2108c6bc:	dc400115 	stw	r17,4(sp)
2108c6c0:	dfc00415 	stw	ra,16(sp)
2108c6c4:	202290fa 	slli	r17,r4,3
2108c6c8:	dcc00315 	stw	r19,12(sp)
2108c6cc:	5281ffcc 	andi	r10,r10,2047
2108c6d0:	0101ffc4 	movi	r4,2047
2108c6d4:	9011883a 	mov	r8,r18
2108c6d8:	8401ffcc 	andi	r16,r16,2047
2108c6dc:	94803fcc 	andi	r18,r18,255
2108c6e0:	494ab03a 	or	r5,r9,r5
2108c6e4:	380ed7fa 	srli	r7,r7,31
2108c6e8:	1886b03a 	or	r3,r3,r2
2108c6ec:	300c90fa 	slli	r6,r6,3
2108c6f0:	51009026 	beq	r10,r4,2108c934 <__subdf3+0x2b0>
2108c6f4:	39c0005c 	xori	r7,r7,1
2108c6f8:	8285c83a 	sub	r2,r16,r10
2108c6fc:	91c06f26 	beq	r18,r7,2108c8bc <__subdf3+0x238>
2108c700:	0080b10e 	bge	zero,r2,2108c9c8 <__subdf3+0x344>
2108c704:	50002a1e 	bne	r10,zero,2108c7b0 <__subdf3+0x12c>
2108c708:	1988b03a 	or	r4,r3,r6
2108c70c:	2000941e 	bne	r4,zero,2108c960 <__subdf3+0x2dc>
2108c710:	888001cc 	andi	r2,r17,7
2108c714:	10005b26 	beq	r2,zero,2108c884 <__subdf3+0x200>
2108c718:	88c003cc 	andi	r3,r17,15
2108c71c:	00800104 	movi	r2,4
2108c720:	18805826 	beq	r3,r2,2108c884 <__subdf3+0x200>
2108c724:	88c00104 	addi	r3,r17,4
2108c728:	1c63803a 	cmpltu	r17,r3,r17
2108c72c:	2c4b883a 	add	r5,r5,r17
2108c730:	2880202c 	andhi	r2,r5,128
2108c734:	9200004c 	andi	r8,r18,1
2108c738:	1823883a 	mov	r17,r3
2108c73c:	10005426 	beq	r2,zero,2108c890 <__subdf3+0x20c>
2108c740:	84000044 	addi	r16,r16,1
2108c744:	0081ffc4 	movi	r2,2047
2108c748:	8080bf26 	beq	r16,r2,2108ca48 <__subdf3+0x3c4>
2108c74c:	013fe034 	movhi	r4,65408
2108c750:	213fffc4 	addi	r4,r4,-1
2108c754:	290a703a 	and	r5,r5,r4
2108c758:	2804977a 	slli	r2,r5,29
2108c75c:	280a927a 	slli	r5,r5,9
2108c760:	8822d0fa 	srli	r17,r17,3
2108c764:	8401ffcc 	andi	r16,r16,2047
2108c768:	2808d33a 	srli	r4,r5,12
2108c76c:	1444b03a 	or	r2,r2,r17
2108c770:	8401ffcc 	andi	r16,r16,2047
2108c774:	800a953a 	slli	r5,r16,20
2108c778:	40c03fcc 	andi	r3,r8,255
2108c77c:	04000434 	movhi	r16,16
2108c780:	180697fa 	slli	r3,r3,31
2108c784:	843fffc4 	addi	r16,r16,-1
2108c788:	2420703a 	and	r16,r4,r16
2108c78c:	8160b03a 	or	r16,r16,r5
2108c790:	80c6b03a 	or	r3,r16,r3
2108c794:	dfc00417 	ldw	ra,16(sp)
2108c798:	dcc00317 	ldw	r19,12(sp)
2108c79c:	dc800217 	ldw	r18,8(sp)
2108c7a0:	dc400117 	ldw	r17,4(sp)
2108c7a4:	dc000017 	ldw	r16,0(sp)
2108c7a8:	dec00504 	addi	sp,sp,20
2108c7ac:	f800283a 	ret
2108c7b0:	0101ffc4 	movi	r4,2047
2108c7b4:	813fd626 	beq	r16,r4,2108c710 <__flash_rwdata_start+0xfffea4c8>
2108c7b8:	18c02034 	orhi	r3,r3,128
2108c7bc:	01000e04 	movi	r4,56
2108c7c0:	2080a416 	blt	r4,r2,2108ca54 <__subdf3+0x3d0>
2108c7c4:	010007c4 	movi	r4,31
2108c7c8:	2080c716 	blt	r4,r2,2108cae8 <__subdf3+0x464>
2108c7cc:	01000804 	movi	r4,32
2108c7d0:	2089c83a 	sub	r4,r4,r2
2108c7d4:	1910983a 	sll	r8,r3,r4
2108c7d8:	308ed83a 	srl	r7,r6,r2
2108c7dc:	3108983a 	sll	r4,r6,r4
2108c7e0:	1884d83a 	srl	r2,r3,r2
2108c7e4:	41ccb03a 	or	r6,r8,r7
2108c7e8:	2008c03a 	cmpne	r4,r4,zero
2108c7ec:	310cb03a 	or	r6,r6,r4
2108c7f0:	898dc83a 	sub	r6,r17,r6
2108c7f4:	89a3803a 	cmpltu	r17,r17,r6
2108c7f8:	288bc83a 	sub	r5,r5,r2
2108c7fc:	2c4bc83a 	sub	r5,r5,r17
2108c800:	3023883a 	mov	r17,r6
2108c804:	2880202c 	andhi	r2,r5,128
2108c808:	10006b26 	beq	r2,zero,2108c9b8 <__subdf3+0x334>
2108c80c:	04c02034 	movhi	r19,128
2108c810:	9cffffc4 	addi	r19,r19,-1
2108c814:	2ce6703a 	and	r19,r5,r19
2108c818:	98007c26 	beq	r19,zero,2108ca0c <__subdf3+0x388>
2108c81c:	9809883a 	mov	r4,r19
2108c820:	108d3f80 	call	2108d3f8 <__clzsi2>
2108c824:	10fffe04 	addi	r3,r2,-8
2108c828:	010007c4 	movi	r4,31
2108c82c:	20c07d16 	blt	r4,r3,2108ca24 <__subdf3+0x3a0>
2108c830:	01400a04 	movi	r5,40
2108c834:	2885c83a 	sub	r2,r5,r2
2108c838:	888ad83a 	srl	r5,r17,r2
2108c83c:	98e6983a 	sll	r19,r19,r3
2108c840:	88e2983a 	sll	r17,r17,r3
2108c844:	2ce6b03a 	or	r19,r5,r19
2108c848:	1c007a16 	blt	r3,r16,2108ca34 <__subdf3+0x3b0>
2108c84c:	1c21c83a 	sub	r16,r3,r16
2108c850:	81400044 	addi	r5,r16,1
2108c854:	00c007c4 	movi	r3,31
2108c858:	19409616 	blt	r3,r5,2108cab4 <__subdf3+0x430>
2108c85c:	1c21c83a 	sub	r16,r3,r16
2108c860:	8c08983a 	sll	r4,r17,r16
2108c864:	8946d83a 	srl	r3,r17,r5
2108c868:	9c20983a 	sll	r16,r19,r16
2108c86c:	2008c03a 	cmpne	r4,r4,zero
2108c870:	994ad83a 	srl	r5,r19,r5
2108c874:	1c06b03a 	or	r3,r3,r16
2108c878:	1922b03a 	or	r17,r3,r4
2108c87c:	0021883a 	mov	r16,zero
2108c880:	003fa306 	br	2108c710 <__flash_rwdata_start+0xfffea4c8>
2108c884:	2880202c 	andhi	r2,r5,128
2108c888:	9200004c 	andi	r8,r18,1
2108c88c:	103fac1e 	bne	r2,zero,2108c740 <__flash_rwdata_start+0xfffea4f8>
2108c890:	2804977a 	slli	r2,r5,29
2108c894:	8822d0fa 	srli	r17,r17,3
2108c898:	00c1ffc4 	movi	r3,2047
2108c89c:	280ad0fa 	srli	r5,r5,3
2108c8a0:	1444b03a 	or	r2,r2,r17
2108c8a4:	80c02726 	beq	r16,r3,2108c944 <__subdf3+0x2c0>
2108c8a8:	01000434 	movhi	r4,16
2108c8ac:	213fffc4 	addi	r4,r4,-1
2108c8b0:	80e0703a 	and	r16,r16,r3
2108c8b4:	2908703a 	and	r4,r5,r4
2108c8b8:	003fad06 	br	2108c770 <__flash_rwdata_start+0xfffea528>
2108c8bc:	0080690e 	bge	zero,r2,2108ca64 <__subdf3+0x3e0>
2108c8c0:	50002f26 	beq	r10,zero,2108c980 <__subdf3+0x2fc>
2108c8c4:	0101ffc4 	movi	r4,2047
2108c8c8:	813f9126 	beq	r16,r4,2108c710 <__flash_rwdata_start+0xfffea4c8>
2108c8cc:	18c02034 	orhi	r3,r3,128
2108c8d0:	01000e04 	movi	r4,56
2108c8d4:	2080b00e 	bge	r4,r2,2108cb98 <__subdf3+0x514>
2108c8d8:	198cb03a 	or	r6,r3,r6
2108c8dc:	300ec03a 	cmpne	r7,r6,zero
2108c8e0:	0005883a 	mov	r2,zero
2108c8e4:	3c4f883a 	add	r7,r7,r17
2108c8e8:	3c63803a 	cmpltu	r17,r7,r17
2108c8ec:	114b883a 	add	r5,r2,r5
2108c8f0:	2c4b883a 	add	r5,r5,r17
2108c8f4:	3823883a 	mov	r17,r7
2108c8f8:	2880202c 	andhi	r2,r5,128
2108c8fc:	10002e26 	beq	r2,zero,2108c9b8 <__subdf3+0x334>
2108c900:	84000044 	addi	r16,r16,1
2108c904:	0081ffc4 	movi	r2,2047
2108c908:	8080de26 	beq	r16,r2,2108cc84 <__subdf3+0x600>
2108c90c:	00bfe034 	movhi	r2,65408
2108c910:	10bfffc4 	addi	r2,r2,-1
2108c914:	288a703a 	and	r5,r5,r2
2108c918:	880cd07a 	srli	r6,r17,1
2108c91c:	280897fa 	slli	r4,r5,31
2108c920:	88c0004c 	andi	r3,r17,1
2108c924:	30e2b03a 	or	r17,r6,r3
2108c928:	280ad07a 	srli	r5,r5,1
2108c92c:	8922b03a 	or	r17,r17,r4
2108c930:	003f7706 	br	2108c710 <__flash_rwdata_start+0xfffea4c8>
2108c934:	1984b03a 	or	r2,r3,r6
2108c938:	103f6e26 	beq	r2,zero,2108c6f4 <__flash_rwdata_start+0xfffea4ac>
2108c93c:	39c03fcc 	andi	r7,r7,255
2108c940:	003f6d06 	br	2108c6f8 <__flash_rwdata_start+0xfffea4b0>
2108c944:	1146b03a 	or	r3,r2,r5
2108c948:	18003f26 	beq	r3,zero,2108ca48 <__subdf3+0x3c4>
2108c94c:	00c00434 	movhi	r3,16
2108c950:	29000234 	orhi	r4,r5,8
2108c954:	18ffffc4 	addi	r3,r3,-1
2108c958:	20c8703a 	and	r4,r4,r3
2108c95c:	003f8406 	br	2108c770 <__flash_rwdata_start+0xfffea528>
2108c960:	10bfffc4 	addi	r2,r2,-1
2108c964:	1000501e 	bne	r2,zero,2108caa8 <__subdf3+0x424>
2108c968:	898fc83a 	sub	r7,r17,r6
2108c96c:	89e3803a 	cmpltu	r17,r17,r7
2108c970:	28cbc83a 	sub	r5,r5,r3
2108c974:	2c4bc83a 	sub	r5,r5,r17
2108c978:	3823883a 	mov	r17,r7
2108c97c:	003fa106 	br	2108c804 <__flash_rwdata_start+0xfffea5bc>
2108c980:	1988b03a 	or	r4,r3,r6
2108c984:	203f6226 	beq	r4,zero,2108c710 <__flash_rwdata_start+0xfffea4c8>
2108c988:	10bfffc4 	addi	r2,r2,-1
2108c98c:	10009b1e 	bne	r2,zero,2108cbfc <__subdf3+0x578>
2108c990:	344d883a 	add	r6,r6,r17
2108c994:	3463803a 	cmpltu	r17,r6,r17
2108c998:	194b883a 	add	r5,r3,r5
2108c99c:	2c4b883a 	add	r5,r5,r17
2108c9a0:	3023883a 	mov	r17,r6
2108c9a4:	003fd406 	br	2108c8f8 <__flash_rwdata_start+0xfffea6b0>
2108c9a8:	1106b03a 	or	r3,r2,r4
2108c9ac:	1800b426 	beq	r3,zero,2108cc80 <__subdf3+0x5fc>
2108c9b0:	100b883a 	mov	r5,r2
2108c9b4:	2023883a 	mov	r17,r4
2108c9b8:	888001cc 	andi	r2,r17,7
2108c9bc:	103f561e 	bne	r2,zero,2108c718 <__flash_rwdata_start+0xfffea4d0>
2108c9c0:	9200004c 	andi	r8,r18,1
2108c9c4:	003fb206 	br	2108c890 <__flash_rwdata_start+0xfffea648>
2108c9c8:	1000531e 	bne	r2,zero,2108cb18 <__subdf3+0x494>
2108c9cc:	80800044 	addi	r2,r16,1
2108c9d0:	1081ffcc 	andi	r2,r2,2047
2108c9d4:	01000044 	movi	r4,1
2108c9d8:	2080a00e 	bge	r4,r2,2108cc5c <__subdf3+0x5d8>
2108c9dc:	8985c83a 	sub	r2,r17,r6
2108c9e0:	8889803a 	cmpltu	r4,r17,r2
2108c9e4:	28e7c83a 	sub	r19,r5,r3
2108c9e8:	9927c83a 	sub	r19,r19,r4
2108c9ec:	9900202c 	andhi	r4,r19,128
2108c9f0:	20006226 	beq	r4,zero,2108cb7c <__subdf3+0x4f8>
2108c9f4:	3463c83a 	sub	r17,r6,r17
2108c9f8:	194bc83a 	sub	r5,r3,r5
2108c9fc:	344d803a 	cmpltu	r6,r6,r17
2108ca00:	29a7c83a 	sub	r19,r5,r6
2108ca04:	3825883a 	mov	r18,r7
2108ca08:	983f841e 	bne	r19,zero,2108c81c <__flash_rwdata_start+0xfffea5d4>
2108ca0c:	8809883a 	mov	r4,r17
2108ca10:	108d3f80 	call	2108d3f8 <__clzsi2>
2108ca14:	10800804 	addi	r2,r2,32
2108ca18:	10fffe04 	addi	r3,r2,-8
2108ca1c:	010007c4 	movi	r4,31
2108ca20:	20ff830e 	bge	r4,r3,2108c830 <__flash_rwdata_start+0xfffea5e8>
2108ca24:	14fff604 	addi	r19,r2,-40
2108ca28:	8ce6983a 	sll	r19,r17,r19
2108ca2c:	0023883a 	mov	r17,zero
2108ca30:	1c3f860e 	bge	r3,r16,2108c84c <__flash_rwdata_start+0xfffea604>
2108ca34:	017fe034 	movhi	r5,65408
2108ca38:	297fffc4 	addi	r5,r5,-1
2108ca3c:	80e1c83a 	sub	r16,r16,r3
2108ca40:	994a703a 	and	r5,r19,r5
2108ca44:	003f3206 	br	2108c710 <__flash_rwdata_start+0xfffea4c8>
2108ca48:	0009883a 	mov	r4,zero
2108ca4c:	0005883a 	mov	r2,zero
2108ca50:	003f4706 	br	2108c770 <__flash_rwdata_start+0xfffea528>
2108ca54:	198cb03a 	or	r6,r3,r6
2108ca58:	300cc03a 	cmpne	r6,r6,zero
2108ca5c:	0005883a 	mov	r2,zero
2108ca60:	003f6306 	br	2108c7f0 <__flash_rwdata_start+0xfffea5a8>
2108ca64:	10009d1e 	bne	r2,zero,2108ccdc <__subdf3+0x658>
2108ca68:	81c00044 	addi	r7,r16,1
2108ca6c:	3881ffcc 	andi	r2,r7,2047
2108ca70:	02400044 	movi	r9,1
2108ca74:	4880680e 	bge	r9,r2,2108cc18 <__subdf3+0x594>
2108ca78:	0081ffc4 	movi	r2,2047
2108ca7c:	3880ae26 	beq	r7,r2,2108cd38 <__subdf3+0x6b4>
2108ca80:	344d883a 	add	r6,r6,r17
2108ca84:	3463803a 	cmpltu	r17,r6,r17
2108ca88:	194b883a 	add	r5,r3,r5
2108ca8c:	2c4b883a 	add	r5,r5,r17
2108ca90:	282297fa 	slli	r17,r5,31
2108ca94:	300cd07a 	srli	r6,r6,1
2108ca98:	280ad07a 	srli	r5,r5,1
2108ca9c:	3821883a 	mov	r16,r7
2108caa0:	89a2b03a 	or	r17,r17,r6
2108caa4:	003f1a06 	br	2108c710 <__flash_rwdata_start+0xfffea4c8>
2108caa8:	0101ffc4 	movi	r4,2047
2108caac:	813f431e 	bne	r16,r4,2108c7bc <__flash_rwdata_start+0xfffea574>
2108cab0:	003f1706 	br	2108c710 <__flash_rwdata_start+0xfffea4c8>
2108cab4:	80bff844 	addi	r2,r16,-31
2108cab8:	00c00804 	movi	r3,32
2108cabc:	9884d83a 	srl	r2,r19,r2
2108cac0:	28c05126 	beq	r5,r3,2108cc08 <__subdf3+0x584>
2108cac4:	00c00fc4 	movi	r3,63
2108cac8:	1c21c83a 	sub	r16,r3,r16
2108cacc:	9c26983a 	sll	r19,r19,r16
2108cad0:	9c62b03a 	or	r17,r19,r17
2108cad4:	8822c03a 	cmpne	r17,r17,zero
2108cad8:	88a2b03a 	or	r17,r17,r2
2108cadc:	000b883a 	mov	r5,zero
2108cae0:	0021883a 	mov	r16,zero
2108cae4:	003fb406 	br	2108c9b8 <__flash_rwdata_start+0xfffea770>
2108cae8:	113ff804 	addi	r4,r2,-32
2108caec:	01c00804 	movi	r7,32
2108caf0:	1908d83a 	srl	r4,r3,r4
2108caf4:	11c04626 	beq	r2,r7,2108cc10 <__subdf3+0x58c>
2108caf8:	01c01004 	movi	r7,64
2108cafc:	3885c83a 	sub	r2,r7,r2
2108cb00:	1884983a 	sll	r2,r3,r2
2108cb04:	118cb03a 	or	r6,r2,r6
2108cb08:	300cc03a 	cmpne	r6,r6,zero
2108cb0c:	310cb03a 	or	r6,r6,r4
2108cb10:	0005883a 	mov	r2,zero
2108cb14:	003f3606 	br	2108c7f0 <__flash_rwdata_start+0xfffea5a8>
2108cb18:	80002b26 	beq	r16,zero,2108cbc8 <__subdf3+0x544>
2108cb1c:	0101ffc4 	movi	r4,2047
2108cb20:	51006926 	beq	r10,r4,2108ccc8 <__subdf3+0x644>
2108cb24:	0085c83a 	sub	r2,zero,r2
2108cb28:	29402034 	orhi	r5,r5,128
2108cb2c:	01000e04 	movi	r4,56
2108cb30:	20807d16 	blt	r4,r2,2108cd28 <__subdf3+0x6a4>
2108cb34:	010007c4 	movi	r4,31
2108cb38:	2080d916 	blt	r4,r2,2108cea0 <__subdf3+0x81c>
2108cb3c:	01000804 	movi	r4,32
2108cb40:	2089c83a 	sub	r4,r4,r2
2108cb44:	2912983a 	sll	r9,r5,r4
2108cb48:	8890d83a 	srl	r8,r17,r2
2108cb4c:	8908983a 	sll	r4,r17,r4
2108cb50:	2884d83a 	srl	r2,r5,r2
2108cb54:	4a22b03a 	or	r17,r9,r8
2108cb58:	2008c03a 	cmpne	r4,r4,zero
2108cb5c:	8922b03a 	or	r17,r17,r4
2108cb60:	3463c83a 	sub	r17,r6,r17
2108cb64:	1885c83a 	sub	r2,r3,r2
2108cb68:	344d803a 	cmpltu	r6,r6,r17
2108cb6c:	118bc83a 	sub	r5,r2,r6
2108cb70:	5021883a 	mov	r16,r10
2108cb74:	3825883a 	mov	r18,r7
2108cb78:	003f2206 	br	2108c804 <__flash_rwdata_start+0xfffea5bc>
2108cb7c:	9886b03a 	or	r3,r19,r2
2108cb80:	18001c1e 	bne	r3,zero,2108cbf4 <__subdf3+0x570>
2108cb84:	0011883a 	mov	r8,zero
2108cb88:	000b883a 	mov	r5,zero
2108cb8c:	0023883a 	mov	r17,zero
2108cb90:	0021883a 	mov	r16,zero
2108cb94:	003f3e06 	br	2108c890 <__flash_rwdata_start+0xfffea648>
2108cb98:	010007c4 	movi	r4,31
2108cb9c:	20803c16 	blt	r4,r2,2108cc90 <__subdf3+0x60c>
2108cba0:	01000804 	movi	r4,32
2108cba4:	2089c83a 	sub	r4,r4,r2
2108cba8:	1912983a 	sll	r9,r3,r4
2108cbac:	308ed83a 	srl	r7,r6,r2
2108cbb0:	3108983a 	sll	r4,r6,r4
2108cbb4:	1884d83a 	srl	r2,r3,r2
2108cbb8:	49ceb03a 	or	r7,r9,r7
2108cbbc:	2008c03a 	cmpne	r4,r4,zero
2108cbc0:	390eb03a 	or	r7,r7,r4
2108cbc4:	003f4706 	br	2108c8e4 <__flash_rwdata_start+0xfffea69c>
2108cbc8:	2c48b03a 	or	r4,r5,r17
2108cbcc:	20003e26 	beq	r4,zero,2108ccc8 <__subdf3+0x644>
2108cbd0:	0084303a 	nor	r2,zero,r2
2108cbd4:	10003a1e 	bne	r2,zero,2108ccc0 <__subdf3+0x63c>
2108cbd8:	3463c83a 	sub	r17,r6,r17
2108cbdc:	194bc83a 	sub	r5,r3,r5
2108cbe0:	344d803a 	cmpltu	r6,r6,r17
2108cbe4:	298bc83a 	sub	r5,r5,r6
2108cbe8:	5021883a 	mov	r16,r10
2108cbec:	3825883a 	mov	r18,r7
2108cbf0:	003f0406 	br	2108c804 <__flash_rwdata_start+0xfffea5bc>
2108cbf4:	1023883a 	mov	r17,r2
2108cbf8:	003f0706 	br	2108c818 <__flash_rwdata_start+0xfffea5d0>
2108cbfc:	0101ffc4 	movi	r4,2047
2108cc00:	813f331e 	bne	r16,r4,2108c8d0 <__flash_rwdata_start+0xfffea688>
2108cc04:	003ec206 	br	2108c710 <__flash_rwdata_start+0xfffea4c8>
2108cc08:	0027883a 	mov	r19,zero
2108cc0c:	003fb006 	br	2108cad0 <__flash_rwdata_start+0xfffea888>
2108cc10:	0005883a 	mov	r2,zero
2108cc14:	003fbb06 	br	2108cb04 <__flash_rwdata_start+0xfffea8bc>
2108cc18:	2c44b03a 	or	r2,r5,r17
2108cc1c:	80008b1e 	bne	r16,zero,2108ce4c <__subdf3+0x7c8>
2108cc20:	1000b526 	beq	r2,zero,2108cef8 <__subdf3+0x874>
2108cc24:	1984b03a 	or	r2,r3,r6
2108cc28:	103eb926 	beq	r2,zero,2108c710 <__flash_rwdata_start+0xfffea4c8>
2108cc2c:	3449883a 	add	r4,r6,r17
2108cc30:	2463803a 	cmpltu	r17,r4,r17
2108cc34:	194b883a 	add	r5,r3,r5
2108cc38:	2c4b883a 	add	r5,r5,r17
2108cc3c:	2880202c 	andhi	r2,r5,128
2108cc40:	2023883a 	mov	r17,r4
2108cc44:	103f5c26 	beq	r2,zero,2108c9b8 <__flash_rwdata_start+0xfffea770>
2108cc48:	00bfe034 	movhi	r2,65408
2108cc4c:	10bfffc4 	addi	r2,r2,-1
2108cc50:	4821883a 	mov	r16,r9
2108cc54:	288a703a 	and	r5,r5,r2
2108cc58:	003ead06 	br	2108c710 <__flash_rwdata_start+0xfffea4c8>
2108cc5c:	2c44b03a 	or	r2,r5,r17
2108cc60:	8000291e 	bne	r16,zero,2108cd08 <__subdf3+0x684>
2108cc64:	10004f1e 	bne	r2,zero,2108cda4 <__subdf3+0x720>
2108cc68:	1984b03a 	or	r2,r3,r6
2108cc6c:	10000426 	beq	r2,zero,2108cc80 <__subdf3+0x5fc>
2108cc70:	180b883a 	mov	r5,r3
2108cc74:	3023883a 	mov	r17,r6
2108cc78:	3825883a 	mov	r18,r7
2108cc7c:	003ea406 	br	2108c710 <__flash_rwdata_start+0xfffea4c8>
2108cc80:	0011883a 	mov	r8,zero
2108cc84:	000b883a 	mov	r5,zero
2108cc88:	0023883a 	mov	r17,zero
2108cc8c:	003f0006 	br	2108c890 <__flash_rwdata_start+0xfffea648>
2108cc90:	11fff804 	addi	r7,r2,-32
2108cc94:	19c8d83a 	srl	r4,r3,r7
2108cc98:	01c00804 	movi	r7,32
2108cc9c:	11c07e26 	beq	r2,r7,2108ce98 <__subdf3+0x814>
2108cca0:	01c01004 	movi	r7,64
2108cca4:	3885c83a 	sub	r2,r7,r2
2108cca8:	1884983a 	sll	r2,r3,r2
2108ccac:	118cb03a 	or	r6,r2,r6
2108ccb0:	300ec03a 	cmpne	r7,r6,zero
2108ccb4:	390eb03a 	or	r7,r7,r4
2108ccb8:	0005883a 	mov	r2,zero
2108ccbc:	003f0906 	br	2108c8e4 <__flash_rwdata_start+0xfffea69c>
2108ccc0:	0101ffc4 	movi	r4,2047
2108ccc4:	513f991e 	bne	r10,r4,2108cb2c <__flash_rwdata_start+0xfffea8e4>
2108ccc8:	180b883a 	mov	r5,r3
2108cccc:	3023883a 	mov	r17,r6
2108ccd0:	5021883a 	mov	r16,r10
2108ccd4:	3825883a 	mov	r18,r7
2108ccd8:	003e8d06 	br	2108c710 <__flash_rwdata_start+0xfffea4c8>
2108ccdc:	80001a1e 	bne	r16,zero,2108cd48 <__subdf3+0x6c4>
2108cce0:	2c48b03a 	or	r4,r5,r17
2108cce4:	20005526 	beq	r4,zero,2108ce3c <__subdf3+0x7b8>
2108cce8:	0084303a 	nor	r2,zero,r2
2108ccec:	1000511e 	bne	r2,zero,2108ce34 <__subdf3+0x7b0>
2108ccf0:	89a3883a 	add	r17,r17,r6
2108ccf4:	194b883a 	add	r5,r3,r5
2108ccf8:	898d803a 	cmpltu	r6,r17,r6
2108ccfc:	298b883a 	add	r5,r5,r6
2108cd00:	5021883a 	mov	r16,r10
2108cd04:	003efc06 	br	2108c8f8 <__flash_rwdata_start+0xfffea6b0>
2108cd08:	1000341e 	bne	r2,zero,2108cddc <__subdf3+0x758>
2108cd0c:	1984b03a 	or	r2,r3,r6
2108cd10:	10006f26 	beq	r2,zero,2108ced0 <__subdf3+0x84c>
2108cd14:	180b883a 	mov	r5,r3
2108cd18:	3023883a 	mov	r17,r6
2108cd1c:	3825883a 	mov	r18,r7
2108cd20:	0401ffc4 	movi	r16,2047
2108cd24:	003e7a06 	br	2108c710 <__flash_rwdata_start+0xfffea4c8>
2108cd28:	2c62b03a 	or	r17,r5,r17
2108cd2c:	8822c03a 	cmpne	r17,r17,zero
2108cd30:	0005883a 	mov	r2,zero
2108cd34:	003f8a06 	br	2108cb60 <__flash_rwdata_start+0xfffea918>
2108cd38:	3821883a 	mov	r16,r7
2108cd3c:	000b883a 	mov	r5,zero
2108cd40:	0023883a 	mov	r17,zero
2108cd44:	003ed206 	br	2108c890 <__flash_rwdata_start+0xfffea648>
2108cd48:	0101ffc4 	movi	r4,2047
2108cd4c:	51003b26 	beq	r10,r4,2108ce3c <__subdf3+0x7b8>
2108cd50:	0085c83a 	sub	r2,zero,r2
2108cd54:	29402034 	orhi	r5,r5,128
2108cd58:	01000e04 	movi	r4,56
2108cd5c:	20806216 	blt	r4,r2,2108cee8 <__subdf3+0x864>
2108cd60:	010007c4 	movi	r4,31
2108cd64:	20806b16 	blt	r4,r2,2108cf14 <__subdf3+0x890>
2108cd68:	01000804 	movi	r4,32
2108cd6c:	2089c83a 	sub	r4,r4,r2
2108cd70:	2912983a 	sll	r9,r5,r4
2108cd74:	888ed83a 	srl	r7,r17,r2
2108cd78:	8908983a 	sll	r4,r17,r4
2108cd7c:	2884d83a 	srl	r2,r5,r2
2108cd80:	49e2b03a 	or	r17,r9,r7
2108cd84:	2008c03a 	cmpne	r4,r4,zero
2108cd88:	8922b03a 	or	r17,r17,r4
2108cd8c:	89a3883a 	add	r17,r17,r6
2108cd90:	10c5883a 	add	r2,r2,r3
2108cd94:	898d803a 	cmpltu	r6,r17,r6
2108cd98:	118b883a 	add	r5,r2,r6
2108cd9c:	5021883a 	mov	r16,r10
2108cda0:	003ed506 	br	2108c8f8 <__flash_rwdata_start+0xfffea6b0>
2108cda4:	1984b03a 	or	r2,r3,r6
2108cda8:	103e5926 	beq	r2,zero,2108c710 <__flash_rwdata_start+0xfffea4c8>
2108cdac:	8989c83a 	sub	r4,r17,r6
2108cdb0:	8911803a 	cmpltu	r8,r17,r4
2108cdb4:	28c5c83a 	sub	r2,r5,r3
2108cdb8:	1205c83a 	sub	r2,r2,r8
2108cdbc:	1200202c 	andhi	r8,r2,128
2108cdc0:	403ef926 	beq	r8,zero,2108c9a8 <__flash_rwdata_start+0xfffea760>
2108cdc4:	3463c83a 	sub	r17,r6,r17
2108cdc8:	194bc83a 	sub	r5,r3,r5
2108cdcc:	344d803a 	cmpltu	r6,r6,r17
2108cdd0:	298bc83a 	sub	r5,r5,r6
2108cdd4:	3825883a 	mov	r18,r7
2108cdd8:	003e4d06 	br	2108c710 <__flash_rwdata_start+0xfffea4c8>
2108cddc:	1984b03a 	or	r2,r3,r6
2108cde0:	10002b26 	beq	r2,zero,2108ce90 <__subdf3+0x80c>
2108cde4:	2808d0fa 	srli	r4,r5,3
2108cde8:	8822d0fa 	srli	r17,r17,3
2108cdec:	280a977a 	slli	r5,r5,29
2108cdf0:	2080022c 	andhi	r2,r4,8
2108cdf4:	2c62b03a 	or	r17,r5,r17
2108cdf8:	10000826 	beq	r2,zero,2108ce1c <__subdf3+0x798>
2108cdfc:	1810d0fa 	srli	r8,r3,3
2108ce00:	4080022c 	andhi	r2,r8,8
2108ce04:	1000051e 	bne	r2,zero,2108ce1c <__subdf3+0x798>
2108ce08:	300cd0fa 	srli	r6,r6,3
2108ce0c:	1804977a 	slli	r2,r3,29
2108ce10:	4009883a 	mov	r4,r8
2108ce14:	3825883a 	mov	r18,r7
2108ce18:	11a2b03a 	or	r17,r2,r6
2108ce1c:	880ad77a 	srli	r5,r17,29
2108ce20:	200890fa 	slli	r4,r4,3
2108ce24:	882290fa 	slli	r17,r17,3
2108ce28:	0401ffc4 	movi	r16,2047
2108ce2c:	290ab03a 	or	r5,r5,r4
2108ce30:	003e3706 	br	2108c710 <__flash_rwdata_start+0xfffea4c8>
2108ce34:	0101ffc4 	movi	r4,2047
2108ce38:	513fc71e 	bne	r10,r4,2108cd58 <__flash_rwdata_start+0xfffeab10>
2108ce3c:	180b883a 	mov	r5,r3
2108ce40:	3023883a 	mov	r17,r6
2108ce44:	5021883a 	mov	r16,r10
2108ce48:	003e3106 	br	2108c710 <__flash_rwdata_start+0xfffea4c8>
2108ce4c:	10002d26 	beq	r2,zero,2108cf04 <__subdf3+0x880>
2108ce50:	1984b03a 	or	r2,r3,r6
2108ce54:	10000e26 	beq	r2,zero,2108ce90 <__subdf3+0x80c>
2108ce58:	2808d0fa 	srli	r4,r5,3
2108ce5c:	8822d0fa 	srli	r17,r17,3
2108ce60:	280a977a 	slli	r5,r5,29
2108ce64:	2080022c 	andhi	r2,r4,8
2108ce68:	2c62b03a 	or	r17,r5,r17
2108ce6c:	103feb26 	beq	r2,zero,2108ce1c <__flash_rwdata_start+0xfffeabd4>
2108ce70:	180ed0fa 	srli	r7,r3,3
2108ce74:	3880022c 	andhi	r2,r7,8
2108ce78:	103fe81e 	bne	r2,zero,2108ce1c <__flash_rwdata_start+0xfffeabd4>
2108ce7c:	300cd0fa 	srli	r6,r6,3
2108ce80:	1804977a 	slli	r2,r3,29
2108ce84:	3809883a 	mov	r4,r7
2108ce88:	11a2b03a 	or	r17,r2,r6
2108ce8c:	003fe306 	br	2108ce1c <__flash_rwdata_start+0xfffeabd4>
2108ce90:	0401ffc4 	movi	r16,2047
2108ce94:	003e1e06 	br	2108c710 <__flash_rwdata_start+0xfffea4c8>
2108ce98:	0005883a 	mov	r2,zero
2108ce9c:	003f8306 	br	2108ccac <__flash_rwdata_start+0xfffeaa64>
2108cea0:	113ff804 	addi	r4,r2,-32
2108cea4:	02000804 	movi	r8,32
2108cea8:	2908d83a 	srl	r4,r5,r4
2108ceac:	12002526 	beq	r2,r8,2108cf44 <__subdf3+0x8c0>
2108ceb0:	02001004 	movi	r8,64
2108ceb4:	4085c83a 	sub	r2,r8,r2
2108ceb8:	288a983a 	sll	r5,r5,r2
2108cebc:	2c62b03a 	or	r17,r5,r17
2108cec0:	8822c03a 	cmpne	r17,r17,zero
2108cec4:	8922b03a 	or	r17,r17,r4
2108cec8:	0005883a 	mov	r2,zero
2108cecc:	003f2406 	br	2108cb60 <__flash_rwdata_start+0xfffea918>
2108ced0:	01402034 	movhi	r5,128
2108ced4:	0011883a 	mov	r8,zero
2108ced8:	297fffc4 	addi	r5,r5,-1
2108cedc:	047ffe04 	movi	r17,-8
2108cee0:	0401ffc4 	movi	r16,2047
2108cee4:	003e6a06 	br	2108c890 <__flash_rwdata_start+0xfffea648>
2108cee8:	2c62b03a 	or	r17,r5,r17
2108ceec:	8822c03a 	cmpne	r17,r17,zero
2108cef0:	0005883a 	mov	r2,zero
2108cef4:	003fa506 	br	2108cd8c <__flash_rwdata_start+0xfffeab44>
2108cef8:	180b883a 	mov	r5,r3
2108cefc:	3023883a 	mov	r17,r6
2108cf00:	003e0306 	br	2108c710 <__flash_rwdata_start+0xfffea4c8>
2108cf04:	180b883a 	mov	r5,r3
2108cf08:	3023883a 	mov	r17,r6
2108cf0c:	0401ffc4 	movi	r16,2047
2108cf10:	003dff06 	br	2108c710 <__flash_rwdata_start+0xfffea4c8>
2108cf14:	113ff804 	addi	r4,r2,-32
2108cf18:	01c00804 	movi	r7,32
2108cf1c:	2908d83a 	srl	r4,r5,r4
2108cf20:	11c00a26 	beq	r2,r7,2108cf4c <__subdf3+0x8c8>
2108cf24:	01c01004 	movi	r7,64
2108cf28:	3885c83a 	sub	r2,r7,r2
2108cf2c:	288a983a 	sll	r5,r5,r2
2108cf30:	2c62b03a 	or	r17,r5,r17
2108cf34:	8822c03a 	cmpne	r17,r17,zero
2108cf38:	8922b03a 	or	r17,r17,r4
2108cf3c:	0005883a 	mov	r2,zero
2108cf40:	003f9206 	br	2108cd8c <__flash_rwdata_start+0xfffeab44>
2108cf44:	000b883a 	mov	r5,zero
2108cf48:	003fdc06 	br	2108cebc <__flash_rwdata_start+0xfffeac74>
2108cf4c:	000b883a 	mov	r5,zero
2108cf50:	003ff706 	br	2108cf30 <__flash_rwdata_start+0xfffeace8>

2108cf54 <__fixdfsi>:
2108cf54:	2806d53a 	srli	r3,r5,20
2108cf58:	00800434 	movhi	r2,16
2108cf5c:	10bfffc4 	addi	r2,r2,-1
2108cf60:	18c1ffcc 	andi	r3,r3,2047
2108cf64:	0180ff84 	movi	r6,1022
2108cf68:	2884703a 	and	r2,r5,r2
2108cf6c:	280ad7fa 	srli	r5,r5,31
2108cf70:	30c0130e 	bge	r6,r3,2108cfc0 <__fixdfsi+0x6c>
2108cf74:	01810744 	movi	r6,1053
2108cf78:	30c00d16 	blt	r6,r3,2108cfb0 <__fixdfsi+0x5c>
2108cf7c:	01810cc4 	movi	r6,1075
2108cf80:	30cdc83a 	sub	r6,r6,r3
2108cf84:	01c007c4 	movi	r7,31
2108cf88:	10800434 	orhi	r2,r2,16
2108cf8c:	39800e0e 	bge	r7,r6,2108cfc8 <__fixdfsi+0x74>
2108cf90:	010104c4 	movi	r4,1043
2108cf94:	20c7c83a 	sub	r3,r4,r3
2108cf98:	10c6d83a 	srl	r3,r2,r3
2108cf9c:	29403fcc 	andi	r5,r5,255
2108cfa0:	0145c83a 	sub	r2,zero,r5
2108cfa4:	1884f03a 	xor	r2,r3,r2
2108cfa8:	1145883a 	add	r2,r2,r5
2108cfac:	f800283a 	ret
2108cfb0:	00a00034 	movhi	r2,32768
2108cfb4:	10bfffc4 	addi	r2,r2,-1
2108cfb8:	2885883a 	add	r2,r5,r2
2108cfbc:	f800283a 	ret
2108cfc0:	0005883a 	mov	r2,zero
2108cfc4:	f800283a 	ret
2108cfc8:	18fefb44 	addi	r3,r3,-1043
2108cfcc:	2188d83a 	srl	r4,r4,r6
2108cfd0:	10c6983a 	sll	r3,r2,r3
2108cfd4:	20c6b03a 	or	r3,r4,r3
2108cfd8:	003ff006 	br	2108cf9c <__flash_rwdata_start+0xfffead54>

2108cfdc <__floatsidf>:
2108cfdc:	defffd04 	addi	sp,sp,-12
2108cfe0:	dc400115 	stw	r17,4(sp)
2108cfe4:	dfc00215 	stw	ra,8(sp)
2108cfe8:	dc000015 	stw	r16,0(sp)
2108cfec:	2023883a 	mov	r17,r4
2108cff0:	20001426 	beq	r4,zero,2108d044 <__floatsidf+0x68>
2108cff4:	2020d7fa 	srli	r16,r4,31
2108cff8:	80000126 	beq	r16,zero,2108d000 <__floatsidf+0x24>
2108cffc:	0123c83a 	sub	r17,zero,r4
2108d000:	8809883a 	mov	r4,r17
2108d004:	108d3f80 	call	2108d3f8 <__clzsi2>
2108d008:	01410784 	movi	r5,1054
2108d00c:	00c00284 	movi	r3,10
2108d010:	288bc83a 	sub	r5,r5,r2
2108d014:	18801c16 	blt	r3,r2,2108d088 <__floatsidf+0xac>
2108d018:	00c002c4 	movi	r3,11
2108d01c:	1887c83a 	sub	r3,r3,r2
2108d020:	88c8d83a 	srl	r4,r17,r3
2108d024:	00c00434 	movhi	r3,16
2108d028:	18ffffc4 	addi	r3,r3,-1
2108d02c:	10800544 	addi	r2,r2,21
2108d030:	20c8703a 	and	r4,r4,r3
2108d034:	8884983a 	sll	r2,r17,r2
2108d038:	28c1ffcc 	andi	r3,r5,2047
2108d03c:	800d883a 	mov	r6,r16
2108d040:	00000406 	br	2108d054 <__floatsidf+0x78>
2108d044:	000d883a 	mov	r6,zero
2108d048:	0007883a 	mov	r3,zero
2108d04c:	0009883a 	mov	r4,zero
2108d050:	0005883a 	mov	r2,zero
2108d054:	180a953a 	slli	r5,r3,20
2108d058:	31803fcc 	andi	r6,r6,255
2108d05c:	00c00434 	movhi	r3,16
2108d060:	300c97fa 	slli	r6,r6,31
2108d064:	18ffffc4 	addi	r3,r3,-1
2108d068:	20c6703a 	and	r3,r4,r3
2108d06c:	1946b03a 	or	r3,r3,r5
2108d070:	1986b03a 	or	r3,r3,r6
2108d074:	dfc00217 	ldw	ra,8(sp)
2108d078:	dc400117 	ldw	r17,4(sp)
2108d07c:	dc000017 	ldw	r16,0(sp)
2108d080:	dec00304 	addi	sp,sp,12
2108d084:	f800283a 	ret
2108d088:	10fffd44 	addi	r3,r2,-11
2108d08c:	88c8983a 	sll	r4,r17,r3
2108d090:	00800434 	movhi	r2,16
2108d094:	10bfffc4 	addi	r2,r2,-1
2108d098:	2088703a 	and	r4,r4,r2
2108d09c:	28c1ffcc 	andi	r3,r5,2047
2108d0a0:	800d883a 	mov	r6,r16
2108d0a4:	0005883a 	mov	r2,zero
2108d0a8:	003fea06 	br	2108d054 <__flash_rwdata_start+0xfffeae0c>

2108d0ac <__floatunsidf>:
2108d0ac:	defffe04 	addi	sp,sp,-8
2108d0b0:	dc000015 	stw	r16,0(sp)
2108d0b4:	dfc00115 	stw	ra,4(sp)
2108d0b8:	2021883a 	mov	r16,r4
2108d0bc:	20001026 	beq	r4,zero,2108d100 <__floatunsidf+0x54>
2108d0c0:	108d3f80 	call	2108d3f8 <__clzsi2>
2108d0c4:	01410784 	movi	r5,1054
2108d0c8:	100d883a 	mov	r6,r2
2108d0cc:	288bc83a 	sub	r5,r5,r2
2108d0d0:	00800284 	movi	r2,10
2108d0d4:	11801616 	blt	r2,r6,2108d130 <__floatunsidf+0x84>
2108d0d8:	008002c4 	movi	r2,11
2108d0dc:	1185c83a 	sub	r2,r2,r6
2108d0e0:	8084d83a 	srl	r2,r16,r2
2108d0e4:	00c00434 	movhi	r3,16
2108d0e8:	31c00544 	addi	r7,r6,21
2108d0ec:	18ffffc4 	addi	r3,r3,-1
2108d0f0:	81e0983a 	sll	r16,r16,r7
2108d0f4:	10cc703a 	and	r6,r2,r3
2108d0f8:	2941ffcc 	andi	r5,r5,2047
2108d0fc:	00000206 	br	2108d108 <__floatunsidf+0x5c>
2108d100:	000b883a 	mov	r5,zero
2108d104:	000d883a 	mov	r6,zero
2108d108:	280a953a 	slli	r5,r5,20
2108d10c:	00c00434 	movhi	r3,16
2108d110:	18ffffc4 	addi	r3,r3,-1
2108d114:	30c6703a 	and	r3,r6,r3
2108d118:	8005883a 	mov	r2,r16
2108d11c:	1946b03a 	or	r3,r3,r5
2108d120:	dfc00117 	ldw	ra,4(sp)
2108d124:	dc000017 	ldw	r16,0(sp)
2108d128:	dec00204 	addi	sp,sp,8
2108d12c:	f800283a 	ret
2108d130:	31bffd44 	addi	r6,r6,-11
2108d134:	818c983a 	sll	r6,r16,r6
2108d138:	00800434 	movhi	r2,16
2108d13c:	10bfffc4 	addi	r2,r2,-1
2108d140:	2941ffcc 	andi	r5,r5,2047
2108d144:	0021883a 	mov	r16,zero
2108d148:	308c703a 	and	r6,r6,r2
2108d14c:	003fee06 	br	2108d108 <__flash_rwdata_start+0xfffeaec0>

2108d150 <__extendsfdf2>:
2108d150:	200ad5fa 	srli	r5,r4,23
2108d154:	defffd04 	addi	sp,sp,-12
2108d158:	dc400115 	stw	r17,4(sp)
2108d15c:	29403fcc 	andi	r5,r5,255
2108d160:	29800044 	addi	r6,r5,1
2108d164:	04402034 	movhi	r17,128
2108d168:	dc000015 	stw	r16,0(sp)
2108d16c:	8c7fffc4 	addi	r17,r17,-1
2108d170:	dfc00215 	stw	ra,8(sp)
2108d174:	31803fcc 	andi	r6,r6,255
2108d178:	00800044 	movi	r2,1
2108d17c:	8922703a 	and	r17,r17,r4
2108d180:	2020d7fa 	srli	r16,r4,31
2108d184:	1180110e 	bge	r2,r6,2108d1cc <__extendsfdf2+0x7c>
2108d188:	880ed0fa 	srli	r7,r17,3
2108d18c:	8822977a 	slli	r17,r17,29
2108d190:	2940e004 	addi	r5,r5,896
2108d194:	2941ffcc 	andi	r5,r5,2047
2108d198:	280c953a 	slli	r6,r5,20
2108d19c:	01400434 	movhi	r5,16
2108d1a0:	800697fa 	slli	r3,r16,31
2108d1a4:	297fffc4 	addi	r5,r5,-1
2108d1a8:	394a703a 	and	r5,r7,r5
2108d1ac:	298ab03a 	or	r5,r5,r6
2108d1b0:	8805883a 	mov	r2,r17
2108d1b4:	28c6b03a 	or	r3,r5,r3
2108d1b8:	dfc00217 	ldw	ra,8(sp)
2108d1bc:	dc400117 	ldw	r17,4(sp)
2108d1c0:	dc000017 	ldw	r16,0(sp)
2108d1c4:	dec00304 	addi	sp,sp,12
2108d1c8:	f800283a 	ret
2108d1cc:	2800111e 	bne	r5,zero,2108d214 <__extendsfdf2+0xc4>
2108d1d0:	88001c26 	beq	r17,zero,2108d244 <__extendsfdf2+0xf4>
2108d1d4:	8809883a 	mov	r4,r17
2108d1d8:	108d3f80 	call	2108d3f8 <__clzsi2>
2108d1dc:	00c00284 	movi	r3,10
2108d1e0:	18801b16 	blt	r3,r2,2108d250 <__extendsfdf2+0x100>
2108d1e4:	01c002c4 	movi	r7,11
2108d1e8:	388fc83a 	sub	r7,r7,r2
2108d1ec:	10c00544 	addi	r3,r2,21
2108d1f0:	89ced83a 	srl	r7,r17,r7
2108d1f4:	88e2983a 	sll	r17,r17,r3
2108d1f8:	0180e244 	movi	r6,905
2108d1fc:	308bc83a 	sub	r5,r6,r2
2108d200:	01800434 	movhi	r6,16
2108d204:	31bfffc4 	addi	r6,r6,-1
2108d208:	398e703a 	and	r7,r7,r6
2108d20c:	2941ffcc 	andi	r5,r5,2047
2108d210:	003fe006 	br	2108d194 <__flash_rwdata_start+0xfffeaf4c>
2108d214:	88000826 	beq	r17,zero,2108d238 <__extendsfdf2+0xe8>
2108d218:	880ed0fa 	srli	r7,r17,3
2108d21c:	00800434 	movhi	r2,16
2108d220:	10bfffc4 	addi	r2,r2,-1
2108d224:	39c00234 	orhi	r7,r7,8
2108d228:	8822977a 	slli	r17,r17,29
2108d22c:	388e703a 	and	r7,r7,r2
2108d230:	0141ffc4 	movi	r5,2047
2108d234:	003fd706 	br	2108d194 <__flash_rwdata_start+0xfffeaf4c>
2108d238:	0141ffc4 	movi	r5,2047
2108d23c:	000f883a 	mov	r7,zero
2108d240:	003fd406 	br	2108d194 <__flash_rwdata_start+0xfffeaf4c>
2108d244:	000b883a 	mov	r5,zero
2108d248:	000f883a 	mov	r7,zero
2108d24c:	003fd106 	br	2108d194 <__flash_rwdata_start+0xfffeaf4c>
2108d250:	11fffd44 	addi	r7,r2,-11
2108d254:	89ce983a 	sll	r7,r17,r7
2108d258:	0023883a 	mov	r17,zero
2108d25c:	003fe606 	br	2108d1f8 <__flash_rwdata_start+0xfffeafb0>

2108d260 <__truncdfsf2>:
2108d260:	2810d53a 	srli	r8,r5,20
2108d264:	01c00434 	movhi	r7,16
2108d268:	39ffffc4 	addi	r7,r7,-1
2108d26c:	29ce703a 	and	r7,r5,r7
2108d270:	380e90fa 	slli	r7,r7,3
2108d274:	4201ffcc 	andi	r8,r8,2047
2108d278:	200cd77a 	srli	r6,r4,29
2108d27c:	42400044 	addi	r9,r8,1
2108d280:	4a41ffcc 	andi	r9,r9,2047
2108d284:	00800044 	movi	r2,1
2108d288:	398cb03a 	or	r6,r7,r6
2108d28c:	280ad7fa 	srli	r5,r5,31
2108d290:	200e90fa 	slli	r7,r4,3
2108d294:	1240230e 	bge	r2,r9,2108d324 <__truncdfsf2+0xc4>
2108d298:	40ff2004 	addi	r3,r8,-896
2108d29c:	00803f84 	movi	r2,254
2108d2a0:	10c01516 	blt	r2,r3,2108d2f8 <__truncdfsf2+0x98>
2108d2a4:	00c02d0e 	bge	zero,r3,2108d35c <__truncdfsf2+0xfc>
2108d2a8:	200891ba 	slli	r4,r4,6
2108d2ac:	300c90fa 	slli	r6,r6,3
2108d2b0:	380ed77a 	srli	r7,r7,29
2108d2b4:	2008c03a 	cmpne	r4,r4,zero
2108d2b8:	310cb03a 	or	r6,r6,r4
2108d2bc:	31ccb03a 	or	r6,r6,r7
2108d2c0:	308001cc 	andi	r2,r6,7
2108d2c4:	10000426 	beq	r2,zero,2108d2d8 <__truncdfsf2+0x78>
2108d2c8:	310003cc 	andi	r4,r6,15
2108d2cc:	00800104 	movi	r2,4
2108d2d0:	20800126 	beq	r4,r2,2108d2d8 <__truncdfsf2+0x78>
2108d2d4:	31800104 	addi	r6,r6,4
2108d2d8:	3081002c 	andhi	r2,r6,1024
2108d2dc:	10002326 	beq	r2,zero,2108d36c <__truncdfsf2+0x10c>
2108d2e0:	18c00044 	addi	r3,r3,1
2108d2e4:	00803fc4 	movi	r2,255
2108d2e8:	18800326 	beq	r3,r2,2108d2f8 <__truncdfsf2+0x98>
2108d2ec:	300c91ba 	slli	r6,r6,6
2108d2f0:	300cd27a 	srli	r6,r6,9
2108d2f4:	00000206 	br	2108d300 <__truncdfsf2+0xa0>
2108d2f8:	00ffffc4 	movi	r3,-1
2108d2fc:	000d883a 	mov	r6,zero
2108d300:	18c03fcc 	andi	r3,r3,255
2108d304:	180895fa 	slli	r4,r3,23
2108d308:	00c02034 	movhi	r3,128
2108d30c:	280a97fa 	slli	r5,r5,31
2108d310:	18ffffc4 	addi	r3,r3,-1
2108d314:	30c6703a 	and	r3,r6,r3
2108d318:	1906b03a 	or	r3,r3,r4
2108d31c:	1944b03a 	or	r2,r3,r5
2108d320:	f800283a 	ret
2108d324:	4000071e 	bne	r8,zero,2108d344 <__truncdfsf2+0xe4>
2108d328:	31ccb03a 	or	r6,r6,r7
2108d32c:	30000d1e 	bne	r6,zero,2108d364 <__truncdfsf2+0x104>
2108d330:	0007883a 	mov	r3,zero
2108d334:	00802034 	movhi	r2,128
2108d338:	10bfffc4 	addi	r2,r2,-1
2108d33c:	308c703a 	and	r6,r6,r2
2108d340:	003fef06 	br	2108d300 <__flash_rwdata_start+0xfffeb0b8>
2108d344:	31c8b03a 	or	r4,r6,r7
2108d348:	203feb26 	beq	r4,zero,2108d2f8 <__flash_rwdata_start+0xfffeb0b0>
2108d34c:	300c90fa 	slli	r6,r6,3
2108d350:	00c03fc4 	movi	r3,255
2108d354:	31808034 	orhi	r6,r6,512
2108d358:	003fd906 	br	2108d2c0 <__flash_rwdata_start+0xfffeb078>
2108d35c:	00bffa44 	movi	r2,-23
2108d360:	1880090e 	bge	r3,r2,2108d388 <__truncdfsf2+0x128>
2108d364:	01800144 	movi	r6,5
2108d368:	0007883a 	mov	r3,zero
2108d36c:	00803fc4 	movi	r2,255
2108d370:	300cd0fa 	srli	r6,r6,3
2108d374:	18bfef1e 	bne	r3,r2,2108d334 <__flash_rwdata_start+0xfffeb0ec>
2108d378:	303fdf26 	beq	r6,zero,2108d2f8 <__flash_rwdata_start+0xfffeb0b0>
2108d37c:	31801034 	orhi	r6,r6,64
2108d380:	00ffffc4 	movi	r3,-1
2108d384:	003feb06 	br	2108d334 <__flash_rwdata_start+0xfffeb0ec>
2108d388:	0080e784 	movi	r2,926
2108d38c:	1205c83a 	sub	r2,r2,r8
2108d390:	00c007c4 	movi	r3,31
2108d394:	31802034 	orhi	r6,r6,128
2108d398:	18800916 	blt	r3,r2,2108d3c0 <__truncdfsf2+0x160>
2108d39c:	423f2084 	addi	r8,r8,-894
2108d3a0:	3a06983a 	sll	r3,r7,r8
2108d3a4:	3210983a 	sll	r8,r6,r8
2108d3a8:	388ed83a 	srl	r7,r7,r2
2108d3ac:	180cc03a 	cmpne	r6,r3,zero
2108d3b0:	418cb03a 	or	r6,r8,r6
2108d3b4:	31ccb03a 	or	r6,r6,r7
2108d3b8:	0007883a 	mov	r3,zero
2108d3bc:	003fc006 	br	2108d2c0 <__flash_rwdata_start+0xfffeb078>
2108d3c0:	00c0df84 	movi	r3,894
2108d3c4:	1a07c83a 	sub	r3,r3,r8
2108d3c8:	01000804 	movi	r4,32
2108d3cc:	30c6d83a 	srl	r3,r6,r3
2108d3d0:	11000726 	beq	r2,r4,2108d3f0 <__truncdfsf2+0x190>
2108d3d4:	423f2884 	addi	r8,r8,-862
2108d3d8:	3210983a 	sll	r8,r6,r8
2108d3dc:	41ceb03a 	or	r7,r8,r7
2108d3e0:	380ec03a 	cmpne	r7,r7,zero
2108d3e4:	38ccb03a 	or	r6,r7,r3
2108d3e8:	0007883a 	mov	r3,zero
2108d3ec:	003fb406 	br	2108d2c0 <__flash_rwdata_start+0xfffeb078>
2108d3f0:	0011883a 	mov	r8,zero
2108d3f4:	003ff906 	br	2108d3dc <__flash_rwdata_start+0xfffeb194>

2108d3f8 <__clzsi2>:
2108d3f8:	00bfffd4 	movui	r2,65535
2108d3fc:	11000b36 	bltu	r2,r4,2108d42c <__clzsi2+0x34>
2108d400:	00803fc4 	movi	r2,255
2108d404:	1100122e 	bgeu	r2,r4,2108d450 <__clzsi2+0x58>
2108d408:	00c00204 	movi	r3,8
2108d40c:	01400604 	movi	r5,24
2108d410:	20c8d83a 	srl	r4,r4,r3
2108d414:	00800034 	movhi	r2,0
2108d418:	108e8904 	addi	r2,r2,14884
2108d41c:	1109883a 	add	r4,r2,r4
2108d420:	20800003 	ldbu	r2,0(r4)
2108d424:	2885c83a 	sub	r2,r5,r2
2108d428:	f800283a 	ret
2108d42c:	00804034 	movhi	r2,256
2108d430:	10bfffc4 	addi	r2,r2,-1
2108d434:	11000336 	bltu	r2,r4,2108d444 <__clzsi2+0x4c>
2108d438:	00c00404 	movi	r3,16
2108d43c:	180b883a 	mov	r5,r3
2108d440:	003ff306 	br	2108d410 <__flash_rwdata_start+0xfffeb1c8>
2108d444:	00c00604 	movi	r3,24
2108d448:	01400204 	movi	r5,8
2108d44c:	003ff006 	br	2108d410 <__flash_rwdata_start+0xfffeb1c8>
2108d450:	0007883a 	mov	r3,zero
2108d454:	01400804 	movi	r5,32
2108d458:	003fed06 	br	2108d410 <__flash_rwdata_start+0xfffeb1c8>

2108d45c <udivmodsi4>:
2108d45c:	2900182e 	bgeu	r5,r4,2108d4c0 <udivmodsi4+0x64>
2108d460:	28001716 	blt	r5,zero,2108d4c0 <udivmodsi4+0x64>
2108d464:	00800804 	movi	r2,32
2108d468:	00c00044 	movi	r3,1
2108d46c:	00000206 	br	2108d478 <udivmodsi4+0x1c>
2108d470:	10001126 	beq	r2,zero,2108d4b8 <udivmodsi4+0x5c>
2108d474:	28000516 	blt	r5,zero,2108d48c <udivmodsi4+0x30>
2108d478:	294b883a 	add	r5,r5,r5
2108d47c:	10bfffc4 	addi	r2,r2,-1
2108d480:	18c7883a 	add	r3,r3,r3
2108d484:	293ffa36 	bltu	r5,r4,2108d470 <__flash_rwdata_start+0xfffeb228>
2108d488:	18000b26 	beq	r3,zero,2108d4b8 <udivmodsi4+0x5c>
2108d48c:	0005883a 	mov	r2,zero
2108d490:	21400236 	bltu	r4,r5,2108d49c <udivmodsi4+0x40>
2108d494:	2149c83a 	sub	r4,r4,r5
2108d498:	10c4b03a 	or	r2,r2,r3
2108d49c:	1806d07a 	srli	r3,r3,1
2108d4a0:	280ad07a 	srli	r5,r5,1
2108d4a4:	183ffa1e 	bne	r3,zero,2108d490 <__flash_rwdata_start+0xfffeb248>
2108d4a8:	3000011e 	bne	r6,zero,2108d4b0 <udivmodsi4+0x54>
2108d4ac:	f800283a 	ret
2108d4b0:	2005883a 	mov	r2,r4
2108d4b4:	f800283a 	ret
2108d4b8:	0005883a 	mov	r2,zero
2108d4bc:	003ffa06 	br	2108d4a8 <__flash_rwdata_start+0xfffeb260>
2108d4c0:	00c00044 	movi	r3,1
2108d4c4:	003ff106 	br	2108d48c <__flash_rwdata_start+0xfffeb244>

2108d4c8 <__divsi3>:
2108d4c8:	defffe04 	addi	sp,sp,-8
2108d4cc:	dfc00115 	stw	ra,4(sp)
2108d4d0:	dc000015 	stw	r16,0(sp)
2108d4d4:	20000b16 	blt	r4,zero,2108d504 <__divsi3+0x3c>
2108d4d8:	0021883a 	mov	r16,zero
2108d4dc:	28000c16 	blt	r5,zero,2108d510 <__divsi3+0x48>
2108d4e0:	000d883a 	mov	r6,zero
2108d4e4:	108d45c0 	call	2108d45c <udivmodsi4>
2108d4e8:	0407c83a 	sub	r3,zero,r16
2108d4ec:	1884f03a 	xor	r2,r3,r2
2108d4f0:	1405883a 	add	r2,r2,r16
2108d4f4:	dfc00117 	ldw	ra,4(sp)
2108d4f8:	dc000017 	ldw	r16,0(sp)
2108d4fc:	dec00204 	addi	sp,sp,8
2108d500:	f800283a 	ret
2108d504:	0109c83a 	sub	r4,zero,r4
2108d508:	04000044 	movi	r16,1
2108d50c:	283ff40e 	bge	r5,zero,2108d4e0 <__flash_rwdata_start+0xfffeb298>
2108d510:	014bc83a 	sub	r5,zero,r5
2108d514:	8400005c 	xori	r16,r16,1
2108d518:	003ff106 	br	2108d4e0 <__flash_rwdata_start+0xfffeb298>

2108d51c <__modsi3>:
2108d51c:	defffd04 	addi	sp,sp,-12
2108d520:	dfc00215 	stw	ra,8(sp)
2108d524:	dc400115 	stw	r17,4(sp)
2108d528:	dc000015 	stw	r16,0(sp)
2108d52c:	20000c16 	blt	r4,zero,2108d560 <__modsi3+0x44>
2108d530:	0023883a 	mov	r17,zero
2108d534:	0021883a 	mov	r16,zero
2108d538:	28000d16 	blt	r5,zero,2108d570 <__modsi3+0x54>
2108d53c:	01800044 	movi	r6,1
2108d540:	108d45c0 	call	2108d45c <udivmodsi4>
2108d544:	1404f03a 	xor	r2,r2,r16
2108d548:	8885883a 	add	r2,r17,r2
2108d54c:	dfc00217 	ldw	ra,8(sp)
2108d550:	dc400117 	ldw	r17,4(sp)
2108d554:	dc000017 	ldw	r16,0(sp)
2108d558:	dec00304 	addi	sp,sp,12
2108d55c:	f800283a 	ret
2108d560:	0109c83a 	sub	r4,zero,r4
2108d564:	04400044 	movi	r17,1
2108d568:	043fffc4 	movi	r16,-1
2108d56c:	283ff30e 	bge	r5,zero,2108d53c <__flash_rwdata_start+0xfffeb2f4>
2108d570:	014bc83a 	sub	r5,zero,r5
2108d574:	003ff106 	br	2108d53c <__flash_rwdata_start+0xfffeb2f4>

2108d578 <__udivsi3>:
2108d578:	000d883a 	mov	r6,zero
2108d57c:	108d45c1 	jmpi	2108d45c <udivmodsi4>

2108d580 <__umodsi3>:
2108d580:	01800044 	movi	r6,1
2108d584:	108d45c1 	jmpi	2108d45c <udivmodsi4>

2108d588 <exit>:
2108d588:	defffe04 	addi	sp,sp,-8
2108d58c:	000b883a 	mov	r5,zero
2108d590:	dc000015 	stw	r16,0(sp)
2108d594:	dfc00115 	stw	ra,4(sp)
2108d598:	2021883a 	mov	r16,r4
2108d59c:	1092a640 	call	21092a64 <__call_exitprocs>
2108d5a0:	00800034 	movhi	r2,0
2108d5a4:	10976a04 	addi	r2,r2,23976
2108d5a8:	11000017 	ldw	r4,0(r2)
2108d5ac:	20800f17 	ldw	r2,60(r4)
2108d5b0:	10000126 	beq	r2,zero,2108d5b8 <exit+0x30>
2108d5b4:	103ee83a 	callr	r2
2108d5b8:	8009883a 	mov	r4,r16
2108d5bc:	109b1bc0 	call	2109b1bc <_exit>

2108d5c0 <_fprintf_r>:
2108d5c0:	defffe04 	addi	sp,sp,-8
2108d5c4:	2809883a 	mov	r4,r5
2108d5c8:	dfc00015 	stw	ra,0(sp)
2108d5cc:	d9c00115 	stw	r7,4(sp)
2108d5d0:	300b883a 	mov	r5,r6
2108d5d4:	d9800104 	addi	r6,sp,4
2108d5d8:	10927000 	call	21092700 <__vfprintf_internal>
2108d5dc:	dfc00017 	ldw	ra,0(sp)
2108d5e0:	dec00204 	addi	sp,sp,8
2108d5e4:	f800283a 	ret

2108d5e8 <fprintf>:
2108d5e8:	defffd04 	addi	sp,sp,-12
2108d5ec:	dfc00015 	stw	ra,0(sp)
2108d5f0:	d9800115 	stw	r6,4(sp)
2108d5f4:	d9c00215 	stw	r7,8(sp)
2108d5f8:	d9800104 	addi	r6,sp,4
2108d5fc:	10927000 	call	21092700 <__vfprintf_internal>
2108d600:	dfc00017 	ldw	ra,0(sp)
2108d604:	dec00304 	addi	sp,sp,12
2108d608:	f800283a 	ret

2108d60c <_fwrite_r>:
2108d60c:	defff504 	addi	sp,sp,-44
2108d610:	dcc00815 	stw	r19,32(sp)
2108d614:	39a7383a 	mul	r19,r7,r6
2108d618:	d8800304 	addi	r2,sp,12
2108d61c:	d8800015 	stw	r2,0(sp)
2108d620:	00800044 	movi	r2,1
2108d624:	dd000915 	stw	r20,36(sp)
2108d628:	dc800715 	stw	r18,28(sp)
2108d62c:	dc400615 	stw	r17,24(sp)
2108d630:	d9400315 	stw	r5,12(sp)
2108d634:	dfc00a15 	stw	ra,40(sp)
2108d638:	dcc00415 	stw	r19,16(sp)
2108d63c:	dcc00215 	stw	r19,8(sp)
2108d640:	d8800115 	stw	r2,4(sp)
2108d644:	3029883a 	mov	r20,r6
2108d648:	3823883a 	mov	r17,r7
2108d64c:	2025883a 	mov	r18,r4
2108d650:	d9400b17 	ldw	r5,44(sp)
2108d654:	20000226 	beq	r4,zero,2108d660 <_fwrite_r+0x54>
2108d658:	20800e17 	ldw	r2,56(r4)
2108d65c:	10001a26 	beq	r2,zero,2108d6c8 <_fwrite_r+0xbc>
2108d660:	2880030b 	ldhu	r2,12(r5)
2108d664:	10c8000c 	andi	r3,r2,8192
2108d668:	1800061e 	bne	r3,zero,2108d684 <_fwrite_r+0x78>
2108d66c:	29001917 	ldw	r4,100(r5)
2108d670:	00f7ffc4 	movi	r3,-8193
2108d674:	10880014 	ori	r2,r2,8192
2108d678:	20c6703a 	and	r3,r4,r3
2108d67c:	2880030d 	sth	r2,12(r5)
2108d680:	28c01915 	stw	r3,100(r5)
2108d684:	9009883a 	mov	r4,r18
2108d688:	d80d883a 	mov	r6,sp
2108d68c:	1094f680 	call	21094f68 <__sfvwrite_r>
2108d690:	10000b26 	beq	r2,zero,2108d6c0 <_fwrite_r+0xb4>
2108d694:	d9000217 	ldw	r4,8(sp)
2108d698:	a00b883a 	mov	r5,r20
2108d69c:	9909c83a 	sub	r4,r19,r4
2108d6a0:	108d5780 	call	2108d578 <__udivsi3>
2108d6a4:	dfc00a17 	ldw	ra,40(sp)
2108d6a8:	dd000917 	ldw	r20,36(sp)
2108d6ac:	dcc00817 	ldw	r19,32(sp)
2108d6b0:	dc800717 	ldw	r18,28(sp)
2108d6b4:	dc400617 	ldw	r17,24(sp)
2108d6b8:	dec00b04 	addi	sp,sp,44
2108d6bc:	f800283a 	ret
2108d6c0:	8805883a 	mov	r2,r17
2108d6c4:	003ff706 	br	2108d6a4 <__flash_rwdata_start+0xfffeb45c>
2108d6c8:	d9400515 	stw	r5,20(sp)
2108d6cc:	1094b040 	call	21094b04 <__sinit>
2108d6d0:	d9400517 	ldw	r5,20(sp)
2108d6d4:	003fe206 	br	2108d660 <__flash_rwdata_start+0xfffeb418>

2108d6d8 <fwrite>:
2108d6d8:	00800034 	movhi	r2,0
2108d6dc:	10976b04 	addi	r2,r2,23980
2108d6e0:	2011883a 	mov	r8,r4
2108d6e4:	11000017 	ldw	r4,0(r2)
2108d6e8:	defffe04 	addi	sp,sp,-8
2108d6ec:	2807883a 	mov	r3,r5
2108d6f0:	3005883a 	mov	r2,r6
2108d6f4:	d9c00015 	stw	r7,0(sp)
2108d6f8:	400b883a 	mov	r5,r8
2108d6fc:	180d883a 	mov	r6,r3
2108d700:	100f883a 	mov	r7,r2
2108d704:	dfc00115 	stw	ra,4(sp)
2108d708:	108d60c0 	call	2108d60c <_fwrite_r>
2108d70c:	dfc00117 	ldw	ra,4(sp)
2108d710:	dec00204 	addi	sp,sp,8
2108d714:	f800283a 	ret

2108d718 <memalign>:
2108d718:	00c00034 	movhi	r3,0
2108d71c:	18d76b04 	addi	r3,r3,23980
2108d720:	2005883a 	mov	r2,r4
2108d724:	19000017 	ldw	r4,0(r3)
2108d728:	280d883a 	mov	r6,r5
2108d72c:	100b883a 	mov	r5,r2
2108d730:	108d7341 	jmpi	2108d734 <_memalign_r>

2108d734 <_memalign_r>:
2108d734:	defffa04 	addi	sp,sp,-24
2108d738:	dc400115 	stw	r17,4(sp)
2108d73c:	dfc00515 	stw	ra,20(sp)
2108d740:	dd000415 	stw	r20,16(sp)
2108d744:	dcc00315 	stw	r19,12(sp)
2108d748:	dc800215 	stw	r18,8(sp)
2108d74c:	dc000015 	stw	r16,0(sp)
2108d750:	00800204 	movi	r2,8
2108d754:	2823883a 	mov	r17,r5
2108d758:	11404b2e 	bgeu	r2,r5,2108d888 <_memalign_r+0x154>
2108d75c:	008003c4 	movi	r2,15
2108d760:	2029883a 	mov	r20,r4
2108d764:	11400136 	bltu	r2,r5,2108d76c <_memalign_r+0x38>
2108d768:	04400404 	movi	r17,16
2108d76c:	308002c4 	addi	r2,r6,11
2108d770:	00c00584 	movi	r3,22
2108d774:	18803e2e 	bgeu	r3,r2,2108d870 <_memalign_r+0x13c>
2108d778:	04bffe04 	movi	r18,-8
2108d77c:	14a4703a 	and	r18,r2,r18
2108d780:	90003d16 	blt	r18,zero,2108d878 <_memalign_r+0x144>
2108d784:	91803c36 	bltu	r18,r6,2108d878 <_memalign_r+0x144>
2108d788:	89400404 	addi	r5,r17,16
2108d78c:	a009883a 	mov	r4,r20
2108d790:	2c8b883a 	add	r5,r5,r18
2108d794:	108d9100 	call	2108d910 <_malloc_r>
2108d798:	1027883a 	mov	r19,r2
2108d79c:	10005026 	beq	r2,zero,2108d8e0 <_memalign_r+0x1ac>
2108d7a0:	a009883a 	mov	r4,r20
2108d7a4:	109b5540 	call	2109b554 <__malloc_lock>
2108d7a8:	9809883a 	mov	r4,r19
2108d7ac:	880b883a 	mov	r5,r17
2108d7b0:	9c3ffe04 	addi	r16,r19,-8
2108d7b4:	108d5800 	call	2108d580 <__umodsi3>
2108d7b8:	10001c26 	beq	r2,zero,2108d82c <_memalign_r+0xf8>
2108d7bc:	88bfffc4 	addi	r2,r17,-1
2108d7c0:	9887883a 	add	r3,r19,r2
2108d7c4:	0445c83a 	sub	r2,zero,r17
2108d7c8:	1884703a 	and	r2,r3,r2
2108d7cc:	10bffe04 	addi	r2,r2,-8
2108d7d0:	1409c83a 	sub	r4,r2,r16
2108d7d4:	014003c4 	movi	r5,15
2108d7d8:	8007883a 	mov	r3,r16
2108d7dc:	2900330e 	bge	r5,r4,2108d8ac <_memalign_r+0x178>
2108d7e0:	1021883a 	mov	r16,r2
2108d7e4:	993fff17 	ldw	r4,-4(r19)
2108d7e8:	00bfff04 	movi	r2,-4
2108d7ec:	80c7c83a 	sub	r3,r16,r3
2108d7f0:	2084703a 	and	r2,r4,r2
2108d7f4:	10c5c83a 	sub	r2,r2,r3
2108d7f8:	11000054 	ori	r4,r2,1
2108d7fc:	81000115 	stw	r4,4(r16)
2108d800:	8085883a 	add	r2,r16,r2
2108d804:	11800117 	ldw	r6,4(r2)
2108d808:	a009883a 	mov	r4,r20
2108d80c:	980b883a 	mov	r5,r19
2108d810:	31800054 	ori	r6,r6,1
2108d814:	11800115 	stw	r6,4(r2)
2108d818:	98bfff17 	ldw	r2,-4(r19)
2108d81c:	1080004c 	andi	r2,r2,1
2108d820:	1884b03a 	or	r2,r3,r2
2108d824:	98bfff15 	stw	r2,-4(r19)
2108d828:	1094c780 	call	21094c78 <_free_r>
2108d82c:	80c00117 	ldw	r3,4(r16)
2108d830:	00bfff04 	movi	r2,-4
2108d834:	1884703a 	and	r2,r3,r2
2108d838:	1485c83a 	sub	r2,r2,r18
2108d83c:	00c003c4 	movi	r3,15
2108d840:	18801c16 	blt	r3,r2,2108d8b4 <_memalign_r+0x180>
2108d844:	a009883a 	mov	r4,r20
2108d848:	109b5580 	call	2109b558 <__malloc_unlock>
2108d84c:	80800204 	addi	r2,r16,8
2108d850:	dfc00517 	ldw	ra,20(sp)
2108d854:	dd000417 	ldw	r20,16(sp)
2108d858:	dcc00317 	ldw	r19,12(sp)
2108d85c:	dc800217 	ldw	r18,8(sp)
2108d860:	dc400117 	ldw	r17,4(sp)
2108d864:	dc000017 	ldw	r16,0(sp)
2108d868:	dec00604 	addi	sp,sp,24
2108d86c:	f800283a 	ret
2108d870:	04800404 	movi	r18,16
2108d874:	91bfc42e 	bgeu	r18,r6,2108d788 <__flash_rwdata_start+0xfffeb540>
2108d878:	00800304 	movi	r2,12
2108d87c:	a0800015 	stw	r2,0(r20)
2108d880:	0005883a 	mov	r2,zero
2108d884:	003ff206 	br	2108d850 <__flash_rwdata_start+0xfffeb608>
2108d888:	300b883a 	mov	r5,r6
2108d88c:	dfc00517 	ldw	ra,20(sp)
2108d890:	dd000417 	ldw	r20,16(sp)
2108d894:	dcc00317 	ldw	r19,12(sp)
2108d898:	dc800217 	ldw	r18,8(sp)
2108d89c:	dc400117 	ldw	r17,4(sp)
2108d8a0:	dc000017 	ldw	r16,0(sp)
2108d8a4:	dec00604 	addi	sp,sp,24
2108d8a8:	108d9101 	jmpi	2108d910 <_malloc_r>
2108d8ac:	1461883a 	add	r16,r2,r17
2108d8b0:	003fcc06 	br	2108d7e4 <__flash_rwdata_start+0xfffeb59c>
2108d8b4:	848b883a 	add	r5,r16,r18
2108d8b8:	10800054 	ori	r2,r2,1
2108d8bc:	28800115 	stw	r2,4(r5)
2108d8c0:	80800117 	ldw	r2,4(r16)
2108d8c4:	a009883a 	mov	r4,r20
2108d8c8:	29400204 	addi	r5,r5,8
2108d8cc:	1080004c 	andi	r2,r2,1
2108d8d0:	90a4b03a 	or	r18,r18,r2
2108d8d4:	84800115 	stw	r18,4(r16)
2108d8d8:	1094c780 	call	21094c78 <_free_r>
2108d8dc:	003fd906 	br	2108d844 <__flash_rwdata_start+0xfffeb5fc>
2108d8e0:	0005883a 	mov	r2,zero
2108d8e4:	003fda06 	br	2108d850 <__flash_rwdata_start+0xfffeb608>

2108d8e8 <malloc>:
2108d8e8:	00800034 	movhi	r2,0
2108d8ec:	10976b04 	addi	r2,r2,23980
2108d8f0:	200b883a 	mov	r5,r4
2108d8f4:	11000017 	ldw	r4,0(r2)
2108d8f8:	108d9101 	jmpi	2108d910 <_malloc_r>

2108d8fc <free>:
2108d8fc:	00800034 	movhi	r2,0
2108d900:	10976b04 	addi	r2,r2,23980
2108d904:	200b883a 	mov	r5,r4
2108d908:	11000017 	ldw	r4,0(r2)
2108d90c:	1094c781 	jmpi	21094c78 <_free_r>

2108d910 <_malloc_r>:
2108d910:	defff504 	addi	sp,sp,-44
2108d914:	dc800315 	stw	r18,12(sp)
2108d918:	dfc00a15 	stw	ra,40(sp)
2108d91c:	df000915 	stw	fp,36(sp)
2108d920:	ddc00815 	stw	r23,32(sp)
2108d924:	dd800715 	stw	r22,28(sp)
2108d928:	dd400615 	stw	r21,24(sp)
2108d92c:	dd000515 	stw	r20,20(sp)
2108d930:	dcc00415 	stw	r19,16(sp)
2108d934:	dc400215 	stw	r17,8(sp)
2108d938:	dc000115 	stw	r16,4(sp)
2108d93c:	288002c4 	addi	r2,r5,11
2108d940:	00c00584 	movi	r3,22
2108d944:	2025883a 	mov	r18,r4
2108d948:	18802a2e 	bgeu	r3,r2,2108d9f4 <_malloc_r+0xe4>
2108d94c:	047ffe04 	movi	r17,-8
2108d950:	1462703a 	and	r17,r2,r17
2108d954:	88009e16 	blt	r17,zero,2108dbd0 <_malloc_r+0x2c0>
2108d958:	89409d36 	bltu	r17,r5,2108dbd0 <_malloc_r+0x2c0>
2108d95c:	109b5540 	call	2109b554 <__malloc_lock>
2108d960:	00807dc4 	movi	r2,503
2108d964:	14402736 	bltu	r2,r17,2108da04 <_malloc_r+0xf4>
2108d968:	8806d0fa 	srli	r3,r17,3
2108d96c:	04c00034 	movhi	r19,0
2108d970:	9cd15504 	addi	r19,r19,17748
2108d974:	18c5883a 	add	r2,r3,r3
2108d978:	1085883a 	add	r2,r2,r2
2108d97c:	1085883a 	add	r2,r2,r2
2108d980:	9885883a 	add	r2,r19,r2
2108d984:	14000317 	ldw	r16,12(r2)
2108d988:	80814a26 	beq	r16,r2,2108deb4 <_malloc_r+0x5a4>
2108d98c:	80c00117 	ldw	r3,4(r16)
2108d990:	81000317 	ldw	r4,12(r16)
2108d994:	00bfff04 	movi	r2,-4
2108d998:	1884703a 	and	r2,r3,r2
2108d99c:	81400217 	ldw	r5,8(r16)
2108d9a0:	8085883a 	add	r2,r16,r2
2108d9a4:	10c00117 	ldw	r3,4(r2)
2108d9a8:	29000315 	stw	r4,12(r5)
2108d9ac:	21400215 	stw	r5,8(r4)
2108d9b0:	18c00054 	ori	r3,r3,1
2108d9b4:	10c00115 	stw	r3,4(r2)
2108d9b8:	9009883a 	mov	r4,r18
2108d9bc:	109b5580 	call	2109b558 <__malloc_unlock>
2108d9c0:	80800204 	addi	r2,r16,8
2108d9c4:	dfc00a17 	ldw	ra,40(sp)
2108d9c8:	df000917 	ldw	fp,36(sp)
2108d9cc:	ddc00817 	ldw	r23,32(sp)
2108d9d0:	dd800717 	ldw	r22,28(sp)
2108d9d4:	dd400617 	ldw	r21,24(sp)
2108d9d8:	dd000517 	ldw	r20,20(sp)
2108d9dc:	dcc00417 	ldw	r19,16(sp)
2108d9e0:	dc800317 	ldw	r18,12(sp)
2108d9e4:	dc400217 	ldw	r17,8(sp)
2108d9e8:	dc000117 	ldw	r16,4(sp)
2108d9ec:	dec00b04 	addi	sp,sp,44
2108d9f0:	f800283a 	ret
2108d9f4:	04400404 	movi	r17,16
2108d9f8:	89407536 	bltu	r17,r5,2108dbd0 <_malloc_r+0x2c0>
2108d9fc:	109b5540 	call	2109b554 <__malloc_lock>
2108da00:	003fd906 	br	2108d968 <__flash_rwdata_start+0xfffeb720>
2108da04:	8806d27a 	srli	r3,r17,9
2108da08:	18007526 	beq	r3,zero,2108dbe0 <_malloc_r+0x2d0>
2108da0c:	00800104 	movi	r2,4
2108da10:	10c0ef36 	bltu	r2,r3,2108ddd0 <_malloc_r+0x4c0>
2108da14:	8806d1ba 	srli	r3,r17,6
2108da18:	19c00e04 	addi	r7,r3,56
2108da1c:	39cb883a 	add	r5,r7,r7
2108da20:	04c00034 	movhi	r19,0
2108da24:	294b883a 	add	r5,r5,r5
2108da28:	9cd15504 	addi	r19,r19,17748
2108da2c:	294b883a 	add	r5,r5,r5
2108da30:	994b883a 	add	r5,r19,r5
2108da34:	2c000317 	ldw	r16,12(r5)
2108da38:	2c000e26 	beq	r5,r16,2108da74 <_malloc_r+0x164>
2108da3c:	80800117 	ldw	r2,4(r16)
2108da40:	01bfff04 	movi	r6,-4
2108da44:	010003c4 	movi	r4,15
2108da48:	1184703a 	and	r2,r2,r6
2108da4c:	1447c83a 	sub	r3,r2,r17
2108da50:	20c00716 	blt	r4,r3,2108da70 <_malloc_r+0x160>
2108da54:	1800650e 	bge	r3,zero,2108dbec <_malloc_r+0x2dc>
2108da58:	84000317 	ldw	r16,12(r16)
2108da5c:	2c000526 	beq	r5,r16,2108da74 <_malloc_r+0x164>
2108da60:	80800117 	ldw	r2,4(r16)
2108da64:	1184703a 	and	r2,r2,r6
2108da68:	1447c83a 	sub	r3,r2,r17
2108da6c:	20fff90e 	bge	r4,r3,2108da54 <__flash_rwdata_start+0xfffeb80c>
2108da70:	39ffffc4 	addi	r7,r7,-1
2108da74:	38c00044 	addi	r3,r7,1
2108da78:	01800034 	movhi	r6,0
2108da7c:	9c000417 	ldw	r16,16(r19)
2108da80:	31915504 	addi	r6,r6,17748
2108da84:	32400204 	addi	r9,r6,8
2108da88:	82410326 	beq	r16,r9,2108de98 <_malloc_r+0x588>
2108da8c:	81000117 	ldw	r4,4(r16)
2108da90:	00bfff04 	movi	r2,-4
2108da94:	208e703a 	and	r7,r4,r2
2108da98:	3c45c83a 	sub	r2,r7,r17
2108da9c:	010003c4 	movi	r4,15
2108daa0:	2080ee16 	blt	r4,r2,2108de5c <_malloc_r+0x54c>
2108daa4:	32400515 	stw	r9,20(r6)
2108daa8:	32400415 	stw	r9,16(r6)
2108daac:	1000510e 	bge	r2,zero,2108dbf4 <_malloc_r+0x2e4>
2108dab0:	00807fc4 	movi	r2,511
2108dab4:	11c0ce36 	bltu	r2,r7,2108ddf0 <_malloc_r+0x4e0>
2108dab8:	3808d0fa 	srli	r4,r7,3
2108dabc:	01c00044 	movi	r7,1
2108dac0:	30800117 	ldw	r2,4(r6)
2108dac4:	210b883a 	add	r5,r4,r4
2108dac8:	294b883a 	add	r5,r5,r5
2108dacc:	2009d0ba 	srai	r4,r4,2
2108dad0:	294b883a 	add	r5,r5,r5
2108dad4:	298b883a 	add	r5,r5,r6
2108dad8:	2a000217 	ldw	r8,8(r5)
2108dadc:	3908983a 	sll	r4,r7,r4
2108dae0:	81400315 	stw	r5,12(r16)
2108dae4:	82000215 	stw	r8,8(r16)
2108dae8:	2088b03a 	or	r4,r4,r2
2108daec:	2c000215 	stw	r16,8(r5)
2108daf0:	31000115 	stw	r4,4(r6)
2108daf4:	44000315 	stw	r16,12(r8)
2108daf8:	1805d0ba 	srai	r2,r3,2
2108dafc:	01400044 	movi	r5,1
2108db00:	288a983a 	sll	r5,r5,r2
2108db04:	21404336 	bltu	r4,r5,2108dc14 <_malloc_r+0x304>
2108db08:	2144703a 	and	r2,r4,r5
2108db0c:	10000a1e 	bne	r2,zero,2108db38 <_malloc_r+0x228>
2108db10:	00bfff04 	movi	r2,-4
2108db14:	294b883a 	add	r5,r5,r5
2108db18:	1886703a 	and	r3,r3,r2
2108db1c:	2144703a 	and	r2,r4,r5
2108db20:	18c00104 	addi	r3,r3,4
2108db24:	1000041e 	bne	r2,zero,2108db38 <_malloc_r+0x228>
2108db28:	294b883a 	add	r5,r5,r5
2108db2c:	2144703a 	and	r2,r4,r5
2108db30:	18c00104 	addi	r3,r3,4
2108db34:	103ffc26 	beq	r2,zero,2108db28 <__flash_rwdata_start+0xfffeb8e0>
2108db38:	023fff04 	movi	r8,-4
2108db3c:	01c003c4 	movi	r7,15
2108db40:	18c5883a 	add	r2,r3,r3
2108db44:	1085883a 	add	r2,r2,r2
2108db48:	1085883a 	add	r2,r2,r2
2108db4c:	9895883a 	add	r10,r19,r2
2108db50:	52c00304 	addi	r11,r10,12
2108db54:	1819883a 	mov	r12,r3
2108db58:	5c000017 	ldw	r16,0(r11)
2108db5c:	59bffd04 	addi	r6,r11,-12
2108db60:	8180041e 	bne	r16,r6,2108db74 <_malloc_r+0x264>
2108db64:	0000ce06 	br	2108dea0 <_malloc_r+0x590>
2108db68:	2000d70e 	bge	r4,zero,2108dec8 <_malloc_r+0x5b8>
2108db6c:	84000317 	ldw	r16,12(r16)
2108db70:	8180cb26 	beq	r16,r6,2108dea0 <_malloc_r+0x590>
2108db74:	80800117 	ldw	r2,4(r16)
2108db78:	1204703a 	and	r2,r2,r8
2108db7c:	1449c83a 	sub	r4,r2,r17
2108db80:	393ff90e 	bge	r7,r4,2108db68 <__flash_rwdata_start+0xfffeb920>
2108db84:	80800317 	ldw	r2,12(r16)
2108db88:	80c00217 	ldw	r3,8(r16)
2108db8c:	89400054 	ori	r5,r17,1
2108db90:	81400115 	stw	r5,4(r16)
2108db94:	18800315 	stw	r2,12(r3)
2108db98:	10c00215 	stw	r3,8(r2)
2108db9c:	8463883a 	add	r17,r16,r17
2108dba0:	9c400515 	stw	r17,20(r19)
2108dba4:	9c400415 	stw	r17,16(r19)
2108dba8:	20800054 	ori	r2,r4,1
2108dbac:	88800115 	stw	r2,4(r17)
2108dbb0:	8a400315 	stw	r9,12(r17)
2108dbb4:	8a400215 	stw	r9,8(r17)
2108dbb8:	8923883a 	add	r17,r17,r4
2108dbbc:	89000015 	stw	r4,0(r17)
2108dbc0:	9009883a 	mov	r4,r18
2108dbc4:	109b5580 	call	2109b558 <__malloc_unlock>
2108dbc8:	80800204 	addi	r2,r16,8
2108dbcc:	003f7d06 	br	2108d9c4 <__flash_rwdata_start+0xfffeb77c>
2108dbd0:	00800304 	movi	r2,12
2108dbd4:	90800015 	stw	r2,0(r18)
2108dbd8:	0005883a 	mov	r2,zero
2108dbdc:	003f7906 	br	2108d9c4 <__flash_rwdata_start+0xfffeb77c>
2108dbe0:	01401f84 	movi	r5,126
2108dbe4:	01c00fc4 	movi	r7,63
2108dbe8:	003f8d06 	br	2108da20 <__flash_rwdata_start+0xfffeb7d8>
2108dbec:	81000317 	ldw	r4,12(r16)
2108dbf0:	003f6a06 	br	2108d99c <__flash_rwdata_start+0xfffeb754>
2108dbf4:	81c5883a 	add	r2,r16,r7
2108dbf8:	10c00117 	ldw	r3,4(r2)
2108dbfc:	9009883a 	mov	r4,r18
2108dc00:	18c00054 	ori	r3,r3,1
2108dc04:	10c00115 	stw	r3,4(r2)
2108dc08:	109b5580 	call	2109b558 <__malloc_unlock>
2108dc0c:	80800204 	addi	r2,r16,8
2108dc10:	003f6c06 	br	2108d9c4 <__flash_rwdata_start+0xfffeb77c>
2108dc14:	9c000217 	ldw	r16,8(r19)
2108dc18:	00bfff04 	movi	r2,-4
2108dc1c:	85800117 	ldw	r22,4(r16)
2108dc20:	b0ac703a 	and	r22,r22,r2
2108dc24:	b4400336 	bltu	r22,r17,2108dc34 <_malloc_r+0x324>
2108dc28:	b445c83a 	sub	r2,r22,r17
2108dc2c:	00c003c4 	movi	r3,15
2108dc30:	18805d16 	blt	r3,r2,2108dda8 <_malloc_r+0x498>
2108dc34:	05c00034 	movhi	r23,0
2108dc38:	00800034 	movhi	r2,0
2108dc3c:	bdd76c04 	addi	r23,r23,23984
2108dc40:	10978404 	addi	r2,r2,24080
2108dc44:	15400017 	ldw	r21,0(r2)
2108dc48:	b9000017 	ldw	r4,0(r23)
2108dc4c:	00ffffc4 	movi	r3,-1
2108dc50:	858d883a 	add	r6,r16,r22
2108dc54:	8d6b883a 	add	r21,r17,r21
2108dc58:	20c0e426 	beq	r4,r3,2108dfec <_malloc_r+0x6dc>
2108dc5c:	ad4403c4 	addi	r21,r21,4111
2108dc60:	00fc0004 	movi	r3,-4096
2108dc64:	a8ea703a 	and	r21,r21,r3
2108dc68:	9009883a 	mov	r4,r18
2108dc6c:	a80b883a 	mov	r5,r21
2108dc70:	d9800015 	stw	r6,0(sp)
2108dc74:	108e4d40 	call	2108e4d4 <_sbrk_r>
2108dc78:	00ffffc4 	movi	r3,-1
2108dc7c:	1029883a 	mov	r20,r2
2108dc80:	d9800017 	ldw	r6,0(sp)
2108dc84:	10c0a426 	beq	r2,r3,2108df18 <_malloc_r+0x608>
2108dc88:	1180a236 	bltu	r2,r6,2108df14 <_malloc_r+0x604>
2108dc8c:	07000034 	movhi	fp,0
2108dc90:	e7187204 	addi	fp,fp,25032
2108dc94:	e0c00017 	ldw	r3,0(fp)
2108dc98:	a8c7883a 	add	r3,r21,r3
2108dc9c:	e0c00015 	stw	r3,0(fp)
2108dca0:	3500da26 	beq	r6,r20,2108e00c <_malloc_r+0x6fc>
2108dca4:	b9000017 	ldw	r4,0(r23)
2108dca8:	00bfffc4 	movi	r2,-1
2108dcac:	2080e426 	beq	r4,r2,2108e040 <_malloc_r+0x730>
2108dcb0:	a185c83a 	sub	r2,r20,r6
2108dcb4:	1885883a 	add	r2,r3,r2
2108dcb8:	e0800015 	stw	r2,0(fp)
2108dcbc:	a0c001cc 	andi	r3,r20,7
2108dcc0:	1800b526 	beq	r3,zero,2108df98 <_malloc_r+0x688>
2108dcc4:	a0e9c83a 	sub	r20,r20,r3
2108dcc8:	00840204 	movi	r2,4104
2108dccc:	a5000204 	addi	r20,r20,8
2108dcd0:	10c7c83a 	sub	r3,r2,r3
2108dcd4:	a545883a 	add	r2,r20,r21
2108dcd8:	1083ffcc 	andi	r2,r2,4095
2108dcdc:	18abc83a 	sub	r21,r3,r2
2108dce0:	9009883a 	mov	r4,r18
2108dce4:	a80b883a 	mov	r5,r21
2108dce8:	108e4d40 	call	2108e4d4 <_sbrk_r>
2108dcec:	00ffffc4 	movi	r3,-1
2108dcf0:	10c0d026 	beq	r2,r3,2108e034 <_malloc_r+0x724>
2108dcf4:	1507c83a 	sub	r3,r2,r20
2108dcf8:	a8c7883a 	add	r3,r21,r3
2108dcfc:	18c00054 	ori	r3,r3,1
2108dd00:	e0800017 	ldw	r2,0(fp)
2108dd04:	9d000215 	stw	r20,8(r19)
2108dd08:	a0c00115 	stw	r3,4(r20)
2108dd0c:	a887883a 	add	r3,r21,r2
2108dd10:	e0c00015 	stw	r3,0(fp)
2108dd14:	84c00e26 	beq	r16,r19,2108dd50 <_malloc_r+0x440>
2108dd18:	018003c4 	movi	r6,15
2108dd1c:	3580a02e 	bgeu	r6,r22,2108dfa0 <_malloc_r+0x690>
2108dd20:	81400117 	ldw	r5,4(r16)
2108dd24:	013ffe04 	movi	r4,-8
2108dd28:	b0bffd04 	addi	r2,r22,-12
2108dd2c:	1104703a 	and	r2,r2,r4
2108dd30:	2900004c 	andi	r4,r5,1
2108dd34:	1108b03a 	or	r4,r2,r4
2108dd38:	81000115 	stw	r4,4(r16)
2108dd3c:	01400144 	movi	r5,5
2108dd40:	8089883a 	add	r4,r16,r2
2108dd44:	21400115 	stw	r5,4(r4)
2108dd48:	21400215 	stw	r5,8(r4)
2108dd4c:	3080c036 	bltu	r6,r2,2108e050 <_malloc_r+0x740>
2108dd50:	00800034 	movhi	r2,0
2108dd54:	10978304 	addi	r2,r2,24076
2108dd58:	11000017 	ldw	r4,0(r2)
2108dd5c:	20c0012e 	bgeu	r4,r3,2108dd64 <_malloc_r+0x454>
2108dd60:	10c00015 	stw	r3,0(r2)
2108dd64:	00800034 	movhi	r2,0
2108dd68:	10978204 	addi	r2,r2,24072
2108dd6c:	11000017 	ldw	r4,0(r2)
2108dd70:	9c000217 	ldw	r16,8(r19)
2108dd74:	20c0012e 	bgeu	r4,r3,2108dd7c <_malloc_r+0x46c>
2108dd78:	10c00015 	stw	r3,0(r2)
2108dd7c:	80c00117 	ldw	r3,4(r16)
2108dd80:	00bfff04 	movi	r2,-4
2108dd84:	1886703a 	and	r3,r3,r2
2108dd88:	1c45c83a 	sub	r2,r3,r17
2108dd8c:	1c400236 	bltu	r3,r17,2108dd98 <_malloc_r+0x488>
2108dd90:	00c003c4 	movi	r3,15
2108dd94:	18800416 	blt	r3,r2,2108dda8 <_malloc_r+0x498>
2108dd98:	9009883a 	mov	r4,r18
2108dd9c:	109b5580 	call	2109b558 <__malloc_unlock>
2108dda0:	0005883a 	mov	r2,zero
2108dda4:	003f0706 	br	2108d9c4 <__flash_rwdata_start+0xfffeb77c>
2108dda8:	88c00054 	ori	r3,r17,1
2108ddac:	80c00115 	stw	r3,4(r16)
2108ddb0:	8463883a 	add	r17,r16,r17
2108ddb4:	10800054 	ori	r2,r2,1
2108ddb8:	9c400215 	stw	r17,8(r19)
2108ddbc:	88800115 	stw	r2,4(r17)
2108ddc0:	9009883a 	mov	r4,r18
2108ddc4:	109b5580 	call	2109b558 <__malloc_unlock>
2108ddc8:	80800204 	addi	r2,r16,8
2108ddcc:	003efd06 	br	2108d9c4 <__flash_rwdata_start+0xfffeb77c>
2108ddd0:	00800504 	movi	r2,20
2108ddd4:	10c0482e 	bgeu	r2,r3,2108def8 <_malloc_r+0x5e8>
2108ddd8:	00801504 	movi	r2,84
2108dddc:	10c06836 	bltu	r2,r3,2108df80 <_malloc_r+0x670>
2108dde0:	8806d33a 	srli	r3,r17,12
2108dde4:	19c01b84 	addi	r7,r3,110
2108dde8:	39cb883a 	add	r5,r7,r7
2108ddec:	003f0c06 	br	2108da20 <__flash_rwdata_start+0xfffeb7d8>
2108ddf0:	3804d27a 	srli	r2,r7,9
2108ddf4:	01000104 	movi	r4,4
2108ddf8:	2080422e 	bgeu	r4,r2,2108df04 <_malloc_r+0x5f4>
2108ddfc:	01000504 	movi	r4,20
2108de00:	20807c36 	bltu	r4,r2,2108dff4 <_malloc_r+0x6e4>
2108de04:	110016c4 	addi	r4,r2,91
2108de08:	210b883a 	add	r5,r4,r4
2108de0c:	294b883a 	add	r5,r5,r5
2108de10:	294b883a 	add	r5,r5,r5
2108de14:	994b883a 	add	r5,r19,r5
2108de18:	28800217 	ldw	r2,8(r5)
2108de1c:	02000034 	movhi	r8,0
2108de20:	42115504 	addi	r8,r8,17748
2108de24:	11406326 	beq	r2,r5,2108dfb4 <_malloc_r+0x6a4>
2108de28:	01bfff04 	movi	r6,-4
2108de2c:	11000117 	ldw	r4,4(r2)
2108de30:	2188703a 	and	r4,r4,r6
2108de34:	3900022e 	bgeu	r7,r4,2108de40 <_malloc_r+0x530>
2108de38:	10800217 	ldw	r2,8(r2)
2108de3c:	28bffb1e 	bne	r5,r2,2108de2c <__flash_rwdata_start+0xfffebbe4>
2108de40:	11800317 	ldw	r6,12(r2)
2108de44:	99000117 	ldw	r4,4(r19)
2108de48:	81800315 	stw	r6,12(r16)
2108de4c:	80800215 	stw	r2,8(r16)
2108de50:	34000215 	stw	r16,8(r6)
2108de54:	14000315 	stw	r16,12(r2)
2108de58:	003f2706 	br	2108daf8 <__flash_rwdata_start+0xfffeb8b0>
2108de5c:	88c00054 	ori	r3,r17,1
2108de60:	80c00115 	stw	r3,4(r16)
2108de64:	8463883a 	add	r17,r16,r17
2108de68:	34400515 	stw	r17,20(r6)
2108de6c:	34400415 	stw	r17,16(r6)
2108de70:	10c00054 	ori	r3,r2,1
2108de74:	8a400315 	stw	r9,12(r17)
2108de78:	8a400215 	stw	r9,8(r17)
2108de7c:	88c00115 	stw	r3,4(r17)
2108de80:	88a3883a 	add	r17,r17,r2
2108de84:	88800015 	stw	r2,0(r17)
2108de88:	9009883a 	mov	r4,r18
2108de8c:	109b5580 	call	2109b558 <__malloc_unlock>
2108de90:	80800204 	addi	r2,r16,8
2108de94:	003ecb06 	br	2108d9c4 <__flash_rwdata_start+0xfffeb77c>
2108de98:	31000117 	ldw	r4,4(r6)
2108de9c:	003f1606 	br	2108daf8 <__flash_rwdata_start+0xfffeb8b0>
2108dea0:	63000044 	addi	r12,r12,1
2108dea4:	608000cc 	andi	r2,r12,3
2108dea8:	5ac00204 	addi	r11,r11,8
2108deac:	103f2a1e 	bne	r2,zero,2108db58 <__flash_rwdata_start+0xfffeb910>
2108deb0:	00002106 	br	2108df38 <_malloc_r+0x628>
2108deb4:	80800204 	addi	r2,r16,8
2108deb8:	84000517 	ldw	r16,20(r16)
2108debc:	143eb31e 	bne	r2,r16,2108d98c <__flash_rwdata_start+0xfffeb744>
2108dec0:	18c00084 	addi	r3,r3,2
2108dec4:	003eec06 	br	2108da78 <__flash_rwdata_start+0xfffeb830>
2108dec8:	8085883a 	add	r2,r16,r2
2108decc:	10c00117 	ldw	r3,4(r2)
2108ded0:	81000317 	ldw	r4,12(r16)
2108ded4:	81400217 	ldw	r5,8(r16)
2108ded8:	18c00054 	ori	r3,r3,1
2108dedc:	10c00115 	stw	r3,4(r2)
2108dee0:	29000315 	stw	r4,12(r5)
2108dee4:	21400215 	stw	r5,8(r4)
2108dee8:	9009883a 	mov	r4,r18
2108deec:	109b5580 	call	2109b558 <__malloc_unlock>
2108def0:	80800204 	addi	r2,r16,8
2108def4:	003eb306 	br	2108d9c4 <__flash_rwdata_start+0xfffeb77c>
2108def8:	19c016c4 	addi	r7,r3,91
2108defc:	39cb883a 	add	r5,r7,r7
2108df00:	003ec706 	br	2108da20 <__flash_rwdata_start+0xfffeb7d8>
2108df04:	3804d1ba 	srli	r2,r7,6
2108df08:	11000e04 	addi	r4,r2,56
2108df0c:	210b883a 	add	r5,r4,r4
2108df10:	003fbe06 	br	2108de0c <__flash_rwdata_start+0xfffebbc4>
2108df14:	84ff5d26 	beq	r16,r19,2108dc8c <__flash_rwdata_start+0xfffeba44>
2108df18:	9c000217 	ldw	r16,8(r19)
2108df1c:	00bfff04 	movi	r2,-4
2108df20:	80c00117 	ldw	r3,4(r16)
2108df24:	1886703a 	and	r3,r3,r2
2108df28:	003f9706 	br	2108dd88 <__flash_rwdata_start+0xfffebb40>
2108df2c:	52800017 	ldw	r10,0(r10)
2108df30:	18ffffc4 	addi	r3,r3,-1
2108df34:	50805c1e 	bne	r10,r2,2108e0a8 <_malloc_r+0x798>
2108df38:	190000cc 	andi	r4,r3,3
2108df3c:	50bffe04 	addi	r2,r10,-8
2108df40:	203ffa1e 	bne	r4,zero,2108df2c <__flash_rwdata_start+0xfffebce4>
2108df44:	98800117 	ldw	r2,4(r19)
2108df48:	0146303a 	nor	r3,zero,r5
2108df4c:	1884703a 	and	r2,r3,r2
2108df50:	98800115 	stw	r2,4(r19)
2108df54:	294b883a 	add	r5,r5,r5
2108df58:	117f2e36 	bltu	r2,r5,2108dc14 <__flash_rwdata_start+0xfffeb9cc>
2108df5c:	283f2d26 	beq	r5,zero,2108dc14 <__flash_rwdata_start+0xfffeb9cc>
2108df60:	1146703a 	and	r3,r2,r5
2108df64:	1800521e 	bne	r3,zero,2108e0b0 <_malloc_r+0x7a0>
2108df68:	6007883a 	mov	r3,r12
2108df6c:	294b883a 	add	r5,r5,r5
2108df70:	1148703a 	and	r4,r2,r5
2108df74:	18c00104 	addi	r3,r3,4
2108df78:	203ffc26 	beq	r4,zero,2108df6c <__flash_rwdata_start+0xfffebd24>
2108df7c:	003ef006 	br	2108db40 <__flash_rwdata_start+0xfffeb8f8>
2108df80:	00805504 	movi	r2,340
2108df84:	10c01336 	bltu	r2,r3,2108dfd4 <_malloc_r+0x6c4>
2108df88:	8806d3fa 	srli	r3,r17,15
2108df8c:	19c01dc4 	addi	r7,r3,119
2108df90:	39cb883a 	add	r5,r7,r7
2108df94:	003ea206 	br	2108da20 <__flash_rwdata_start+0xfffeb7d8>
2108df98:	00c40004 	movi	r3,4096
2108df9c:	003f4d06 	br	2108dcd4 <__flash_rwdata_start+0xfffeba8c>
2108dfa0:	00800044 	movi	r2,1
2108dfa4:	a0800115 	stw	r2,4(r20)
2108dfa8:	a021883a 	mov	r16,r20
2108dfac:	0007883a 	mov	r3,zero
2108dfb0:	003f7506 	br	2108dd88 <__flash_rwdata_start+0xfffebb40>
2108dfb4:	200bd0ba 	srai	r5,r4,2
2108dfb8:	01800044 	movi	r6,1
2108dfbc:	41000117 	ldw	r4,4(r8)
2108dfc0:	314a983a 	sll	r5,r6,r5
2108dfc4:	100d883a 	mov	r6,r2
2108dfc8:	2908b03a 	or	r4,r5,r4
2108dfcc:	41000115 	stw	r4,4(r8)
2108dfd0:	003f9d06 	br	2108de48 <__flash_rwdata_start+0xfffebc00>
2108dfd4:	00815504 	movi	r2,1364
2108dfd8:	10c01336 	bltu	r2,r3,2108e028 <_malloc_r+0x718>
2108dfdc:	8806d4ba 	srli	r3,r17,18
2108dfe0:	19c01f04 	addi	r7,r3,124
2108dfe4:	39cb883a 	add	r5,r7,r7
2108dfe8:	003e8d06 	br	2108da20 <__flash_rwdata_start+0xfffeb7d8>
2108dfec:	ad400404 	addi	r21,r21,16
2108dff0:	003f1d06 	br	2108dc68 <__flash_rwdata_start+0xfffeba20>
2108dff4:	01001504 	movi	r4,84
2108dff8:	20801c36 	bltu	r4,r2,2108e06c <_malloc_r+0x75c>
2108dffc:	3804d33a 	srli	r2,r7,12
2108e000:	11001b84 	addi	r4,r2,110
2108e004:	210b883a 	add	r5,r4,r4
2108e008:	003f8006 	br	2108de0c <__flash_rwdata_start+0xfffebbc4>
2108e00c:	3083ffcc 	andi	r2,r6,4095
2108e010:	103f241e 	bne	r2,zero,2108dca4 <__flash_rwdata_start+0xfffeba5c>
2108e014:	99000217 	ldw	r4,8(r19)
2108e018:	ad85883a 	add	r2,r21,r22
2108e01c:	10800054 	ori	r2,r2,1
2108e020:	20800115 	stw	r2,4(r4)
2108e024:	003f4a06 	br	2108dd50 <__flash_rwdata_start+0xfffebb08>
2108e028:	01403f04 	movi	r5,252
2108e02c:	01c01f84 	movi	r7,126
2108e030:	003e7b06 	br	2108da20 <__flash_rwdata_start+0xfffeb7d8>
2108e034:	00c00044 	movi	r3,1
2108e038:	002b883a 	mov	r21,zero
2108e03c:	003f3006 	br	2108dd00 <__flash_rwdata_start+0xfffebab8>
2108e040:	00800034 	movhi	r2,0
2108e044:	10976c04 	addi	r2,r2,23984
2108e048:	15000015 	stw	r20,0(r2)
2108e04c:	003f1b06 	br	2108dcbc <__flash_rwdata_start+0xfffeba74>
2108e050:	9009883a 	mov	r4,r18
2108e054:	81400204 	addi	r5,r16,8
2108e058:	1094c780 	call	21094c78 <_free_r>
2108e05c:	00800034 	movhi	r2,0
2108e060:	10987204 	addi	r2,r2,25032
2108e064:	10c00017 	ldw	r3,0(r2)
2108e068:	003f3906 	br	2108dd50 <__flash_rwdata_start+0xfffebb08>
2108e06c:	01005504 	movi	r4,340
2108e070:	20800436 	bltu	r4,r2,2108e084 <_malloc_r+0x774>
2108e074:	3804d3fa 	srli	r2,r7,15
2108e078:	11001dc4 	addi	r4,r2,119
2108e07c:	210b883a 	add	r5,r4,r4
2108e080:	003f6206 	br	2108de0c <__flash_rwdata_start+0xfffebbc4>
2108e084:	01015504 	movi	r4,1364
2108e088:	20800436 	bltu	r4,r2,2108e09c <_malloc_r+0x78c>
2108e08c:	3804d4ba 	srli	r2,r7,18
2108e090:	11001f04 	addi	r4,r2,124
2108e094:	210b883a 	add	r5,r4,r4
2108e098:	003f5c06 	br	2108de0c <__flash_rwdata_start+0xfffebbc4>
2108e09c:	01403f04 	movi	r5,252
2108e0a0:	01001f84 	movi	r4,126
2108e0a4:	003f5906 	br	2108de0c <__flash_rwdata_start+0xfffebbc4>
2108e0a8:	98800117 	ldw	r2,4(r19)
2108e0ac:	003fa906 	br	2108df54 <__flash_rwdata_start+0xfffebd0c>
2108e0b0:	6007883a 	mov	r3,r12
2108e0b4:	003ea206 	br	2108db40 <__flash_rwdata_start+0xfffeb8f8>

2108e0b8 <memcmp>:
2108e0b8:	01c000c4 	movi	r7,3
2108e0bc:	3980192e 	bgeu	r7,r6,2108e124 <memcmp+0x6c>
2108e0c0:	2144b03a 	or	r2,r4,r5
2108e0c4:	11c4703a 	and	r2,r2,r7
2108e0c8:	10000f26 	beq	r2,zero,2108e108 <memcmp+0x50>
2108e0cc:	20800003 	ldbu	r2,0(r4)
2108e0d0:	28c00003 	ldbu	r3,0(r5)
2108e0d4:	10c0151e 	bne	r2,r3,2108e12c <memcmp+0x74>
2108e0d8:	31bfff84 	addi	r6,r6,-2
2108e0dc:	01ffffc4 	movi	r7,-1
2108e0e0:	00000406 	br	2108e0f4 <memcmp+0x3c>
2108e0e4:	20800003 	ldbu	r2,0(r4)
2108e0e8:	28c00003 	ldbu	r3,0(r5)
2108e0ec:	31bfffc4 	addi	r6,r6,-1
2108e0f0:	10c00e1e 	bne	r2,r3,2108e12c <memcmp+0x74>
2108e0f4:	21000044 	addi	r4,r4,1
2108e0f8:	29400044 	addi	r5,r5,1
2108e0fc:	31fff91e 	bne	r6,r7,2108e0e4 <__flash_rwdata_start+0xfffebe9c>
2108e100:	0005883a 	mov	r2,zero
2108e104:	f800283a 	ret
2108e108:	20c00017 	ldw	r3,0(r4)
2108e10c:	28800017 	ldw	r2,0(r5)
2108e110:	1880041e 	bne	r3,r2,2108e124 <memcmp+0x6c>
2108e114:	31bfff04 	addi	r6,r6,-4
2108e118:	21000104 	addi	r4,r4,4
2108e11c:	29400104 	addi	r5,r5,4
2108e120:	39bff936 	bltu	r7,r6,2108e108 <__flash_rwdata_start+0xfffebec0>
2108e124:	303fe91e 	bne	r6,zero,2108e0cc <__flash_rwdata_start+0xfffebe84>
2108e128:	003ff506 	br	2108e100 <__flash_rwdata_start+0xfffebeb8>
2108e12c:	10c5c83a 	sub	r2,r2,r3
2108e130:	f800283a 	ret

2108e134 <memcpy>:
2108e134:	deffff04 	addi	sp,sp,-4
2108e138:	dc000015 	stw	r16,0(sp)
2108e13c:	00c003c4 	movi	r3,15
2108e140:	2005883a 	mov	r2,r4
2108e144:	1980432e 	bgeu	r3,r6,2108e254 <memcpy+0x120>
2108e148:	2146b03a 	or	r3,r4,r5
2108e14c:	18c000cc 	andi	r3,r3,3
2108e150:	1800421e 	bne	r3,zero,2108e25c <memcpy+0x128>
2108e154:	343ffc04 	addi	r16,r6,-16
2108e158:	8020d13a 	srli	r16,r16,4
2108e15c:	28c00104 	addi	r3,r5,4
2108e160:	23400104 	addi	r13,r4,4
2108e164:	801e913a 	slli	r15,r16,4
2108e168:	2b000204 	addi	r12,r5,8
2108e16c:	22c00204 	addi	r11,r4,8
2108e170:	7bc00504 	addi	r15,r15,20
2108e174:	2a800304 	addi	r10,r5,12
2108e178:	22400304 	addi	r9,r4,12
2108e17c:	2bdf883a 	add	r15,r5,r15
2108e180:	2811883a 	mov	r8,r5
2108e184:	200f883a 	mov	r7,r4
2108e188:	41000017 	ldw	r4,0(r8)
2108e18c:	39c00404 	addi	r7,r7,16
2108e190:	18c00404 	addi	r3,r3,16
2108e194:	393ffc15 	stw	r4,-16(r7)
2108e198:	1bbffc17 	ldw	r14,-16(r3)
2108e19c:	6b400404 	addi	r13,r13,16
2108e1a0:	5ac00404 	addi	r11,r11,16
2108e1a4:	6bbffc15 	stw	r14,-16(r13)
2108e1a8:	63800017 	ldw	r14,0(r12)
2108e1ac:	4a400404 	addi	r9,r9,16
2108e1b0:	42000404 	addi	r8,r8,16
2108e1b4:	5bbffc15 	stw	r14,-16(r11)
2108e1b8:	53800017 	ldw	r14,0(r10)
2108e1bc:	63000404 	addi	r12,r12,16
2108e1c0:	52800404 	addi	r10,r10,16
2108e1c4:	4bbffc15 	stw	r14,-16(r9)
2108e1c8:	1bffef1e 	bne	r3,r15,2108e188 <__flash_rwdata_start+0xfffebf40>
2108e1cc:	81c00044 	addi	r7,r16,1
2108e1d0:	380e913a 	slli	r7,r7,4
2108e1d4:	310003cc 	andi	r4,r6,15
2108e1d8:	02c000c4 	movi	r11,3
2108e1dc:	11c7883a 	add	r3,r2,r7
2108e1e0:	29cb883a 	add	r5,r5,r7
2108e1e4:	59001f2e 	bgeu	r11,r4,2108e264 <memcpy+0x130>
2108e1e8:	1813883a 	mov	r9,r3
2108e1ec:	2811883a 	mov	r8,r5
2108e1f0:	200f883a 	mov	r7,r4
2108e1f4:	42800017 	ldw	r10,0(r8)
2108e1f8:	4a400104 	addi	r9,r9,4
2108e1fc:	39ffff04 	addi	r7,r7,-4
2108e200:	4abfff15 	stw	r10,-4(r9)
2108e204:	42000104 	addi	r8,r8,4
2108e208:	59fffa36 	bltu	r11,r7,2108e1f4 <__flash_rwdata_start+0xfffebfac>
2108e20c:	213fff04 	addi	r4,r4,-4
2108e210:	2008d0ba 	srli	r4,r4,2
2108e214:	318000cc 	andi	r6,r6,3
2108e218:	21000044 	addi	r4,r4,1
2108e21c:	2109883a 	add	r4,r4,r4
2108e220:	2109883a 	add	r4,r4,r4
2108e224:	1907883a 	add	r3,r3,r4
2108e228:	290b883a 	add	r5,r5,r4
2108e22c:	30000626 	beq	r6,zero,2108e248 <memcpy+0x114>
2108e230:	198d883a 	add	r6,r3,r6
2108e234:	29c00003 	ldbu	r7,0(r5)
2108e238:	18c00044 	addi	r3,r3,1
2108e23c:	29400044 	addi	r5,r5,1
2108e240:	19ffffc5 	stb	r7,-1(r3)
2108e244:	19bffb1e 	bne	r3,r6,2108e234 <__flash_rwdata_start+0xfffebfec>
2108e248:	dc000017 	ldw	r16,0(sp)
2108e24c:	dec00104 	addi	sp,sp,4
2108e250:	f800283a 	ret
2108e254:	2007883a 	mov	r3,r4
2108e258:	003ff406 	br	2108e22c <__flash_rwdata_start+0xfffebfe4>
2108e25c:	2007883a 	mov	r3,r4
2108e260:	003ff306 	br	2108e230 <__flash_rwdata_start+0xfffebfe8>
2108e264:	200d883a 	mov	r6,r4
2108e268:	003ff006 	br	2108e22c <__flash_rwdata_start+0xfffebfe4>

2108e26c <memset>:
2108e26c:	20c000cc 	andi	r3,r4,3
2108e270:	2005883a 	mov	r2,r4
2108e274:	18004326 	beq	r3,zero,2108e384 <memset+0x118>
2108e278:	31ffffc4 	addi	r7,r6,-1
2108e27c:	30004026 	beq	r6,zero,2108e380 <memset+0x114>
2108e280:	2813883a 	mov	r9,r5
2108e284:	200d883a 	mov	r6,r4
2108e288:	2007883a 	mov	r3,r4
2108e28c:	00000406 	br	2108e2a0 <memset+0x34>
2108e290:	3a3fffc4 	addi	r8,r7,-1
2108e294:	31800044 	addi	r6,r6,1
2108e298:	38003926 	beq	r7,zero,2108e380 <memset+0x114>
2108e29c:	400f883a 	mov	r7,r8
2108e2a0:	18c00044 	addi	r3,r3,1
2108e2a4:	32400005 	stb	r9,0(r6)
2108e2a8:	1a0000cc 	andi	r8,r3,3
2108e2ac:	403ff81e 	bne	r8,zero,2108e290 <__flash_rwdata_start+0xfffec048>
2108e2b0:	010000c4 	movi	r4,3
2108e2b4:	21c02d2e 	bgeu	r4,r7,2108e36c <memset+0x100>
2108e2b8:	29803fcc 	andi	r6,r5,255
2108e2bc:	3008923a 	slli	r4,r6,8
2108e2c0:	218cb03a 	or	r6,r4,r6
2108e2c4:	3008943a 	slli	r4,r6,16
2108e2c8:	218cb03a 	or	r6,r4,r6
2108e2cc:	010003c4 	movi	r4,15
2108e2d0:	21c0182e 	bgeu	r4,r7,2108e334 <memset+0xc8>
2108e2d4:	3b3ffc04 	addi	r12,r7,-16
2108e2d8:	6018d13a 	srli	r12,r12,4
2108e2dc:	1a000104 	addi	r8,r3,4
2108e2e0:	1ac00204 	addi	r11,r3,8
2108e2e4:	6008913a 	slli	r4,r12,4
2108e2e8:	1a800304 	addi	r10,r3,12
2108e2ec:	1813883a 	mov	r9,r3
2108e2f0:	21000504 	addi	r4,r4,20
2108e2f4:	1909883a 	add	r4,r3,r4
2108e2f8:	49800015 	stw	r6,0(r9)
2108e2fc:	41800015 	stw	r6,0(r8)
2108e300:	59800015 	stw	r6,0(r11)
2108e304:	51800015 	stw	r6,0(r10)
2108e308:	42000404 	addi	r8,r8,16
2108e30c:	4a400404 	addi	r9,r9,16
2108e310:	5ac00404 	addi	r11,r11,16
2108e314:	52800404 	addi	r10,r10,16
2108e318:	413ff71e 	bne	r8,r4,2108e2f8 <__flash_rwdata_start+0xfffec0b0>
2108e31c:	63000044 	addi	r12,r12,1
2108e320:	6018913a 	slli	r12,r12,4
2108e324:	39c003cc 	andi	r7,r7,15
2108e328:	010000c4 	movi	r4,3
2108e32c:	1b07883a 	add	r3,r3,r12
2108e330:	21c00e2e 	bgeu	r4,r7,2108e36c <memset+0x100>
2108e334:	1813883a 	mov	r9,r3
2108e338:	3811883a 	mov	r8,r7
2108e33c:	010000c4 	movi	r4,3
2108e340:	49800015 	stw	r6,0(r9)
2108e344:	423fff04 	addi	r8,r8,-4
2108e348:	4a400104 	addi	r9,r9,4
2108e34c:	223ffc36 	bltu	r4,r8,2108e340 <__flash_rwdata_start+0xfffec0f8>
2108e350:	393fff04 	addi	r4,r7,-4
2108e354:	2008d0ba 	srli	r4,r4,2
2108e358:	39c000cc 	andi	r7,r7,3
2108e35c:	21000044 	addi	r4,r4,1
2108e360:	2109883a 	add	r4,r4,r4
2108e364:	2109883a 	add	r4,r4,r4
2108e368:	1907883a 	add	r3,r3,r4
2108e36c:	38000426 	beq	r7,zero,2108e380 <memset+0x114>
2108e370:	19cf883a 	add	r7,r3,r7
2108e374:	19400005 	stb	r5,0(r3)
2108e378:	18c00044 	addi	r3,r3,1
2108e37c:	19fffd1e 	bne	r3,r7,2108e374 <__flash_rwdata_start+0xfffec12c>
2108e380:	f800283a 	ret
2108e384:	2007883a 	mov	r3,r4
2108e388:	300f883a 	mov	r7,r6
2108e38c:	003fc806 	br	2108e2b0 <__flash_rwdata_start+0xfffec068>

2108e390 <_printf_r>:
2108e390:	defffd04 	addi	sp,sp,-12
2108e394:	dfc00015 	stw	ra,0(sp)
2108e398:	d9800115 	stw	r6,4(sp)
2108e39c:	d9c00215 	stw	r7,8(sp)
2108e3a0:	280d883a 	mov	r6,r5
2108e3a4:	21400217 	ldw	r5,8(r4)
2108e3a8:	d9c00104 	addi	r7,sp,4
2108e3ac:	10907b00 	call	210907b0 <___vfprintf_internal_r>
2108e3b0:	dfc00017 	ldw	ra,0(sp)
2108e3b4:	dec00304 	addi	sp,sp,12
2108e3b8:	f800283a 	ret

2108e3bc <printf>:
2108e3bc:	defffc04 	addi	sp,sp,-16
2108e3c0:	dfc00015 	stw	ra,0(sp)
2108e3c4:	d9400115 	stw	r5,4(sp)
2108e3c8:	d9800215 	stw	r6,8(sp)
2108e3cc:	d9c00315 	stw	r7,12(sp)
2108e3d0:	00800034 	movhi	r2,0
2108e3d4:	10976b04 	addi	r2,r2,23980
2108e3d8:	10800017 	ldw	r2,0(r2)
2108e3dc:	200b883a 	mov	r5,r4
2108e3e0:	d9800104 	addi	r6,sp,4
2108e3e4:	11000217 	ldw	r4,8(r2)
2108e3e8:	10927000 	call	21092700 <__vfprintf_internal>
2108e3ec:	dfc00017 	ldw	ra,0(sp)
2108e3f0:	dec00404 	addi	sp,sp,16
2108e3f4:	f800283a 	ret

2108e3f8 <_putchar_r>:
2108e3f8:	21800217 	ldw	r6,8(r4)
2108e3fc:	1096a2c1 	jmpi	21096a2c <_putc_r>

2108e400 <putchar>:
2108e400:	00800034 	movhi	r2,0
2108e404:	10976b04 	addi	r2,r2,23980
2108e408:	200b883a 	mov	r5,r4
2108e40c:	11000017 	ldw	r4,0(r2)
2108e410:	21800217 	ldw	r6,8(r4)
2108e414:	1096a2c1 	jmpi	21096a2c <_putc_r>

2108e418 <_puts_r>:
2108e418:	defff604 	addi	sp,sp,-40
2108e41c:	dc000715 	stw	r16,28(sp)
2108e420:	2021883a 	mov	r16,r4
2108e424:	2809883a 	mov	r4,r5
2108e428:	dc400815 	stw	r17,32(sp)
2108e42c:	dfc00915 	stw	ra,36(sp)
2108e430:	2823883a 	mov	r17,r5
2108e434:	108e7200 	call	2108e720 <strlen>
2108e438:	81400217 	ldw	r5,8(r16)
2108e43c:	11000044 	addi	r4,r2,1
2108e440:	d8800115 	stw	r2,4(sp)
2108e444:	00800034 	movhi	r2,0
2108e448:	2980030b 	ldhu	r6,12(r5)
2108e44c:	10809f04 	addi	r2,r2,636
2108e450:	d8800215 	stw	r2,8(sp)
2108e454:	00800044 	movi	r2,1
2108e458:	d8800315 	stw	r2,12(sp)
2108e45c:	00800084 	movi	r2,2
2108e460:	d8800515 	stw	r2,20(sp)
2108e464:	dc400015 	stw	r17,0(sp)
2108e468:	d9000615 	stw	r4,24(sp)
2108e46c:	dec00415 	stw	sp,16(sp)
2108e470:	3088000c 	andi	r2,r6,8192
2108e474:	1000061e 	bne	r2,zero,2108e490 <_puts_r+0x78>
2108e478:	29001917 	ldw	r4,100(r5)
2108e47c:	00b7ffc4 	movi	r2,-8193
2108e480:	31880014 	ori	r6,r6,8192
2108e484:	2084703a 	and	r2,r4,r2
2108e488:	2980030d 	sth	r6,12(r5)
2108e48c:	28801915 	stw	r2,100(r5)
2108e490:	8009883a 	mov	r4,r16
2108e494:	d9800404 	addi	r6,sp,16
2108e498:	1094f680 	call	21094f68 <__sfvwrite_r>
2108e49c:	1000061e 	bne	r2,zero,2108e4b8 <_puts_r+0xa0>
2108e4a0:	00800284 	movi	r2,10
2108e4a4:	dfc00917 	ldw	ra,36(sp)
2108e4a8:	dc400817 	ldw	r17,32(sp)
2108e4ac:	dc000717 	ldw	r16,28(sp)
2108e4b0:	dec00a04 	addi	sp,sp,40
2108e4b4:	f800283a 	ret
2108e4b8:	00bfffc4 	movi	r2,-1
2108e4bc:	003ff906 	br	2108e4a4 <__flash_rwdata_start+0xfffec25c>

2108e4c0 <puts>:
2108e4c0:	00800034 	movhi	r2,0
2108e4c4:	10976b04 	addi	r2,r2,23980
2108e4c8:	200b883a 	mov	r5,r4
2108e4cc:	11000017 	ldw	r4,0(r2)
2108e4d0:	108e4181 	jmpi	2108e418 <_puts_r>

2108e4d4 <_sbrk_r>:
2108e4d4:	defffd04 	addi	sp,sp,-12
2108e4d8:	dc000015 	stw	r16,0(sp)
2108e4dc:	04000034 	movhi	r16,0
2108e4e0:	dc400115 	stw	r17,4(sp)
2108e4e4:	84178504 	addi	r16,r16,24084
2108e4e8:	2023883a 	mov	r17,r4
2108e4ec:	2809883a 	mov	r4,r5
2108e4f0:	dfc00215 	stw	ra,8(sp)
2108e4f4:	80000015 	stw	zero,0(r16)
2108e4f8:	109b66c0 	call	2109b66c <sbrk>
2108e4fc:	00ffffc4 	movi	r3,-1
2108e500:	10c00526 	beq	r2,r3,2108e518 <_sbrk_r+0x44>
2108e504:	dfc00217 	ldw	ra,8(sp)
2108e508:	dc400117 	ldw	r17,4(sp)
2108e50c:	dc000017 	ldw	r16,0(sp)
2108e510:	dec00304 	addi	sp,sp,12
2108e514:	f800283a 	ret
2108e518:	80c00017 	ldw	r3,0(r16)
2108e51c:	183ff926 	beq	r3,zero,2108e504 <__flash_rwdata_start+0xfffec2bc>
2108e520:	88c00015 	stw	r3,0(r17)
2108e524:	003ff706 	br	2108e504 <__flash_rwdata_start+0xfffec2bc>

2108e528 <_sprintf_r>:
2108e528:	deffe404 	addi	sp,sp,-112
2108e52c:	2807883a 	mov	r3,r5
2108e530:	dfc01a15 	stw	ra,104(sp)
2108e534:	d9c01b15 	stw	r7,108(sp)
2108e538:	00a00034 	movhi	r2,32768
2108e53c:	10bfffc4 	addi	r2,r2,-1
2108e540:	02008204 	movi	r8,520
2108e544:	d8800215 	stw	r2,8(sp)
2108e548:	d8800515 	stw	r2,20(sp)
2108e54c:	d80b883a 	mov	r5,sp
2108e550:	d9c01b04 	addi	r7,sp,108
2108e554:	00bfffc4 	movi	r2,-1
2108e558:	d8c00015 	stw	r3,0(sp)
2108e55c:	d8c00415 	stw	r3,16(sp)
2108e560:	da00030d 	sth	r8,12(sp)
2108e564:	d880038d 	sth	r2,14(sp)
2108e568:	108e8200 	call	2108e820 <___svfprintf_internal_r>
2108e56c:	d8c00017 	ldw	r3,0(sp)
2108e570:	18000005 	stb	zero,0(r3)
2108e574:	dfc01a17 	ldw	ra,104(sp)
2108e578:	dec01c04 	addi	sp,sp,112
2108e57c:	f800283a 	ret

2108e580 <sprintf>:
2108e580:	deffe304 	addi	sp,sp,-116
2108e584:	2007883a 	mov	r3,r4
2108e588:	dfc01a15 	stw	ra,104(sp)
2108e58c:	d9801b15 	stw	r6,108(sp)
2108e590:	d9c01c15 	stw	r7,112(sp)
2108e594:	01000034 	movhi	r4,0
2108e598:	21176b04 	addi	r4,r4,23980
2108e59c:	21000017 	ldw	r4,0(r4)
2108e5a0:	00a00034 	movhi	r2,32768
2108e5a4:	10bfffc4 	addi	r2,r2,-1
2108e5a8:	280d883a 	mov	r6,r5
2108e5ac:	02008204 	movi	r8,520
2108e5b0:	d8800215 	stw	r2,8(sp)
2108e5b4:	d8800515 	stw	r2,20(sp)
2108e5b8:	d80b883a 	mov	r5,sp
2108e5bc:	d9c01b04 	addi	r7,sp,108
2108e5c0:	00bfffc4 	movi	r2,-1
2108e5c4:	d8c00015 	stw	r3,0(sp)
2108e5c8:	d8c00415 	stw	r3,16(sp)
2108e5cc:	da00030d 	sth	r8,12(sp)
2108e5d0:	d880038d 	sth	r2,14(sp)
2108e5d4:	108e8200 	call	2108e820 <___svfprintf_internal_r>
2108e5d8:	d8c00017 	ldw	r3,0(sp)
2108e5dc:	18000005 	stb	zero,0(r3)
2108e5e0:	dfc01a17 	ldw	ra,104(sp)
2108e5e4:	dec01d04 	addi	sp,sp,116
2108e5e8:	f800283a 	ret

2108e5ec <strcmp>:
2108e5ec:	2144b03a 	or	r2,r4,r5
2108e5f0:	108000cc 	andi	r2,r2,3
2108e5f4:	1000171e 	bne	r2,zero,2108e654 <strcmp+0x68>
2108e5f8:	20800017 	ldw	r2,0(r4)
2108e5fc:	28c00017 	ldw	r3,0(r5)
2108e600:	10c0141e 	bne	r2,r3,2108e654 <strcmp+0x68>
2108e604:	027fbff4 	movhi	r9,65279
2108e608:	4a7fbfc4 	addi	r9,r9,-257
2108e60c:	0086303a 	nor	r3,zero,r2
2108e610:	02202074 	movhi	r8,32897
2108e614:	1245883a 	add	r2,r2,r9
2108e618:	42202004 	addi	r8,r8,-32640
2108e61c:	10c4703a 	and	r2,r2,r3
2108e620:	1204703a 	and	r2,r2,r8
2108e624:	10000226 	beq	r2,zero,2108e630 <strcmp+0x44>
2108e628:	00001706 	br	2108e688 <strcmp+0x9c>
2108e62c:	1000161e 	bne	r2,zero,2108e688 <strcmp+0x9c>
2108e630:	21000104 	addi	r4,r4,4
2108e634:	20c00017 	ldw	r3,0(r4)
2108e638:	29400104 	addi	r5,r5,4
2108e63c:	29800017 	ldw	r6,0(r5)
2108e640:	1a4f883a 	add	r7,r3,r9
2108e644:	00c4303a 	nor	r2,zero,r3
2108e648:	3884703a 	and	r2,r7,r2
2108e64c:	1204703a 	and	r2,r2,r8
2108e650:	19bff626 	beq	r3,r6,2108e62c <__flash_rwdata_start+0xfffec3e4>
2108e654:	20800007 	ldb	r2,0(r4)
2108e658:	1000051e 	bne	r2,zero,2108e670 <strcmp+0x84>
2108e65c:	00000606 	br	2108e678 <strcmp+0x8c>
2108e660:	21000044 	addi	r4,r4,1
2108e664:	20800007 	ldb	r2,0(r4)
2108e668:	29400044 	addi	r5,r5,1
2108e66c:	10000226 	beq	r2,zero,2108e678 <strcmp+0x8c>
2108e670:	28c00007 	ldb	r3,0(r5)
2108e674:	10fffa26 	beq	r2,r3,2108e660 <__flash_rwdata_start+0xfffec418>
2108e678:	20800003 	ldbu	r2,0(r4)
2108e67c:	28c00003 	ldbu	r3,0(r5)
2108e680:	10c5c83a 	sub	r2,r2,r3
2108e684:	f800283a 	ret
2108e688:	0005883a 	mov	r2,zero
2108e68c:	f800283a 	ret

2108e690 <strcpy>:
2108e690:	2906b03a 	or	r3,r5,r4
2108e694:	18c000cc 	andi	r3,r3,3
2108e698:	2005883a 	mov	r2,r4
2108e69c:	1800161e 	bne	r3,zero,2108e6f8 <strcpy+0x68>
2108e6a0:	29c00017 	ldw	r7,0(r5)
2108e6a4:	02ffbff4 	movhi	r11,65279
2108e6a8:	5affbfc4 	addi	r11,r11,-257
2108e6ac:	02a02074 	movhi	r10,32897
2108e6b0:	01c8303a 	nor	r4,zero,r7
2108e6b4:	3ac7883a 	add	r3,r7,r11
2108e6b8:	52a02004 	addi	r10,r10,-32640
2108e6bc:	20c6703a 	and	r3,r4,r3
2108e6c0:	1a86703a 	and	r3,r3,r10
2108e6c4:	18000c1e 	bne	r3,zero,2108e6f8 <strcpy+0x68>
2108e6c8:	1011883a 	mov	r8,r2
2108e6cc:	41c00015 	stw	r7,0(r8)
2108e6d0:	29400104 	addi	r5,r5,4
2108e6d4:	29c00017 	ldw	r7,0(r5)
2108e6d8:	41800104 	addi	r6,r8,4
2108e6dc:	3011883a 	mov	r8,r6
2108e6e0:	01d2303a 	nor	r9,zero,r7
2108e6e4:	3ac7883a 	add	r3,r7,r11
2108e6e8:	48c6703a 	and	r3,r9,r3
2108e6ec:	1a86703a 	and	r3,r3,r10
2108e6f0:	183ff626 	beq	r3,zero,2108e6cc <__flash_rwdata_start+0xfffec484>
2108e6f4:	00000106 	br	2108e6fc <strcpy+0x6c>
2108e6f8:	100d883a 	mov	r6,r2
2108e6fc:	28c00003 	ldbu	r3,0(r5)
2108e700:	31800044 	addi	r6,r6,1
2108e704:	29400044 	addi	r5,r5,1
2108e708:	30ffffc5 	stb	r3,-1(r6)
2108e70c:	18c03fcc 	andi	r3,r3,255
2108e710:	18c0201c 	xori	r3,r3,128
2108e714:	18ffe004 	addi	r3,r3,-128
2108e718:	183ff81e 	bne	r3,zero,2108e6fc <__flash_rwdata_start+0xfffec4b4>
2108e71c:	f800283a 	ret

2108e720 <strlen>:
2108e720:	208000cc 	andi	r2,r4,3
2108e724:	10002026 	beq	r2,zero,2108e7a8 <strlen+0x88>
2108e728:	20800007 	ldb	r2,0(r4)
2108e72c:	10002026 	beq	r2,zero,2108e7b0 <strlen+0x90>
2108e730:	2005883a 	mov	r2,r4
2108e734:	00000206 	br	2108e740 <strlen+0x20>
2108e738:	10c00007 	ldb	r3,0(r2)
2108e73c:	18001826 	beq	r3,zero,2108e7a0 <strlen+0x80>
2108e740:	10800044 	addi	r2,r2,1
2108e744:	10c000cc 	andi	r3,r2,3
2108e748:	183ffb1e 	bne	r3,zero,2108e738 <__flash_rwdata_start+0xfffec4f0>
2108e74c:	10c00017 	ldw	r3,0(r2)
2108e750:	01ffbff4 	movhi	r7,65279
2108e754:	39ffbfc4 	addi	r7,r7,-257
2108e758:	00ca303a 	nor	r5,zero,r3
2108e75c:	01a02074 	movhi	r6,32897
2108e760:	19c7883a 	add	r3,r3,r7
2108e764:	31a02004 	addi	r6,r6,-32640
2108e768:	1946703a 	and	r3,r3,r5
2108e76c:	1986703a 	and	r3,r3,r6
2108e770:	1800091e 	bne	r3,zero,2108e798 <strlen+0x78>
2108e774:	10800104 	addi	r2,r2,4
2108e778:	10c00017 	ldw	r3,0(r2)
2108e77c:	19cb883a 	add	r5,r3,r7
2108e780:	00c6303a 	nor	r3,zero,r3
2108e784:	28c6703a 	and	r3,r5,r3
2108e788:	1986703a 	and	r3,r3,r6
2108e78c:	183ff926 	beq	r3,zero,2108e774 <__flash_rwdata_start+0xfffec52c>
2108e790:	00000106 	br	2108e798 <strlen+0x78>
2108e794:	10800044 	addi	r2,r2,1
2108e798:	10c00007 	ldb	r3,0(r2)
2108e79c:	183ffd1e 	bne	r3,zero,2108e794 <__flash_rwdata_start+0xfffec54c>
2108e7a0:	1105c83a 	sub	r2,r2,r4
2108e7a4:	f800283a 	ret
2108e7a8:	2005883a 	mov	r2,r4
2108e7ac:	003fe706 	br	2108e74c <__flash_rwdata_start+0xfffec504>
2108e7b0:	0005883a 	mov	r2,zero
2108e7b4:	f800283a 	ret

2108e7b8 <strrchr>:
2108e7b8:	defffd04 	addi	sp,sp,-12
2108e7bc:	dc000015 	stw	r16,0(sp)
2108e7c0:	dfc00215 	stw	ra,8(sp)
2108e7c4:	dc400115 	stw	r17,4(sp)
2108e7c8:	2821883a 	mov	r16,r5
2108e7cc:	28000f26 	beq	r5,zero,2108e80c <strrchr+0x54>
2108e7d0:	2007883a 	mov	r3,r4
2108e7d4:	0023883a 	mov	r17,zero
2108e7d8:	00000206 	br	2108e7e4 <strrchr+0x2c>
2108e7dc:	10c00044 	addi	r3,r2,1
2108e7e0:	1023883a 	mov	r17,r2
2108e7e4:	1809883a 	mov	r4,r3
2108e7e8:	800b883a 	mov	r5,r16
2108e7ec:	10972b00 	call	210972b0 <strchr>
2108e7f0:	103ffa1e 	bne	r2,zero,2108e7dc <__flash_rwdata_start+0xfffec594>
2108e7f4:	8805883a 	mov	r2,r17
2108e7f8:	dfc00217 	ldw	ra,8(sp)
2108e7fc:	dc400117 	ldw	r17,4(sp)
2108e800:	dc000017 	ldw	r16,0(sp)
2108e804:	dec00304 	addi	sp,sp,12
2108e808:	f800283a 	ret
2108e80c:	dfc00217 	ldw	ra,8(sp)
2108e810:	dc400117 	ldw	r17,4(sp)
2108e814:	dc000017 	ldw	r16,0(sp)
2108e818:	dec00304 	addi	sp,sp,12
2108e81c:	10972b01 	jmpi	210972b0 <strchr>

2108e820 <___svfprintf_internal_r>:
2108e820:	deffb504 	addi	sp,sp,-300
2108e824:	dfc04a15 	stw	ra,296(sp)
2108e828:	ddc04815 	stw	r23,288(sp)
2108e82c:	d9002f15 	stw	r4,188(sp)
2108e830:	282f883a 	mov	r23,r5
2108e834:	d9802915 	stw	r6,164(sp)
2108e838:	d9c02d15 	stw	r7,180(sp)
2108e83c:	df004915 	stw	fp,292(sp)
2108e840:	dd804715 	stw	r22,284(sp)
2108e844:	dd404615 	stw	r21,280(sp)
2108e848:	dd004515 	stw	r20,276(sp)
2108e84c:	dcc04415 	stw	r19,272(sp)
2108e850:	dc804315 	stw	r18,268(sp)
2108e854:	dc404215 	stw	r17,264(sp)
2108e858:	dc004115 	stw	r16,260(sp)
2108e85c:	109565c0 	call	2109565c <_localeconv_r>
2108e860:	10800017 	ldw	r2,0(r2)
2108e864:	1009883a 	mov	r4,r2
2108e868:	d8803515 	stw	r2,212(sp)
2108e86c:	108e7200 	call	2108e720 <strlen>
2108e870:	d8803915 	stw	r2,228(sp)
2108e874:	b880030b 	ldhu	r2,12(r23)
2108e878:	1080200c 	andi	r2,r2,128
2108e87c:	10000226 	beq	r2,zero,2108e888 <___svfprintf_internal_r+0x68>
2108e880:	b8800417 	ldw	r2,16(r23)
2108e884:	10065f26 	beq	r2,zero,21090204 <___svfprintf_internal_r+0x19e4>
2108e888:	db001dc4 	addi	r12,sp,119
2108e88c:	dd801e04 	addi	r22,sp,120
2108e890:	d8800404 	addi	r2,sp,16
2108e894:	05000034 	movhi	r20,0
2108e898:	b317c83a 	sub	r11,r22,r12
2108e89c:	a50ed984 	addi	r20,r20,15206
2108e8a0:	db002815 	stw	r12,160(sp)
2108e8a4:	d8801e15 	stw	r2,120(sp)
2108e8a8:	d8002015 	stw	zero,128(sp)
2108e8ac:	d8001f15 	stw	zero,124(sp)
2108e8b0:	d8003315 	stw	zero,204(sp)
2108e8b4:	d8003715 	stw	zero,220(sp)
2108e8b8:	d8003815 	stw	zero,224(sp)
2108e8bc:	1011883a 	mov	r8,r2
2108e8c0:	d8003b15 	stw	zero,236(sp)
2108e8c4:	d8003a15 	stw	zero,232(sp)
2108e8c8:	d8003015 	stw	zero,192(sp)
2108e8cc:	dac03d15 	stw	r11,244(sp)
2108e8d0:	db002917 	ldw	r12,164(sp)
2108e8d4:	60800007 	ldb	r2,0(r12)
2108e8d8:	1000ab26 	beq	r2,zero,2108eb88 <___svfprintf_internal_r+0x368>
2108e8dc:	00c00944 	movi	r3,37
2108e8e0:	10c0a926 	beq	r2,r3,2108eb88 <___svfprintf_internal_r+0x368>
2108e8e4:	6021883a 	mov	r16,r12
2108e8e8:	00000106 	br	2108e8f0 <___svfprintf_internal_r+0xd0>
2108e8ec:	10c08426 	beq	r2,r3,2108eb00 <___svfprintf_internal_r+0x2e0>
2108e8f0:	84000044 	addi	r16,r16,1
2108e8f4:	80800007 	ldb	r2,0(r16)
2108e8f8:	103ffc1e 	bne	r2,zero,2108e8ec <__flash_rwdata_start+0xfffec6a4>
2108e8fc:	dac02917 	ldw	r11,164(sp)
2108e900:	82e3c83a 	sub	r17,r16,r11
2108e904:	88000f26 	beq	r17,zero,2108e944 <___svfprintf_internal_r+0x124>
2108e908:	d8c02017 	ldw	r3,128(sp)
2108e90c:	d8801f17 	ldw	r2,124(sp)
2108e910:	dac02917 	ldw	r11,164(sp)
2108e914:	1c47883a 	add	r3,r3,r17
2108e918:	10800044 	addi	r2,r2,1
2108e91c:	d8c02015 	stw	r3,128(sp)
2108e920:	42c00015 	stw	r11,0(r8)
2108e924:	44400115 	stw	r17,4(r8)
2108e928:	d8801f15 	stw	r2,124(sp)
2108e92c:	00c001c4 	movi	r3,7
2108e930:	18807616 	blt	r3,r2,2108eb0c <___svfprintf_internal_r+0x2ec>
2108e934:	42000204 	addi	r8,r8,8
2108e938:	db003017 	ldw	r12,192(sp)
2108e93c:	6459883a 	add	r12,r12,r17
2108e940:	db003015 	stw	r12,192(sp)
2108e944:	80800007 	ldb	r2,0(r16)
2108e948:	10007726 	beq	r2,zero,2108eb28 <___svfprintf_internal_r+0x308>
2108e94c:	80800044 	addi	r2,r16,1
2108e950:	84000047 	ldb	r16,1(r16)
2108e954:	d8002785 	stb	zero,158(sp)
2108e958:	000d883a 	mov	r6,zero
2108e95c:	027fffc4 	movi	r9,-1
2108e960:	d8002e15 	stw	zero,184(sp)
2108e964:	0023883a 	mov	r17,zero
2108e968:	01001604 	movi	r4,88
2108e96c:	01400244 	movi	r5,9
2108e970:	02800a84 	movi	r10,42
2108e974:	01c01b04 	movi	r7,108
2108e978:	10c00044 	addi	r3,r2,1
2108e97c:	80bff804 	addi	r2,r16,-32
2108e980:	2082e636 	bltu	r4,r2,2108f51c <___svfprintf_internal_r+0xcfc>
2108e984:	100490ba 	slli	r2,r2,2
2108e988:	02c84274 	movhi	r11,8457
2108e98c:	5afa6704 	addi	r11,r11,-5732
2108e990:	12c5883a 	add	r2,r2,r11
2108e994:	10800017 	ldw	r2,0(r2)
2108e998:	1000683a 	jmp	r2
2108e99c:	2108f2fc 	xorhi	r4,r4,9163
2108e9a0:	2108f51c 	xori	r4,r4,9172
2108e9a4:	2108f51c 	xori	r4,r4,9172
2108e9a8:	2108f31c 	xori	r4,r4,9164
2108e9ac:	2108f51c 	xori	r4,r4,9172
2108e9b0:	2108f51c 	xori	r4,r4,9172
2108e9b4:	2108f51c 	xori	r4,r4,9172
2108e9b8:	2108f51c 	xori	r4,r4,9172
2108e9bc:	2108f51c 	xori	r4,r4,9172
2108e9c0:	2108f51c 	xori	r4,r4,9172
2108e9c4:	2108f32c 	andhi	r4,r4,9164
2108e9c8:	2108f358 	cmpnei	r4,r4,9165
2108e9cc:	2108f51c 	xori	r4,r4,9172
2108e9d0:	2108eb90 	cmplti	r4,r4,9134
2108e9d4:	2108eba0 	cmpeqi	r4,r4,9134
2108e9d8:	2108f51c 	xori	r4,r4,9172
2108e9dc:	2108ebe0 	cmpeqi	r4,r4,9135
2108e9e0:	2108f1c0 	call	22108f1c <__flash_rwdata_start+0x1066cd4>
2108e9e4:	2108f1c0 	call	22108f1c <__flash_rwdata_start+0x1066cd4>
2108e9e8:	2108f1c0 	call	22108f1c <__flash_rwdata_start+0x1066cd4>
2108e9ec:	2108f1c0 	call	22108f1c <__flash_rwdata_start+0x1066cd4>
2108e9f0:	2108f1c0 	call	22108f1c <__flash_rwdata_start+0x1066cd4>
2108e9f4:	2108f1c0 	call	22108f1c <__flash_rwdata_start+0x1066cd4>
2108e9f8:	2108f1c0 	call	22108f1c <__flash_rwdata_start+0x1066cd4>
2108e9fc:	2108f1c0 	call	22108f1c <__flash_rwdata_start+0x1066cd4>
2108ea00:	2108f1c0 	call	22108f1c <__flash_rwdata_start+0x1066cd4>
2108ea04:	2108f51c 	xori	r4,r4,9172
2108ea08:	2108f51c 	xori	r4,r4,9172
2108ea0c:	2108f51c 	xori	r4,r4,9172
2108ea10:	2108f51c 	xori	r4,r4,9172
2108ea14:	2108f51c 	xori	r4,r4,9172
2108ea18:	2108f51c 	xori	r4,r4,9172
2108ea1c:	2108f51c 	xori	r4,r4,9172
2108ea20:	2108f51c 	xori	r4,r4,9172
2108ea24:	2108f51c 	xori	r4,r4,9172
2108ea28:	2108f51c 	xori	r4,r4,9172
2108ea2c:	2108ebf0 	cmpltui	r4,r4,9135
2108ea30:	2108f070 	cmpltui	r4,r4,9153
2108ea34:	2108f51c 	xori	r4,r4,9172
2108ea38:	2108f070 	cmpltui	r4,r4,9153
2108ea3c:	2108f51c 	xori	r4,r4,9172
2108ea40:	2108f51c 	xori	r4,r4,9172
2108ea44:	2108f51c 	xori	r4,r4,9172
2108ea48:	2108f51c 	xori	r4,r4,9172
2108ea4c:	2108f114 	ori	r4,r4,9156
2108ea50:	2108f51c 	xori	r4,r4,9172
2108ea54:	2108f51c 	xori	r4,r4,9172
2108ea58:	2108f4b0 	cmpltui	r4,r4,9170
2108ea5c:	2108f51c 	xori	r4,r4,9172
2108ea60:	2108f51c 	xori	r4,r4,9172
2108ea64:	2108f51c 	xori	r4,r4,9172
2108ea68:	2108f51c 	xori	r4,r4,9172
2108ea6c:	2108f51c 	xori	r4,r4,9172
2108ea70:	2108f124 	muli	r4,r4,9156
2108ea74:	2108f51c 	xori	r4,r4,9172
2108ea78:	2108f51c 	xori	r4,r4,9172
2108ea7c:	2108f164 	muli	r4,r4,9157
2108ea80:	2108f51c 	xori	r4,r4,9172
2108ea84:	2108f51c 	xori	r4,r4,9172
2108ea88:	2108f51c 	xori	r4,r4,9172
2108ea8c:	2108f51c 	xori	r4,r4,9172
2108ea90:	2108f51c 	xori	r4,r4,9172
2108ea94:	2108f51c 	xori	r4,r4,9172
2108ea98:	2108f51c 	xori	r4,r4,9172
2108ea9c:	2108f51c 	xori	r4,r4,9172
2108eaa0:	2108f51c 	xori	r4,r4,9172
2108eaa4:	2108f51c 	xori	r4,r4,9172
2108eaa8:	2108f408 	cmpgei	r4,r4,9168
2108eaac:	2108f448 	cmpgei	r4,r4,9169
2108eab0:	2108f070 	cmpltui	r4,r4,9153
2108eab4:	2108f070 	cmpltui	r4,r4,9153
2108eab8:	2108f070 	cmpltui	r4,r4,9153
2108eabc:	2108f368 	cmpgeui	r4,r4,9165
2108eac0:	2108f448 	cmpgei	r4,r4,9169
2108eac4:	2108f51c 	xori	r4,r4,9172
2108eac8:	2108f51c 	xori	r4,r4,9172
2108eacc:	2108f378 	rdprs	r4,r4,9165
2108ead0:	2108f51c 	xori	r4,r4,9172
2108ead4:	2108f38c 	andi	r4,r4,9166
2108ead8:	2108f4e0 	cmpeqi	r4,r4,9171
2108eadc:	2108f3c0 	call	22108f3c <__flash_rwdata_start+0x1066cf4>
2108eae0:	2108f1f4 	orhi	r4,r4,9159
2108eae4:	2108f51c 	xori	r4,r4,9172
2108eae8:	2108f204 	addi	r4,r4,9160
2108eaec:	2108f51c 	xori	r4,r4,9172
2108eaf0:	2108f27c 	xorhi	r4,r4,9161
2108eaf4:	2108f51c 	xori	r4,r4,9172
2108eaf8:	2108f51c 	xori	r4,r4,9172
2108eafc:	2108f2bc 	xorhi	r4,r4,9162
2108eb00:	db002917 	ldw	r12,164(sp)
2108eb04:	8323c83a 	sub	r17,r16,r12
2108eb08:	003f7e06 	br	2108e904 <__flash_rwdata_start+0xfffec6bc>
2108eb0c:	d9002f17 	ldw	r4,188(sp)
2108eb10:	b80b883a 	mov	r5,r23
2108eb14:	b00d883a 	mov	r6,r22
2108eb18:	10974140 	call	21097414 <__ssprint_r>
2108eb1c:	1000081e 	bne	r2,zero,2108eb40 <___svfprintf_internal_r+0x320>
2108eb20:	da000404 	addi	r8,sp,16
2108eb24:	003f8406 	br	2108e938 <__flash_rwdata_start+0xfffec6f0>
2108eb28:	d8802017 	ldw	r2,128(sp)
2108eb2c:	10000426 	beq	r2,zero,2108eb40 <___svfprintf_internal_r+0x320>
2108eb30:	d9002f17 	ldw	r4,188(sp)
2108eb34:	b80b883a 	mov	r5,r23
2108eb38:	d9801e04 	addi	r6,sp,120
2108eb3c:	10974140 	call	21097414 <__ssprint_r>
2108eb40:	b880030b 	ldhu	r2,12(r23)
2108eb44:	1080100c 	andi	r2,r2,64
2108eb48:	10000d1e 	bne	r2,zero,2108eb80 <___svfprintf_internal_r+0x360>
2108eb4c:	d8803017 	ldw	r2,192(sp)
2108eb50:	dfc04a17 	ldw	ra,296(sp)
2108eb54:	df004917 	ldw	fp,292(sp)
2108eb58:	ddc04817 	ldw	r23,288(sp)
2108eb5c:	dd804717 	ldw	r22,284(sp)
2108eb60:	dd404617 	ldw	r21,280(sp)
2108eb64:	dd004517 	ldw	r20,276(sp)
2108eb68:	dcc04417 	ldw	r19,272(sp)
2108eb6c:	dc804317 	ldw	r18,268(sp)
2108eb70:	dc404217 	ldw	r17,264(sp)
2108eb74:	dc004117 	ldw	r16,260(sp)
2108eb78:	dec04b04 	addi	sp,sp,300
2108eb7c:	f800283a 	ret
2108eb80:	00bfffc4 	movi	r2,-1
2108eb84:	003ff206 	br	2108eb50 <__flash_rwdata_start+0xfffec908>
2108eb88:	dc002917 	ldw	r16,164(sp)
2108eb8c:	003f6d06 	br	2108e944 <__flash_rwdata_start+0xfffec6fc>
2108eb90:	1805883a 	mov	r2,r3
2108eb94:	8c400114 	ori	r17,r17,4
2108eb98:	1c000007 	ldb	r16,0(r3)
2108eb9c:	003f7606 	br	2108e978 <__flash_rwdata_start+0xfffec730>
2108eba0:	1c000007 	ldb	r16,0(r3)
2108eba4:	18800044 	addi	r2,r3,1
2108eba8:	8286e726 	beq	r16,r10,21090748 <___svfprintf_internal_r+0x1f28>
2108ebac:	82fff404 	addi	r11,r16,-48
2108ebb0:	1007883a 	mov	r3,r2
2108ebb4:	0013883a 	mov	r9,zero
2108ebb8:	2aff7036 	bltu	r5,r11,2108e97c <__flash_rwdata_start+0xfffec734>
2108ebbc:	1c000007 	ldb	r16,0(r3)
2108ebc0:	4a4002a4 	muli	r9,r9,10
2108ebc4:	18c00044 	addi	r3,r3,1
2108ebc8:	5a53883a 	add	r9,r11,r9
2108ebcc:	82fff404 	addi	r11,r16,-48
2108ebd0:	2afffa2e 	bgeu	r5,r11,2108ebbc <__flash_rwdata_start+0xfffec974>
2108ebd4:	483f690e 	bge	r9,zero,2108e97c <__flash_rwdata_start+0xfffec734>
2108ebd8:	027fffc4 	movi	r9,-1
2108ebdc:	003f6706 	br	2108e97c <__flash_rwdata_start+0xfffec734>
2108ebe0:	8c402014 	ori	r17,r17,128
2108ebe4:	1805883a 	mov	r2,r3
2108ebe8:	1c000007 	ldb	r16,0(r3)
2108ebec:	003f6206 	br	2108e978 <__flash_rwdata_start+0xfffec730>
2108ebf0:	8c400414 	ori	r17,r17,16
2108ebf4:	d8c02915 	stw	r3,164(sp)
2108ebf8:	d9802785 	stb	r6,158(sp)
2108ebfc:	8880080c 	andi	r2,r17,32
2108ec00:	d8c02d17 	ldw	r3,180(sp)
2108ec04:	10021526 	beq	r2,zero,2108f45c <___svfprintf_internal_r+0xc3c>
2108ec08:	db002d17 	ldw	r12,180(sp)
2108ec0c:	18800117 	ldw	r2,4(r3)
2108ec10:	1cc00017 	ldw	r19,0(r3)
2108ec14:	63000204 	addi	r12,r12,8
2108ec18:	db002d15 	stw	r12,180(sp)
2108ec1c:	1039883a 	mov	fp,r2
2108ec20:	10021916 	blt	r2,zero,2108f488 <___svfprintf_internal_r+0xc68>
2108ec24:	dd402783 	ldbu	r21,158(sp)
2108ec28:	da403215 	stw	r9,200(sp)
2108ec2c:	00800044 	movi	r2,1
2108ec30:	9f06b03a 	or	r3,r19,fp
2108ec34:	48000216 	blt	r9,zero,2108ec40 <___svfprintf_internal_r+0x420>
2108ec38:	013fdfc4 	movi	r4,-129
2108ec3c:	8922703a 	and	r17,r17,r4
2108ec40:	1802461e 	bne	r3,zero,2108f55c <___svfprintf_internal_r+0xd3c>
2108ec44:	48035426 	beq	r9,zero,2108f998 <___svfprintf_internal_r+0x1178>
2108ec48:	10803fcc 	andi	r2,r2,255
2108ec4c:	00c00044 	movi	r3,1
2108ec50:	10c26726 	beq	r2,r3,2108f5f0 <___svfprintf_internal_r+0xdd0>
2108ec54:	00c00084 	movi	r3,2
2108ec58:	10c2ea26 	beq	r2,r3,2108f804 <___svfprintf_internal_r+0xfe4>
2108ec5c:	b007883a 	mov	r3,r22
2108ec60:	9808d0fa 	srli	r4,r19,3
2108ec64:	e00a977a 	slli	r5,fp,29
2108ec68:	e038d0fa 	srli	fp,fp,3
2108ec6c:	9cc001cc 	andi	r19,r19,7
2108ec70:	98800c04 	addi	r2,r19,48
2108ec74:	18ffffc4 	addi	r3,r3,-1
2108ec78:	2926b03a 	or	r19,r5,r4
2108ec7c:	18800005 	stb	r2,0(r3)
2108ec80:	9f08b03a 	or	r4,r19,fp
2108ec84:	203ff61e 	bne	r4,zero,2108ec60 <__flash_rwdata_start+0xfffeca18>
2108ec88:	8900004c 	andi	r4,r17,1
2108ec8c:	d8c03115 	stw	r3,196(sp)
2108ec90:	2002ea26 	beq	r4,zero,2108f83c <___svfprintf_internal_r+0x101c>
2108ec94:	10803fcc 	andi	r2,r2,255
2108ec98:	1080201c 	xori	r2,r2,128
2108ec9c:	10bfe004 	addi	r2,r2,-128
2108eca0:	01000c04 	movi	r4,48
2108eca4:	11057526 	beq	r2,r4,2109027c <___svfprintf_internal_r+0x1a5c>
2108eca8:	dac03117 	ldw	r11,196(sp)
2108ecac:	193fffc5 	stb	r4,-1(r3)
2108ecb0:	5affffc4 	addi	r11,r11,-1
2108ecb4:	dac03115 	stw	r11,196(sp)
2108ecb8:	b2e5c83a 	sub	r18,r22,r11
2108ecbc:	9005883a 	mov	r2,r18
2108ecc0:	9240010e 	bge	r18,r9,2108ecc8 <___svfprintf_internal_r+0x4a8>
2108ecc4:	4805883a 	mov	r2,r9
2108ecc8:	d8802a15 	stw	r2,168(sp)
2108eccc:	d8003415 	stw	zero,208(sp)
2108ecd0:	a8803fcc 	andi	r2,r21,255
2108ecd4:	1080201c 	xori	r2,r2,128
2108ecd8:	10bfe004 	addi	r2,r2,-128
2108ecdc:	10000326 	beq	r2,zero,2108ecec <___svfprintf_internal_r+0x4cc>
2108ece0:	d8c02a17 	ldw	r3,168(sp)
2108ece4:	18c00044 	addi	r3,r3,1
2108ece8:	d8c02a15 	stw	r3,168(sp)
2108ecec:	8ac0008c 	andi	r11,r17,2
2108ecf0:	dac02b15 	stw	r11,172(sp)
2108ecf4:	58000326 	beq	r11,zero,2108ed04 <___svfprintf_internal_r+0x4e4>
2108ecf8:	db002a17 	ldw	r12,168(sp)
2108ecfc:	63000084 	addi	r12,r12,2
2108ed00:	db002a15 	stw	r12,168(sp)
2108ed04:	88c0210c 	andi	r3,r17,132
2108ed08:	d8c02c15 	stw	r3,176(sp)
2108ed0c:	1802111e 	bne	r3,zero,2108f554 <___svfprintf_internal_r+0xd34>
2108ed10:	dac02e17 	ldw	r11,184(sp)
2108ed14:	db002a17 	ldw	r12,168(sp)
2108ed18:	5b39c83a 	sub	fp,r11,r12
2108ed1c:	07020d0e 	bge	zero,fp,2108f554 <___svfprintf_internal_r+0xd34>
2108ed20:	02400404 	movi	r9,16
2108ed24:	d8c02017 	ldw	r3,128(sp)
2108ed28:	d8801f17 	ldw	r2,124(sp)
2108ed2c:	4f058c0e 	bge	r9,fp,21090360 <___svfprintf_internal_r+0x1b40>
2108ed30:	01400034 	movhi	r5,0
2108ed34:	e009883a 	mov	r4,fp
2108ed38:	294edd84 	addi	r5,r5,15222
2108ed3c:	dc003c15 	stw	r16,240(sp)
2108ed40:	9039883a 	mov	fp,r18
2108ed44:	d9403615 	stw	r5,216(sp)
2108ed48:	8825883a 	mov	r18,r17
2108ed4c:	482b883a 	mov	r21,r9
2108ed50:	04c001c4 	movi	r19,7
2108ed54:	dc002f17 	ldw	r16,188(sp)
2108ed58:	2023883a 	mov	r17,r4
2108ed5c:	00000306 	br	2108ed6c <___svfprintf_internal_r+0x54c>
2108ed60:	8c7ffc04 	addi	r17,r17,-16
2108ed64:	42000204 	addi	r8,r8,8
2108ed68:	ac40130e 	bge	r21,r17,2108edb8 <___svfprintf_internal_r+0x598>
2108ed6c:	02c00034 	movhi	r11,0
2108ed70:	18c00404 	addi	r3,r3,16
2108ed74:	10800044 	addi	r2,r2,1
2108ed78:	5acedd84 	addi	r11,r11,15222
2108ed7c:	42c00015 	stw	r11,0(r8)
2108ed80:	45400115 	stw	r21,4(r8)
2108ed84:	d8c02015 	stw	r3,128(sp)
2108ed88:	d8801f15 	stw	r2,124(sp)
2108ed8c:	98bff40e 	bge	r19,r2,2108ed60 <__flash_rwdata_start+0xfffecb18>
2108ed90:	8009883a 	mov	r4,r16
2108ed94:	b80b883a 	mov	r5,r23
2108ed98:	b00d883a 	mov	r6,r22
2108ed9c:	10974140 	call	21097414 <__ssprint_r>
2108eda0:	103f671e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
2108eda4:	8c7ffc04 	addi	r17,r17,-16
2108eda8:	d8c02017 	ldw	r3,128(sp)
2108edac:	d8801f17 	ldw	r2,124(sp)
2108edb0:	da000404 	addi	r8,sp,16
2108edb4:	ac7fed16 	blt	r21,r17,2108ed6c <__flash_rwdata_start+0xfffecb24>
2108edb8:	dc003c17 	ldw	r16,240(sp)
2108edbc:	8809883a 	mov	r4,r17
2108edc0:	9023883a 	mov	r17,r18
2108edc4:	e025883a 	mov	r18,fp
2108edc8:	2039883a 	mov	fp,r4
2108edcc:	db003617 	ldw	r12,216(sp)
2108edd0:	e0c7883a 	add	r3,fp,r3
2108edd4:	10800044 	addi	r2,r2,1
2108edd8:	43000015 	stw	r12,0(r8)
2108eddc:	47000115 	stw	fp,4(r8)
2108ede0:	d8c02015 	stw	r3,128(sp)
2108ede4:	d8801f15 	stw	r2,124(sp)
2108ede8:	010001c4 	movi	r4,7
2108edec:	20834416 	blt	r4,r2,2108fb00 <___svfprintf_internal_r+0x12e0>
2108edf0:	d8802787 	ldb	r2,158(sp)
2108edf4:	42000204 	addi	r8,r8,8
2108edf8:	10000c26 	beq	r2,zero,2108ee2c <___svfprintf_internal_r+0x60c>
2108edfc:	d8801f17 	ldw	r2,124(sp)
2108ee00:	d9002784 	addi	r4,sp,158
2108ee04:	18c00044 	addi	r3,r3,1
2108ee08:	10800044 	addi	r2,r2,1
2108ee0c:	41000015 	stw	r4,0(r8)
2108ee10:	01000044 	movi	r4,1
2108ee14:	41000115 	stw	r4,4(r8)
2108ee18:	d8c02015 	stw	r3,128(sp)
2108ee1c:	d8801f15 	stw	r2,124(sp)
2108ee20:	010001c4 	movi	r4,7
2108ee24:	2082f616 	blt	r4,r2,2108fa00 <___svfprintf_internal_r+0x11e0>
2108ee28:	42000204 	addi	r8,r8,8
2108ee2c:	dac02b17 	ldw	r11,172(sp)
2108ee30:	58000c26 	beq	r11,zero,2108ee64 <___svfprintf_internal_r+0x644>
2108ee34:	d8801f17 	ldw	r2,124(sp)
2108ee38:	d9002704 	addi	r4,sp,156
2108ee3c:	18c00084 	addi	r3,r3,2
2108ee40:	10800044 	addi	r2,r2,1
2108ee44:	41000015 	stw	r4,0(r8)
2108ee48:	01000084 	movi	r4,2
2108ee4c:	41000115 	stw	r4,4(r8)
2108ee50:	d8c02015 	stw	r3,128(sp)
2108ee54:	d8801f15 	stw	r2,124(sp)
2108ee58:	010001c4 	movi	r4,7
2108ee5c:	2082e016 	blt	r4,r2,2108f9e0 <___svfprintf_internal_r+0x11c0>
2108ee60:	42000204 	addi	r8,r8,8
2108ee64:	db002c17 	ldw	r12,176(sp)
2108ee68:	00802004 	movi	r2,128
2108ee6c:	60822f26 	beq	r12,r2,2108f72c <___svfprintf_internal_r+0xf0c>
2108ee70:	db003217 	ldw	r12,200(sp)
2108ee74:	64abc83a 	sub	r21,r12,r18
2108ee78:	0540310e 	bge	zero,r21,2108ef40 <___svfprintf_internal_r+0x720>
2108ee7c:	07000404 	movi	fp,16
2108ee80:	d8801f17 	ldw	r2,124(sp)
2108ee84:	e544270e 	bge	fp,r21,2108ff24 <___svfprintf_internal_r+0x1704>
2108ee88:	01400034 	movhi	r5,0
2108ee8c:	a809883a 	mov	r4,r21
2108ee90:	294ed984 	addi	r5,r5,15206
2108ee94:	dc002c15 	stw	r16,176(sp)
2108ee98:	902b883a 	mov	r21,r18
2108ee9c:	d9402b15 	stw	r5,172(sp)
2108eea0:	8825883a 	mov	r18,r17
2108eea4:	04c001c4 	movi	r19,7
2108eea8:	dc002f17 	ldw	r16,188(sp)
2108eeac:	2023883a 	mov	r17,r4
2108eeb0:	00000306 	br	2108eec0 <___svfprintf_internal_r+0x6a0>
2108eeb4:	8c7ffc04 	addi	r17,r17,-16
2108eeb8:	42000204 	addi	r8,r8,8
2108eebc:	e440110e 	bge	fp,r17,2108ef04 <___svfprintf_internal_r+0x6e4>
2108eec0:	18c00404 	addi	r3,r3,16
2108eec4:	10800044 	addi	r2,r2,1
2108eec8:	45000015 	stw	r20,0(r8)
2108eecc:	47000115 	stw	fp,4(r8)
2108eed0:	d8c02015 	stw	r3,128(sp)
2108eed4:	d8801f15 	stw	r2,124(sp)
2108eed8:	98bff60e 	bge	r19,r2,2108eeb4 <__flash_rwdata_start+0xfffecc6c>
2108eedc:	8009883a 	mov	r4,r16
2108eee0:	b80b883a 	mov	r5,r23
2108eee4:	b00d883a 	mov	r6,r22
2108eee8:	10974140 	call	21097414 <__ssprint_r>
2108eeec:	103f141e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
2108eef0:	8c7ffc04 	addi	r17,r17,-16
2108eef4:	d8c02017 	ldw	r3,128(sp)
2108eef8:	d8801f17 	ldw	r2,124(sp)
2108eefc:	da000404 	addi	r8,sp,16
2108ef00:	e47fef16 	blt	fp,r17,2108eec0 <__flash_rwdata_start+0xfffecc78>
2108ef04:	dc002c17 	ldw	r16,176(sp)
2108ef08:	8809883a 	mov	r4,r17
2108ef0c:	9023883a 	mov	r17,r18
2108ef10:	a825883a 	mov	r18,r21
2108ef14:	202b883a 	mov	r21,r4
2108ef18:	dac02b17 	ldw	r11,172(sp)
2108ef1c:	1d47883a 	add	r3,r3,r21
2108ef20:	10800044 	addi	r2,r2,1
2108ef24:	42c00015 	stw	r11,0(r8)
2108ef28:	45400115 	stw	r21,4(r8)
2108ef2c:	d8c02015 	stw	r3,128(sp)
2108ef30:	d8801f15 	stw	r2,124(sp)
2108ef34:	010001c4 	movi	r4,7
2108ef38:	2082a116 	blt	r4,r2,2108f9c0 <___svfprintf_internal_r+0x11a0>
2108ef3c:	42000204 	addi	r8,r8,8
2108ef40:	8880400c 	andi	r2,r17,256
2108ef44:	1001b01e 	bne	r2,zero,2108f608 <___svfprintf_internal_r+0xde8>
2108ef48:	d8801f17 	ldw	r2,124(sp)
2108ef4c:	db003117 	ldw	r12,196(sp)
2108ef50:	1c87883a 	add	r3,r3,r18
2108ef54:	10800044 	addi	r2,r2,1
2108ef58:	43000015 	stw	r12,0(r8)
2108ef5c:	44800115 	stw	r18,4(r8)
2108ef60:	d8c02015 	stw	r3,128(sp)
2108ef64:	d8801f15 	stw	r2,124(sp)
2108ef68:	010001c4 	movi	r4,7
2108ef6c:	20828216 	blt	r4,r2,2108f978 <___svfprintf_internal_r+0x1158>
2108ef70:	42000204 	addi	r8,r8,8
2108ef74:	8c40010c 	andi	r17,r17,4
2108ef78:	88003226 	beq	r17,zero,2108f044 <___svfprintf_internal_r+0x824>
2108ef7c:	db002e17 	ldw	r12,184(sp)
2108ef80:	dac02a17 	ldw	r11,168(sp)
2108ef84:	62e1c83a 	sub	r16,r12,r11
2108ef88:	04002e0e 	bge	zero,r16,2108f044 <___svfprintf_internal_r+0x824>
2108ef8c:	04400404 	movi	r17,16
2108ef90:	d8801f17 	ldw	r2,124(sp)
2108ef94:	8c05330e 	bge	r17,r16,21090464 <___svfprintf_internal_r+0x1c44>
2108ef98:	01000034 	movhi	r4,0
2108ef9c:	210edd84 	addi	r4,r4,15222
2108efa0:	d9003615 	stw	r4,216(sp)
2108efa4:	048001c4 	movi	r18,7
2108efa8:	dcc02f17 	ldw	r19,188(sp)
2108efac:	00000306 	br	2108efbc <___svfprintf_internal_r+0x79c>
2108efb0:	843ffc04 	addi	r16,r16,-16
2108efb4:	42000204 	addi	r8,r8,8
2108efb8:	8c00130e 	bge	r17,r16,2108f008 <___svfprintf_internal_r+0x7e8>
2108efbc:	01400034 	movhi	r5,0
2108efc0:	18c00404 	addi	r3,r3,16
2108efc4:	10800044 	addi	r2,r2,1
2108efc8:	294edd84 	addi	r5,r5,15222
2108efcc:	41400015 	stw	r5,0(r8)
2108efd0:	44400115 	stw	r17,4(r8)
2108efd4:	d8c02015 	stw	r3,128(sp)
2108efd8:	d8801f15 	stw	r2,124(sp)
2108efdc:	90bff40e 	bge	r18,r2,2108efb0 <__flash_rwdata_start+0xfffecd68>
2108efe0:	9809883a 	mov	r4,r19
2108efe4:	b80b883a 	mov	r5,r23
2108efe8:	b00d883a 	mov	r6,r22
2108efec:	10974140 	call	21097414 <__ssprint_r>
2108eff0:	103ed31e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
2108eff4:	843ffc04 	addi	r16,r16,-16
2108eff8:	d8c02017 	ldw	r3,128(sp)
2108effc:	d8801f17 	ldw	r2,124(sp)
2108f000:	da000404 	addi	r8,sp,16
2108f004:	8c3fed16 	blt	r17,r16,2108efbc <__flash_rwdata_start+0xfffecd74>
2108f008:	dac03617 	ldw	r11,216(sp)
2108f00c:	1c07883a 	add	r3,r3,r16
2108f010:	10800044 	addi	r2,r2,1
2108f014:	42c00015 	stw	r11,0(r8)
2108f018:	44000115 	stw	r16,4(r8)
2108f01c:	d8c02015 	stw	r3,128(sp)
2108f020:	d8801f15 	stw	r2,124(sp)
2108f024:	010001c4 	movi	r4,7
2108f028:	2080060e 	bge	r4,r2,2108f044 <___svfprintf_internal_r+0x824>
2108f02c:	d9002f17 	ldw	r4,188(sp)
2108f030:	b80b883a 	mov	r5,r23
2108f034:	b00d883a 	mov	r6,r22
2108f038:	10974140 	call	21097414 <__ssprint_r>
2108f03c:	103ec01e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
2108f040:	d8c02017 	ldw	r3,128(sp)
2108f044:	d8802a17 	ldw	r2,168(sp)
2108f048:	db002e17 	ldw	r12,184(sp)
2108f04c:	1300010e 	bge	r2,r12,2108f054 <___svfprintf_internal_r+0x834>
2108f050:	6005883a 	mov	r2,r12
2108f054:	dac03017 	ldw	r11,192(sp)
2108f058:	5897883a 	add	r11,r11,r2
2108f05c:	dac03015 	stw	r11,192(sp)
2108f060:	1802331e 	bne	r3,zero,2108f930 <___svfprintf_internal_r+0x1110>
2108f064:	d8001f15 	stw	zero,124(sp)
2108f068:	da000404 	addi	r8,sp,16
2108f06c:	003e1806 	br	2108e8d0 <__flash_rwdata_start+0xfffec688>
2108f070:	db002d17 	ldw	r12,180(sp)
2108f074:	dac02d17 	ldw	r11,180(sp)
2108f078:	d8c02915 	stw	r3,164(sp)
2108f07c:	63000017 	ldw	r12,0(r12)
2108f080:	5ac00117 	ldw	r11,4(r11)
2108f084:	d9802785 	stb	r6,158(sp)
2108f088:	6009883a 	mov	r4,r12
2108f08c:	580b883a 	mov	r5,r11
2108f090:	db003715 	stw	r12,220(sp)
2108f094:	da004015 	stw	r8,256(sp)
2108f098:	da403f15 	stw	r9,252(sp)
2108f09c:	dac03815 	stw	r11,224(sp)
2108f0a0:	10971000 	call	21097100 <__fpclassifyd>
2108f0a4:	db002d17 	ldw	r12,180(sp)
2108f0a8:	04800044 	movi	r18,1
2108f0ac:	da004017 	ldw	r8,256(sp)
2108f0b0:	64c00204 	addi	r19,r12,8
2108f0b4:	da403f17 	ldw	r9,252(sp)
2108f0b8:	d9003717 	ldw	r4,220(sp)
2108f0bc:	d9403817 	ldw	r5,224(sp)
2108f0c0:	1483561e 	bne	r2,r18,2108fe1c <___svfprintf_internal_r+0x15fc>
2108f0c4:	000d883a 	mov	r6,zero
2108f0c8:	000f883a 	mov	r7,zero
2108f0cc:	109afa80 	call	2109afa8 <__ledf2>
2108f0d0:	da004017 	ldw	r8,256(sp)
2108f0d4:	1004ee16 	blt	r2,zero,21090490 <___svfprintf_internal_r+0x1c70>
2108f0d8:	dd402783 	ldbu	r21,158(sp)
2108f0dc:	008011c4 	movi	r2,71
2108f0e0:	1404440e 	bge	r2,r16,210901f4 <___svfprintf_internal_r+0x19d4>
2108f0e4:	00c00034 	movhi	r3,0
2108f0e8:	18ceca04 	addi	r3,r3,15144
2108f0ec:	d8c03115 	stw	r3,196(sp)
2108f0f0:	02c000c4 	movi	r11,3
2108f0f4:	00bfdfc4 	movi	r2,-129
2108f0f8:	dac02a15 	stw	r11,168(sp)
2108f0fc:	88a2703a 	and	r17,r17,r2
2108f100:	dcc02d15 	stw	r19,180(sp)
2108f104:	5825883a 	mov	r18,r11
2108f108:	d8003215 	stw	zero,200(sp)
2108f10c:	d8003415 	stw	zero,208(sp)
2108f110:	003eef06 	br	2108ecd0 <__flash_rwdata_start+0xfffeca88>
2108f114:	8c400214 	ori	r17,r17,8
2108f118:	1805883a 	mov	r2,r3
2108f11c:	1c000007 	ldb	r16,0(r3)
2108f120:	003e1506 	br	2108e978 <__flash_rwdata_start+0xfffec730>
2108f124:	8c400414 	ori	r17,r17,16
2108f128:	d8c02915 	stw	r3,164(sp)
2108f12c:	88c0080c 	andi	r3,r17,32
2108f130:	d8802d17 	ldw	r2,180(sp)
2108f134:	18005526 	beq	r3,zero,2108f28c <___svfprintf_internal_r+0xa6c>
2108f138:	dac02d17 	ldw	r11,180(sp)
2108f13c:	14c00017 	ldw	r19,0(r2)
2108f140:	17000117 	ldw	fp,4(r2)
2108f144:	5ac00204 	addi	r11,r11,8
2108f148:	dac02d15 	stw	r11,180(sp)
2108f14c:	00800044 	movi	r2,1
2108f150:	9f06b03a 	or	r3,r19,fp
2108f154:	d8002785 	stb	zero,158(sp)
2108f158:	da403215 	stw	r9,200(sp)
2108f15c:	002b883a 	mov	r21,zero
2108f160:	003eb406 	br	2108ec34 <__flash_rwdata_start+0xfffec9ec>
2108f164:	03000034 	movhi	r12,0
2108f168:	630ecd04 	addi	r12,r12,15156
2108f16c:	d8c02915 	stw	r3,164(sp)
2108f170:	d9802785 	stb	r6,158(sp)
2108f174:	db003b15 	stw	r12,236(sp)
2108f178:	88c0080c 	andi	r3,r17,32
2108f17c:	d8802d17 	ldw	r2,180(sp)
2108f180:	18005626 	beq	r3,zero,2108f2dc <___svfprintf_internal_r+0xabc>
2108f184:	dac02d17 	ldw	r11,180(sp)
2108f188:	14c00017 	ldw	r19,0(r2)
2108f18c:	17000117 	ldw	fp,4(r2)
2108f190:	5ac00204 	addi	r11,r11,8
2108f194:	dac02d15 	stw	r11,180(sp)
2108f198:	8880004c 	andi	r2,r17,1
2108f19c:	10029326 	beq	r2,zero,2108fbec <___svfprintf_internal_r+0x13cc>
2108f1a0:	9f06b03a 	or	r3,r19,fp
2108f1a4:	18033526 	beq	r3,zero,2108fe7c <___svfprintf_internal_r+0x165c>
2108f1a8:	00800c04 	movi	r2,48
2108f1ac:	d8802705 	stb	r2,156(sp)
2108f1b0:	dc002745 	stb	r16,157(sp)
2108f1b4:	8c400094 	ori	r17,r17,2
2108f1b8:	00800084 	movi	r2,2
2108f1bc:	003fe506 	br	2108f154 <__flash_rwdata_start+0xfffecf0c>
2108f1c0:	1805883a 	mov	r2,r3
2108f1c4:	d8002e15 	stw	zero,184(sp)
2108f1c8:	82fff404 	addi	r11,r16,-48
2108f1cc:	0019883a 	mov	r12,zero
2108f1d0:	14000007 	ldb	r16,0(r2)
2108f1d4:	630002a4 	muli	r12,r12,10
2108f1d8:	18c00044 	addi	r3,r3,1
2108f1dc:	1805883a 	mov	r2,r3
2108f1e0:	62d9883a 	add	r12,r12,r11
2108f1e4:	82fff404 	addi	r11,r16,-48
2108f1e8:	2afff92e 	bgeu	r5,r11,2108f1d0 <__flash_rwdata_start+0xfffecf88>
2108f1ec:	db002e15 	stw	r12,184(sp)
2108f1f0:	003de206 	br	2108e97c <__flash_rwdata_start+0xfffec734>
2108f1f4:	8c400814 	ori	r17,r17,32
2108f1f8:	1805883a 	mov	r2,r3
2108f1fc:	1c000007 	ldb	r16,0(r3)
2108f200:	003ddd06 	br	2108e978 <__flash_rwdata_start+0xfffec730>
2108f204:	dac02d17 	ldw	r11,180(sp)
2108f208:	db002d17 	ldw	r12,180(sp)
2108f20c:	d8c02915 	stw	r3,164(sp)
2108f210:	5ac00017 	ldw	r11,0(r11)
2108f214:	d8002785 	stb	zero,158(sp)
2108f218:	64c00104 	addi	r19,r12,4
2108f21c:	dac03115 	stw	r11,196(sp)
2108f220:	58048126 	beq	r11,zero,21090428 <___svfprintf_internal_r+0x1c08>
2108f224:	d9003117 	ldw	r4,196(sp)
2108f228:	48041716 	blt	r9,zero,21090288 <___svfprintf_internal_r+0x1a68>
2108f22c:	480d883a 	mov	r6,r9
2108f230:	000b883a 	mov	r5,zero
2108f234:	da004015 	stw	r8,256(sp)
2108f238:	da403f15 	stw	r9,252(sp)
2108f23c:	10958480 	call	21095848 <memchr>
2108f240:	da004017 	ldw	r8,256(sp)
2108f244:	da403f17 	ldw	r9,252(sp)
2108f248:	1004db26 	beq	r2,zero,210905b8 <___svfprintf_internal_r+0x1d98>
2108f24c:	d8c03117 	ldw	r3,196(sp)
2108f250:	10e5c83a 	sub	r18,r2,r3
2108f254:	4c80010e 	bge	r9,r18,2108f25c <___svfprintf_internal_r+0xa3c>
2108f258:	4825883a 	mov	r18,r9
2108f25c:	9005883a 	mov	r2,r18
2108f260:	90040e16 	blt	r18,zero,2109029c <___svfprintf_internal_r+0x1a7c>
2108f264:	dd402783 	ldbu	r21,158(sp)
2108f268:	d8802a15 	stw	r2,168(sp)
2108f26c:	dcc02d15 	stw	r19,180(sp)
2108f270:	d8003215 	stw	zero,200(sp)
2108f274:	d8003415 	stw	zero,208(sp)
2108f278:	003e9506 	br	2108ecd0 <__flash_rwdata_start+0xfffeca88>
2108f27c:	d8c02915 	stw	r3,164(sp)
2108f280:	88c0080c 	andi	r3,r17,32
2108f284:	d8802d17 	ldw	r2,180(sp)
2108f288:	183fab1e 	bne	r3,zero,2108f138 <__flash_rwdata_start+0xfffecef0>
2108f28c:	88c0040c 	andi	r3,r17,16
2108f290:	1802681e 	bne	r3,zero,2108fc34 <___svfprintf_internal_r+0x1414>
2108f294:	88c0100c 	andi	r3,r17,64
2108f298:	18026626 	beq	r3,zero,2108fc34 <___svfprintf_internal_r+0x1414>
2108f29c:	dac02d17 	ldw	r11,180(sp)
2108f2a0:	14c0000b 	ldhu	r19,0(r2)
2108f2a4:	0039883a 	mov	fp,zero
2108f2a8:	5ac00104 	addi	r11,r11,4
2108f2ac:	dac02d15 	stw	r11,180(sp)
2108f2b0:	00800044 	movi	r2,1
2108f2b4:	9807883a 	mov	r3,r19
2108f2b8:	003fa606 	br	2108f154 <__flash_rwdata_start+0xfffecf0c>
2108f2bc:	00800034 	movhi	r2,0
2108f2c0:	108ed204 	addi	r2,r2,15176
2108f2c4:	d8c02915 	stw	r3,164(sp)
2108f2c8:	d8803b15 	stw	r2,236(sp)
2108f2cc:	d9802785 	stb	r6,158(sp)
2108f2d0:	88c0080c 	andi	r3,r17,32
2108f2d4:	d8802d17 	ldw	r2,180(sp)
2108f2d8:	183faa1e 	bne	r3,zero,2108f184 <__flash_rwdata_start+0xfffecf3c>
2108f2dc:	88c0040c 	andi	r3,r17,16
2108f2e0:	1802e826 	beq	r3,zero,2108fe84 <___svfprintf_internal_r+0x1664>
2108f2e4:	db002d17 	ldw	r12,180(sp)
2108f2e8:	14c00017 	ldw	r19,0(r2)
2108f2ec:	0039883a 	mov	fp,zero
2108f2f0:	63000104 	addi	r12,r12,4
2108f2f4:	db002d15 	stw	r12,180(sp)
2108f2f8:	003fa706 	br	2108f198 <__flash_rwdata_start+0xfffecf50>
2108f2fc:	30803fcc 	andi	r2,r6,255
2108f300:	1080201c 	xori	r2,r2,128
2108f304:	10bfe004 	addi	r2,r2,-128
2108f308:	1002d91e 	bne	r2,zero,2108fe70 <___svfprintf_internal_r+0x1650>
2108f30c:	1805883a 	mov	r2,r3
2108f310:	01800804 	movi	r6,32
2108f314:	1c000007 	ldb	r16,0(r3)
2108f318:	003d9706 	br	2108e978 <__flash_rwdata_start+0xfffec730>
2108f31c:	8c400054 	ori	r17,r17,1
2108f320:	1805883a 	mov	r2,r3
2108f324:	1c000007 	ldb	r16,0(r3)
2108f328:	003d9306 	br	2108e978 <__flash_rwdata_start+0xfffec730>
2108f32c:	dac02d17 	ldw	r11,180(sp)
2108f330:	db002d17 	ldw	r12,180(sp)
2108f334:	5ac00017 	ldw	r11,0(r11)
2108f338:	dac02e15 	stw	r11,184(sp)
2108f33c:	62c00104 	addi	r11,r12,4
2108f340:	db002e17 	ldw	r12,184(sp)
2108f344:	60033e16 	blt	r12,zero,21090040 <___svfprintf_internal_r+0x1820>
2108f348:	dac02d15 	stw	r11,180(sp)
2108f34c:	1805883a 	mov	r2,r3
2108f350:	1c000007 	ldb	r16,0(r3)
2108f354:	003d8806 	br	2108e978 <__flash_rwdata_start+0xfffec730>
2108f358:	1805883a 	mov	r2,r3
2108f35c:	01800ac4 	movi	r6,43
2108f360:	1c000007 	ldb	r16,0(r3)
2108f364:	003d8406 	br	2108e978 <__flash_rwdata_start+0xfffec730>
2108f368:	8c401014 	ori	r17,r17,64
2108f36c:	1805883a 	mov	r2,r3
2108f370:	1c000007 	ldb	r16,0(r3)
2108f374:	003d8006 	br	2108e978 <__flash_rwdata_start+0xfffec730>
2108f378:	1c000007 	ldb	r16,0(r3)
2108f37c:	81c33626 	beq	r16,r7,21090058 <___svfprintf_internal_r+0x1838>
2108f380:	8c400414 	ori	r17,r17,16
2108f384:	1805883a 	mov	r2,r3
2108f388:	003d7b06 	br	2108e978 <__flash_rwdata_start+0xfffec730>
2108f38c:	d8c02915 	stw	r3,164(sp)
2108f390:	d9802785 	stb	r6,158(sp)
2108f394:	8880080c 	andi	r2,r17,32
2108f398:	1002c226 	beq	r2,zero,2108fea4 <___svfprintf_internal_r+0x1684>
2108f39c:	db002d17 	ldw	r12,180(sp)
2108f3a0:	dac03017 	ldw	r11,192(sp)
2108f3a4:	60800017 	ldw	r2,0(r12)
2108f3a8:	5807d7fa 	srai	r3,r11,31
2108f3ac:	63000104 	addi	r12,r12,4
2108f3b0:	db002d15 	stw	r12,180(sp)
2108f3b4:	12c00015 	stw	r11,0(r2)
2108f3b8:	10c00115 	stw	r3,4(r2)
2108f3bc:	003d4406 	br	2108e8d0 <__flash_rwdata_start+0xfffec688>
2108f3c0:	db002d17 	ldw	r12,180(sp)
2108f3c4:	00800c04 	movi	r2,48
2108f3c8:	d8802705 	stb	r2,156(sp)
2108f3cc:	64c00017 	ldw	r19,0(r12)
2108f3d0:	00801e04 	movi	r2,120
2108f3d4:	d8802745 	stb	r2,157(sp)
2108f3d8:	00800034 	movhi	r2,0
2108f3dc:	108ed204 	addi	r2,r2,15176
2108f3e0:	63000104 	addi	r12,r12,4
2108f3e4:	d8c02915 	stw	r3,164(sp)
2108f3e8:	d8803b15 	stw	r2,236(sp)
2108f3ec:	0039883a 	mov	fp,zero
2108f3f0:	8c400094 	ori	r17,r17,2
2108f3f4:	db002d15 	stw	r12,180(sp)
2108f3f8:	00800084 	movi	r2,2
2108f3fc:	04001e04 	movi	r16,120
2108f400:	9807883a 	mov	r3,r19
2108f404:	003f5306 	br	2108f154 <__flash_rwdata_start+0xfffecf0c>
2108f408:	db002d17 	ldw	r12,180(sp)
2108f40c:	d8c02915 	stw	r3,164(sp)
2108f410:	dac01404 	addi	r11,sp,80
2108f414:	60800017 	ldw	r2,0(r12)
2108f418:	00c00044 	movi	r3,1
2108f41c:	63000104 	addi	r12,r12,4
2108f420:	d8801405 	stb	r2,80(sp)
2108f424:	d8c02a15 	stw	r3,168(sp)
2108f428:	d8002785 	stb	zero,158(sp)
2108f42c:	db002d15 	stw	r12,180(sp)
2108f430:	1825883a 	mov	r18,r3
2108f434:	d8003215 	stw	zero,200(sp)
2108f438:	d8003415 	stw	zero,208(sp)
2108f43c:	dac03115 	stw	r11,196(sp)
2108f440:	0005883a 	mov	r2,zero
2108f444:	003e2906 	br	2108ecec <__flash_rwdata_start+0xfffecaa4>
2108f448:	d8c02915 	stw	r3,164(sp)
2108f44c:	d9802785 	stb	r6,158(sp)
2108f450:	8880080c 	andi	r2,r17,32
2108f454:	d8c02d17 	ldw	r3,180(sp)
2108f458:	103deb1e 	bne	r2,zero,2108ec08 <__flash_rwdata_start+0xfffec9c0>
2108f45c:	8880040c 	andi	r2,r17,16
2108f460:	1001e51e 	bne	r2,zero,2108fbf8 <___svfprintf_internal_r+0x13d8>
2108f464:	8880100c 	andi	r2,r17,64
2108f468:	1001e326 	beq	r2,zero,2108fbf8 <___svfprintf_internal_r+0x13d8>
2108f46c:	1cc0000f 	ldh	r19,0(r3)
2108f470:	db002d17 	ldw	r12,180(sp)
2108f474:	9839d7fa 	srai	fp,r19,31
2108f478:	63000104 	addi	r12,r12,4
2108f47c:	db002d15 	stw	r12,180(sp)
2108f480:	e005883a 	mov	r2,fp
2108f484:	103de70e 	bge	r2,zero,2108ec24 <__flash_rwdata_start+0xfffec9dc>
2108f488:	04e7c83a 	sub	r19,zero,r19
2108f48c:	9804c03a 	cmpne	r2,r19,zero
2108f490:	0739c83a 	sub	fp,zero,fp
2108f494:	e0b9c83a 	sub	fp,fp,r2
2108f498:	05400b44 	movi	r21,45
2108f49c:	dd402785 	stb	r21,158(sp)
2108f4a0:	da403215 	stw	r9,200(sp)
2108f4a4:	00800044 	movi	r2,1
2108f4a8:	9f06b03a 	or	r3,r19,fp
2108f4ac:	003de106 	br	2108ec34 <__flash_rwdata_start+0xfffec9ec>
2108f4b0:	8c400414 	ori	r17,r17,16
2108f4b4:	d8c02915 	stw	r3,164(sp)
2108f4b8:	8880080c 	andi	r2,r17,32
2108f4bc:	10000b26 	beq	r2,zero,2108f4ec <___svfprintf_internal_r+0xccc>
2108f4c0:	db002d17 	ldw	r12,180(sp)
2108f4c4:	0005883a 	mov	r2,zero
2108f4c8:	64c00017 	ldw	r19,0(r12)
2108f4cc:	67000117 	ldw	fp,4(r12)
2108f4d0:	63000204 	addi	r12,r12,8
2108f4d4:	db002d15 	stw	r12,180(sp)
2108f4d8:	9f06b03a 	or	r3,r19,fp
2108f4dc:	003f1d06 	br	2108f154 <__flash_rwdata_start+0xfffecf0c>
2108f4e0:	d8c02915 	stw	r3,164(sp)
2108f4e4:	8880080c 	andi	r2,r17,32
2108f4e8:	103ff51e 	bne	r2,zero,2108f4c0 <__flash_rwdata_start+0xfffed278>
2108f4ec:	8880040c 	andi	r2,r17,16
2108f4f0:	1001c81e 	bne	r2,zero,2108fc14 <___svfprintf_internal_r+0x13f4>
2108f4f4:	8880100c 	andi	r2,r17,64
2108f4f8:	1001c626 	beq	r2,zero,2108fc14 <___svfprintf_internal_r+0x13f4>
2108f4fc:	db002d17 	ldw	r12,180(sp)
2108f500:	0039883a 	mov	fp,zero
2108f504:	0005883a 	mov	r2,zero
2108f508:	64c0000b 	ldhu	r19,0(r12)
2108f50c:	63000104 	addi	r12,r12,4
2108f510:	db002d15 	stw	r12,180(sp)
2108f514:	9807883a 	mov	r3,r19
2108f518:	003f0e06 	br	2108f154 <__flash_rwdata_start+0xfffecf0c>
2108f51c:	d8c02915 	stw	r3,164(sp)
2108f520:	d9802785 	stb	r6,158(sp)
2108f524:	803d8026 	beq	r16,zero,2108eb28 <__flash_rwdata_start+0xfffec8e0>
2108f528:	02c00044 	movi	r11,1
2108f52c:	db001404 	addi	r12,sp,80
2108f530:	dac02a15 	stw	r11,168(sp)
2108f534:	dc001405 	stb	r16,80(sp)
2108f538:	d8002785 	stb	zero,158(sp)
2108f53c:	5825883a 	mov	r18,r11
2108f540:	d8003215 	stw	zero,200(sp)
2108f544:	d8003415 	stw	zero,208(sp)
2108f548:	db003115 	stw	r12,196(sp)
2108f54c:	0005883a 	mov	r2,zero
2108f550:	003de606 	br	2108ecec <__flash_rwdata_start+0xfffecaa4>
2108f554:	d8c02017 	ldw	r3,128(sp)
2108f558:	003e2706 	br	2108edf8 <__flash_rwdata_start+0xfffecbb0>
2108f55c:	10803fcc 	andi	r2,r2,255
2108f560:	00c00044 	movi	r3,1
2108f564:	10fdbb1e 	bne	r2,r3,2108ec54 <__flash_rwdata_start+0xfffeca0c>
2108f568:	e000021e 	bne	fp,zero,2108f574 <___svfprintf_internal_r+0xd54>
2108f56c:	00800244 	movi	r2,9
2108f570:	14c01f2e 	bgeu	r2,r19,2108f5f0 <___svfprintf_internal_r+0xdd0>
2108f574:	dc002a15 	stw	r16,168(sp)
2108f578:	dc402b15 	stw	r17,172(sp)
2108f57c:	9821883a 	mov	r16,r19
2108f580:	e023883a 	mov	r17,fp
2108f584:	b025883a 	mov	r18,r22
2108f588:	4827883a 	mov	r19,r9
2108f58c:	4039883a 	mov	fp,r8
2108f590:	8009883a 	mov	r4,r16
2108f594:	880b883a 	mov	r5,r17
2108f598:	01800284 	movi	r6,10
2108f59c:	000f883a 	mov	r7,zero
2108f5a0:	109a9940 	call	2109a994 <__umoddi3>
2108f5a4:	10800c04 	addi	r2,r2,48
2108f5a8:	94bfffc4 	addi	r18,r18,-1
2108f5ac:	8009883a 	mov	r4,r16
2108f5b0:	880b883a 	mov	r5,r17
2108f5b4:	01800284 	movi	r6,10
2108f5b8:	000f883a 	mov	r7,zero
2108f5bc:	90800005 	stb	r2,0(r18)
2108f5c0:	109a3d40 	call	2109a3d4 <__udivdi3>
2108f5c4:	1021883a 	mov	r16,r2
2108f5c8:	10c4b03a 	or	r2,r2,r3
2108f5cc:	1823883a 	mov	r17,r3
2108f5d0:	103fef1e 	bne	r2,zero,2108f590 <__flash_rwdata_start+0xfffed348>
2108f5d4:	dc803115 	stw	r18,196(sp)
2108f5d8:	dc002a17 	ldw	r16,168(sp)
2108f5dc:	dc402b17 	ldw	r17,172(sp)
2108f5e0:	9813883a 	mov	r9,r19
2108f5e4:	e011883a 	mov	r8,fp
2108f5e8:	b4a5c83a 	sub	r18,r22,r18
2108f5ec:	003db306 	br	2108ecbc <__flash_rwdata_start+0xfffeca74>
2108f5f0:	9cc00c04 	addi	r19,r19,48
2108f5f4:	db001dc4 	addi	r12,sp,119
2108f5f8:	dcc01dc5 	stb	r19,119(sp)
2108f5fc:	dc803d17 	ldw	r18,244(sp)
2108f600:	db003115 	stw	r12,196(sp)
2108f604:	003dad06 	br	2108ecbc <__flash_rwdata_start+0xfffeca74>
2108f608:	00801944 	movi	r2,101
2108f60c:	14008d0e 	bge	r2,r16,2108f844 <___svfprintf_internal_r+0x1024>
2108f610:	d9003717 	ldw	r4,220(sp)
2108f614:	d9403817 	ldw	r5,224(sp)
2108f618:	000d883a 	mov	r6,zero
2108f61c:	000f883a 	mov	r7,zero
2108f620:	d8c03e15 	stw	r3,248(sp)
2108f624:	da004015 	stw	r8,256(sp)
2108f628:	109af240 	call	2109af24 <__eqdf2>
2108f62c:	d8c03e17 	ldw	r3,248(sp)
2108f630:	da004017 	ldw	r8,256(sp)
2108f634:	1000fd1e 	bne	r2,zero,2108fa2c <___svfprintf_internal_r+0x120c>
2108f638:	d8801f17 	ldw	r2,124(sp)
2108f63c:	01000034 	movhi	r4,0
2108f640:	210ed904 	addi	r4,r4,15204
2108f644:	18c00044 	addi	r3,r3,1
2108f648:	10800044 	addi	r2,r2,1
2108f64c:	41000015 	stw	r4,0(r8)
2108f650:	01000044 	movi	r4,1
2108f654:	41000115 	stw	r4,4(r8)
2108f658:	d8c02015 	stw	r3,128(sp)
2108f65c:	d8801f15 	stw	r2,124(sp)
2108f660:	010001c4 	movi	r4,7
2108f664:	20823316 	blt	r4,r2,2108ff34 <___svfprintf_internal_r+0x1714>
2108f668:	42000204 	addi	r8,r8,8
2108f66c:	d8802617 	ldw	r2,152(sp)
2108f670:	dac03317 	ldw	r11,204(sp)
2108f674:	12c00216 	blt	r2,r11,2108f680 <___svfprintf_internal_r+0xe60>
2108f678:	8880004c 	andi	r2,r17,1
2108f67c:	103e3d26 	beq	r2,zero,2108ef74 <__flash_rwdata_start+0xfffecd2c>
2108f680:	db003917 	ldw	r12,228(sp)
2108f684:	d8801f17 	ldw	r2,124(sp)
2108f688:	dac03517 	ldw	r11,212(sp)
2108f68c:	1b07883a 	add	r3,r3,r12
2108f690:	10800044 	addi	r2,r2,1
2108f694:	42c00015 	stw	r11,0(r8)
2108f698:	43000115 	stw	r12,4(r8)
2108f69c:	d8c02015 	stw	r3,128(sp)
2108f6a0:	d8801f15 	stw	r2,124(sp)
2108f6a4:	010001c4 	movi	r4,7
2108f6a8:	20826f16 	blt	r4,r2,21090068 <___svfprintf_internal_r+0x1848>
2108f6ac:	42000204 	addi	r8,r8,8
2108f6b0:	db003317 	ldw	r12,204(sp)
2108f6b4:	643fffc4 	addi	r16,r12,-1
2108f6b8:	043e2e0e 	bge	zero,r16,2108ef74 <__flash_rwdata_start+0xfffecd2c>
2108f6bc:	04800404 	movi	r18,16
2108f6c0:	d8801f17 	ldw	r2,124(sp)
2108f6c4:	9400a00e 	bge	r18,r16,2108f948 <___svfprintf_internal_r+0x1128>
2108f6c8:	01400034 	movhi	r5,0
2108f6cc:	294ed984 	addi	r5,r5,15206
2108f6d0:	d9402b15 	stw	r5,172(sp)
2108f6d4:	054001c4 	movi	r21,7
2108f6d8:	dcc02f17 	ldw	r19,188(sp)
2108f6dc:	00000306 	br	2108f6ec <___svfprintf_internal_r+0xecc>
2108f6e0:	42000204 	addi	r8,r8,8
2108f6e4:	843ffc04 	addi	r16,r16,-16
2108f6e8:	94009a0e 	bge	r18,r16,2108f954 <___svfprintf_internal_r+0x1134>
2108f6ec:	18c00404 	addi	r3,r3,16
2108f6f0:	10800044 	addi	r2,r2,1
2108f6f4:	45000015 	stw	r20,0(r8)
2108f6f8:	44800115 	stw	r18,4(r8)
2108f6fc:	d8c02015 	stw	r3,128(sp)
2108f700:	d8801f15 	stw	r2,124(sp)
2108f704:	a8bff60e 	bge	r21,r2,2108f6e0 <__flash_rwdata_start+0xfffed498>
2108f708:	9809883a 	mov	r4,r19
2108f70c:	b80b883a 	mov	r5,r23
2108f710:	b00d883a 	mov	r6,r22
2108f714:	10974140 	call	21097414 <__ssprint_r>
2108f718:	103d091e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
2108f71c:	d8c02017 	ldw	r3,128(sp)
2108f720:	d8801f17 	ldw	r2,124(sp)
2108f724:	da000404 	addi	r8,sp,16
2108f728:	003fee06 	br	2108f6e4 <__flash_rwdata_start+0xfffed49c>
2108f72c:	dac02e17 	ldw	r11,184(sp)
2108f730:	db002a17 	ldw	r12,168(sp)
2108f734:	5b2bc83a 	sub	r21,r11,r12
2108f738:	057dcd0e 	bge	zero,r21,2108ee70 <__flash_rwdata_start+0xfffecc28>
2108f73c:	07000404 	movi	fp,16
2108f740:	d8801f17 	ldw	r2,124(sp)
2108f744:	e5435d0e 	bge	fp,r21,210904bc <___svfprintf_internal_r+0x1c9c>
2108f748:	01400034 	movhi	r5,0
2108f74c:	a809883a 	mov	r4,r21
2108f750:	294ed984 	addi	r5,r5,15206
2108f754:	dc002c15 	stw	r16,176(sp)
2108f758:	902b883a 	mov	r21,r18
2108f75c:	d9402b15 	stw	r5,172(sp)
2108f760:	8825883a 	mov	r18,r17
2108f764:	04c001c4 	movi	r19,7
2108f768:	dc002f17 	ldw	r16,188(sp)
2108f76c:	2023883a 	mov	r17,r4
2108f770:	00000306 	br	2108f780 <___svfprintf_internal_r+0xf60>
2108f774:	8c7ffc04 	addi	r17,r17,-16
2108f778:	42000204 	addi	r8,r8,8
2108f77c:	e440110e 	bge	fp,r17,2108f7c4 <___svfprintf_internal_r+0xfa4>
2108f780:	18c00404 	addi	r3,r3,16
2108f784:	10800044 	addi	r2,r2,1
2108f788:	45000015 	stw	r20,0(r8)
2108f78c:	47000115 	stw	fp,4(r8)
2108f790:	d8c02015 	stw	r3,128(sp)
2108f794:	d8801f15 	stw	r2,124(sp)
2108f798:	98bff60e 	bge	r19,r2,2108f774 <__flash_rwdata_start+0xfffed52c>
2108f79c:	8009883a 	mov	r4,r16
2108f7a0:	b80b883a 	mov	r5,r23
2108f7a4:	b00d883a 	mov	r6,r22
2108f7a8:	10974140 	call	21097414 <__ssprint_r>
2108f7ac:	103ce41e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
2108f7b0:	8c7ffc04 	addi	r17,r17,-16
2108f7b4:	d8c02017 	ldw	r3,128(sp)
2108f7b8:	d8801f17 	ldw	r2,124(sp)
2108f7bc:	da000404 	addi	r8,sp,16
2108f7c0:	e47fef16 	blt	fp,r17,2108f780 <__flash_rwdata_start+0xfffed538>
2108f7c4:	dc002c17 	ldw	r16,176(sp)
2108f7c8:	8809883a 	mov	r4,r17
2108f7cc:	9023883a 	mov	r17,r18
2108f7d0:	a825883a 	mov	r18,r21
2108f7d4:	202b883a 	mov	r21,r4
2108f7d8:	dac02b17 	ldw	r11,172(sp)
2108f7dc:	1d47883a 	add	r3,r3,r21
2108f7e0:	10800044 	addi	r2,r2,1
2108f7e4:	42c00015 	stw	r11,0(r8)
2108f7e8:	45400115 	stw	r21,4(r8)
2108f7ec:	d8c02015 	stw	r3,128(sp)
2108f7f0:	d8801f15 	stw	r2,124(sp)
2108f7f4:	010001c4 	movi	r4,7
2108f7f8:	20818016 	blt	r4,r2,2108fdfc <___svfprintf_internal_r+0x15dc>
2108f7fc:	42000204 	addi	r8,r8,8
2108f800:	003d9b06 	br	2108ee70 <__flash_rwdata_start+0xfffecc28>
2108f804:	d9403b17 	ldw	r5,236(sp)
2108f808:	b007883a 	mov	r3,r22
2108f80c:	988003cc 	andi	r2,r19,15
2108f810:	e008973a 	slli	r4,fp,28
2108f814:	2885883a 	add	r2,r5,r2
2108f818:	9826d13a 	srli	r19,r19,4
2108f81c:	10800003 	ldbu	r2,0(r2)
2108f820:	e038d13a 	srli	fp,fp,4
2108f824:	18ffffc4 	addi	r3,r3,-1
2108f828:	24e6b03a 	or	r19,r4,r19
2108f82c:	18800005 	stb	r2,0(r3)
2108f830:	9f04b03a 	or	r2,r19,fp
2108f834:	103ff51e 	bne	r2,zero,2108f80c <__flash_rwdata_start+0xfffed5c4>
2108f838:	d8c03115 	stw	r3,196(sp)
2108f83c:	b0e5c83a 	sub	r18,r22,r3
2108f840:	003d1e06 	br	2108ecbc <__flash_rwdata_start+0xfffeca74>
2108f844:	db003317 	ldw	r12,204(sp)
2108f848:	00800044 	movi	r2,1
2108f84c:	18c00044 	addi	r3,r3,1
2108f850:	13014b0e 	bge	r2,r12,2108fd80 <___svfprintf_internal_r+0x1560>
2108f854:	dc001f17 	ldw	r16,124(sp)
2108f858:	dac03117 	ldw	r11,196(sp)
2108f85c:	00800044 	movi	r2,1
2108f860:	84000044 	addi	r16,r16,1
2108f864:	40800115 	stw	r2,4(r8)
2108f868:	42c00015 	stw	r11,0(r8)
2108f86c:	d8c02015 	stw	r3,128(sp)
2108f870:	dc001f15 	stw	r16,124(sp)
2108f874:	008001c4 	movi	r2,7
2108f878:	14014e16 	blt	r2,r16,2108fdb4 <___svfprintf_internal_r+0x1594>
2108f87c:	42000204 	addi	r8,r8,8
2108f880:	db003917 	ldw	r12,228(sp)
2108f884:	dac03517 	ldw	r11,212(sp)
2108f888:	84000044 	addi	r16,r16,1
2108f88c:	1b07883a 	add	r3,r3,r12
2108f890:	42c00015 	stw	r11,0(r8)
2108f894:	43000115 	stw	r12,4(r8)
2108f898:	d8c02015 	stw	r3,128(sp)
2108f89c:	dc001f15 	stw	r16,124(sp)
2108f8a0:	008001c4 	movi	r2,7
2108f8a4:	14014c16 	blt	r2,r16,2108fdd8 <___svfprintf_internal_r+0x15b8>
2108f8a8:	44800204 	addi	r18,r8,8
2108f8ac:	d9003717 	ldw	r4,220(sp)
2108f8b0:	d9403817 	ldw	r5,224(sp)
2108f8b4:	000d883a 	mov	r6,zero
2108f8b8:	000f883a 	mov	r7,zero
2108f8bc:	d8c03e15 	stw	r3,248(sp)
2108f8c0:	109af240 	call	2109af24 <__eqdf2>
2108f8c4:	d8c03e17 	ldw	r3,248(sp)
2108f8c8:	db003317 	ldw	r12,204(sp)
2108f8cc:	10009526 	beq	r2,zero,2108fb24 <___svfprintf_internal_r+0x1304>
2108f8d0:	dac03117 	ldw	r11,196(sp)
2108f8d4:	60bfffc4 	addi	r2,r12,-1
2108f8d8:	1887883a 	add	r3,r3,r2
2108f8dc:	59000044 	addi	r4,r11,1
2108f8e0:	84000044 	addi	r16,r16,1
2108f8e4:	90800115 	stw	r2,4(r18)
2108f8e8:	91000015 	stw	r4,0(r18)
2108f8ec:	d8c02015 	stw	r3,128(sp)
2108f8f0:	dc001f15 	stw	r16,124(sp)
2108f8f4:	008001c4 	movi	r2,7
2108f8f8:	1400b316 	blt	r2,r16,2108fbc8 <___svfprintf_internal_r+0x13a8>
2108f8fc:	94800204 	addi	r18,r18,8
2108f900:	dac03a17 	ldw	r11,232(sp)
2108f904:	dd4022c4 	addi	r21,sp,139
2108f908:	84000044 	addi	r16,r16,1
2108f90c:	1ac7883a 	add	r3,r3,r11
2108f910:	95400015 	stw	r21,0(r18)
2108f914:	92c00115 	stw	r11,4(r18)
2108f918:	d8c02015 	stw	r3,128(sp)
2108f91c:	dc001f15 	stw	r16,124(sp)
2108f920:	008001c4 	movi	r2,7
2108f924:	14001416 	blt	r2,r16,2108f978 <___svfprintf_internal_r+0x1158>
2108f928:	92000204 	addi	r8,r18,8
2108f92c:	003d9106 	br	2108ef74 <__flash_rwdata_start+0xfffecd2c>
2108f930:	d9002f17 	ldw	r4,188(sp)
2108f934:	b80b883a 	mov	r5,r23
2108f938:	b00d883a 	mov	r6,r22
2108f93c:	10974140 	call	21097414 <__ssprint_r>
2108f940:	103dc826 	beq	r2,zero,2108f064 <__flash_rwdata_start+0xfffece1c>
2108f944:	003c7e06 	br	2108eb40 <__flash_rwdata_start+0xfffec8f8>
2108f948:	01000034 	movhi	r4,0
2108f94c:	210ed984 	addi	r4,r4,15206
2108f950:	d9002b15 	stw	r4,172(sp)
2108f954:	dac02b17 	ldw	r11,172(sp)
2108f958:	1c07883a 	add	r3,r3,r16
2108f95c:	44000115 	stw	r16,4(r8)
2108f960:	42c00015 	stw	r11,0(r8)
2108f964:	10800044 	addi	r2,r2,1
2108f968:	d8c02015 	stw	r3,128(sp)
2108f96c:	d8801f15 	stw	r2,124(sp)
2108f970:	010001c4 	movi	r4,7
2108f974:	20bd7e0e 	bge	r4,r2,2108ef70 <__flash_rwdata_start+0xfffecd28>
2108f978:	d9002f17 	ldw	r4,188(sp)
2108f97c:	b80b883a 	mov	r5,r23
2108f980:	b00d883a 	mov	r6,r22
2108f984:	10974140 	call	21097414 <__ssprint_r>
2108f988:	103c6d1e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
2108f98c:	d8c02017 	ldw	r3,128(sp)
2108f990:	da000404 	addi	r8,sp,16
2108f994:	003d7706 	br	2108ef74 <__flash_rwdata_start+0xfffecd2c>
2108f998:	10803fcc 	andi	r2,r2,255
2108f99c:	1000201e 	bne	r2,zero,2108fa20 <___svfprintf_internal_r+0x1200>
2108f9a0:	8880004c 	andi	r2,r17,1
2108f9a4:	10001e26 	beq	r2,zero,2108fa20 <___svfprintf_internal_r+0x1200>
2108f9a8:	00800c04 	movi	r2,48
2108f9ac:	d8c01dc4 	addi	r3,sp,119
2108f9b0:	d8801dc5 	stb	r2,119(sp)
2108f9b4:	dc803d17 	ldw	r18,244(sp)
2108f9b8:	d8c03115 	stw	r3,196(sp)
2108f9bc:	003cbf06 	br	2108ecbc <__flash_rwdata_start+0xfffeca74>
2108f9c0:	d9002f17 	ldw	r4,188(sp)
2108f9c4:	b80b883a 	mov	r5,r23
2108f9c8:	b00d883a 	mov	r6,r22
2108f9cc:	10974140 	call	21097414 <__ssprint_r>
2108f9d0:	103c5b1e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
2108f9d4:	d8c02017 	ldw	r3,128(sp)
2108f9d8:	da000404 	addi	r8,sp,16
2108f9dc:	003d5806 	br	2108ef40 <__flash_rwdata_start+0xfffeccf8>
2108f9e0:	d9002f17 	ldw	r4,188(sp)
2108f9e4:	b80b883a 	mov	r5,r23
2108f9e8:	b00d883a 	mov	r6,r22
2108f9ec:	10974140 	call	21097414 <__ssprint_r>
2108f9f0:	103c531e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
2108f9f4:	d8c02017 	ldw	r3,128(sp)
2108f9f8:	da000404 	addi	r8,sp,16
2108f9fc:	003d1906 	br	2108ee64 <__flash_rwdata_start+0xfffecc1c>
2108fa00:	d9002f17 	ldw	r4,188(sp)
2108fa04:	b80b883a 	mov	r5,r23
2108fa08:	b00d883a 	mov	r6,r22
2108fa0c:	10974140 	call	21097414 <__ssprint_r>
2108fa10:	103c4b1e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
2108fa14:	d8c02017 	ldw	r3,128(sp)
2108fa18:	da000404 	addi	r8,sp,16
2108fa1c:	003d0306 	br	2108ee2c <__flash_rwdata_start+0xfffecbe4>
2108fa20:	0025883a 	mov	r18,zero
2108fa24:	dd803115 	stw	r22,196(sp)
2108fa28:	003ca406 	br	2108ecbc <__flash_rwdata_start+0xfffeca74>
2108fa2c:	dc002617 	ldw	r16,152(sp)
2108fa30:	0401480e 	bge	zero,r16,2108ff54 <___svfprintf_internal_r+0x1734>
2108fa34:	db003117 	ldw	r12,196(sp)
2108fa38:	dac03317 	ldw	r11,204(sp)
2108fa3c:	62e1883a 	add	r16,r12,r11
2108fa40:	db003417 	ldw	r12,208(sp)
2108fa44:	5825883a 	mov	r18,r11
2108fa48:	62c0010e 	bge	r12,r11,2108fa50 <___svfprintf_internal_r+0x1230>
2108fa4c:	6025883a 	mov	r18,r12
2108fa50:	04800b0e 	bge	zero,r18,2108fa80 <___svfprintf_internal_r+0x1260>
2108fa54:	d8801f17 	ldw	r2,124(sp)
2108fa58:	dac03117 	ldw	r11,196(sp)
2108fa5c:	1c87883a 	add	r3,r3,r18
2108fa60:	10800044 	addi	r2,r2,1
2108fa64:	42c00015 	stw	r11,0(r8)
2108fa68:	44800115 	stw	r18,4(r8)
2108fa6c:	d8c02015 	stw	r3,128(sp)
2108fa70:	d8801f15 	stw	r2,124(sp)
2108fa74:	010001c4 	movi	r4,7
2108fa78:	20823f16 	blt	r4,r2,21090378 <___svfprintf_internal_r+0x1b58>
2108fa7c:	42000204 	addi	r8,r8,8
2108fa80:	90023b16 	blt	r18,zero,21090370 <___svfprintf_internal_r+0x1b50>
2108fa84:	db003417 	ldw	r12,208(sp)
2108fa88:	64a5c83a 	sub	r18,r12,r18
2108fa8c:	0480780e 	bge	zero,r18,2108fc70 <___svfprintf_internal_r+0x1450>
2108fa90:	05400404 	movi	r21,16
2108fa94:	d8801f17 	ldw	r2,124(sp)
2108fa98:	ac81140e 	bge	r21,r18,2108feec <___svfprintf_internal_r+0x16cc>
2108fa9c:	01400034 	movhi	r5,0
2108faa0:	294ed984 	addi	r5,r5,15206
2108faa4:	d9402b15 	stw	r5,172(sp)
2108faa8:	070001c4 	movi	fp,7
2108faac:	dcc02f17 	ldw	r19,188(sp)
2108fab0:	00000306 	br	2108fac0 <___svfprintf_internal_r+0x12a0>
2108fab4:	42000204 	addi	r8,r8,8
2108fab8:	94bffc04 	addi	r18,r18,-16
2108fabc:	ac810e0e 	bge	r21,r18,2108fef8 <___svfprintf_internal_r+0x16d8>
2108fac0:	18c00404 	addi	r3,r3,16
2108fac4:	10800044 	addi	r2,r2,1
2108fac8:	45000015 	stw	r20,0(r8)
2108facc:	45400115 	stw	r21,4(r8)
2108fad0:	d8c02015 	stw	r3,128(sp)
2108fad4:	d8801f15 	stw	r2,124(sp)
2108fad8:	e0bff60e 	bge	fp,r2,2108fab4 <__flash_rwdata_start+0xfffed86c>
2108fadc:	9809883a 	mov	r4,r19
2108fae0:	b80b883a 	mov	r5,r23
2108fae4:	b00d883a 	mov	r6,r22
2108fae8:	10974140 	call	21097414 <__ssprint_r>
2108faec:	103c141e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
2108faf0:	d8c02017 	ldw	r3,128(sp)
2108faf4:	d8801f17 	ldw	r2,124(sp)
2108faf8:	da000404 	addi	r8,sp,16
2108fafc:	003fee06 	br	2108fab8 <__flash_rwdata_start+0xfffed870>
2108fb00:	d9002f17 	ldw	r4,188(sp)
2108fb04:	b80b883a 	mov	r5,r23
2108fb08:	b00d883a 	mov	r6,r22
2108fb0c:	10974140 	call	21097414 <__ssprint_r>
2108fb10:	103c0b1e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
2108fb14:	d8c02017 	ldw	r3,128(sp)
2108fb18:	d8802787 	ldb	r2,158(sp)
2108fb1c:	da000404 	addi	r8,sp,16
2108fb20:	003cb506 	br	2108edf8 <__flash_rwdata_start+0xfffecbb0>
2108fb24:	657fffc4 	addi	r21,r12,-1
2108fb28:	057f750e 	bge	zero,r21,2108f900 <__flash_rwdata_start+0xfffed6b8>
2108fb2c:	07000404 	movi	fp,16
2108fb30:	e542ed0e 	bge	fp,r21,210906e8 <___svfprintf_internal_r+0x1ec8>
2108fb34:	01000034 	movhi	r4,0
2108fb38:	210ed984 	addi	r4,r4,15206
2108fb3c:	d9002b15 	stw	r4,172(sp)
2108fb40:	01c001c4 	movi	r7,7
2108fb44:	dcc02f17 	ldw	r19,188(sp)
2108fb48:	00000306 	br	2108fb58 <___svfprintf_internal_r+0x1338>
2108fb4c:	ad7ffc04 	addi	r21,r21,-16
2108fb50:	94800204 	addi	r18,r18,8
2108fb54:	e540130e 	bge	fp,r21,2108fba4 <___svfprintf_internal_r+0x1384>
2108fb58:	18c00404 	addi	r3,r3,16
2108fb5c:	84000044 	addi	r16,r16,1
2108fb60:	95000015 	stw	r20,0(r18)
2108fb64:	97000115 	stw	fp,4(r18)
2108fb68:	d8c02015 	stw	r3,128(sp)
2108fb6c:	dc001f15 	stw	r16,124(sp)
2108fb70:	3c3ff60e 	bge	r7,r16,2108fb4c <__flash_rwdata_start+0xfffed904>
2108fb74:	9809883a 	mov	r4,r19
2108fb78:	b80b883a 	mov	r5,r23
2108fb7c:	b00d883a 	mov	r6,r22
2108fb80:	d9c03e15 	stw	r7,248(sp)
2108fb84:	10974140 	call	21097414 <__ssprint_r>
2108fb88:	d9c03e17 	ldw	r7,248(sp)
2108fb8c:	103bec1e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
2108fb90:	ad7ffc04 	addi	r21,r21,-16
2108fb94:	d8c02017 	ldw	r3,128(sp)
2108fb98:	dc001f17 	ldw	r16,124(sp)
2108fb9c:	dc800404 	addi	r18,sp,16
2108fba0:	e57fed16 	blt	fp,r21,2108fb58 <__flash_rwdata_start+0xfffed910>
2108fba4:	dac02b17 	ldw	r11,172(sp)
2108fba8:	1d47883a 	add	r3,r3,r21
2108fbac:	84000044 	addi	r16,r16,1
2108fbb0:	92c00015 	stw	r11,0(r18)
2108fbb4:	95400115 	stw	r21,4(r18)
2108fbb8:	d8c02015 	stw	r3,128(sp)
2108fbbc:	dc001f15 	stw	r16,124(sp)
2108fbc0:	008001c4 	movi	r2,7
2108fbc4:	143f4d0e 	bge	r2,r16,2108f8fc <__flash_rwdata_start+0xfffed6b4>
2108fbc8:	d9002f17 	ldw	r4,188(sp)
2108fbcc:	b80b883a 	mov	r5,r23
2108fbd0:	b00d883a 	mov	r6,r22
2108fbd4:	10974140 	call	21097414 <__ssprint_r>
2108fbd8:	103bd91e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
2108fbdc:	d8c02017 	ldw	r3,128(sp)
2108fbe0:	dc001f17 	ldw	r16,124(sp)
2108fbe4:	dc800404 	addi	r18,sp,16
2108fbe8:	003f4506 	br	2108f900 <__flash_rwdata_start+0xfffed6b8>
2108fbec:	00800084 	movi	r2,2
2108fbf0:	9f06b03a 	or	r3,r19,fp
2108fbf4:	003d5706 	br	2108f154 <__flash_rwdata_start+0xfffecf0c>
2108fbf8:	1cc00017 	ldw	r19,0(r3)
2108fbfc:	dac02d17 	ldw	r11,180(sp)
2108fc00:	9839d7fa 	srai	fp,r19,31
2108fc04:	5ac00104 	addi	r11,r11,4
2108fc08:	dac02d15 	stw	r11,180(sp)
2108fc0c:	e005883a 	mov	r2,fp
2108fc10:	003c0306 	br	2108ec20 <__flash_rwdata_start+0xfffec9d8>
2108fc14:	dac02d17 	ldw	r11,180(sp)
2108fc18:	0039883a 	mov	fp,zero
2108fc1c:	0005883a 	mov	r2,zero
2108fc20:	5cc00017 	ldw	r19,0(r11)
2108fc24:	5ac00104 	addi	r11,r11,4
2108fc28:	dac02d15 	stw	r11,180(sp)
2108fc2c:	9807883a 	mov	r3,r19
2108fc30:	003d4806 	br	2108f154 <__flash_rwdata_start+0xfffecf0c>
2108fc34:	db002d17 	ldw	r12,180(sp)
2108fc38:	14c00017 	ldw	r19,0(r2)
2108fc3c:	0039883a 	mov	fp,zero
2108fc40:	63000104 	addi	r12,r12,4
2108fc44:	db002d15 	stw	r12,180(sp)
2108fc48:	00800044 	movi	r2,1
2108fc4c:	9807883a 	mov	r3,r19
2108fc50:	003d4006 	br	2108f154 <__flash_rwdata_start+0xfffecf0c>
2108fc54:	d9002f17 	ldw	r4,188(sp)
2108fc58:	b80b883a 	mov	r5,r23
2108fc5c:	b00d883a 	mov	r6,r22
2108fc60:	10974140 	call	21097414 <__ssprint_r>
2108fc64:	103bb61e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
2108fc68:	d8c02017 	ldw	r3,128(sp)
2108fc6c:	da000404 	addi	r8,sp,16
2108fc70:	db003117 	ldw	r12,196(sp)
2108fc74:	dac03417 	ldw	r11,208(sp)
2108fc78:	d8802617 	ldw	r2,152(sp)
2108fc7c:	62e5883a 	add	r18,r12,r11
2108fc80:	db003317 	ldw	r12,204(sp)
2108fc84:	13000216 	blt	r2,r12,2108fc90 <___svfprintf_internal_r+0x1470>
2108fc88:	8900004c 	andi	r4,r17,1
2108fc8c:	20000c26 	beq	r4,zero,2108fcc0 <___svfprintf_internal_r+0x14a0>
2108fc90:	dac03917 	ldw	r11,228(sp)
2108fc94:	d9001f17 	ldw	r4,124(sp)
2108fc98:	db003517 	ldw	r12,212(sp)
2108fc9c:	1ac7883a 	add	r3,r3,r11
2108fca0:	21000044 	addi	r4,r4,1
2108fca4:	43000015 	stw	r12,0(r8)
2108fca8:	42c00115 	stw	r11,4(r8)
2108fcac:	d8c02015 	stw	r3,128(sp)
2108fcb0:	d9001f15 	stw	r4,124(sp)
2108fcb4:	014001c4 	movi	r5,7
2108fcb8:	2901b716 	blt	r5,r4,21090398 <___svfprintf_internal_r+0x1b78>
2108fcbc:	42000204 	addi	r8,r8,8
2108fcc0:	dac03317 	ldw	r11,204(sp)
2108fcc4:	8489c83a 	sub	r4,r16,r18
2108fcc8:	5885c83a 	sub	r2,r11,r2
2108fccc:	1021883a 	mov	r16,r2
2108fcd0:	2080010e 	bge	r4,r2,2108fcd8 <___svfprintf_internal_r+0x14b8>
2108fcd4:	2021883a 	mov	r16,r4
2108fcd8:	04000a0e 	bge	zero,r16,2108fd04 <___svfprintf_internal_r+0x14e4>
2108fcdc:	d9001f17 	ldw	r4,124(sp)
2108fce0:	1c07883a 	add	r3,r3,r16
2108fce4:	44800015 	stw	r18,0(r8)
2108fce8:	21000044 	addi	r4,r4,1
2108fcec:	44000115 	stw	r16,4(r8)
2108fcf0:	d8c02015 	stw	r3,128(sp)
2108fcf4:	d9001f15 	stw	r4,124(sp)
2108fcf8:	014001c4 	movi	r5,7
2108fcfc:	2901bf16 	blt	r5,r4,210903fc <___svfprintf_internal_r+0x1bdc>
2108fd00:	42000204 	addi	r8,r8,8
2108fd04:	8001bb16 	blt	r16,zero,210903f4 <___svfprintf_internal_r+0x1bd4>
2108fd08:	1421c83a 	sub	r16,r2,r16
2108fd0c:	043c990e 	bge	zero,r16,2108ef74 <__flash_rwdata_start+0xfffecd2c>
2108fd10:	04800404 	movi	r18,16
2108fd14:	d8801f17 	ldw	r2,124(sp)
2108fd18:	943f0b0e 	bge	r18,r16,2108f948 <__flash_rwdata_start+0xfffed700>
2108fd1c:	01400034 	movhi	r5,0
2108fd20:	294ed984 	addi	r5,r5,15206
2108fd24:	d9402b15 	stw	r5,172(sp)
2108fd28:	054001c4 	movi	r21,7
2108fd2c:	dcc02f17 	ldw	r19,188(sp)
2108fd30:	00000306 	br	2108fd40 <___svfprintf_internal_r+0x1520>
2108fd34:	42000204 	addi	r8,r8,8
2108fd38:	843ffc04 	addi	r16,r16,-16
2108fd3c:	943f050e 	bge	r18,r16,2108f954 <__flash_rwdata_start+0xfffed70c>
2108fd40:	18c00404 	addi	r3,r3,16
2108fd44:	10800044 	addi	r2,r2,1
2108fd48:	45000015 	stw	r20,0(r8)
2108fd4c:	44800115 	stw	r18,4(r8)
2108fd50:	d8c02015 	stw	r3,128(sp)
2108fd54:	d8801f15 	stw	r2,124(sp)
2108fd58:	a8bff60e 	bge	r21,r2,2108fd34 <__flash_rwdata_start+0xfffedaec>
2108fd5c:	9809883a 	mov	r4,r19
2108fd60:	b80b883a 	mov	r5,r23
2108fd64:	b00d883a 	mov	r6,r22
2108fd68:	10974140 	call	21097414 <__ssprint_r>
2108fd6c:	103b741e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
2108fd70:	d8c02017 	ldw	r3,128(sp)
2108fd74:	d8801f17 	ldw	r2,124(sp)
2108fd78:	da000404 	addi	r8,sp,16
2108fd7c:	003fee06 	br	2108fd38 <__flash_rwdata_start+0xfffedaf0>
2108fd80:	8888703a 	and	r4,r17,r2
2108fd84:	203eb31e 	bne	r4,zero,2108f854 <__flash_rwdata_start+0xfffed60c>
2108fd88:	dc001f17 	ldw	r16,124(sp)
2108fd8c:	db003117 	ldw	r12,196(sp)
2108fd90:	40800115 	stw	r2,4(r8)
2108fd94:	84000044 	addi	r16,r16,1
2108fd98:	43000015 	stw	r12,0(r8)
2108fd9c:	d8c02015 	stw	r3,128(sp)
2108fda0:	dc001f15 	stw	r16,124(sp)
2108fda4:	008001c4 	movi	r2,7
2108fda8:	143f8716 	blt	r2,r16,2108fbc8 <__flash_rwdata_start+0xfffed980>
2108fdac:	44800204 	addi	r18,r8,8
2108fdb0:	003ed306 	br	2108f900 <__flash_rwdata_start+0xfffed6b8>
2108fdb4:	d9002f17 	ldw	r4,188(sp)
2108fdb8:	b80b883a 	mov	r5,r23
2108fdbc:	b00d883a 	mov	r6,r22
2108fdc0:	10974140 	call	21097414 <__ssprint_r>
2108fdc4:	103b5e1e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
2108fdc8:	d8c02017 	ldw	r3,128(sp)
2108fdcc:	dc001f17 	ldw	r16,124(sp)
2108fdd0:	da000404 	addi	r8,sp,16
2108fdd4:	003eaa06 	br	2108f880 <__flash_rwdata_start+0xfffed638>
2108fdd8:	d9002f17 	ldw	r4,188(sp)
2108fddc:	b80b883a 	mov	r5,r23
2108fde0:	b00d883a 	mov	r6,r22
2108fde4:	10974140 	call	21097414 <__ssprint_r>
2108fde8:	103b551e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
2108fdec:	d8c02017 	ldw	r3,128(sp)
2108fdf0:	dc001f17 	ldw	r16,124(sp)
2108fdf4:	dc800404 	addi	r18,sp,16
2108fdf8:	003eac06 	br	2108f8ac <__flash_rwdata_start+0xfffed664>
2108fdfc:	d9002f17 	ldw	r4,188(sp)
2108fe00:	b80b883a 	mov	r5,r23
2108fe04:	b00d883a 	mov	r6,r22
2108fe08:	10974140 	call	21097414 <__ssprint_r>
2108fe0c:	103b4c1e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
2108fe10:	d8c02017 	ldw	r3,128(sp)
2108fe14:	da000404 	addi	r8,sp,16
2108fe18:	003c1506 	br	2108ee70 <__flash_rwdata_start+0xfffecc28>
2108fe1c:	da004015 	stw	r8,256(sp)
2108fe20:	da403f15 	stw	r9,252(sp)
2108fe24:	10971000 	call	21097100 <__fpclassifyd>
2108fe28:	da004017 	ldw	r8,256(sp)
2108fe2c:	da403f17 	ldw	r9,252(sp)
2108fe30:	1000951e 	bne	r2,zero,21090088 <___svfprintf_internal_r+0x1868>
2108fe34:	008011c4 	movi	r2,71
2108fe38:	1400fb16 	blt	r2,r16,21090228 <___svfprintf_internal_r+0x1a08>
2108fe3c:	03000034 	movhi	r12,0
2108fe40:	630ecb04 	addi	r12,r12,15148
2108fe44:	db003115 	stw	r12,196(sp)
2108fe48:	00c000c4 	movi	r3,3
2108fe4c:	00bfdfc4 	movi	r2,-129
2108fe50:	d8c02a15 	stw	r3,168(sp)
2108fe54:	88a2703a 	and	r17,r17,r2
2108fe58:	dd402783 	ldbu	r21,158(sp)
2108fe5c:	dcc02d15 	stw	r19,180(sp)
2108fe60:	1825883a 	mov	r18,r3
2108fe64:	d8003215 	stw	zero,200(sp)
2108fe68:	d8003415 	stw	zero,208(sp)
2108fe6c:	003b9806 	br	2108ecd0 <__flash_rwdata_start+0xfffeca88>
2108fe70:	1c000007 	ldb	r16,0(r3)
2108fe74:	1805883a 	mov	r2,r3
2108fe78:	003abf06 	br	2108e978 <__flash_rwdata_start+0xfffec730>
2108fe7c:	00800084 	movi	r2,2
2108fe80:	003cb406 	br	2108f154 <__flash_rwdata_start+0xfffecf0c>
2108fe84:	88c0100c 	andi	r3,r17,64
2108fe88:	1800f626 	beq	r3,zero,21090264 <___svfprintf_internal_r+0x1a44>
2108fe8c:	dac02d17 	ldw	r11,180(sp)
2108fe90:	14c0000b 	ldhu	r19,0(r2)
2108fe94:	0039883a 	mov	fp,zero
2108fe98:	5ac00104 	addi	r11,r11,4
2108fe9c:	dac02d15 	stw	r11,180(sp)
2108fea0:	003cbd06 	br	2108f198 <__flash_rwdata_start+0xfffecf50>
2108fea4:	8880040c 	andi	r2,r17,16
2108fea8:	1000091e 	bne	r2,zero,2108fed0 <___svfprintf_internal_r+0x16b0>
2108feac:	8c40100c 	andi	r17,r17,64
2108feb0:	88000726 	beq	r17,zero,2108fed0 <___svfprintf_internal_r+0x16b0>
2108feb4:	db002d17 	ldw	r12,180(sp)
2108feb8:	dac03017 	ldw	r11,192(sp)
2108febc:	60800017 	ldw	r2,0(r12)
2108fec0:	63000104 	addi	r12,r12,4
2108fec4:	db002d15 	stw	r12,180(sp)
2108fec8:	12c0000d 	sth	r11,0(r2)
2108fecc:	003a8006 	br	2108e8d0 <__flash_rwdata_start+0xfffec688>
2108fed0:	db002d17 	ldw	r12,180(sp)
2108fed4:	dac03017 	ldw	r11,192(sp)
2108fed8:	60800017 	ldw	r2,0(r12)
2108fedc:	63000104 	addi	r12,r12,4
2108fee0:	db002d15 	stw	r12,180(sp)
2108fee4:	12c00015 	stw	r11,0(r2)
2108fee8:	003a7906 	br	2108e8d0 <__flash_rwdata_start+0xfffec688>
2108feec:	01000034 	movhi	r4,0
2108fef0:	210ed984 	addi	r4,r4,15206
2108fef4:	d9002b15 	stw	r4,172(sp)
2108fef8:	dac02b17 	ldw	r11,172(sp)
2108fefc:	1c87883a 	add	r3,r3,r18
2108ff00:	10800044 	addi	r2,r2,1
2108ff04:	42c00015 	stw	r11,0(r8)
2108ff08:	44800115 	stw	r18,4(r8)
2108ff0c:	d8c02015 	stw	r3,128(sp)
2108ff10:	d8801f15 	stw	r2,124(sp)
2108ff14:	010001c4 	movi	r4,7
2108ff18:	20bf4e16 	blt	r4,r2,2108fc54 <__flash_rwdata_start+0xfffeda0c>
2108ff1c:	42000204 	addi	r8,r8,8
2108ff20:	003f5306 	br	2108fc70 <__flash_rwdata_start+0xfffeda28>
2108ff24:	01000034 	movhi	r4,0
2108ff28:	210ed984 	addi	r4,r4,15206
2108ff2c:	d9002b15 	stw	r4,172(sp)
2108ff30:	003bf906 	br	2108ef18 <__flash_rwdata_start+0xfffeccd0>
2108ff34:	d9002f17 	ldw	r4,188(sp)
2108ff38:	b80b883a 	mov	r5,r23
2108ff3c:	b00d883a 	mov	r6,r22
2108ff40:	10974140 	call	21097414 <__ssprint_r>
2108ff44:	103afe1e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
2108ff48:	d8c02017 	ldw	r3,128(sp)
2108ff4c:	da000404 	addi	r8,sp,16
2108ff50:	003dc606 	br	2108f66c <__flash_rwdata_start+0xfffed424>
2108ff54:	d8801f17 	ldw	r2,124(sp)
2108ff58:	03000034 	movhi	r12,0
2108ff5c:	01000044 	movi	r4,1
2108ff60:	18c00044 	addi	r3,r3,1
2108ff64:	10800044 	addi	r2,r2,1
2108ff68:	630ed904 	addi	r12,r12,15204
2108ff6c:	41000115 	stw	r4,4(r8)
2108ff70:	43000015 	stw	r12,0(r8)
2108ff74:	d8c02015 	stw	r3,128(sp)
2108ff78:	d8801f15 	stw	r2,124(sp)
2108ff7c:	010001c4 	movi	r4,7
2108ff80:	2080ad16 	blt	r4,r2,21090238 <___svfprintf_internal_r+0x1a18>
2108ff84:	42000204 	addi	r8,r8,8
2108ff88:	8000041e 	bne	r16,zero,2108ff9c <___svfprintf_internal_r+0x177c>
2108ff8c:	dac03317 	ldw	r11,204(sp)
2108ff90:	5800021e 	bne	r11,zero,2108ff9c <___svfprintf_internal_r+0x177c>
2108ff94:	8880004c 	andi	r2,r17,1
2108ff98:	103bf626 	beq	r2,zero,2108ef74 <__flash_rwdata_start+0xfffecd2c>
2108ff9c:	db003917 	ldw	r12,228(sp)
2108ffa0:	d8801f17 	ldw	r2,124(sp)
2108ffa4:	dac03517 	ldw	r11,212(sp)
2108ffa8:	1b07883a 	add	r3,r3,r12
2108ffac:	10800044 	addi	r2,r2,1
2108ffb0:	42c00015 	stw	r11,0(r8)
2108ffb4:	43000115 	stw	r12,4(r8)
2108ffb8:	d8c02015 	stw	r3,128(sp)
2108ffbc:	d8801f15 	stw	r2,124(sp)
2108ffc0:	010001c4 	movi	r4,7
2108ffc4:	20818616 	blt	r4,r2,210905e0 <___svfprintf_internal_r+0x1dc0>
2108ffc8:	42000204 	addi	r8,r8,8
2108ffcc:	0421c83a 	sub	r16,zero,r16
2108ffd0:	0400bc0e 	bge	zero,r16,210902c4 <___svfprintf_internal_r+0x1aa4>
2108ffd4:	04800404 	movi	r18,16
2108ffd8:	9400f80e 	bge	r18,r16,210903bc <___svfprintf_internal_r+0x1b9c>
2108ffdc:	01000034 	movhi	r4,0
2108ffe0:	210ed984 	addi	r4,r4,15206
2108ffe4:	d9002b15 	stw	r4,172(sp)
2108ffe8:	054001c4 	movi	r21,7
2108ffec:	dcc02f17 	ldw	r19,188(sp)
2108fff0:	00000306 	br	21090000 <___svfprintf_internal_r+0x17e0>
2108fff4:	42000204 	addi	r8,r8,8
2108fff8:	843ffc04 	addi	r16,r16,-16
2108fffc:	9400f20e 	bge	r18,r16,210903c8 <___svfprintf_internal_r+0x1ba8>
21090000:	18c00404 	addi	r3,r3,16
21090004:	10800044 	addi	r2,r2,1
21090008:	45000015 	stw	r20,0(r8)
2109000c:	44800115 	stw	r18,4(r8)
21090010:	d8c02015 	stw	r3,128(sp)
21090014:	d8801f15 	stw	r2,124(sp)
21090018:	a8bff60e 	bge	r21,r2,2108fff4 <__flash_rwdata_start+0xfffeddac>
2109001c:	9809883a 	mov	r4,r19
21090020:	b80b883a 	mov	r5,r23
21090024:	b00d883a 	mov	r6,r22
21090028:	10974140 	call	21097414 <__ssprint_r>
2109002c:	103ac41e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
21090030:	d8c02017 	ldw	r3,128(sp)
21090034:	d8801f17 	ldw	r2,124(sp)
21090038:	da000404 	addi	r8,sp,16
2109003c:	003fee06 	br	2108fff8 <__flash_rwdata_start+0xfffeddb0>
21090040:	db002e17 	ldw	r12,184(sp)
21090044:	1805883a 	mov	r2,r3
21090048:	dac02d15 	stw	r11,180(sp)
2109004c:	0319c83a 	sub	r12,zero,r12
21090050:	db002e15 	stw	r12,184(sp)
21090054:	003acf06 	br	2108eb94 <__flash_rwdata_start+0xfffec94c>
21090058:	18800044 	addi	r2,r3,1
2109005c:	8c400814 	ori	r17,r17,32
21090060:	1c000047 	ldb	r16,1(r3)
21090064:	003a4406 	br	2108e978 <__flash_rwdata_start+0xfffec730>
21090068:	d9002f17 	ldw	r4,188(sp)
2109006c:	b80b883a 	mov	r5,r23
21090070:	b00d883a 	mov	r6,r22
21090074:	10974140 	call	21097414 <__ssprint_r>
21090078:	103ab11e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
2109007c:	d8c02017 	ldw	r3,128(sp)
21090080:	da000404 	addi	r8,sp,16
21090084:	003d8a06 	br	2108f6b0 <__flash_rwdata_start+0xfffed468>
21090088:	057ff7c4 	movi	r21,-33
2109008c:	00bfffc4 	movi	r2,-1
21090090:	856a703a 	and	r21,r16,r21
21090094:	48807126 	beq	r9,r2,2109025c <___svfprintf_internal_r+0x1a3c>
21090098:	008011c4 	movi	r2,71
2109009c:	a8814d26 	beq	r21,r2,210905d4 <___svfprintf_internal_r+0x1db4>
210900a0:	db003817 	ldw	r12,224(sp)
210900a4:	8ac04014 	ori	r11,r17,256
210900a8:	dac02d15 	stw	r11,180(sp)
210900ac:	60015616 	blt	r12,zero,21090608 <___svfprintf_internal_r+0x1de8>
210900b0:	dc803817 	ldw	r18,224(sp)
210900b4:	d8002a05 	stb	zero,168(sp)
210900b8:	00801984 	movi	r2,102
210900bc:	80808c26 	beq	r16,r2,210902f0 <___svfprintf_internal_r+0x1ad0>
210900c0:	00801184 	movi	r2,70
210900c4:	80808a26 	beq	r16,r2,210902f0 <___svfprintf_internal_r+0x1ad0>
210900c8:	00801144 	movi	r2,69
210900cc:	a8815226 	beq	r21,r2,21090618 <___svfprintf_internal_r+0x1df8>
210900d0:	4839883a 	mov	fp,r9
210900d4:	d8802604 	addi	r2,sp,152
210900d8:	d8800115 	stw	r2,4(sp)
210900dc:	d9002f17 	ldw	r4,188(sp)
210900e0:	d8802504 	addi	r2,sp,148
210900e4:	d9403717 	ldw	r5,220(sp)
210900e8:	d8800215 	stw	r2,8(sp)
210900ec:	d8802104 	addi	r2,sp,132
210900f0:	df000015 	stw	fp,0(sp)
210900f4:	d8800315 	stw	r2,12(sp)
210900f8:	900d883a 	mov	r6,r18
210900fc:	01c00084 	movi	r7,2
21090100:	da004015 	stw	r8,256(sp)
21090104:	da403f15 	stw	r9,252(sp)
21090108:	1092df80 	call	21092df8 <_dtoa_r>
2109010c:	d8803115 	stw	r2,196(sp)
21090110:	008019c4 	movi	r2,103
21090114:	da004017 	ldw	r8,256(sp)
21090118:	da403f17 	ldw	r9,252(sp)
2109011c:	80800226 	beq	r16,r2,21090128 <___svfprintf_internal_r+0x1908>
21090120:	008011c4 	movi	r2,71
21090124:	8080841e 	bne	r16,r2,21090338 <___svfprintf_internal_r+0x1b18>
21090128:	8880004c 	andi	r2,r17,1
2109012c:	10014f26 	beq	r2,zero,2109066c <___svfprintf_internal_r+0x1e4c>
21090130:	db003117 	ldw	r12,196(sp)
21090134:	6715883a 	add	r10,r12,fp
21090138:	d9003717 	ldw	r4,220(sp)
2109013c:	900b883a 	mov	r5,r18
21090140:	000d883a 	mov	r6,zero
21090144:	000f883a 	mov	r7,zero
21090148:	da004015 	stw	r8,256(sp)
2109014c:	da403f15 	stw	r9,252(sp)
21090150:	da803e15 	stw	r10,248(sp)
21090154:	109af240 	call	2109af24 <__eqdf2>
21090158:	da004017 	ldw	r8,256(sp)
2109015c:	da403f17 	ldw	r9,252(sp)
21090160:	da803e17 	ldw	r10,248(sp)
21090164:	1000d926 	beq	r2,zero,210904cc <___svfprintf_internal_r+0x1cac>
21090168:	d8802117 	ldw	r2,132(sp)
2109016c:	1280062e 	bgeu	r2,r10,21090188 <___svfprintf_internal_r+0x1968>
21090170:	01000c04 	movi	r4,48
21090174:	10c00044 	addi	r3,r2,1
21090178:	d8c02115 	stw	r3,132(sp)
2109017c:	11000005 	stb	r4,0(r2)
21090180:	d8802117 	ldw	r2,132(sp)
21090184:	12bffb36 	bltu	r2,r10,21090174 <__flash_rwdata_start+0xfffedf2c>
21090188:	db003117 	ldw	r12,196(sp)
2109018c:	1305c83a 	sub	r2,r2,r12
21090190:	d8803315 	stw	r2,204(sp)
21090194:	008011c4 	movi	r2,71
21090198:	a880b626 	beq	r21,r2,21090474 <___svfprintf_internal_r+0x1c54>
2109019c:	00801944 	movi	r2,101
210901a0:	14017c0e 	bge	r2,r16,21090794 <___svfprintf_internal_r+0x1f74>
210901a4:	00801984 	movi	r2,102
210901a8:	80812626 	beq	r16,r2,21090644 <___svfprintf_internal_r+0x1e24>
210901ac:	db002617 	ldw	r12,152(sp)
210901b0:	db003415 	stw	r12,208(sp)
210901b4:	db003417 	ldw	r12,208(sp)
210901b8:	dac03317 	ldw	r11,204(sp)
210901bc:	62c11816 	blt	r12,r11,21090620 <___svfprintf_internal_r+0x1e00>
210901c0:	8c40004c 	andi	r17,r17,1
210901c4:	88013b1e 	bne	r17,zero,210906b4 <___svfprintf_internal_r+0x1e94>
210901c8:	6005883a 	mov	r2,r12
210901cc:	60012516 	blt	r12,zero,21090664 <___svfprintf_internal_r+0x1e44>
210901d0:	dc803417 	ldw	r18,208(sp)
210901d4:	df002a07 	ldb	fp,168(sp)
210901d8:	e000b01e 	bne	fp,zero,2109049c <___svfprintf_internal_r+0x1c7c>
210901dc:	dc402d17 	ldw	r17,180(sp)
210901e0:	dd402783 	ldbu	r21,158(sp)
210901e4:	d8802a15 	stw	r2,168(sp)
210901e8:	dcc02d15 	stw	r19,180(sp)
210901ec:	d8003215 	stw	zero,200(sp)
210901f0:	003ab706 	br	2108ecd0 <__flash_rwdata_start+0xfffeca88>
210901f4:	00800034 	movhi	r2,0
210901f8:	108ec904 	addi	r2,r2,15140
210901fc:	d8803115 	stw	r2,196(sp)
21090200:	003bbb06 	br	2108f0f0 <__flash_rwdata_start+0xfffecea8>
21090204:	d9002f17 	ldw	r4,188(sp)
21090208:	04001004 	movi	r16,64
2109020c:	800b883a 	mov	r5,r16
21090210:	108d9100 	call	2108d910 <_malloc_r>
21090214:	b8800015 	stw	r2,0(r23)
21090218:	b8800415 	stw	r2,16(r23)
2109021c:	10015f26 	beq	r2,zero,2109079c <___svfprintf_internal_r+0x1f7c>
21090220:	bc000515 	stw	r16,20(r23)
21090224:	00399806 	br	2108e888 <__flash_rwdata_start+0xfffec640>
21090228:	00800034 	movhi	r2,0
2109022c:	108ecc04 	addi	r2,r2,15152
21090230:	d8803115 	stw	r2,196(sp)
21090234:	003f0406 	br	2108fe48 <__flash_rwdata_start+0xfffedc00>
21090238:	d9002f17 	ldw	r4,188(sp)
2109023c:	b80b883a 	mov	r5,r23
21090240:	b00d883a 	mov	r6,r22
21090244:	10974140 	call	21097414 <__ssprint_r>
21090248:	103a3d1e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
2109024c:	dc002617 	ldw	r16,152(sp)
21090250:	d8c02017 	ldw	r3,128(sp)
21090254:	da000404 	addi	r8,sp,16
21090258:	003f4b06 	br	2108ff88 <__flash_rwdata_start+0xfffedd40>
2109025c:	02400184 	movi	r9,6
21090260:	003f8f06 	br	210900a0 <__flash_rwdata_start+0xfffede58>
21090264:	db002d17 	ldw	r12,180(sp)
21090268:	14c00017 	ldw	r19,0(r2)
2109026c:	0039883a 	mov	fp,zero
21090270:	63000104 	addi	r12,r12,4
21090274:	db002d15 	stw	r12,180(sp)
21090278:	003bc706 	br	2108f198 <__flash_rwdata_start+0xfffecf50>
2109027c:	d8c03117 	ldw	r3,196(sp)
21090280:	b0e5c83a 	sub	r18,r22,r3
21090284:	003a8d06 	br	2108ecbc <__flash_rwdata_start+0xfffeca74>
21090288:	da004015 	stw	r8,256(sp)
2109028c:	108e7200 	call	2108e720 <strlen>
21090290:	1025883a 	mov	r18,r2
21090294:	da004017 	ldw	r8,256(sp)
21090298:	903bf20e 	bge	r18,zero,2108f264 <__flash_rwdata_start+0xfffed01c>
2109029c:	0005883a 	mov	r2,zero
210902a0:	003bf006 	br	2108f264 <__flash_rwdata_start+0xfffed01c>
210902a4:	d9002f17 	ldw	r4,188(sp)
210902a8:	b80b883a 	mov	r5,r23
210902ac:	b00d883a 	mov	r6,r22
210902b0:	10974140 	call	21097414 <__ssprint_r>
210902b4:	103a221e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
210902b8:	d8c02017 	ldw	r3,128(sp)
210902bc:	d8801f17 	ldw	r2,124(sp)
210902c0:	da000404 	addi	r8,sp,16
210902c4:	db003317 	ldw	r12,204(sp)
210902c8:	dac03117 	ldw	r11,196(sp)
210902cc:	10800044 	addi	r2,r2,1
210902d0:	1b07883a 	add	r3,r3,r12
210902d4:	42c00015 	stw	r11,0(r8)
210902d8:	43000115 	stw	r12,4(r8)
210902dc:	d8c02015 	stw	r3,128(sp)
210902e0:	d8801f15 	stw	r2,124(sp)
210902e4:	010001c4 	movi	r4,7
210902e8:	20bb210e 	bge	r4,r2,2108ef70 <__flash_rwdata_start+0xfffecd28>
210902ec:	003da206 	br	2108f978 <__flash_rwdata_start+0xfffed730>
210902f0:	d8802604 	addi	r2,sp,152
210902f4:	d8800115 	stw	r2,4(sp)
210902f8:	d9002f17 	ldw	r4,188(sp)
210902fc:	d8802504 	addi	r2,sp,148
21090300:	d9403717 	ldw	r5,220(sp)
21090304:	d8800215 	stw	r2,8(sp)
21090308:	d8802104 	addi	r2,sp,132
2109030c:	da400015 	stw	r9,0(sp)
21090310:	d8800315 	stw	r2,12(sp)
21090314:	900d883a 	mov	r6,r18
21090318:	01c000c4 	movi	r7,3
2109031c:	da004015 	stw	r8,256(sp)
21090320:	da403f15 	stw	r9,252(sp)
21090324:	1092df80 	call	21092df8 <_dtoa_r>
21090328:	da403f17 	ldw	r9,252(sp)
2109032c:	da004017 	ldw	r8,256(sp)
21090330:	d8803115 	stw	r2,196(sp)
21090334:	4839883a 	mov	fp,r9
21090338:	dac03117 	ldw	r11,196(sp)
2109033c:	00801184 	movi	r2,70
21090340:	5f15883a 	add	r10,r11,fp
21090344:	a8bf7c1e 	bne	r21,r2,21090138 <__flash_rwdata_start+0xfffedef0>
21090348:	59000007 	ldb	r4,0(r11)
2109034c:	00800c04 	movi	r2,48
21090350:	2080c826 	beq	r4,r2,21090674 <___svfprintf_internal_r+0x1e54>
21090354:	d8c02617 	ldw	r3,152(sp)
21090358:	50d5883a 	add	r10,r10,r3
2109035c:	003f7606 	br	21090138 <__flash_rwdata_start+0xfffedef0>
21090360:	01000034 	movhi	r4,0
21090364:	210edd84 	addi	r4,r4,15222
21090368:	d9003615 	stw	r4,216(sp)
2109036c:	003a9706 	br	2108edcc <__flash_rwdata_start+0xfffecb84>
21090370:	0025883a 	mov	r18,zero
21090374:	003dc306 	br	2108fa84 <__flash_rwdata_start+0xfffed83c>
21090378:	d9002f17 	ldw	r4,188(sp)
2109037c:	b80b883a 	mov	r5,r23
21090380:	b00d883a 	mov	r6,r22
21090384:	10974140 	call	21097414 <__ssprint_r>
21090388:	1039ed1e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
2109038c:	d8c02017 	ldw	r3,128(sp)
21090390:	da000404 	addi	r8,sp,16
21090394:	003dba06 	br	2108fa80 <__flash_rwdata_start+0xfffed838>
21090398:	d9002f17 	ldw	r4,188(sp)
2109039c:	b80b883a 	mov	r5,r23
210903a0:	b00d883a 	mov	r6,r22
210903a4:	10974140 	call	21097414 <__ssprint_r>
210903a8:	1039e51e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
210903ac:	d8802617 	ldw	r2,152(sp)
210903b0:	d8c02017 	ldw	r3,128(sp)
210903b4:	da000404 	addi	r8,sp,16
210903b8:	003e4106 	br	2108fcc0 <__flash_rwdata_start+0xfffeda78>
210903bc:	03000034 	movhi	r12,0
210903c0:	630ed984 	addi	r12,r12,15206
210903c4:	db002b15 	stw	r12,172(sp)
210903c8:	dac02b17 	ldw	r11,172(sp)
210903cc:	1c07883a 	add	r3,r3,r16
210903d0:	10800044 	addi	r2,r2,1
210903d4:	42c00015 	stw	r11,0(r8)
210903d8:	44000115 	stw	r16,4(r8)
210903dc:	d8c02015 	stw	r3,128(sp)
210903e0:	d8801f15 	stw	r2,124(sp)
210903e4:	010001c4 	movi	r4,7
210903e8:	20bfae16 	blt	r4,r2,210902a4 <__flash_rwdata_start+0xfffee05c>
210903ec:	42000204 	addi	r8,r8,8
210903f0:	003fb406 	br	210902c4 <__flash_rwdata_start+0xfffee07c>
210903f4:	0021883a 	mov	r16,zero
210903f8:	003e4306 	br	2108fd08 <__flash_rwdata_start+0xfffedac0>
210903fc:	d9002f17 	ldw	r4,188(sp)
21090400:	b80b883a 	mov	r5,r23
21090404:	b00d883a 	mov	r6,r22
21090408:	10974140 	call	21097414 <__ssprint_r>
2109040c:	1039cc1e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
21090410:	d8802617 	ldw	r2,152(sp)
21090414:	db003317 	ldw	r12,204(sp)
21090418:	d8c02017 	ldw	r3,128(sp)
2109041c:	da000404 	addi	r8,sp,16
21090420:	6085c83a 	sub	r2,r12,r2
21090424:	003e3706 	br	2108fd04 <__flash_rwdata_start+0xfffedabc>
21090428:	00800184 	movi	r2,6
2109042c:	1240012e 	bgeu	r2,r9,21090434 <___svfprintf_internal_r+0x1c14>
21090430:	1013883a 	mov	r9,r2
21090434:	4825883a 	mov	r18,r9
21090438:	4805883a 	mov	r2,r9
2109043c:	4800a216 	blt	r9,zero,210906c8 <___svfprintf_internal_r+0x1ea8>
21090440:	d8802a15 	stw	r2,168(sp)
21090444:	00800034 	movhi	r2,0
21090448:	108ed704 	addi	r2,r2,15196
2109044c:	d8803115 	stw	r2,196(sp)
21090450:	dcc02d15 	stw	r19,180(sp)
21090454:	d8003215 	stw	zero,200(sp)
21090458:	d8003415 	stw	zero,208(sp)
2109045c:	0005883a 	mov	r2,zero
21090460:	003a2206 	br	2108ecec <__flash_rwdata_start+0xfffecaa4>
21090464:	03000034 	movhi	r12,0
21090468:	630edd84 	addi	r12,r12,15222
2109046c:	db003615 	stw	r12,216(sp)
21090470:	003ae506 	br	2108f008 <__flash_rwdata_start+0xfffecdc0>
21090474:	d8c02617 	ldw	r3,152(sp)
21090478:	00bfff44 	movi	r2,-3
2109047c:	18801516 	blt	r3,r2,210904d4 <___svfprintf_internal_r+0x1cb4>
21090480:	48c01416 	blt	r9,r3,210904d4 <___svfprintf_internal_r+0x1cb4>
21090484:	d8c03415 	stw	r3,208(sp)
21090488:	040019c4 	movi	r16,103
2109048c:	003f4906 	br	210901b4 <__flash_rwdata_start+0xfffedf6c>
21090490:	05400b44 	movi	r21,45
21090494:	dd402785 	stb	r21,158(sp)
21090498:	003b1006 	br	2108f0dc <__flash_rwdata_start+0xfffece94>
2109049c:	00c00b44 	movi	r3,45
210904a0:	d8802a15 	stw	r2,168(sp)
210904a4:	dc402d17 	ldw	r17,180(sp)
210904a8:	d8c02785 	stb	r3,158(sp)
210904ac:	dcc02d15 	stw	r19,180(sp)
210904b0:	d8003215 	stw	zero,200(sp)
210904b4:	00800b44 	movi	r2,45
210904b8:	003a0906 	br	2108ece0 <__flash_rwdata_start+0xfffeca98>
210904bc:	01000034 	movhi	r4,0
210904c0:	210ed984 	addi	r4,r4,15206
210904c4:	d9002b15 	stw	r4,172(sp)
210904c8:	003cc306 	br	2108f7d8 <__flash_rwdata_start+0xfffed590>
210904cc:	5005883a 	mov	r2,r10
210904d0:	003f2d06 	br	21090188 <__flash_rwdata_start+0xfffedf40>
210904d4:	843fff84 	addi	r16,r16,-2
210904d8:	1f3fffc4 	addi	fp,r3,-1
210904dc:	df002615 	stw	fp,152(sp)
210904e0:	dc0022c5 	stb	r16,139(sp)
210904e4:	e000a016 	blt	fp,zero,21090768 <___svfprintf_internal_r+0x1f48>
210904e8:	00800ac4 	movi	r2,43
210904ec:	d8802305 	stb	r2,140(sp)
210904f0:	00800244 	movi	r2,9
210904f4:	1700800e 	bge	r2,fp,210906f8 <___svfprintf_internal_r+0x1ed8>
210904f8:	dd4022c4 	addi	r21,sp,139
210904fc:	dc002b15 	stw	r16,172(sp)
21090500:	4025883a 	mov	r18,r8
21090504:	a821883a 	mov	r16,r21
21090508:	e009883a 	mov	r4,fp
2109050c:	01400284 	movi	r5,10
21090510:	108d51c0 	call	2108d51c <__modsi3>
21090514:	10800c04 	addi	r2,r2,48
21090518:	843fffc4 	addi	r16,r16,-1
2109051c:	e009883a 	mov	r4,fp
21090520:	01400284 	movi	r5,10
21090524:	80800005 	stb	r2,0(r16)
21090528:	108d4c80 	call	2108d4c8 <__divsi3>
2109052c:	1039883a 	mov	fp,r2
21090530:	00800244 	movi	r2,9
21090534:	173ff416 	blt	r2,fp,21090508 <__flash_rwdata_start+0xfffee2c0>
21090538:	9011883a 	mov	r8,r18
2109053c:	e0800c04 	addi	r2,fp,48
21090540:	8025883a 	mov	r18,r16
21090544:	913fffc4 	addi	r4,r18,-1
21090548:	90bfffc5 	stb	r2,-1(r18)
2109054c:	dc002b17 	ldw	r16,172(sp)
21090550:	25408e2e 	bgeu	r4,r21,2109078c <___svfprintf_internal_r+0x1f6c>
21090554:	d9402384 	addi	r5,sp,142
21090558:	2c8bc83a 	sub	r5,r5,r18
2109055c:	d8c02344 	addi	r3,sp,141
21090560:	a94b883a 	add	r5,r21,r5
21090564:	00000106 	br	2109056c <___svfprintf_internal_r+0x1d4c>
21090568:	20800003 	ldbu	r2,0(r4)
2109056c:	18800005 	stb	r2,0(r3)
21090570:	18c00044 	addi	r3,r3,1
21090574:	21000044 	addi	r4,r4,1
21090578:	197ffb1e 	bne	r3,r5,21090568 <__flash_rwdata_start+0xfffee320>
2109057c:	d8802304 	addi	r2,sp,140
21090580:	1485c83a 	sub	r2,r2,r18
21090584:	d8c02344 	addi	r3,sp,141
21090588:	1885883a 	add	r2,r3,r2
2109058c:	dac03317 	ldw	r11,204(sp)
21090590:	156bc83a 	sub	r21,r2,r21
21090594:	dd403a15 	stw	r21,232(sp)
21090598:	00800044 	movi	r2,1
2109059c:	5d65883a 	add	r18,r11,r21
210905a0:	12c0770e 	bge	r2,r11,21090780 <___svfprintf_internal_r+0x1f60>
210905a4:	94800044 	addi	r18,r18,1
210905a8:	9005883a 	mov	r2,r18
210905ac:	90007216 	blt	r18,zero,21090778 <___svfprintf_internal_r+0x1f58>
210905b0:	d8003415 	stw	zero,208(sp)
210905b4:	003f0706 	br	210901d4 <__flash_rwdata_start+0xfffedf8c>
210905b8:	da402a15 	stw	r9,168(sp)
210905bc:	dd402783 	ldbu	r21,158(sp)
210905c0:	4825883a 	mov	r18,r9
210905c4:	dcc02d15 	stw	r19,180(sp)
210905c8:	d8003215 	stw	zero,200(sp)
210905cc:	d8003415 	stw	zero,208(sp)
210905d0:	0039bf06 	br	2108ecd0 <__flash_rwdata_start+0xfffeca88>
210905d4:	483eb21e 	bne	r9,zero,210900a0 <__flash_rwdata_start+0xfffede58>
210905d8:	9013883a 	mov	r9,r18
210905dc:	003eb006 	br	210900a0 <__flash_rwdata_start+0xfffede58>
210905e0:	d9002f17 	ldw	r4,188(sp)
210905e4:	b80b883a 	mov	r5,r23
210905e8:	b00d883a 	mov	r6,r22
210905ec:	10974140 	call	21097414 <__ssprint_r>
210905f0:	1039531e 	bne	r2,zero,2108eb40 <__flash_rwdata_start+0xfffec8f8>
210905f4:	dc002617 	ldw	r16,152(sp)
210905f8:	d8c02017 	ldw	r3,128(sp)
210905fc:	d8801f17 	ldw	r2,124(sp)
21090600:	da000404 	addi	r8,sp,16
21090604:	003e7106 	br	2108ffcc <__flash_rwdata_start+0xfffedd84>
21090608:	00c00b44 	movi	r3,45
2109060c:	64a0003c 	xorhi	r18,r12,32768
21090610:	d8c02a05 	stb	r3,168(sp)
21090614:	003ea806 	br	210900b8 <__flash_rwdata_start+0xfffede70>
21090618:	4f000044 	addi	fp,r9,1
2109061c:	003ead06 	br	210900d4 <__flash_rwdata_start+0xfffede8c>
21090620:	d8c03417 	ldw	r3,208(sp)
21090624:	00c0410e 	bge	zero,r3,2109072c <___svfprintf_internal_r+0x1f0c>
21090628:	04800044 	movi	r18,1
2109062c:	dac03317 	ldw	r11,204(sp)
21090630:	92e5883a 	add	r18,r18,r11
21090634:	9005883a 	mov	r2,r18
21090638:	903ee60e 	bge	r18,zero,210901d4 <__flash_rwdata_start+0xfffedf8c>
2109063c:	0005883a 	mov	r2,zero
21090640:	003ee406 	br	210901d4 <__flash_rwdata_start+0xfffedf8c>
21090644:	d8c02617 	ldw	r3,152(sp)
21090648:	d8c03415 	stw	r3,208(sp)
2109064c:	00c0310e 	bge	zero,r3,21090714 <___svfprintf_internal_r+0x1ef4>
21090650:	48001f1e 	bne	r9,zero,210906d0 <___svfprintf_internal_r+0x1eb0>
21090654:	8c40004c 	andi	r17,r17,1
21090658:	88001d1e 	bne	r17,zero,210906d0 <___svfprintf_internal_r+0x1eb0>
2109065c:	1805883a 	mov	r2,r3
21090660:	183edb0e 	bge	r3,zero,210901d0 <__flash_rwdata_start+0xfffedf88>
21090664:	0005883a 	mov	r2,zero
21090668:	003ed906 	br	210901d0 <__flash_rwdata_start+0xfffedf88>
2109066c:	d8802117 	ldw	r2,132(sp)
21090670:	003ec506 	br	21090188 <__flash_rwdata_start+0xfffedf40>
21090674:	d9003717 	ldw	r4,220(sp)
21090678:	900b883a 	mov	r5,r18
2109067c:	000d883a 	mov	r6,zero
21090680:	000f883a 	mov	r7,zero
21090684:	da004015 	stw	r8,256(sp)
21090688:	da403f15 	stw	r9,252(sp)
2109068c:	da803e15 	stw	r10,248(sp)
21090690:	109af240 	call	2109af24 <__eqdf2>
21090694:	da004017 	ldw	r8,256(sp)
21090698:	da403f17 	ldw	r9,252(sp)
2109069c:	da803e17 	ldw	r10,248(sp)
210906a0:	103f2c26 	beq	r2,zero,21090354 <__flash_rwdata_start+0xfffee10c>
210906a4:	00800044 	movi	r2,1
210906a8:	1707c83a 	sub	r3,r2,fp
210906ac:	d8c02615 	stw	r3,152(sp)
210906b0:	003f2906 	br	21090358 <__flash_rwdata_start+0xfffee110>
210906b4:	db003417 	ldw	r12,208(sp)
210906b8:	64800044 	addi	r18,r12,1
210906bc:	9005883a 	mov	r2,r18
210906c0:	903ec40e 	bge	r18,zero,210901d4 <__flash_rwdata_start+0xfffedf8c>
210906c4:	003fdd06 	br	2109063c <__flash_rwdata_start+0xfffee3f4>
210906c8:	0005883a 	mov	r2,zero
210906cc:	003f5c06 	br	21090440 <__flash_rwdata_start+0xfffee1f8>
210906d0:	dac03417 	ldw	r11,208(sp)
210906d4:	4a400044 	addi	r9,r9,1
210906d8:	5a65883a 	add	r18,r11,r9
210906dc:	9005883a 	mov	r2,r18
210906e0:	903ebc0e 	bge	r18,zero,210901d4 <__flash_rwdata_start+0xfffedf8c>
210906e4:	003fd506 	br	2109063c <__flash_rwdata_start+0xfffee3f4>
210906e8:	00800034 	movhi	r2,0
210906ec:	108ed984 	addi	r2,r2,15206
210906f0:	d8802b15 	stw	r2,172(sp)
210906f4:	003d2b06 	br	2108fba4 <__flash_rwdata_start+0xfffed95c>
210906f8:	00800c04 	movi	r2,48
210906fc:	e0c00c04 	addi	r3,fp,48
21090700:	d8802345 	stb	r2,141(sp)
21090704:	d8c02385 	stb	r3,142(sp)
21090708:	d88023c4 	addi	r2,sp,143
2109070c:	dd4022c4 	addi	r21,sp,139
21090710:	003f9e06 	br	2109058c <__flash_rwdata_start+0xfffee344>
21090714:	4800081e 	bne	r9,zero,21090738 <___svfprintf_internal_r+0x1f18>
21090718:	8c40004c 	andi	r17,r17,1
2109071c:	8800061e 	bne	r17,zero,21090738 <___svfprintf_internal_r+0x1f18>
21090720:	00800044 	movi	r2,1
21090724:	1025883a 	mov	r18,r2
21090728:	003eaa06 	br	210901d4 <__flash_rwdata_start+0xfffedf8c>
2109072c:	04800084 	movi	r18,2
21090730:	90e5c83a 	sub	r18,r18,r3
21090734:	003fbd06 	br	2109062c <__flash_rwdata_start+0xfffee3e4>
21090738:	4c800084 	addi	r18,r9,2
2109073c:	9005883a 	mov	r2,r18
21090740:	903ea40e 	bge	r18,zero,210901d4 <__flash_rwdata_start+0xfffedf8c>
21090744:	003fbd06 	br	2109063c <__flash_rwdata_start+0xfffee3f4>
21090748:	dac02d17 	ldw	r11,180(sp)
2109074c:	5a400017 	ldw	r9,0(r11)
21090750:	5ac00104 	addi	r11,r11,4
21090754:	dac02d15 	stw	r11,180(sp)
21090758:	483e410e 	bge	r9,zero,21090060 <__flash_rwdata_start+0xfffede18>
2109075c:	027fffc4 	movi	r9,-1
21090760:	1c000047 	ldb	r16,1(r3)
21090764:	00388406 	br	2108e978 <__flash_rwdata_start+0xfffec730>
21090768:	00800b44 	movi	r2,45
2109076c:	0739c83a 	sub	fp,zero,fp
21090770:	d8802305 	stb	r2,140(sp)
21090774:	003f5e06 	br	210904f0 <__flash_rwdata_start+0xfffee2a8>
21090778:	0005883a 	mov	r2,zero
2109077c:	003f8c06 	br	210905b0 <__flash_rwdata_start+0xfffee368>
21090780:	88a2703a 	and	r17,r17,r2
21090784:	883f8826 	beq	r17,zero,210905a8 <__flash_rwdata_start+0xfffee360>
21090788:	003f8606 	br	210905a4 <__flash_rwdata_start+0xfffee35c>
2109078c:	d8802344 	addi	r2,sp,141
21090790:	003f7e06 	br	2109058c <__flash_rwdata_start+0xfffee344>
21090794:	d8c02617 	ldw	r3,152(sp)
21090798:	003f4f06 	br	210904d8 <__flash_rwdata_start+0xfffee290>
2109079c:	dac02f17 	ldw	r11,188(sp)
210907a0:	00800304 	movi	r2,12
210907a4:	58800015 	stw	r2,0(r11)
210907a8:	00bfffc4 	movi	r2,-1
210907ac:	0038e806 	br	2108eb50 <__flash_rwdata_start+0xfffec908>

210907b0 <___vfprintf_internal_r>:
210907b0:	deffb604 	addi	sp,sp,-296
210907b4:	dfc04915 	stw	ra,292(sp)
210907b8:	ddc04715 	stw	r23,284(sp)
210907bc:	dd804615 	stw	r22,280(sp)
210907c0:	282f883a 	mov	r23,r5
210907c4:	202d883a 	mov	r22,r4
210907c8:	d9802a15 	stw	r6,168(sp)
210907cc:	d9c02d15 	stw	r7,180(sp)
210907d0:	df004815 	stw	fp,288(sp)
210907d4:	dd404515 	stw	r21,276(sp)
210907d8:	dd004415 	stw	r20,272(sp)
210907dc:	dcc04315 	stw	r19,268(sp)
210907e0:	dc804215 	stw	r18,264(sp)
210907e4:	dc404115 	stw	r17,260(sp)
210907e8:	dc004015 	stw	r16,256(sp)
210907ec:	109565c0 	call	2109565c <_localeconv_r>
210907f0:	10800017 	ldw	r2,0(r2)
210907f4:	1009883a 	mov	r4,r2
210907f8:	d8803515 	stw	r2,212(sp)
210907fc:	108e7200 	call	2108e720 <strlen>
21090800:	d8803815 	stw	r2,224(sp)
21090804:	b0000226 	beq	r22,zero,21090810 <___vfprintf_internal_r+0x60>
21090808:	b0800e17 	ldw	r2,56(r22)
2109080c:	1000e126 	beq	r2,zero,21090b94 <___vfprintf_internal_r+0x3e4>
21090810:	b880030b 	ldhu	r2,12(r23)
21090814:	10c8000c 	andi	r3,r2,8192
21090818:	1800061e 	bne	r3,zero,21090834 <___vfprintf_internal_r+0x84>
2109081c:	b9001917 	ldw	r4,100(r23)
21090820:	00f7ffc4 	movi	r3,-8193
21090824:	10880014 	ori	r2,r2,8192
21090828:	20c6703a 	and	r3,r4,r3
2109082c:	b880030d 	sth	r2,12(r23)
21090830:	b8c01915 	stw	r3,100(r23)
21090834:	10c0020c 	andi	r3,r2,8
21090838:	1800a726 	beq	r3,zero,21090ad8 <___vfprintf_internal_r+0x328>
2109083c:	b8c00417 	ldw	r3,16(r23)
21090840:	1800a526 	beq	r3,zero,21090ad8 <___vfprintf_internal_r+0x328>
21090844:	1080068c 	andi	r2,r2,26
21090848:	00c00284 	movi	r3,10
2109084c:	10c0aa26 	beq	r2,r3,21090af8 <___vfprintf_internal_r+0x348>
21090850:	dac01e04 	addi	r11,sp,120
21090854:	db001dc4 	addi	r12,sp,119
21090858:	d8800404 	addi	r2,sp,16
2109085c:	05000034 	movhi	r20,0
21090860:	dac02815 	stw	r11,160(sp)
21090864:	5b17c83a 	sub	r11,r11,r12
21090868:	a50ee184 	addi	r20,r20,15238
2109086c:	db002915 	stw	r12,164(sp)
21090870:	d8801e15 	stw	r2,120(sp)
21090874:	d8002015 	stw	zero,128(sp)
21090878:	d8001f15 	stw	zero,124(sp)
2109087c:	d8003315 	stw	zero,204(sp)
21090880:	d8003715 	stw	zero,220(sp)
21090884:	d8003915 	stw	zero,228(sp)
21090888:	1011883a 	mov	r8,r2
2109088c:	d8003b15 	stw	zero,236(sp)
21090890:	d8003a15 	stw	zero,232(sp)
21090894:	d8002f15 	stw	zero,188(sp)
21090898:	dac03c15 	stw	r11,240(sp)
2109089c:	db002a17 	ldw	r12,168(sp)
210908a0:	60800007 	ldb	r2,0(r12)
210908a4:	1000be26 	beq	r2,zero,21090ba0 <___vfprintf_internal_r+0x3f0>
210908a8:	00c00944 	movi	r3,37
210908ac:	10c0bc26 	beq	r2,r3,21090ba0 <___vfprintf_internal_r+0x3f0>
210908b0:	6021883a 	mov	r16,r12
210908b4:	00000106 	br	210908bc <___vfprintf_internal_r+0x10c>
210908b8:	10c08426 	beq	r2,r3,21090acc <___vfprintf_internal_r+0x31c>
210908bc:	84000044 	addi	r16,r16,1
210908c0:	80800007 	ldb	r2,0(r16)
210908c4:	103ffc1e 	bne	r2,zero,210908b8 <__flash_rwdata_start+0xfffee670>
210908c8:	dac02a17 	ldw	r11,168(sp)
210908cc:	82e3c83a 	sub	r17,r16,r11
210908d0:	88000f26 	beq	r17,zero,21090910 <___vfprintf_internal_r+0x160>
210908d4:	d8c02017 	ldw	r3,128(sp)
210908d8:	d8801f17 	ldw	r2,124(sp)
210908dc:	dac02a17 	ldw	r11,168(sp)
210908e0:	1c47883a 	add	r3,r3,r17
210908e4:	10800044 	addi	r2,r2,1
210908e8:	d8c02015 	stw	r3,128(sp)
210908ec:	42c00015 	stw	r11,0(r8)
210908f0:	44400115 	stw	r17,4(r8)
210908f4:	d8801f15 	stw	r2,124(sp)
210908f8:	00c001c4 	movi	r3,7
210908fc:	18809316 	blt	r3,r2,21090b4c <___vfprintf_internal_r+0x39c>
21090900:	42000204 	addi	r8,r8,8
21090904:	db002f17 	ldw	r12,188(sp)
21090908:	6459883a 	add	r12,r12,r17
2109090c:	db002f15 	stw	r12,188(sp)
21090910:	80800007 	ldb	r2,0(r16)
21090914:	10009426 	beq	r2,zero,21090b68 <___vfprintf_internal_r+0x3b8>
21090918:	80800044 	addi	r2,r16,1
2109091c:	84000047 	ldb	r16,1(r16)
21090920:	d8002785 	stb	zero,158(sp)
21090924:	000d883a 	mov	r6,zero
21090928:	027fffc4 	movi	r9,-1
2109092c:	d8002e15 	stw	zero,184(sp)
21090930:	0023883a 	mov	r17,zero
21090934:	01001604 	movi	r4,88
21090938:	01400244 	movi	r5,9
2109093c:	02800a84 	movi	r10,42
21090940:	01c01b04 	movi	r7,108
21090944:	10c00044 	addi	r3,r2,1
21090948:	80bff804 	addi	r2,r16,-32
2109094c:	2082cd36 	bltu	r4,r2,21091484 <___vfprintf_internal_r+0xcd4>
21090950:	100490ba 	slli	r2,r2,2
21090954:	02c84274 	movhi	r11,8457
21090958:	5ac25a04 	addi	r11,r11,2408
2109095c:	12c5883a 	add	r2,r2,r11
21090960:	10800017 	ldw	r2,0(r2)
21090964:	1000683a 	jmp	r2
21090968:	2109129c 	xori	r4,r4,9290
2109096c:	21091484 	addi	r4,r4,9298
21090970:	21091484 	addi	r4,r4,9298
21090974:	210913ec 	andhi	r4,r4,9295
21090978:	21091484 	addi	r4,r4,9298
2109097c:	21091484 	addi	r4,r4,9298
21090980:	21091484 	addi	r4,r4,9298
21090984:	21091484 	addi	r4,r4,9298
21090988:	21091484 	addi	r4,r4,9298
2109098c:	21091484 	addi	r4,r4,9298
21090990:	210912bc 	xorhi	r4,r4,9290
21090994:	210912e8 	cmpgeui	r4,r4,9291
21090998:	21091484 	addi	r4,r4,9298
2109099c:	21090ba8 	cmpgeui	r4,r4,9262
210909a0:	21090bb8 	rdprs	r4,r4,9262
210909a4:	21091484 	addi	r4,r4,9298
210909a8:	21090bf8 	rdprs	r4,r4,9263
210909ac:	21090c08 	cmpgei	r4,r4,9264
210909b0:	21090c08 	cmpgei	r4,r4,9264
210909b4:	21090c08 	cmpgei	r4,r4,9264
210909b8:	21090c08 	cmpgei	r4,r4,9264
210909bc:	21090c08 	cmpgei	r4,r4,9264
210909c0:	21090c08 	cmpgei	r4,r4,9264
210909c4:	21090c08 	cmpgei	r4,r4,9264
210909c8:	21090c08 	cmpgei	r4,r4,9264
210909cc:	21090c08 	cmpgei	r4,r4,9264
210909d0:	21091484 	addi	r4,r4,9298
210909d4:	21091484 	addi	r4,r4,9298
210909d8:	21091484 	addi	r4,r4,9298
210909dc:	21091484 	addi	r4,r4,9298
210909e0:	21091484 	addi	r4,r4,9298
210909e4:	21091484 	addi	r4,r4,9298
210909e8:	21091484 	addi	r4,r4,9298
210909ec:	21091484 	addi	r4,r4,9298
210909f0:	21091484 	addi	r4,r4,9298
210909f4:	21091484 	addi	r4,r4,9298
210909f8:	21090c3c 	xorhi	r4,r4,9264
210909fc:	210910ac 	andhi	r4,r4,9282
21090a00:	21091484 	addi	r4,r4,9298
21090a04:	210910ac 	andhi	r4,r4,9282
21090a08:	21091484 	addi	r4,r4,9298
21090a0c:	21091484 	addi	r4,r4,9298
21090a10:	21091484 	addi	r4,r4,9298
21090a14:	21091484 	addi	r4,r4,9298
21090a18:	21091198 	cmpnei	r4,r4,9286
21090a1c:	21091484 	addi	r4,r4,9298
21090a20:	21091484 	addi	r4,r4,9298
21090a24:	21091040 	call	22109104 <__flash_rwdata_start+0x1066ebc>
21090a28:	21091484 	addi	r4,r4,9298
21090a2c:	21091484 	addi	r4,r4,9298
21090a30:	21091484 	addi	r4,r4,9298
21090a34:	21091484 	addi	r4,r4,9298
21090a38:	21091484 	addi	r4,r4,9298
21090a3c:	2109107c 	xorhi	r4,r4,9281
21090a40:	21091484 	addi	r4,r4,9298
21090a44:	21091484 	addi	r4,r4,9298
21090a48:	21091240 	call	22109124 <__flash_rwdata_start+0x1066edc>
21090a4c:	21091484 	addi	r4,r4,9298
21090a50:	21091484 	addi	r4,r4,9298
21090a54:	21091484 	addi	r4,r4,9298
21090a58:	21091484 	addi	r4,r4,9298
21090a5c:	21091484 	addi	r4,r4,9298
21090a60:	21091484 	addi	r4,r4,9298
21090a64:	21091484 	addi	r4,r4,9298
21090a68:	21091484 	addi	r4,r4,9298
21090a6c:	21091484 	addi	r4,r4,9298
21090a70:	21091484 	addi	r4,r4,9298
21090a74:	210912f8 	rdprs	r4,r4,9291
21090a78:	210911a8 	cmpgeui	r4,r4,9286
21090a7c:	210910ac 	andhi	r4,r4,9282
21090a80:	210910ac 	andhi	r4,r4,9282
21090a84:	210910ac 	andhi	r4,r4,9282
21090a88:	210911e8 	cmpgeui	r4,r4,9287
21090a8c:	210911a8 	cmpgeui	r4,r4,9286
21090a90:	21091484 	addi	r4,r4,9298
21090a94:	21091484 	addi	r4,r4,9298
21090a98:	210911f8 	rdprs	r4,r4,9287
21090a9c:	21091484 	addi	r4,r4,9298
21090aa0:	2109120c 	andi	r4,r4,9288
21090aa4:	21091448 	cmpgei	r4,r4,9297
21090aa8:	21091150 	cmplti	r4,r4,9285
21090aac:	210913fc 	xorhi	r4,r4,9295
21090ab0:	21091484 	addi	r4,r4,9298
21090ab4:	21091338 	rdprs	r4,r4,9292
21090ab8:	21091484 	addi	r4,r4,9298
21090abc:	2109140c 	andi	r4,r4,9296
21090ac0:	21091484 	addi	r4,r4,9298
21090ac4:	21091484 	addi	r4,r4,9298
21090ac8:	210913ac 	andhi	r4,r4,9294
21090acc:	db002a17 	ldw	r12,168(sp)
21090ad0:	8323c83a 	sub	r17,r16,r12
21090ad4:	003f7e06 	br	210908d0 <__flash_rwdata_start+0xfffee688>
21090ad8:	b009883a 	mov	r4,r22
21090adc:	b80b883a 	mov	r5,r23
21090ae0:	10929100 	call	21092910 <__swsetup_r>
21090ae4:	10000c1e 	bne	r2,zero,21090b18 <___vfprintf_internal_r+0x368>
21090ae8:	b880030b 	ldhu	r2,12(r23)
21090aec:	00c00284 	movi	r3,10
21090af0:	1080068c 	andi	r2,r2,26
21090af4:	10ff561e 	bne	r2,r3,21090850 <__flash_rwdata_start+0xfffee608>
21090af8:	b880038f 	ldh	r2,14(r23)
21090afc:	103f5416 	blt	r2,zero,21090850 <__flash_rwdata_start+0xfffee608>
21090b00:	d9802a17 	ldw	r6,168(sp)
21090b04:	d9c02d17 	ldw	r7,180(sp)
21090b08:	b009883a 	mov	r4,r22
21090b0c:	b80b883a 	mov	r5,r23
21090b10:	10927240 	call	21092724 <__sbprintf>
21090b14:	00000106 	br	21090b1c <___vfprintf_internal_r+0x36c>
21090b18:	00bfffc4 	movi	r2,-1
21090b1c:	dfc04917 	ldw	ra,292(sp)
21090b20:	df004817 	ldw	fp,288(sp)
21090b24:	ddc04717 	ldw	r23,284(sp)
21090b28:	dd804617 	ldw	r22,280(sp)
21090b2c:	dd404517 	ldw	r21,276(sp)
21090b30:	dd004417 	ldw	r20,272(sp)
21090b34:	dcc04317 	ldw	r19,268(sp)
21090b38:	dc804217 	ldw	r18,264(sp)
21090b3c:	dc404117 	ldw	r17,260(sp)
21090b40:	dc004017 	ldw	r16,256(sp)
21090b44:	dec04a04 	addi	sp,sp,296
21090b48:	f800283a 	ret
21090b4c:	b009883a 	mov	r4,r22
21090b50:	b80b883a 	mov	r5,r23
21090b54:	d9801e04 	addi	r6,sp,120
21090b58:	10987140 	call	21098714 <__sprint_r>
21090b5c:	1000081e 	bne	r2,zero,21090b80 <___vfprintf_internal_r+0x3d0>
21090b60:	da000404 	addi	r8,sp,16
21090b64:	003f6706 	br	21090904 <__flash_rwdata_start+0xfffee6bc>
21090b68:	d8802017 	ldw	r2,128(sp)
21090b6c:	10000426 	beq	r2,zero,21090b80 <___vfprintf_internal_r+0x3d0>
21090b70:	b009883a 	mov	r4,r22
21090b74:	b80b883a 	mov	r5,r23
21090b78:	d9801e04 	addi	r6,sp,120
21090b7c:	10987140 	call	21098714 <__sprint_r>
21090b80:	b880030b 	ldhu	r2,12(r23)
21090b84:	1080100c 	andi	r2,r2,64
21090b88:	103fe31e 	bne	r2,zero,21090b18 <__flash_rwdata_start+0xfffee8d0>
21090b8c:	d8802f17 	ldw	r2,188(sp)
21090b90:	003fe206 	br	21090b1c <__flash_rwdata_start+0xfffee8d4>
21090b94:	b009883a 	mov	r4,r22
21090b98:	1094b040 	call	21094b04 <__sinit>
21090b9c:	003f1c06 	br	21090810 <__flash_rwdata_start+0xfffee5c8>
21090ba0:	dc002a17 	ldw	r16,168(sp)
21090ba4:	003f5a06 	br	21090910 <__flash_rwdata_start+0xfffee6c8>
21090ba8:	1805883a 	mov	r2,r3
21090bac:	8c400114 	ori	r17,r17,4
21090bb0:	1c000007 	ldb	r16,0(r3)
21090bb4:	003f6306 	br	21090944 <__flash_rwdata_start+0xfffee6fc>
21090bb8:	1c000007 	ldb	r16,0(r3)
21090bbc:	18800044 	addi	r2,r3,1
21090bc0:	8286ad26 	beq	r16,r10,21092678 <___vfprintf_internal_r+0x1ec8>
21090bc4:	82fff404 	addi	r11,r16,-48
21090bc8:	1007883a 	mov	r3,r2
21090bcc:	0013883a 	mov	r9,zero
21090bd0:	2aff5d36 	bltu	r5,r11,21090948 <__flash_rwdata_start+0xfffee700>
21090bd4:	1c000007 	ldb	r16,0(r3)
21090bd8:	4a4002a4 	muli	r9,r9,10
21090bdc:	18c00044 	addi	r3,r3,1
21090be0:	5a53883a 	add	r9,r11,r9
21090be4:	82fff404 	addi	r11,r16,-48
21090be8:	2afffa2e 	bgeu	r5,r11,21090bd4 <__flash_rwdata_start+0xfffee98c>
21090bec:	483f560e 	bge	r9,zero,21090948 <__flash_rwdata_start+0xfffee700>
21090bf0:	027fffc4 	movi	r9,-1
21090bf4:	003f5406 	br	21090948 <__flash_rwdata_start+0xfffee700>
21090bf8:	8c402014 	ori	r17,r17,128
21090bfc:	1805883a 	mov	r2,r3
21090c00:	1c000007 	ldb	r16,0(r3)
21090c04:	003f4f06 	br	21090944 <__flash_rwdata_start+0xfffee6fc>
21090c08:	1805883a 	mov	r2,r3
21090c0c:	d8002e15 	stw	zero,184(sp)
21090c10:	82fff404 	addi	r11,r16,-48
21090c14:	0019883a 	mov	r12,zero
21090c18:	14000007 	ldb	r16,0(r2)
21090c1c:	630002a4 	muli	r12,r12,10
21090c20:	18c00044 	addi	r3,r3,1
21090c24:	1805883a 	mov	r2,r3
21090c28:	62d9883a 	add	r12,r12,r11
21090c2c:	82fff404 	addi	r11,r16,-48
21090c30:	2afff92e 	bgeu	r5,r11,21090c18 <__flash_rwdata_start+0xfffee9d0>
21090c34:	db002e15 	stw	r12,184(sp)
21090c38:	003f4306 	br	21090948 <__flash_rwdata_start+0xfffee700>
21090c3c:	8c400414 	ori	r17,r17,16
21090c40:	d8c02a15 	stw	r3,168(sp)
21090c44:	d9802785 	stb	r6,158(sp)
21090c48:	8880080c 	andi	r2,r17,32
21090c4c:	d8c02d17 	ldw	r3,180(sp)
21090c50:	10015a26 	beq	r2,zero,210911bc <___vfprintf_internal_r+0xa0c>
21090c54:	db002d17 	ldw	r12,180(sp)
21090c58:	18800117 	ldw	r2,4(r3)
21090c5c:	1cc00017 	ldw	r19,0(r3)
21090c60:	63000204 	addi	r12,r12,8
21090c64:	db002d15 	stw	r12,180(sp)
21090c68:	1039883a 	mov	fp,r2
21090c6c:	10044516 	blt	r2,zero,21091d84 <___vfprintf_internal_r+0x15d4>
21090c70:	dd402783 	ldbu	r21,158(sp)
21090c74:	da403215 	stw	r9,200(sp)
21090c78:	00800044 	movi	r2,1
21090c7c:	9f06b03a 	or	r3,r19,fp
21090c80:	48000216 	blt	r9,zero,21090c8c <___vfprintf_internal_r+0x4dc>
21090c84:	013fdfc4 	movi	r4,-129
21090c88:	8922703a 	and	r17,r17,r4
21090c8c:	1802071e 	bne	r3,zero,210914ac <___vfprintf_internal_r+0xcfc>
21090c90:	4802fa26 	beq	r9,zero,2109187c <___vfprintf_internal_r+0x10cc>
21090c94:	10803fcc 	andi	r2,r2,255
21090c98:	00c00044 	movi	r3,1
21090c9c:	10c22926 	beq	r2,r3,21091544 <___vfprintf_internal_r+0xd94>
21090ca0:	00c00084 	movi	r3,2
21090ca4:	10c31726 	beq	r2,r3,21091904 <___vfprintf_internal_r+0x1154>
21090ca8:	d8c01e04 	addi	r3,sp,120
21090cac:	9808d0fa 	srli	r4,r19,3
21090cb0:	e00a977a 	slli	r5,fp,29
21090cb4:	e038d0fa 	srli	fp,fp,3
21090cb8:	9cc001cc 	andi	r19,r19,7
21090cbc:	98800c04 	addi	r2,r19,48
21090cc0:	18ffffc4 	addi	r3,r3,-1
21090cc4:	2926b03a 	or	r19,r5,r4
21090cc8:	18800005 	stb	r2,0(r3)
21090ccc:	9f08b03a 	or	r4,r19,fp
21090cd0:	203ff61e 	bne	r4,zero,21090cac <__flash_rwdata_start+0xfffeea64>
21090cd4:	8900004c 	andi	r4,r17,1
21090cd8:	d8c03115 	stw	r3,196(sp)
21090cdc:	2003931e 	bne	r4,zero,21091b2c <___vfprintf_internal_r+0x137c>
21090ce0:	dac02817 	ldw	r11,160(sp)
21090ce4:	58e5c83a 	sub	r18,r11,r3
21090ce8:	9005883a 	mov	r2,r18
21090cec:	9240010e 	bge	r18,r9,21090cf4 <___vfprintf_internal_r+0x544>
21090cf0:	4805883a 	mov	r2,r9
21090cf4:	d8802b15 	stw	r2,172(sp)
21090cf8:	d8003415 	stw	zero,208(sp)
21090cfc:	a8803fcc 	andi	r2,r21,255
21090d00:	1080201c 	xori	r2,r2,128
21090d04:	10bfe004 	addi	r2,r2,-128
21090d08:	10000326 	beq	r2,zero,21090d18 <___vfprintf_internal_r+0x568>
21090d0c:	db002b17 	ldw	r12,172(sp)
21090d10:	63000044 	addi	r12,r12,1
21090d14:	db002b15 	stw	r12,172(sp)
21090d18:	88c0008c 	andi	r3,r17,2
21090d1c:	d8c02c15 	stw	r3,176(sp)
21090d20:	18000326 	beq	r3,zero,21090d30 <___vfprintf_internal_r+0x580>
21090d24:	dac02b17 	ldw	r11,172(sp)
21090d28:	5ac00084 	addi	r11,r11,2
21090d2c:	dac02b15 	stw	r11,172(sp)
21090d30:	8b00210c 	andi	r12,r17,132
21090d34:	db003015 	stw	r12,192(sp)
21090d38:	6001da1e 	bne	r12,zero,210914a4 <___vfprintf_internal_r+0xcf4>
21090d3c:	dac02e17 	ldw	r11,184(sp)
21090d40:	db002b17 	ldw	r12,172(sp)
21090d44:	5b39c83a 	sub	fp,r11,r12
21090d48:	0701d60e 	bge	zero,fp,210914a4 <___vfprintf_internal_r+0xcf4>
21090d4c:	02400404 	movi	r9,16
21090d50:	d8c02017 	ldw	r3,128(sp)
21090d54:	d8801f17 	ldw	r2,124(sp)
21090d58:	4f053c0e 	bge	r9,fp,2109224c <___vfprintf_internal_r+0x1a9c>
21090d5c:	01400034 	movhi	r5,0
21090d60:	294ee584 	addi	r5,r5,15254
21090d64:	d9403615 	stw	r5,216(sp)
21090d68:	482b883a 	mov	r21,r9
21090d6c:	04c001c4 	movi	r19,7
21090d70:	00000306 	br	21090d80 <___vfprintf_internal_r+0x5d0>
21090d74:	e73ffc04 	addi	fp,fp,-16
21090d78:	42000204 	addi	r8,r8,8
21090d7c:	af00130e 	bge	r21,fp,21090dcc <___vfprintf_internal_r+0x61c>
21090d80:	02c00034 	movhi	r11,0
21090d84:	18c00404 	addi	r3,r3,16
21090d88:	10800044 	addi	r2,r2,1
21090d8c:	5acee584 	addi	r11,r11,15254
21090d90:	42c00015 	stw	r11,0(r8)
21090d94:	45400115 	stw	r21,4(r8)
21090d98:	d8c02015 	stw	r3,128(sp)
21090d9c:	d8801f15 	stw	r2,124(sp)
21090da0:	98bff40e 	bge	r19,r2,21090d74 <__flash_rwdata_start+0xfffeeb2c>
21090da4:	b009883a 	mov	r4,r22
21090da8:	b80b883a 	mov	r5,r23
21090dac:	d9801e04 	addi	r6,sp,120
21090db0:	10987140 	call	21098714 <__sprint_r>
21090db4:	103f721e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
21090db8:	e73ffc04 	addi	fp,fp,-16
21090dbc:	d8c02017 	ldw	r3,128(sp)
21090dc0:	d8801f17 	ldw	r2,124(sp)
21090dc4:	da000404 	addi	r8,sp,16
21090dc8:	af3fed16 	blt	r21,fp,21090d80 <__flash_rwdata_start+0xfffeeb38>
21090dcc:	db003617 	ldw	r12,216(sp)
21090dd0:	e0c7883a 	add	r3,fp,r3
21090dd4:	10800044 	addi	r2,r2,1
21090dd8:	43000015 	stw	r12,0(r8)
21090ddc:	47000115 	stw	fp,4(r8)
21090de0:	d8c02015 	stw	r3,128(sp)
21090de4:	d8801f15 	stw	r2,124(sp)
21090de8:	010001c4 	movi	r4,7
21090dec:	20830e16 	blt	r4,r2,21091a28 <___vfprintf_internal_r+0x1278>
21090df0:	d8802787 	ldb	r2,158(sp)
21090df4:	42000204 	addi	r8,r8,8
21090df8:	10000c26 	beq	r2,zero,21090e2c <___vfprintf_internal_r+0x67c>
21090dfc:	d8801f17 	ldw	r2,124(sp)
21090e00:	d9002784 	addi	r4,sp,158
21090e04:	18c00044 	addi	r3,r3,1
21090e08:	10800044 	addi	r2,r2,1
21090e0c:	41000015 	stw	r4,0(r8)
21090e10:	01000044 	movi	r4,1
21090e14:	41000115 	stw	r4,4(r8)
21090e18:	d8c02015 	stw	r3,128(sp)
21090e1c:	d8801f15 	stw	r2,124(sp)
21090e20:	010001c4 	movi	r4,7
21090e24:	2082a716 	blt	r4,r2,210918c4 <___vfprintf_internal_r+0x1114>
21090e28:	42000204 	addi	r8,r8,8
21090e2c:	dac02c17 	ldw	r11,176(sp)
21090e30:	58000c26 	beq	r11,zero,21090e64 <___vfprintf_internal_r+0x6b4>
21090e34:	d8801f17 	ldw	r2,124(sp)
21090e38:	d9002704 	addi	r4,sp,156
21090e3c:	18c00084 	addi	r3,r3,2
21090e40:	10800044 	addi	r2,r2,1
21090e44:	41000015 	stw	r4,0(r8)
21090e48:	01000084 	movi	r4,2
21090e4c:	41000115 	stw	r4,4(r8)
21090e50:	d8c02015 	stw	r3,128(sp)
21090e54:	d8801f15 	stw	r2,124(sp)
21090e58:	010001c4 	movi	r4,7
21090e5c:	2082a116 	blt	r4,r2,210918e4 <___vfprintf_internal_r+0x1134>
21090e60:	42000204 	addi	r8,r8,8
21090e64:	db003017 	ldw	r12,192(sp)
21090e68:	00802004 	movi	r2,128
21090e6c:	60820326 	beq	r12,r2,2109167c <___vfprintf_internal_r+0xecc>
21090e70:	db003217 	ldw	r12,200(sp)
21090e74:	64abc83a 	sub	r21,r12,r18
21090e78:	0540260e 	bge	zero,r21,21090f14 <___vfprintf_internal_r+0x764>
21090e7c:	07000404 	movi	fp,16
21090e80:	d8801f17 	ldw	r2,124(sp)
21090e84:	e544570e 	bge	fp,r21,21091fe4 <___vfprintf_internal_r+0x1834>
21090e88:	01400034 	movhi	r5,0
21090e8c:	294ee184 	addi	r5,r5,15238
21090e90:	d9402c15 	stw	r5,176(sp)
21090e94:	04c001c4 	movi	r19,7
21090e98:	00000306 	br	21090ea8 <___vfprintf_internal_r+0x6f8>
21090e9c:	ad7ffc04 	addi	r21,r21,-16
21090ea0:	42000204 	addi	r8,r8,8
21090ea4:	e540110e 	bge	fp,r21,21090eec <___vfprintf_internal_r+0x73c>
21090ea8:	18c00404 	addi	r3,r3,16
21090eac:	10800044 	addi	r2,r2,1
21090eb0:	45000015 	stw	r20,0(r8)
21090eb4:	47000115 	stw	fp,4(r8)
21090eb8:	d8c02015 	stw	r3,128(sp)
21090ebc:	d8801f15 	stw	r2,124(sp)
21090ec0:	98bff60e 	bge	r19,r2,21090e9c <__flash_rwdata_start+0xfffeec54>
21090ec4:	b009883a 	mov	r4,r22
21090ec8:	b80b883a 	mov	r5,r23
21090ecc:	d9801e04 	addi	r6,sp,120
21090ed0:	10987140 	call	21098714 <__sprint_r>
21090ed4:	103f2a1e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
21090ed8:	ad7ffc04 	addi	r21,r21,-16
21090edc:	d8c02017 	ldw	r3,128(sp)
21090ee0:	d8801f17 	ldw	r2,124(sp)
21090ee4:	da000404 	addi	r8,sp,16
21090ee8:	e57fef16 	blt	fp,r21,21090ea8 <__flash_rwdata_start+0xfffeec60>
21090eec:	dac02c17 	ldw	r11,176(sp)
21090ef0:	1d47883a 	add	r3,r3,r21
21090ef4:	10800044 	addi	r2,r2,1
21090ef8:	42c00015 	stw	r11,0(r8)
21090efc:	45400115 	stw	r21,4(r8)
21090f00:	d8c02015 	stw	r3,128(sp)
21090f04:	d8801f15 	stw	r2,124(sp)
21090f08:	010001c4 	movi	r4,7
21090f0c:	20826516 	blt	r4,r2,210918a4 <___vfprintf_internal_r+0x10f4>
21090f10:	42000204 	addi	r8,r8,8
21090f14:	8880400c 	andi	r2,r17,256
21090f18:	1001901e 	bne	r2,zero,2109155c <___vfprintf_internal_r+0xdac>
21090f1c:	d8801f17 	ldw	r2,124(sp)
21090f20:	db003117 	ldw	r12,196(sp)
21090f24:	1c87883a 	add	r3,r3,r18
21090f28:	10800044 	addi	r2,r2,1
21090f2c:	43000015 	stw	r12,0(r8)
21090f30:	44800115 	stw	r18,4(r8)
21090f34:	d8c02015 	stw	r3,128(sp)
21090f38:	d8801f15 	stw	r2,124(sp)
21090f3c:	010001c4 	movi	r4,7
21090f40:	20824016 	blt	r4,r2,21091844 <___vfprintf_internal_r+0x1094>
21090f44:	42000204 	addi	r8,r8,8
21090f48:	8c40010c 	andi	r17,r17,4
21090f4c:	88003126 	beq	r17,zero,21091014 <___vfprintf_internal_r+0x864>
21090f50:	db002e17 	ldw	r12,184(sp)
21090f54:	dac02b17 	ldw	r11,172(sp)
21090f58:	62e1c83a 	sub	r16,r12,r11
21090f5c:	04002d0e 	bge	zero,r16,21091014 <___vfprintf_internal_r+0x864>
21090f60:	04400404 	movi	r17,16
21090f64:	d8801f17 	ldw	r2,124(sp)
21090f68:	8c05150e 	bge	r17,r16,210923c0 <___vfprintf_internal_r+0x1c10>
21090f6c:	01000034 	movhi	r4,0
21090f70:	210ee584 	addi	r4,r4,15254
21090f74:	d9003615 	stw	r4,216(sp)
21090f78:	048001c4 	movi	r18,7
21090f7c:	00000306 	br	21090f8c <___vfprintf_internal_r+0x7dc>
21090f80:	843ffc04 	addi	r16,r16,-16
21090f84:	42000204 	addi	r8,r8,8
21090f88:	8c00130e 	bge	r17,r16,21090fd8 <___vfprintf_internal_r+0x828>
21090f8c:	01400034 	movhi	r5,0
21090f90:	18c00404 	addi	r3,r3,16
21090f94:	10800044 	addi	r2,r2,1
21090f98:	294ee584 	addi	r5,r5,15254
21090f9c:	41400015 	stw	r5,0(r8)
21090fa0:	44400115 	stw	r17,4(r8)
21090fa4:	d8c02015 	stw	r3,128(sp)
21090fa8:	d8801f15 	stw	r2,124(sp)
21090fac:	90bff40e 	bge	r18,r2,21090f80 <__flash_rwdata_start+0xfffeed38>
21090fb0:	b009883a 	mov	r4,r22
21090fb4:	b80b883a 	mov	r5,r23
21090fb8:	d9801e04 	addi	r6,sp,120
21090fbc:	10987140 	call	21098714 <__sprint_r>
21090fc0:	103eef1e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
21090fc4:	843ffc04 	addi	r16,r16,-16
21090fc8:	d8c02017 	ldw	r3,128(sp)
21090fcc:	d8801f17 	ldw	r2,124(sp)
21090fd0:	da000404 	addi	r8,sp,16
21090fd4:	8c3fed16 	blt	r17,r16,21090f8c <__flash_rwdata_start+0xfffeed44>
21090fd8:	dac03617 	ldw	r11,216(sp)
21090fdc:	1c07883a 	add	r3,r3,r16
21090fe0:	10800044 	addi	r2,r2,1
21090fe4:	42c00015 	stw	r11,0(r8)
21090fe8:	44000115 	stw	r16,4(r8)
21090fec:	d8c02015 	stw	r3,128(sp)
21090ff0:	d8801f15 	stw	r2,124(sp)
21090ff4:	010001c4 	movi	r4,7
21090ff8:	2080060e 	bge	r4,r2,21091014 <___vfprintf_internal_r+0x864>
21090ffc:	b009883a 	mov	r4,r22
21091000:	b80b883a 	mov	r5,r23
21091004:	d9801e04 	addi	r6,sp,120
21091008:	10987140 	call	21098714 <__sprint_r>
2109100c:	103edc1e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
21091010:	d8c02017 	ldw	r3,128(sp)
21091014:	d8802b17 	ldw	r2,172(sp)
21091018:	db002e17 	ldw	r12,184(sp)
2109101c:	1300010e 	bge	r2,r12,21091024 <___vfprintf_internal_r+0x874>
21091020:	6005883a 	mov	r2,r12
21091024:	dac02f17 	ldw	r11,188(sp)
21091028:	5897883a 	add	r11,r11,r2
2109102c:	dac02f15 	stw	r11,188(sp)
21091030:	18020c1e 	bne	r3,zero,21091864 <___vfprintf_internal_r+0x10b4>
21091034:	d8001f15 	stw	zero,124(sp)
21091038:	da000404 	addi	r8,sp,16
2109103c:	003e1706 	br	2109089c <__flash_rwdata_start+0xfffee654>
21091040:	8c400414 	ori	r17,r17,16
21091044:	d8c02a15 	stw	r3,168(sp)
21091048:	8880080c 	andi	r2,r17,32
2109104c:	10010126 	beq	r2,zero,21091454 <___vfprintf_internal_r+0xca4>
21091050:	db002d17 	ldw	r12,180(sp)
21091054:	0005883a 	mov	r2,zero
21091058:	64c00017 	ldw	r19,0(r12)
2109105c:	67000117 	ldw	fp,4(r12)
21091060:	63000204 	addi	r12,r12,8
21091064:	db002d15 	stw	r12,180(sp)
21091068:	9f06b03a 	or	r3,r19,fp
2109106c:	d8002785 	stb	zero,158(sp)
21091070:	da403215 	stw	r9,200(sp)
21091074:	002b883a 	mov	r21,zero
21091078:	003f0106 	br	21090c80 <__flash_rwdata_start+0xfffeea38>
2109107c:	8c400414 	ori	r17,r17,16
21091080:	d8c02a15 	stw	r3,168(sp)
21091084:	8880080c 	andi	r2,r17,32
21091088:	1000e326 	beq	r2,zero,21091418 <___vfprintf_internal_r+0xc68>
2109108c:	dac02d17 	ldw	r11,180(sp)
21091090:	00800044 	movi	r2,1
21091094:	5cc00017 	ldw	r19,0(r11)
21091098:	5f000117 	ldw	fp,4(r11)
2109109c:	5ac00204 	addi	r11,r11,8
210910a0:	dac02d15 	stw	r11,180(sp)
210910a4:	9f06b03a 	or	r3,r19,fp
210910a8:	003ff006 	br	2109106c <__flash_rwdata_start+0xfffeee24>
210910ac:	db002d17 	ldw	r12,180(sp)
210910b0:	dac02d17 	ldw	r11,180(sp)
210910b4:	d8c02a15 	stw	r3,168(sp)
210910b8:	63000017 	ldw	r12,0(r12)
210910bc:	5ac00117 	ldw	r11,4(r11)
210910c0:	d9802785 	stb	r6,158(sp)
210910c4:	6009883a 	mov	r4,r12
210910c8:	580b883a 	mov	r5,r11
210910cc:	db003715 	stw	r12,220(sp)
210910d0:	da003f15 	stw	r8,252(sp)
210910d4:	da403e15 	stw	r9,248(sp)
210910d8:	dac03915 	stw	r11,228(sp)
210910dc:	10971000 	call	21097100 <__fpclassifyd>
210910e0:	db002d17 	ldw	r12,180(sp)
210910e4:	04800044 	movi	r18,1
210910e8:	da003f17 	ldw	r8,252(sp)
210910ec:	64c00204 	addi	r19,r12,8
210910f0:	da403e17 	ldw	r9,248(sp)
210910f4:	d9003717 	ldw	r4,220(sp)
210910f8:	d9403917 	ldw	r5,228(sp)
210910fc:	14832b1e 	bne	r2,r18,21091dac <___vfprintf_internal_r+0x15fc>
21091100:	000d883a 	mov	r6,zero
21091104:	000f883a 	mov	r7,zero
21091108:	109afa80 	call	2109afa8 <__ledf2>
2109110c:	da003f17 	ldw	r8,252(sp)
21091110:	1004b716 	blt	r2,zero,210923f0 <___vfprintf_internal_r+0x1c40>
21091114:	dd402783 	ldbu	r21,158(sp)
21091118:	008011c4 	movi	r2,71
2109111c:	14040e0e 	bge	r2,r16,21092158 <___vfprintf_internal_r+0x19a8>
21091120:	00c00034 	movhi	r3,0
21091124:	18ceca04 	addi	r3,r3,15144
21091128:	d8c03115 	stw	r3,196(sp)
2109112c:	02c000c4 	movi	r11,3
21091130:	00bfdfc4 	movi	r2,-129
21091134:	dac02b15 	stw	r11,172(sp)
21091138:	88a2703a 	and	r17,r17,r2
2109113c:	dcc02d15 	stw	r19,180(sp)
21091140:	5825883a 	mov	r18,r11
21091144:	d8003215 	stw	zero,200(sp)
21091148:	d8003415 	stw	zero,208(sp)
2109114c:	003eeb06 	br	21090cfc <__flash_rwdata_start+0xfffeeab4>
21091150:	db002d17 	ldw	r12,180(sp)
21091154:	00800c04 	movi	r2,48
21091158:	d8802705 	stb	r2,156(sp)
2109115c:	64c00017 	ldw	r19,0(r12)
21091160:	00801e04 	movi	r2,120
21091164:	d8802745 	stb	r2,157(sp)
21091168:	00800034 	movhi	r2,0
2109116c:	108ed204 	addi	r2,r2,15176
21091170:	63000104 	addi	r12,r12,4
21091174:	d8c02a15 	stw	r3,168(sp)
21091178:	d8803b15 	stw	r2,236(sp)
2109117c:	0039883a 	mov	fp,zero
21091180:	8c400094 	ori	r17,r17,2
21091184:	db002d15 	stw	r12,180(sp)
21091188:	00800084 	movi	r2,2
2109118c:	04001e04 	movi	r16,120
21091190:	9807883a 	mov	r3,r19
21091194:	003fb506 	br	2109106c <__flash_rwdata_start+0xfffeee24>
21091198:	8c400214 	ori	r17,r17,8
2109119c:	1805883a 	mov	r2,r3
210911a0:	1c000007 	ldb	r16,0(r3)
210911a4:	003de706 	br	21090944 <__flash_rwdata_start+0xfffee6fc>
210911a8:	d8c02a15 	stw	r3,168(sp)
210911ac:	d9802785 	stb	r6,158(sp)
210911b0:	8880080c 	andi	r2,r17,32
210911b4:	d8c02d17 	ldw	r3,180(sp)
210911b8:	103ea61e 	bne	r2,zero,21090c54 <__flash_rwdata_start+0xfffeea0c>
210911bc:	8880040c 	andi	r2,r17,16
210911c0:	1002221e 	bne	r2,zero,21091a4c <___vfprintf_internal_r+0x129c>
210911c4:	8880100c 	andi	r2,r17,64
210911c8:	10022026 	beq	r2,zero,21091a4c <___vfprintf_internal_r+0x129c>
210911cc:	1cc0000f 	ldh	r19,0(r3)
210911d0:	db002d17 	ldw	r12,180(sp)
210911d4:	9839d7fa 	srai	fp,r19,31
210911d8:	63000104 	addi	r12,r12,4
210911dc:	db002d15 	stw	r12,180(sp)
210911e0:	e005883a 	mov	r2,fp
210911e4:	003ea106 	br	21090c6c <__flash_rwdata_start+0xfffeea24>
210911e8:	8c401014 	ori	r17,r17,64
210911ec:	1805883a 	mov	r2,r3
210911f0:	1c000007 	ldb	r16,0(r3)
210911f4:	003dd306 	br	21090944 <__flash_rwdata_start+0xfffee6fc>
210911f8:	1c000007 	ldb	r16,0(r3)
210911fc:	81c3e926 	beq	r16,r7,210921a4 <___vfprintf_internal_r+0x19f4>
21091200:	8c400414 	ori	r17,r17,16
21091204:	1805883a 	mov	r2,r3
21091208:	003dce06 	br	21090944 <__flash_rwdata_start+0xfffee6fc>
2109120c:	d8c02a15 	stw	r3,168(sp)
21091210:	d9802785 	stb	r6,158(sp)
21091214:	8880080c 	andi	r2,r17,32
21091218:	10034726 	beq	r2,zero,21091f38 <___vfprintf_internal_r+0x1788>
2109121c:	db002d17 	ldw	r12,180(sp)
21091220:	dac02f17 	ldw	r11,188(sp)
21091224:	60800017 	ldw	r2,0(r12)
21091228:	5807d7fa 	srai	r3,r11,31
2109122c:	63000104 	addi	r12,r12,4
21091230:	db002d15 	stw	r12,180(sp)
21091234:	12c00015 	stw	r11,0(r2)
21091238:	10c00115 	stw	r3,4(r2)
2109123c:	003d9706 	br	2109089c <__flash_rwdata_start+0xfffee654>
21091240:	03000034 	movhi	r12,0
21091244:	630ecd04 	addi	r12,r12,15156
21091248:	d8c02a15 	stw	r3,168(sp)
2109124c:	d9802785 	stb	r6,158(sp)
21091250:	db003b15 	stw	r12,236(sp)
21091254:	88c0080c 	andi	r3,r17,32
21091258:	d8802d17 	ldw	r2,180(sp)
2109125c:	18005b26 	beq	r3,zero,210913cc <___vfprintf_internal_r+0xc1c>
21091260:	dac02d17 	ldw	r11,180(sp)
21091264:	14c00017 	ldw	r19,0(r2)
21091268:	17000117 	ldw	fp,4(r2)
2109126c:	5ac00204 	addi	r11,r11,8
21091270:	dac02d15 	stw	r11,180(sp)
21091274:	8880004c 	andi	r2,r17,1
21091278:	10022926 	beq	r2,zero,21091b20 <___vfprintf_internal_r+0x1370>
2109127c:	9f06b03a 	or	r3,r19,fp
21091280:	18032b26 	beq	r3,zero,21091f30 <___vfprintf_internal_r+0x1780>
21091284:	00800c04 	movi	r2,48
21091288:	d8802705 	stb	r2,156(sp)
2109128c:	dc002745 	stb	r16,157(sp)
21091290:	8c400094 	ori	r17,r17,2
21091294:	00800084 	movi	r2,2
21091298:	003f7406 	br	2109106c <__flash_rwdata_start+0xfffeee24>
2109129c:	30803fcc 	andi	r2,r6,255
210912a0:	1080201c 	xori	r2,r2,128
210912a4:	10bfe004 	addi	r2,r2,-128
210912a8:	1003351e 	bne	r2,zero,21091f80 <___vfprintf_internal_r+0x17d0>
210912ac:	1805883a 	mov	r2,r3
210912b0:	01800804 	movi	r6,32
210912b4:	1c000007 	ldb	r16,0(r3)
210912b8:	003da206 	br	21090944 <__flash_rwdata_start+0xfffee6fc>
210912bc:	dac02d17 	ldw	r11,180(sp)
210912c0:	db002d17 	ldw	r12,180(sp)
210912c4:	5ac00017 	ldw	r11,0(r11)
210912c8:	dac02e15 	stw	r11,184(sp)
210912cc:	62c00104 	addi	r11,r12,4
210912d0:	db002e17 	ldw	r12,184(sp)
210912d4:	6003ad16 	blt	r12,zero,2109218c <___vfprintf_internal_r+0x19dc>
210912d8:	dac02d15 	stw	r11,180(sp)
210912dc:	1805883a 	mov	r2,r3
210912e0:	1c000007 	ldb	r16,0(r3)
210912e4:	003d9706 	br	21090944 <__flash_rwdata_start+0xfffee6fc>
210912e8:	1805883a 	mov	r2,r3
210912ec:	01800ac4 	movi	r6,43
210912f0:	1c000007 	ldb	r16,0(r3)
210912f4:	003d9306 	br	21090944 <__flash_rwdata_start+0xfffee6fc>
210912f8:	db002d17 	ldw	r12,180(sp)
210912fc:	d8c02a15 	stw	r3,168(sp)
21091300:	00c00044 	movi	r3,1
21091304:	60800017 	ldw	r2,0(r12)
21091308:	63000104 	addi	r12,r12,4
2109130c:	d8c02b15 	stw	r3,172(sp)
21091310:	d8002785 	stb	zero,158(sp)
21091314:	d8801405 	stb	r2,80(sp)
21091318:	db002d15 	stw	r12,180(sp)
2109131c:	dac01404 	addi	r11,sp,80
21091320:	1825883a 	mov	r18,r3
21091324:	d8003215 	stw	zero,200(sp)
21091328:	d8003415 	stw	zero,208(sp)
2109132c:	dac03115 	stw	r11,196(sp)
21091330:	0005883a 	mov	r2,zero
21091334:	003e7806 	br	21090d18 <__flash_rwdata_start+0xfffeead0>
21091338:	dac02d17 	ldw	r11,180(sp)
2109133c:	db002d17 	ldw	r12,180(sp)
21091340:	d8c02a15 	stw	r3,168(sp)
21091344:	5ac00017 	ldw	r11,0(r11)
21091348:	d8002785 	stb	zero,158(sp)
2109134c:	64c00104 	addi	r19,r12,4
21091350:	dac03115 	stw	r11,196(sp)
21091354:	5803fe26 	beq	r11,zero,21092350 <___vfprintf_internal_r+0x1ba0>
21091358:	d9003117 	ldw	r4,196(sp)
2109135c:	4803b416 	blt	r9,zero,21092230 <___vfprintf_internal_r+0x1a80>
21091360:	480d883a 	mov	r6,r9
21091364:	000b883a 	mov	r5,zero
21091368:	da003f15 	stw	r8,252(sp)
2109136c:	da403e15 	stw	r9,248(sp)
21091370:	10958480 	call	21095848 <memchr>
21091374:	da003f17 	ldw	r8,252(sp)
21091378:	da403e17 	ldw	r9,248(sp)
2109137c:	10043026 	beq	r2,zero,21092440 <___vfprintf_internal_r+0x1c90>
21091380:	d8c03117 	ldw	r3,196(sp)
21091384:	10e5c83a 	sub	r18,r2,r3
21091388:	4c836b16 	blt	r9,r18,21092138 <___vfprintf_internal_r+0x1988>
2109138c:	9005883a 	mov	r2,r18
21091390:	9003ac16 	blt	r18,zero,21092244 <___vfprintf_internal_r+0x1a94>
21091394:	dd402783 	ldbu	r21,158(sp)
21091398:	d8802b15 	stw	r2,172(sp)
2109139c:	dcc02d15 	stw	r19,180(sp)
210913a0:	d8003215 	stw	zero,200(sp)
210913a4:	d8003415 	stw	zero,208(sp)
210913a8:	003e5406 	br	21090cfc <__flash_rwdata_start+0xfffeeab4>
210913ac:	00800034 	movhi	r2,0
210913b0:	108ed204 	addi	r2,r2,15176
210913b4:	d8c02a15 	stw	r3,168(sp)
210913b8:	d8803b15 	stw	r2,236(sp)
210913bc:	d9802785 	stb	r6,158(sp)
210913c0:	88c0080c 	andi	r3,r17,32
210913c4:	d8802d17 	ldw	r2,180(sp)
210913c8:	183fa51e 	bne	r3,zero,21091260 <__flash_rwdata_start+0xfffef018>
210913cc:	88c0040c 	andi	r3,r17,16
210913d0:	1802ee26 	beq	r3,zero,21091f8c <___vfprintf_internal_r+0x17dc>
210913d4:	db002d17 	ldw	r12,180(sp)
210913d8:	14c00017 	ldw	r19,0(r2)
210913dc:	0039883a 	mov	fp,zero
210913e0:	63000104 	addi	r12,r12,4
210913e4:	db002d15 	stw	r12,180(sp)
210913e8:	003fa206 	br	21091274 <__flash_rwdata_start+0xfffef02c>
210913ec:	8c400054 	ori	r17,r17,1
210913f0:	1805883a 	mov	r2,r3
210913f4:	1c000007 	ldb	r16,0(r3)
210913f8:	003d5206 	br	21090944 <__flash_rwdata_start+0xfffee6fc>
210913fc:	8c400814 	ori	r17,r17,32
21091400:	1805883a 	mov	r2,r3
21091404:	1c000007 	ldb	r16,0(r3)
21091408:	003d4e06 	br	21090944 <__flash_rwdata_start+0xfffee6fc>
2109140c:	d8c02a15 	stw	r3,168(sp)
21091410:	8880080c 	andi	r2,r17,32
21091414:	103f1d1e 	bne	r2,zero,2109108c <__flash_rwdata_start+0xfffeee44>
21091418:	8880040c 	andi	r2,r17,16
2109141c:	1001b81e 	bne	r2,zero,21091b00 <___vfprintf_internal_r+0x1350>
21091420:	8880100c 	andi	r2,r17,64
21091424:	1001b626 	beq	r2,zero,21091b00 <___vfprintf_internal_r+0x1350>
21091428:	dac02d17 	ldw	r11,180(sp)
2109142c:	0039883a 	mov	fp,zero
21091430:	00800044 	movi	r2,1
21091434:	5cc0000b 	ldhu	r19,0(r11)
21091438:	5ac00104 	addi	r11,r11,4
2109143c:	dac02d15 	stw	r11,180(sp)
21091440:	9807883a 	mov	r3,r19
21091444:	003f0906 	br	2109106c <__flash_rwdata_start+0xfffeee24>
21091448:	d8c02a15 	stw	r3,168(sp)
2109144c:	8880080c 	andi	r2,r17,32
21091450:	103eff1e 	bne	r2,zero,21091050 <__flash_rwdata_start+0xfffeee08>
21091454:	8880040c 	andi	r2,r17,16
21091458:	1001a11e 	bne	r2,zero,21091ae0 <___vfprintf_internal_r+0x1330>
2109145c:	8880100c 	andi	r2,r17,64
21091460:	10019f26 	beq	r2,zero,21091ae0 <___vfprintf_internal_r+0x1330>
21091464:	db002d17 	ldw	r12,180(sp)
21091468:	0039883a 	mov	fp,zero
2109146c:	0005883a 	mov	r2,zero
21091470:	64c0000b 	ldhu	r19,0(r12)
21091474:	63000104 	addi	r12,r12,4
21091478:	db002d15 	stw	r12,180(sp)
2109147c:	9807883a 	mov	r3,r19
21091480:	003efa06 	br	2109106c <__flash_rwdata_start+0xfffeee24>
21091484:	d8c02a15 	stw	r3,168(sp)
21091488:	d9802785 	stb	r6,158(sp)
2109148c:	803db626 	beq	r16,zero,21090b68 <__flash_rwdata_start+0xfffee920>
21091490:	00c00044 	movi	r3,1
21091494:	d8c02b15 	stw	r3,172(sp)
21091498:	dc001405 	stb	r16,80(sp)
2109149c:	d8002785 	stb	zero,158(sp)
210914a0:	003f9e06 	br	2109131c <__flash_rwdata_start+0xfffef0d4>
210914a4:	d8c02017 	ldw	r3,128(sp)
210914a8:	003e5306 	br	21090df8 <__flash_rwdata_start+0xfffeebb0>
210914ac:	10803fcc 	andi	r2,r2,255
210914b0:	00c00044 	movi	r3,1
210914b4:	10fdfa1e 	bne	r2,r3,21090ca0 <__flash_rwdata_start+0xfffeea58>
210914b8:	e000021e 	bne	fp,zero,210914c4 <___vfprintf_internal_r+0xd14>
210914bc:	00800244 	movi	r2,9
210914c0:	14c0202e 	bgeu	r2,r19,21091544 <___vfprintf_internal_r+0xd94>
210914c4:	dc002b15 	stw	r16,172(sp)
210914c8:	dc402c15 	stw	r17,176(sp)
210914cc:	9821883a 	mov	r16,r19
210914d0:	e023883a 	mov	r17,fp
210914d4:	dc801e04 	addi	r18,sp,120
210914d8:	4827883a 	mov	r19,r9
210914dc:	4039883a 	mov	fp,r8
210914e0:	8009883a 	mov	r4,r16
210914e4:	880b883a 	mov	r5,r17
210914e8:	01800284 	movi	r6,10
210914ec:	000f883a 	mov	r7,zero
210914f0:	109a9940 	call	2109a994 <__umoddi3>
210914f4:	10800c04 	addi	r2,r2,48
210914f8:	94bfffc4 	addi	r18,r18,-1
210914fc:	8009883a 	mov	r4,r16
21091500:	880b883a 	mov	r5,r17
21091504:	01800284 	movi	r6,10
21091508:	000f883a 	mov	r7,zero
2109150c:	90800005 	stb	r2,0(r18)
21091510:	109a3d40 	call	2109a3d4 <__udivdi3>
21091514:	1021883a 	mov	r16,r2
21091518:	10c4b03a 	or	r2,r2,r3
2109151c:	1823883a 	mov	r17,r3
21091520:	103fef1e 	bne	r2,zero,210914e0 <__flash_rwdata_start+0xfffef298>
21091524:	dac02817 	ldw	r11,160(sp)
21091528:	dc803115 	stw	r18,196(sp)
2109152c:	dc002b17 	ldw	r16,172(sp)
21091530:	dc402c17 	ldw	r17,176(sp)
21091534:	9813883a 	mov	r9,r19
21091538:	e011883a 	mov	r8,fp
2109153c:	5ca5c83a 	sub	r18,r11,r18
21091540:	003de906 	br	21090ce8 <__flash_rwdata_start+0xfffeeaa0>
21091544:	9cc00c04 	addi	r19,r19,48
21091548:	d8c01dc4 	addi	r3,sp,119
2109154c:	dcc01dc5 	stb	r19,119(sp)
21091550:	dc803c17 	ldw	r18,240(sp)
21091554:	d8c03115 	stw	r3,196(sp)
21091558:	003de306 	br	21090ce8 <__flash_rwdata_start+0xfffeeaa0>
2109155c:	00801944 	movi	r2,101
21091560:	1400710e 	bge	r2,r16,21091728 <___vfprintf_internal_r+0xf78>
21091564:	d9003717 	ldw	r4,220(sp)
21091568:	d9403917 	ldw	r5,228(sp)
2109156c:	000d883a 	mov	r6,zero
21091570:	000f883a 	mov	r7,zero
21091574:	d8c03d15 	stw	r3,244(sp)
21091578:	da003f15 	stw	r8,252(sp)
2109157c:	109af240 	call	2109af24 <__eqdf2>
21091580:	d8c03d17 	ldw	r3,244(sp)
21091584:	da003f17 	ldw	r8,252(sp)
21091588:	1000ef1e 	bne	r2,zero,21091948 <___vfprintf_internal_r+0x1198>
2109158c:	d8801f17 	ldw	r2,124(sp)
21091590:	01000034 	movhi	r4,0
21091594:	210ed904 	addi	r4,r4,15204
21091598:	18c00044 	addi	r3,r3,1
2109159c:	10800044 	addi	r2,r2,1
210915a0:	41000015 	stw	r4,0(r8)
210915a4:	01000044 	movi	r4,1
210915a8:	41000115 	stw	r4,4(r8)
210915ac:	d8c02015 	stw	r3,128(sp)
210915b0:	d8801f15 	stw	r2,124(sp)
210915b4:	010001c4 	movi	r4,7
210915b8:	20828e16 	blt	r4,r2,21091ff4 <___vfprintf_internal_r+0x1844>
210915bc:	42000204 	addi	r8,r8,8
210915c0:	d8802617 	ldw	r2,152(sp)
210915c4:	dac03317 	ldw	r11,204(sp)
210915c8:	12c00216 	blt	r2,r11,210915d4 <___vfprintf_internal_r+0xe24>
210915cc:	8880004c 	andi	r2,r17,1
210915d0:	103e5d26 	beq	r2,zero,21090f48 <__flash_rwdata_start+0xfffeed00>
210915d4:	db003817 	ldw	r12,224(sp)
210915d8:	d8801f17 	ldw	r2,124(sp)
210915dc:	dac03517 	ldw	r11,212(sp)
210915e0:	1b07883a 	add	r3,r3,r12
210915e4:	10800044 	addi	r2,r2,1
210915e8:	42c00015 	stw	r11,0(r8)
210915ec:	43000115 	stw	r12,4(r8)
210915f0:	d8c02015 	stw	r3,128(sp)
210915f4:	d8801f15 	stw	r2,124(sp)
210915f8:	010001c4 	movi	r4,7
210915fc:	2082ed16 	blt	r4,r2,210921b4 <___vfprintf_internal_r+0x1a04>
21091600:	42000204 	addi	r8,r8,8
21091604:	db003317 	ldw	r12,204(sp)
21091608:	643fffc4 	addi	r16,r12,-1
2109160c:	043e4e0e 	bge	zero,r16,21090f48 <__flash_rwdata_start+0xfffeed00>
21091610:	04800404 	movi	r18,16
21091614:	d8801f17 	ldw	r2,124(sp)
21091618:	94007e0e 	bge	r18,r16,21091814 <___vfprintf_internal_r+0x1064>
2109161c:	01400034 	movhi	r5,0
21091620:	294ee184 	addi	r5,r5,15238
21091624:	d9402c15 	stw	r5,176(sp)
21091628:	054001c4 	movi	r21,7
2109162c:	00000306 	br	2109163c <___vfprintf_internal_r+0xe8c>
21091630:	42000204 	addi	r8,r8,8
21091634:	843ffc04 	addi	r16,r16,-16
21091638:	9400790e 	bge	r18,r16,21091820 <___vfprintf_internal_r+0x1070>
2109163c:	18c00404 	addi	r3,r3,16
21091640:	10800044 	addi	r2,r2,1
21091644:	45000015 	stw	r20,0(r8)
21091648:	44800115 	stw	r18,4(r8)
2109164c:	d8c02015 	stw	r3,128(sp)
21091650:	d8801f15 	stw	r2,124(sp)
21091654:	a8bff60e 	bge	r21,r2,21091630 <__flash_rwdata_start+0xfffef3e8>
21091658:	b009883a 	mov	r4,r22
2109165c:	b80b883a 	mov	r5,r23
21091660:	d9801e04 	addi	r6,sp,120
21091664:	10987140 	call	21098714 <__sprint_r>
21091668:	103d451e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
2109166c:	d8c02017 	ldw	r3,128(sp)
21091670:	d8801f17 	ldw	r2,124(sp)
21091674:	da000404 	addi	r8,sp,16
21091678:	003fee06 	br	21091634 <__flash_rwdata_start+0xfffef3ec>
2109167c:	dac02e17 	ldw	r11,184(sp)
21091680:	db002b17 	ldw	r12,172(sp)
21091684:	5b2bc83a 	sub	r21,r11,r12
21091688:	057df90e 	bge	zero,r21,21090e70 <__flash_rwdata_start+0xfffeec28>
2109168c:	07000404 	movi	fp,16
21091690:	d8801f17 	ldw	r2,124(sp)
21091694:	e543640e 	bge	fp,r21,21092428 <___vfprintf_internal_r+0x1c78>
21091698:	01400034 	movhi	r5,0
2109169c:	294ee184 	addi	r5,r5,15238
210916a0:	d9402c15 	stw	r5,176(sp)
210916a4:	04c001c4 	movi	r19,7
210916a8:	00000306 	br	210916b8 <___vfprintf_internal_r+0xf08>
210916ac:	ad7ffc04 	addi	r21,r21,-16
210916b0:	42000204 	addi	r8,r8,8
210916b4:	e540110e 	bge	fp,r21,210916fc <___vfprintf_internal_r+0xf4c>
210916b8:	18c00404 	addi	r3,r3,16
210916bc:	10800044 	addi	r2,r2,1
210916c0:	45000015 	stw	r20,0(r8)
210916c4:	47000115 	stw	fp,4(r8)
210916c8:	d8c02015 	stw	r3,128(sp)
210916cc:	d8801f15 	stw	r2,124(sp)
210916d0:	98bff60e 	bge	r19,r2,210916ac <__flash_rwdata_start+0xfffef464>
210916d4:	b009883a 	mov	r4,r22
210916d8:	b80b883a 	mov	r5,r23
210916dc:	d9801e04 	addi	r6,sp,120
210916e0:	10987140 	call	21098714 <__sprint_r>
210916e4:	103d261e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
210916e8:	ad7ffc04 	addi	r21,r21,-16
210916ec:	d8c02017 	ldw	r3,128(sp)
210916f0:	d8801f17 	ldw	r2,124(sp)
210916f4:	da000404 	addi	r8,sp,16
210916f8:	e57fef16 	blt	fp,r21,210916b8 <__flash_rwdata_start+0xfffef470>
210916fc:	dac02c17 	ldw	r11,176(sp)
21091700:	1d47883a 	add	r3,r3,r21
21091704:	10800044 	addi	r2,r2,1
21091708:	42c00015 	stw	r11,0(r8)
2109170c:	45400115 	stw	r21,4(r8)
21091710:	d8c02015 	stw	r3,128(sp)
21091714:	d8801f15 	stw	r2,124(sp)
21091718:	010001c4 	movi	r4,7
2109171c:	20819116 	blt	r4,r2,21091d64 <___vfprintf_internal_r+0x15b4>
21091720:	42000204 	addi	r8,r8,8
21091724:	003dd206 	br	21090e70 <__flash_rwdata_start+0xfffeec28>
21091728:	db003317 	ldw	r12,204(sp)
2109172c:	00800044 	movi	r2,1
21091730:	18c00044 	addi	r3,r3,1
21091734:	1301530e 	bge	r2,r12,21091c84 <___vfprintf_internal_r+0x14d4>
21091738:	dc001f17 	ldw	r16,124(sp)
2109173c:	dac03117 	ldw	r11,196(sp)
21091740:	00800044 	movi	r2,1
21091744:	84000044 	addi	r16,r16,1
21091748:	40800115 	stw	r2,4(r8)
2109174c:	42c00015 	stw	r11,0(r8)
21091750:	d8c02015 	stw	r3,128(sp)
21091754:	dc001f15 	stw	r16,124(sp)
21091758:	008001c4 	movi	r2,7
2109175c:	14016b16 	blt	r2,r16,21091d0c <___vfprintf_internal_r+0x155c>
21091760:	42000204 	addi	r8,r8,8
21091764:	db003817 	ldw	r12,224(sp)
21091768:	dac03517 	ldw	r11,212(sp)
2109176c:	84000044 	addi	r16,r16,1
21091770:	1b07883a 	add	r3,r3,r12
21091774:	42c00015 	stw	r11,0(r8)
21091778:	43000115 	stw	r12,4(r8)
2109177c:	d8c02015 	stw	r3,128(sp)
21091780:	dc001f15 	stw	r16,124(sp)
21091784:	008001c4 	movi	r2,7
21091788:	14016916 	blt	r2,r16,21091d30 <___vfprintf_internal_r+0x1580>
2109178c:	44800204 	addi	r18,r8,8
21091790:	d9003717 	ldw	r4,220(sp)
21091794:	d9403917 	ldw	r5,228(sp)
21091798:	000d883a 	mov	r6,zero
2109179c:	000f883a 	mov	r7,zero
210917a0:	d8c03d15 	stw	r3,244(sp)
210917a4:	109af240 	call	2109af24 <__eqdf2>
210917a8:	d8c03d17 	ldw	r3,244(sp)
210917ac:	db003317 	ldw	r12,204(sp)
210917b0:	1000ad26 	beq	r2,zero,21091a68 <___vfprintf_internal_r+0x12b8>
210917b4:	dac03117 	ldw	r11,196(sp)
210917b8:	60bfffc4 	addi	r2,r12,-1
210917bc:	1887883a 	add	r3,r3,r2
210917c0:	59000044 	addi	r4,r11,1
210917c4:	84000044 	addi	r16,r16,1
210917c8:	90800115 	stw	r2,4(r18)
210917cc:	91000015 	stw	r4,0(r18)
210917d0:	d8c02015 	stw	r3,128(sp)
210917d4:	dc001f15 	stw	r16,124(sp)
210917d8:	008001c4 	movi	r2,7
210917dc:	14014216 	blt	r2,r16,21091ce8 <___vfprintf_internal_r+0x1538>
210917e0:	94800204 	addi	r18,r18,8
210917e4:	dac03a17 	ldw	r11,232(sp)
210917e8:	dd4022c4 	addi	r21,sp,139
210917ec:	84000044 	addi	r16,r16,1
210917f0:	1ac7883a 	add	r3,r3,r11
210917f4:	95400015 	stw	r21,0(r18)
210917f8:	92c00115 	stw	r11,4(r18)
210917fc:	d8c02015 	stw	r3,128(sp)
21091800:	dc001f15 	stw	r16,124(sp)
21091804:	008001c4 	movi	r2,7
21091808:	14000e16 	blt	r2,r16,21091844 <___vfprintf_internal_r+0x1094>
2109180c:	92000204 	addi	r8,r18,8
21091810:	003dcd06 	br	21090f48 <__flash_rwdata_start+0xfffeed00>
21091814:	01000034 	movhi	r4,0
21091818:	210ee184 	addi	r4,r4,15238
2109181c:	d9002c15 	stw	r4,176(sp)
21091820:	dac02c17 	ldw	r11,176(sp)
21091824:	1c07883a 	add	r3,r3,r16
21091828:	44000115 	stw	r16,4(r8)
2109182c:	42c00015 	stw	r11,0(r8)
21091830:	10800044 	addi	r2,r2,1
21091834:	d8c02015 	stw	r3,128(sp)
21091838:	d8801f15 	stw	r2,124(sp)
2109183c:	010001c4 	movi	r4,7
21091840:	20bdc00e 	bge	r4,r2,21090f44 <__flash_rwdata_start+0xfffeecfc>
21091844:	b009883a 	mov	r4,r22
21091848:	b80b883a 	mov	r5,r23
2109184c:	d9801e04 	addi	r6,sp,120
21091850:	10987140 	call	21098714 <__sprint_r>
21091854:	103cca1e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
21091858:	d8c02017 	ldw	r3,128(sp)
2109185c:	da000404 	addi	r8,sp,16
21091860:	003db906 	br	21090f48 <__flash_rwdata_start+0xfffeed00>
21091864:	b009883a 	mov	r4,r22
21091868:	b80b883a 	mov	r5,r23
2109186c:	d9801e04 	addi	r6,sp,120
21091870:	10987140 	call	21098714 <__sprint_r>
21091874:	103def26 	beq	r2,zero,21091034 <__flash_rwdata_start+0xfffeedec>
21091878:	003cc106 	br	21090b80 <__flash_rwdata_start+0xfffee938>
2109187c:	10803fcc 	andi	r2,r2,255
21091880:	1000651e 	bne	r2,zero,21091a18 <___vfprintf_internal_r+0x1268>
21091884:	8880004c 	andi	r2,r17,1
21091888:	10013226 	beq	r2,zero,21091d54 <___vfprintf_internal_r+0x15a4>
2109188c:	00800c04 	movi	r2,48
21091890:	d8c01dc4 	addi	r3,sp,119
21091894:	d8801dc5 	stb	r2,119(sp)
21091898:	dc803c17 	ldw	r18,240(sp)
2109189c:	d8c03115 	stw	r3,196(sp)
210918a0:	003d1106 	br	21090ce8 <__flash_rwdata_start+0xfffeeaa0>
210918a4:	b009883a 	mov	r4,r22
210918a8:	b80b883a 	mov	r5,r23
210918ac:	d9801e04 	addi	r6,sp,120
210918b0:	10987140 	call	21098714 <__sprint_r>
210918b4:	103cb21e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
210918b8:	d8c02017 	ldw	r3,128(sp)
210918bc:	da000404 	addi	r8,sp,16
210918c0:	003d9406 	br	21090f14 <__flash_rwdata_start+0xfffeeccc>
210918c4:	b009883a 	mov	r4,r22
210918c8:	b80b883a 	mov	r5,r23
210918cc:	d9801e04 	addi	r6,sp,120
210918d0:	10987140 	call	21098714 <__sprint_r>
210918d4:	103caa1e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
210918d8:	d8c02017 	ldw	r3,128(sp)
210918dc:	da000404 	addi	r8,sp,16
210918e0:	003d5206 	br	21090e2c <__flash_rwdata_start+0xfffeebe4>
210918e4:	b009883a 	mov	r4,r22
210918e8:	b80b883a 	mov	r5,r23
210918ec:	d9801e04 	addi	r6,sp,120
210918f0:	10987140 	call	21098714 <__sprint_r>
210918f4:	103ca21e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
210918f8:	d8c02017 	ldw	r3,128(sp)
210918fc:	da000404 	addi	r8,sp,16
21091900:	003d5806 	br	21090e64 <__flash_rwdata_start+0xfffeec1c>
21091904:	d9403b17 	ldw	r5,236(sp)
21091908:	d8c01e04 	addi	r3,sp,120
2109190c:	988003cc 	andi	r2,r19,15
21091910:	e008973a 	slli	r4,fp,28
21091914:	2885883a 	add	r2,r5,r2
21091918:	9826d13a 	srli	r19,r19,4
2109191c:	10800003 	ldbu	r2,0(r2)
21091920:	e038d13a 	srli	fp,fp,4
21091924:	18ffffc4 	addi	r3,r3,-1
21091928:	24e6b03a 	or	r19,r4,r19
2109192c:	18800005 	stb	r2,0(r3)
21091930:	9f04b03a 	or	r2,r19,fp
21091934:	103ff51e 	bne	r2,zero,2109190c <__flash_rwdata_start+0xfffef6c4>
21091938:	db002817 	ldw	r12,160(sp)
2109193c:	d8c03115 	stw	r3,196(sp)
21091940:	60e5c83a 	sub	r18,r12,r3
21091944:	003ce806 	br	21090ce8 <__flash_rwdata_start+0xfffeeaa0>
21091948:	dc002617 	ldw	r16,152(sp)
2109194c:	0401b10e 	bge	zero,r16,21092014 <___vfprintf_internal_r+0x1864>
21091950:	db003117 	ldw	r12,196(sp)
21091954:	dac03317 	ldw	r11,204(sp)
21091958:	62e1883a 	add	r16,r12,r11
2109195c:	db003417 	ldw	r12,208(sp)
21091960:	5825883a 	mov	r18,r11
21091964:	62c0010e 	bge	r12,r11,2109196c <___vfprintf_internal_r+0x11bc>
21091968:	6025883a 	mov	r18,r12
2109196c:	04800b0e 	bge	zero,r18,2109199c <___vfprintf_internal_r+0x11ec>
21091970:	d8801f17 	ldw	r2,124(sp)
21091974:	dac03117 	ldw	r11,196(sp)
21091978:	1c87883a 	add	r3,r3,r18
2109197c:	10800044 	addi	r2,r2,1
21091980:	42c00015 	stw	r11,0(r8)
21091984:	44800115 	stw	r18,4(r8)
21091988:	d8c02015 	stw	r3,128(sp)
2109198c:	d8801f15 	stw	r2,124(sp)
21091990:	010001c4 	movi	r4,7
21091994:	20824f16 	blt	r4,r2,210922d4 <___vfprintf_internal_r+0x1b24>
21091998:	42000204 	addi	r8,r8,8
2109199c:	90024b16 	blt	r18,zero,210922cc <___vfprintf_internal_r+0x1b1c>
210919a0:	db003417 	ldw	r12,208(sp)
210919a4:	64a5c83a 	sub	r18,r12,r18
210919a8:	0480730e 	bge	zero,r18,21091b78 <___vfprintf_internal_r+0x13c8>
210919ac:	05400404 	movi	r21,16
210919b0:	d8801f17 	ldw	r2,124(sp)
210919b4:	ac817d0e 	bge	r21,r18,21091fac <___vfprintf_internal_r+0x17fc>
210919b8:	01400034 	movhi	r5,0
210919bc:	294ee184 	addi	r5,r5,15238
210919c0:	d9402c15 	stw	r5,176(sp)
210919c4:	070001c4 	movi	fp,7
210919c8:	00000306 	br	210919d8 <___vfprintf_internal_r+0x1228>
210919cc:	42000204 	addi	r8,r8,8
210919d0:	94bffc04 	addi	r18,r18,-16
210919d4:	ac81780e 	bge	r21,r18,21091fb8 <___vfprintf_internal_r+0x1808>
210919d8:	18c00404 	addi	r3,r3,16
210919dc:	10800044 	addi	r2,r2,1
210919e0:	45000015 	stw	r20,0(r8)
210919e4:	45400115 	stw	r21,4(r8)
210919e8:	d8c02015 	stw	r3,128(sp)
210919ec:	d8801f15 	stw	r2,124(sp)
210919f0:	e0bff60e 	bge	fp,r2,210919cc <__flash_rwdata_start+0xfffef784>
210919f4:	b009883a 	mov	r4,r22
210919f8:	b80b883a 	mov	r5,r23
210919fc:	d9801e04 	addi	r6,sp,120
21091a00:	10987140 	call	21098714 <__sprint_r>
21091a04:	103c5e1e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
21091a08:	d8c02017 	ldw	r3,128(sp)
21091a0c:	d8801f17 	ldw	r2,124(sp)
21091a10:	da000404 	addi	r8,sp,16
21091a14:	003fee06 	br	210919d0 <__flash_rwdata_start+0xfffef788>
21091a18:	dac01e04 	addi	r11,sp,120
21091a1c:	0025883a 	mov	r18,zero
21091a20:	dac03115 	stw	r11,196(sp)
21091a24:	003cb006 	br	21090ce8 <__flash_rwdata_start+0xfffeeaa0>
21091a28:	b009883a 	mov	r4,r22
21091a2c:	b80b883a 	mov	r5,r23
21091a30:	d9801e04 	addi	r6,sp,120
21091a34:	10987140 	call	21098714 <__sprint_r>
21091a38:	103c511e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
21091a3c:	d8c02017 	ldw	r3,128(sp)
21091a40:	d8802787 	ldb	r2,158(sp)
21091a44:	da000404 	addi	r8,sp,16
21091a48:	003ceb06 	br	21090df8 <__flash_rwdata_start+0xfffeebb0>
21091a4c:	1cc00017 	ldw	r19,0(r3)
21091a50:	dac02d17 	ldw	r11,180(sp)
21091a54:	9839d7fa 	srai	fp,r19,31
21091a58:	5ac00104 	addi	r11,r11,4
21091a5c:	dac02d15 	stw	r11,180(sp)
21091a60:	e005883a 	mov	r2,fp
21091a64:	003c8106 	br	21090c6c <__flash_rwdata_start+0xfffeea24>
21091a68:	657fffc4 	addi	r21,r12,-1
21091a6c:	057f5d0e 	bge	zero,r21,210917e4 <__flash_rwdata_start+0xfffef59c>
21091a70:	07000404 	movi	fp,16
21091a74:	e540900e 	bge	fp,r21,21091cb8 <___vfprintf_internal_r+0x1508>
21091a78:	01000034 	movhi	r4,0
21091a7c:	210ee184 	addi	r4,r4,15238
21091a80:	d9002c15 	stw	r4,176(sp)
21091a84:	01c001c4 	movi	r7,7
21091a88:	00000306 	br	21091a98 <___vfprintf_internal_r+0x12e8>
21091a8c:	94800204 	addi	r18,r18,8
21091a90:	ad7ffc04 	addi	r21,r21,-16
21091a94:	e5408b0e 	bge	fp,r21,21091cc4 <___vfprintf_internal_r+0x1514>
21091a98:	18c00404 	addi	r3,r3,16
21091a9c:	84000044 	addi	r16,r16,1
21091aa0:	95000015 	stw	r20,0(r18)
21091aa4:	97000115 	stw	fp,4(r18)
21091aa8:	d8c02015 	stw	r3,128(sp)
21091aac:	dc001f15 	stw	r16,124(sp)
21091ab0:	3c3ff60e 	bge	r7,r16,21091a8c <__flash_rwdata_start+0xfffef844>
21091ab4:	b009883a 	mov	r4,r22
21091ab8:	b80b883a 	mov	r5,r23
21091abc:	d9801e04 	addi	r6,sp,120
21091ac0:	d9c03d15 	stw	r7,244(sp)
21091ac4:	10987140 	call	21098714 <__sprint_r>
21091ac8:	d9c03d17 	ldw	r7,244(sp)
21091acc:	103c2c1e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
21091ad0:	d8c02017 	ldw	r3,128(sp)
21091ad4:	dc001f17 	ldw	r16,124(sp)
21091ad8:	dc800404 	addi	r18,sp,16
21091adc:	003fec06 	br	21091a90 <__flash_rwdata_start+0xfffef848>
21091ae0:	dac02d17 	ldw	r11,180(sp)
21091ae4:	0039883a 	mov	fp,zero
21091ae8:	0005883a 	mov	r2,zero
21091aec:	5cc00017 	ldw	r19,0(r11)
21091af0:	5ac00104 	addi	r11,r11,4
21091af4:	dac02d15 	stw	r11,180(sp)
21091af8:	9807883a 	mov	r3,r19
21091afc:	003d5b06 	br	2109106c <__flash_rwdata_start+0xfffeee24>
21091b00:	db002d17 	ldw	r12,180(sp)
21091b04:	0039883a 	mov	fp,zero
21091b08:	00800044 	movi	r2,1
21091b0c:	64c00017 	ldw	r19,0(r12)
21091b10:	63000104 	addi	r12,r12,4
21091b14:	db002d15 	stw	r12,180(sp)
21091b18:	9807883a 	mov	r3,r19
21091b1c:	003d5306 	br	2109106c <__flash_rwdata_start+0xfffeee24>
21091b20:	00800084 	movi	r2,2
21091b24:	9f06b03a 	or	r3,r19,fp
21091b28:	003d5006 	br	2109106c <__flash_rwdata_start+0xfffeee24>
21091b2c:	10803fcc 	andi	r2,r2,255
21091b30:	1080201c 	xori	r2,r2,128
21091b34:	10bfe004 	addi	r2,r2,-128
21091b38:	01000c04 	movi	r4,48
21091b3c:	1101a526 	beq	r2,r4,210921d4 <___vfprintf_internal_r+0x1a24>
21091b40:	dac03117 	ldw	r11,196(sp)
21091b44:	db002817 	ldw	r12,160(sp)
21091b48:	193fffc5 	stb	r4,-1(r3)
21091b4c:	5affffc4 	addi	r11,r11,-1
21091b50:	dac03115 	stw	r11,196(sp)
21091b54:	62e5c83a 	sub	r18,r12,r11
21091b58:	003c6306 	br	21090ce8 <__flash_rwdata_start+0xfffeeaa0>
21091b5c:	b009883a 	mov	r4,r22
21091b60:	b80b883a 	mov	r5,r23
21091b64:	d9801e04 	addi	r6,sp,120
21091b68:	10987140 	call	21098714 <__sprint_r>
21091b6c:	103c041e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
21091b70:	d8c02017 	ldw	r3,128(sp)
21091b74:	da000404 	addi	r8,sp,16
21091b78:	db003117 	ldw	r12,196(sp)
21091b7c:	dac03417 	ldw	r11,208(sp)
21091b80:	d8802617 	ldw	r2,152(sp)
21091b84:	62e5883a 	add	r18,r12,r11
21091b88:	db003317 	ldw	r12,204(sp)
21091b8c:	13000216 	blt	r2,r12,21091b98 <___vfprintf_internal_r+0x13e8>
21091b90:	8900004c 	andi	r4,r17,1
21091b94:	20000c26 	beq	r4,zero,21091bc8 <___vfprintf_internal_r+0x1418>
21091b98:	dac03817 	ldw	r11,224(sp)
21091b9c:	d9001f17 	ldw	r4,124(sp)
21091ba0:	db003517 	ldw	r12,212(sp)
21091ba4:	1ac7883a 	add	r3,r3,r11
21091ba8:	21000044 	addi	r4,r4,1
21091bac:	43000015 	stw	r12,0(r8)
21091bb0:	42c00115 	stw	r11,4(r8)
21091bb4:	d8c02015 	stw	r3,128(sp)
21091bb8:	d9001f15 	stw	r4,124(sp)
21091bbc:	014001c4 	movi	r5,7
21091bc0:	2901cc16 	blt	r5,r4,210922f4 <___vfprintf_internal_r+0x1b44>
21091bc4:	42000204 	addi	r8,r8,8
21091bc8:	dac03317 	ldw	r11,204(sp)
21091bcc:	8489c83a 	sub	r4,r16,r18
21091bd0:	5885c83a 	sub	r2,r11,r2
21091bd4:	1021883a 	mov	r16,r2
21091bd8:	2080010e 	bge	r4,r2,21091be0 <___vfprintf_internal_r+0x1430>
21091bdc:	2021883a 	mov	r16,r4
21091be0:	04000a0e 	bge	zero,r16,21091c0c <___vfprintf_internal_r+0x145c>
21091be4:	d9001f17 	ldw	r4,124(sp)
21091be8:	1c07883a 	add	r3,r3,r16
21091bec:	44800015 	stw	r18,0(r8)
21091bf0:	21000044 	addi	r4,r4,1
21091bf4:	44000115 	stw	r16,4(r8)
21091bf8:	d8c02015 	stw	r3,128(sp)
21091bfc:	d9001f15 	stw	r4,124(sp)
21091c00:	014001c4 	movi	r5,7
21091c04:	2901e316 	blt	r5,r4,21092394 <___vfprintf_internal_r+0x1be4>
21091c08:	42000204 	addi	r8,r8,8
21091c0c:	8001df16 	blt	r16,zero,2109238c <___vfprintf_internal_r+0x1bdc>
21091c10:	1421c83a 	sub	r16,r2,r16
21091c14:	043ccc0e 	bge	zero,r16,21090f48 <__flash_rwdata_start+0xfffeed00>
21091c18:	04800404 	movi	r18,16
21091c1c:	d8801f17 	ldw	r2,124(sp)
21091c20:	943efc0e 	bge	r18,r16,21091814 <__flash_rwdata_start+0xfffef5cc>
21091c24:	01400034 	movhi	r5,0
21091c28:	294ee184 	addi	r5,r5,15238
21091c2c:	d9402c15 	stw	r5,176(sp)
21091c30:	054001c4 	movi	r21,7
21091c34:	00000306 	br	21091c44 <___vfprintf_internal_r+0x1494>
21091c38:	42000204 	addi	r8,r8,8
21091c3c:	843ffc04 	addi	r16,r16,-16
21091c40:	943ef70e 	bge	r18,r16,21091820 <__flash_rwdata_start+0xfffef5d8>
21091c44:	18c00404 	addi	r3,r3,16
21091c48:	10800044 	addi	r2,r2,1
21091c4c:	45000015 	stw	r20,0(r8)
21091c50:	44800115 	stw	r18,4(r8)
21091c54:	d8c02015 	stw	r3,128(sp)
21091c58:	d8801f15 	stw	r2,124(sp)
21091c5c:	a8bff60e 	bge	r21,r2,21091c38 <__flash_rwdata_start+0xfffef9f0>
21091c60:	b009883a 	mov	r4,r22
21091c64:	b80b883a 	mov	r5,r23
21091c68:	d9801e04 	addi	r6,sp,120
21091c6c:	10987140 	call	21098714 <__sprint_r>
21091c70:	103bc31e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
21091c74:	d8c02017 	ldw	r3,128(sp)
21091c78:	d8801f17 	ldw	r2,124(sp)
21091c7c:	da000404 	addi	r8,sp,16
21091c80:	003fee06 	br	21091c3c <__flash_rwdata_start+0xfffef9f4>
21091c84:	8888703a 	and	r4,r17,r2
21091c88:	203eab1e 	bne	r4,zero,21091738 <__flash_rwdata_start+0xfffef4f0>
21091c8c:	dc001f17 	ldw	r16,124(sp)
21091c90:	db003117 	ldw	r12,196(sp)
21091c94:	40800115 	stw	r2,4(r8)
21091c98:	84000044 	addi	r16,r16,1
21091c9c:	43000015 	stw	r12,0(r8)
21091ca0:	d8c02015 	stw	r3,128(sp)
21091ca4:	dc001f15 	stw	r16,124(sp)
21091ca8:	008001c4 	movi	r2,7
21091cac:	14000e16 	blt	r2,r16,21091ce8 <___vfprintf_internal_r+0x1538>
21091cb0:	44800204 	addi	r18,r8,8
21091cb4:	003ecb06 	br	210917e4 <__flash_rwdata_start+0xfffef59c>
21091cb8:	00800034 	movhi	r2,0
21091cbc:	108ee184 	addi	r2,r2,15238
21091cc0:	d8802c15 	stw	r2,176(sp)
21091cc4:	dac02c17 	ldw	r11,176(sp)
21091cc8:	1d47883a 	add	r3,r3,r21
21091ccc:	84000044 	addi	r16,r16,1
21091cd0:	92c00015 	stw	r11,0(r18)
21091cd4:	95400115 	stw	r21,4(r18)
21091cd8:	d8c02015 	stw	r3,128(sp)
21091cdc:	dc001f15 	stw	r16,124(sp)
21091ce0:	008001c4 	movi	r2,7
21091ce4:	143ebe0e 	bge	r2,r16,210917e0 <__flash_rwdata_start+0xfffef598>
21091ce8:	b009883a 	mov	r4,r22
21091cec:	b80b883a 	mov	r5,r23
21091cf0:	d9801e04 	addi	r6,sp,120
21091cf4:	10987140 	call	21098714 <__sprint_r>
21091cf8:	103ba11e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
21091cfc:	d8c02017 	ldw	r3,128(sp)
21091d00:	dc001f17 	ldw	r16,124(sp)
21091d04:	dc800404 	addi	r18,sp,16
21091d08:	003eb606 	br	210917e4 <__flash_rwdata_start+0xfffef59c>
21091d0c:	b009883a 	mov	r4,r22
21091d10:	b80b883a 	mov	r5,r23
21091d14:	d9801e04 	addi	r6,sp,120
21091d18:	10987140 	call	21098714 <__sprint_r>
21091d1c:	103b981e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
21091d20:	d8c02017 	ldw	r3,128(sp)
21091d24:	dc001f17 	ldw	r16,124(sp)
21091d28:	da000404 	addi	r8,sp,16
21091d2c:	003e8d06 	br	21091764 <__flash_rwdata_start+0xfffef51c>
21091d30:	b009883a 	mov	r4,r22
21091d34:	b80b883a 	mov	r5,r23
21091d38:	d9801e04 	addi	r6,sp,120
21091d3c:	10987140 	call	21098714 <__sprint_r>
21091d40:	103b8f1e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
21091d44:	d8c02017 	ldw	r3,128(sp)
21091d48:	dc001f17 	ldw	r16,124(sp)
21091d4c:	dc800404 	addi	r18,sp,16
21091d50:	003e8f06 	br	21091790 <__flash_rwdata_start+0xfffef548>
21091d54:	db001e04 	addi	r12,sp,120
21091d58:	0025883a 	mov	r18,zero
21091d5c:	db003115 	stw	r12,196(sp)
21091d60:	003be106 	br	21090ce8 <__flash_rwdata_start+0xfffeeaa0>
21091d64:	b009883a 	mov	r4,r22
21091d68:	b80b883a 	mov	r5,r23
21091d6c:	d9801e04 	addi	r6,sp,120
21091d70:	10987140 	call	21098714 <__sprint_r>
21091d74:	103b821e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
21091d78:	d8c02017 	ldw	r3,128(sp)
21091d7c:	da000404 	addi	r8,sp,16
21091d80:	003c3b06 	br	21090e70 <__flash_rwdata_start+0xfffeec28>
21091d84:	04e7c83a 	sub	r19,zero,r19
21091d88:	9804c03a 	cmpne	r2,r19,zero
21091d8c:	0739c83a 	sub	fp,zero,fp
21091d90:	e0b9c83a 	sub	fp,fp,r2
21091d94:	05400b44 	movi	r21,45
21091d98:	dd402785 	stb	r21,158(sp)
21091d9c:	da403215 	stw	r9,200(sp)
21091da0:	00800044 	movi	r2,1
21091da4:	9f06b03a 	or	r3,r19,fp
21091da8:	003bb506 	br	21090c80 <__flash_rwdata_start+0xfffeea38>
21091dac:	da003f15 	stw	r8,252(sp)
21091db0:	da403e15 	stw	r9,248(sp)
21091db4:	10971000 	call	21097100 <__fpclassifyd>
21091db8:	da003f17 	ldw	r8,252(sp)
21091dbc:	da403e17 	ldw	r9,248(sp)
21091dc0:	1000ce26 	beq	r2,zero,210920fc <___vfprintf_internal_r+0x194c>
21091dc4:	057ff7c4 	movi	r21,-33
21091dc8:	00bfffc4 	movi	r2,-1
21091dcc:	856a703a 	and	r21,r16,r21
21091dd0:	4881e826 	beq	r9,r2,21092574 <___vfprintf_internal_r+0x1dc4>
21091dd4:	008011c4 	movi	r2,71
21091dd8:	a881e326 	beq	r21,r2,21092568 <___vfprintf_internal_r+0x1db8>
21091ddc:	db003917 	ldw	r12,228(sp)
21091de0:	8ac04014 	ori	r11,r17,256
21091de4:	dac02d15 	stw	r11,180(sp)
21091de8:	6001ed16 	blt	r12,zero,210925a0 <___vfprintf_internal_r+0x1df0>
21091dec:	dc803917 	ldw	r18,228(sp)
21091df0:	d8002b05 	stb	zero,172(sp)
21091df4:	00801984 	movi	r2,102
21091df8:	80811826 	beq	r16,r2,2109225c <___vfprintf_internal_r+0x1aac>
21091dfc:	00801184 	movi	r2,70
21091e00:	80811626 	beq	r16,r2,2109225c <___vfprintf_internal_r+0x1aac>
21091e04:	00801144 	movi	r2,69
21091e08:	a881e926 	beq	r21,r2,210925b0 <___vfprintf_internal_r+0x1e00>
21091e0c:	4839883a 	mov	fp,r9
21091e10:	d8802604 	addi	r2,sp,152
21091e14:	d8800115 	stw	r2,4(sp)
21091e18:	d9403717 	ldw	r5,220(sp)
21091e1c:	d8802504 	addi	r2,sp,148
21091e20:	d8800215 	stw	r2,8(sp)
21091e24:	d8802104 	addi	r2,sp,132
21091e28:	df000015 	stw	fp,0(sp)
21091e2c:	d8800315 	stw	r2,12(sp)
21091e30:	b009883a 	mov	r4,r22
21091e34:	900d883a 	mov	r6,r18
21091e38:	01c00084 	movi	r7,2
21091e3c:	da003f15 	stw	r8,252(sp)
21091e40:	da403e15 	stw	r9,248(sp)
21091e44:	1092df80 	call	21092df8 <_dtoa_r>
21091e48:	d8803115 	stw	r2,196(sp)
21091e4c:	008019c4 	movi	r2,103
21091e50:	da003f17 	ldw	r8,252(sp)
21091e54:	da403e17 	ldw	r9,248(sp)
21091e58:	80800226 	beq	r16,r2,21091e64 <___vfprintf_internal_r+0x16b4>
21091e5c:	008011c4 	movi	r2,71
21091e60:	8081101e 	bne	r16,r2,210922a4 <___vfprintf_internal_r+0x1af4>
21091e64:	8880004c 	andi	r2,r17,1
21091e68:	1001dd26 	beq	r2,zero,210925e0 <___vfprintf_internal_r+0x1e30>
21091e6c:	db003117 	ldw	r12,196(sp)
21091e70:	6715883a 	add	r10,r12,fp
21091e74:	d9003717 	ldw	r4,220(sp)
21091e78:	900b883a 	mov	r5,r18
21091e7c:	000d883a 	mov	r6,zero
21091e80:	000f883a 	mov	r7,zero
21091e84:	da003f15 	stw	r8,252(sp)
21091e88:	da403e15 	stw	r9,248(sp)
21091e8c:	da803d15 	stw	r10,244(sp)
21091e90:	109af240 	call	2109af24 <__eqdf2>
21091e94:	da003f17 	ldw	r8,252(sp)
21091e98:	da403e17 	ldw	r9,248(sp)
21091e9c:	da803d17 	ldw	r10,244(sp)
21091ea0:	10016526 	beq	r2,zero,21092438 <___vfprintf_internal_r+0x1c88>
21091ea4:	d8802117 	ldw	r2,132(sp)
21091ea8:	1280062e 	bgeu	r2,r10,21091ec4 <___vfprintf_internal_r+0x1714>
21091eac:	01000c04 	movi	r4,48
21091eb0:	10c00044 	addi	r3,r2,1
21091eb4:	d8c02115 	stw	r3,132(sp)
21091eb8:	11000005 	stb	r4,0(r2)
21091ebc:	d8802117 	ldw	r2,132(sp)
21091ec0:	12bffb36 	bltu	r2,r10,21091eb0 <__flash_rwdata_start+0xfffefc68>
21091ec4:	db003117 	ldw	r12,196(sp)
21091ec8:	1305c83a 	sub	r2,r2,r12
21091ecc:	d8803315 	stw	r2,204(sp)
21091ed0:	008011c4 	movi	r2,71
21091ed4:	a8814d26 	beq	r21,r2,2109240c <___vfprintf_internal_r+0x1c5c>
21091ed8:	00801944 	movi	r2,101
21091edc:	1402060e 	bge	r2,r16,210926f8 <___vfprintf_internal_r+0x1f48>
21091ee0:	00801984 	movi	r2,102
21091ee4:	8081b426 	beq	r16,r2,210925b8 <___vfprintf_internal_r+0x1e08>
21091ee8:	db002617 	ldw	r12,152(sp)
21091eec:	db003415 	stw	r12,208(sp)
21091ef0:	db003417 	ldw	r12,208(sp)
21091ef4:	dac03317 	ldw	r11,204(sp)
21091ef8:	62c1a016 	blt	r12,r11,2109257c <___vfprintf_internal_r+0x1dcc>
21091efc:	8c40004c 	andi	r17,r17,1
21091f00:	8801bf1e 	bne	r17,zero,21092600 <___vfprintf_internal_r+0x1e50>
21091f04:	6005883a 	mov	r2,r12
21091f08:	6001b316 	blt	r12,zero,210925d8 <___vfprintf_internal_r+0x1e28>
21091f0c:	dc803417 	ldw	r18,208(sp)
21091f10:	df002b07 	ldb	fp,172(sp)
21091f14:	e0012e1e 	bne	fp,zero,210923d0 <___vfprintf_internal_r+0x1c20>
21091f18:	dc402d17 	ldw	r17,180(sp)
21091f1c:	dd402783 	ldbu	r21,158(sp)
21091f20:	d8802b15 	stw	r2,172(sp)
21091f24:	dcc02d15 	stw	r19,180(sp)
21091f28:	d8003215 	stw	zero,200(sp)
21091f2c:	003b7306 	br	21090cfc <__flash_rwdata_start+0xfffeeab4>
21091f30:	00800084 	movi	r2,2
21091f34:	003c4d06 	br	2109106c <__flash_rwdata_start+0xfffeee24>
21091f38:	8880040c 	andi	r2,r17,16
21091f3c:	1000091e 	bne	r2,zero,21091f64 <___vfprintf_internal_r+0x17b4>
21091f40:	8c40100c 	andi	r17,r17,64
21091f44:	88000726 	beq	r17,zero,21091f64 <___vfprintf_internal_r+0x17b4>
21091f48:	db002d17 	ldw	r12,180(sp)
21091f4c:	dac02f17 	ldw	r11,188(sp)
21091f50:	60800017 	ldw	r2,0(r12)
21091f54:	63000104 	addi	r12,r12,4
21091f58:	db002d15 	stw	r12,180(sp)
21091f5c:	12c0000d 	sth	r11,0(r2)
21091f60:	003a4e06 	br	2109089c <__flash_rwdata_start+0xfffee654>
21091f64:	db002d17 	ldw	r12,180(sp)
21091f68:	dac02f17 	ldw	r11,188(sp)
21091f6c:	60800017 	ldw	r2,0(r12)
21091f70:	63000104 	addi	r12,r12,4
21091f74:	db002d15 	stw	r12,180(sp)
21091f78:	12c00015 	stw	r11,0(r2)
21091f7c:	003a4706 	br	2109089c <__flash_rwdata_start+0xfffee654>
21091f80:	1c000007 	ldb	r16,0(r3)
21091f84:	1805883a 	mov	r2,r3
21091f88:	003a6e06 	br	21090944 <__flash_rwdata_start+0xfffee6fc>
21091f8c:	88c0100c 	andi	r3,r17,64
21091f90:	18006b26 	beq	r3,zero,21092140 <___vfprintf_internal_r+0x1990>
21091f94:	dac02d17 	ldw	r11,180(sp)
21091f98:	14c0000b 	ldhu	r19,0(r2)
21091f9c:	0039883a 	mov	fp,zero
21091fa0:	5ac00104 	addi	r11,r11,4
21091fa4:	dac02d15 	stw	r11,180(sp)
21091fa8:	003cb206 	br	21091274 <__flash_rwdata_start+0xfffef02c>
21091fac:	01000034 	movhi	r4,0
21091fb0:	210ee184 	addi	r4,r4,15238
21091fb4:	d9002c15 	stw	r4,176(sp)
21091fb8:	dac02c17 	ldw	r11,176(sp)
21091fbc:	1c87883a 	add	r3,r3,r18
21091fc0:	10800044 	addi	r2,r2,1
21091fc4:	42c00015 	stw	r11,0(r8)
21091fc8:	44800115 	stw	r18,4(r8)
21091fcc:	d8c02015 	stw	r3,128(sp)
21091fd0:	d8801f15 	stw	r2,124(sp)
21091fd4:	010001c4 	movi	r4,7
21091fd8:	20bee016 	blt	r4,r2,21091b5c <__flash_rwdata_start+0xfffef914>
21091fdc:	42000204 	addi	r8,r8,8
21091fe0:	003ee506 	br	21091b78 <__flash_rwdata_start+0xfffef930>
21091fe4:	01000034 	movhi	r4,0
21091fe8:	210ee184 	addi	r4,r4,15238
21091fec:	d9002c15 	stw	r4,176(sp)
21091ff0:	003bbe06 	br	21090eec <__flash_rwdata_start+0xfffeeca4>
21091ff4:	b009883a 	mov	r4,r22
21091ff8:	b80b883a 	mov	r5,r23
21091ffc:	d9801e04 	addi	r6,sp,120
21092000:	10987140 	call	21098714 <__sprint_r>
21092004:	103ade1e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
21092008:	d8c02017 	ldw	r3,128(sp)
2109200c:	da000404 	addi	r8,sp,16
21092010:	003d6b06 	br	210915c0 <__flash_rwdata_start+0xfffef378>
21092014:	d8801f17 	ldw	r2,124(sp)
21092018:	03000034 	movhi	r12,0
2109201c:	01000044 	movi	r4,1
21092020:	18c00044 	addi	r3,r3,1
21092024:	10800044 	addi	r2,r2,1
21092028:	630ed904 	addi	r12,r12,15204
2109202c:	41000115 	stw	r4,4(r8)
21092030:	43000015 	stw	r12,0(r8)
21092034:	d8c02015 	stw	r3,128(sp)
21092038:	d8801f15 	stw	r2,124(sp)
2109203c:	010001c4 	movi	r4,7
21092040:	20804916 	blt	r4,r2,21092168 <___vfprintf_internal_r+0x19b8>
21092044:	42000204 	addi	r8,r8,8
21092048:	8000041e 	bne	r16,zero,2109205c <___vfprintf_internal_r+0x18ac>
2109204c:	dac03317 	ldw	r11,204(sp)
21092050:	5800021e 	bne	r11,zero,2109205c <___vfprintf_internal_r+0x18ac>
21092054:	8880004c 	andi	r2,r17,1
21092058:	103bbb26 	beq	r2,zero,21090f48 <__flash_rwdata_start+0xfffeed00>
2109205c:	db003817 	ldw	r12,224(sp)
21092060:	d8801f17 	ldw	r2,124(sp)
21092064:	dac03517 	ldw	r11,212(sp)
21092068:	1b07883a 	add	r3,r3,r12
2109206c:	10800044 	addi	r2,r2,1
21092070:	42c00015 	stw	r11,0(r8)
21092074:	43000115 	stw	r12,4(r8)
21092078:	d8c02015 	stw	r3,128(sp)
2109207c:	d8801f15 	stw	r2,124(sp)
21092080:	010001c4 	movi	r4,7
21092084:	20812e16 	blt	r4,r2,21092540 <___vfprintf_internal_r+0x1d90>
21092088:	42000204 	addi	r8,r8,8
2109208c:	0421c83a 	sub	r16,zero,r16
21092090:	04005c0e 	bge	zero,r16,21092204 <___vfprintf_internal_r+0x1a54>
21092094:	04800404 	movi	r18,16
21092098:	94009f0e 	bge	r18,r16,21092318 <___vfprintf_internal_r+0x1b68>
2109209c:	01000034 	movhi	r4,0
210920a0:	210ee184 	addi	r4,r4,15238
210920a4:	d9002c15 	stw	r4,176(sp)
210920a8:	054001c4 	movi	r21,7
210920ac:	00000306 	br	210920bc <___vfprintf_internal_r+0x190c>
210920b0:	42000204 	addi	r8,r8,8
210920b4:	843ffc04 	addi	r16,r16,-16
210920b8:	94009a0e 	bge	r18,r16,21092324 <___vfprintf_internal_r+0x1b74>
210920bc:	18c00404 	addi	r3,r3,16
210920c0:	10800044 	addi	r2,r2,1
210920c4:	45000015 	stw	r20,0(r8)
210920c8:	44800115 	stw	r18,4(r8)
210920cc:	d8c02015 	stw	r3,128(sp)
210920d0:	d8801f15 	stw	r2,124(sp)
210920d4:	a8bff60e 	bge	r21,r2,210920b0 <__flash_rwdata_start+0xfffefe68>
210920d8:	b009883a 	mov	r4,r22
210920dc:	b80b883a 	mov	r5,r23
210920e0:	d9801e04 	addi	r6,sp,120
210920e4:	10987140 	call	21098714 <__sprint_r>
210920e8:	103aa51e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
210920ec:	d8c02017 	ldw	r3,128(sp)
210920f0:	d8801f17 	ldw	r2,124(sp)
210920f4:	da000404 	addi	r8,sp,16
210920f8:	003fee06 	br	210920b4 <__flash_rwdata_start+0xfffefe6c>
210920fc:	008011c4 	movi	r2,71
21092100:	1400be16 	blt	r2,r16,210923fc <___vfprintf_internal_r+0x1c4c>
21092104:	03000034 	movhi	r12,0
21092108:	630ecb04 	addi	r12,r12,15148
2109210c:	db003115 	stw	r12,196(sp)
21092110:	00c000c4 	movi	r3,3
21092114:	00bfdfc4 	movi	r2,-129
21092118:	d8c02b15 	stw	r3,172(sp)
2109211c:	88a2703a 	and	r17,r17,r2
21092120:	dd402783 	ldbu	r21,158(sp)
21092124:	dcc02d15 	stw	r19,180(sp)
21092128:	1825883a 	mov	r18,r3
2109212c:	d8003215 	stw	zero,200(sp)
21092130:	d8003415 	stw	zero,208(sp)
21092134:	003af106 	br	21090cfc <__flash_rwdata_start+0xfffeeab4>
21092138:	4825883a 	mov	r18,r9
2109213c:	003c9306 	br	2109138c <__flash_rwdata_start+0xfffef144>
21092140:	db002d17 	ldw	r12,180(sp)
21092144:	14c00017 	ldw	r19,0(r2)
21092148:	0039883a 	mov	fp,zero
2109214c:	63000104 	addi	r12,r12,4
21092150:	db002d15 	stw	r12,180(sp)
21092154:	003c4706 	br	21091274 <__flash_rwdata_start+0xfffef02c>
21092158:	00800034 	movhi	r2,0
2109215c:	108ec904 	addi	r2,r2,15140
21092160:	d8803115 	stw	r2,196(sp)
21092164:	003bf106 	br	2109112c <__flash_rwdata_start+0xfffeeee4>
21092168:	b009883a 	mov	r4,r22
2109216c:	b80b883a 	mov	r5,r23
21092170:	d9801e04 	addi	r6,sp,120
21092174:	10987140 	call	21098714 <__sprint_r>
21092178:	103a811e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
2109217c:	dc002617 	ldw	r16,152(sp)
21092180:	d8c02017 	ldw	r3,128(sp)
21092184:	da000404 	addi	r8,sp,16
21092188:	003faf06 	br	21092048 <__flash_rwdata_start+0xfffefe00>
2109218c:	db002e17 	ldw	r12,184(sp)
21092190:	1805883a 	mov	r2,r3
21092194:	dac02d15 	stw	r11,180(sp)
21092198:	0319c83a 	sub	r12,zero,r12
2109219c:	db002e15 	stw	r12,184(sp)
210921a0:	003a8206 	br	21090bac <__flash_rwdata_start+0xfffee964>
210921a4:	18800044 	addi	r2,r3,1
210921a8:	8c400814 	ori	r17,r17,32
210921ac:	1c000047 	ldb	r16,1(r3)
210921b0:	0039e406 	br	21090944 <__flash_rwdata_start+0xfffee6fc>
210921b4:	b009883a 	mov	r4,r22
210921b8:	b80b883a 	mov	r5,r23
210921bc:	d9801e04 	addi	r6,sp,120
210921c0:	10987140 	call	21098714 <__sprint_r>
210921c4:	103a6e1e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
210921c8:	d8c02017 	ldw	r3,128(sp)
210921cc:	da000404 	addi	r8,sp,16
210921d0:	003d0c06 	br	21091604 <__flash_rwdata_start+0xfffef3bc>
210921d4:	db002817 	ldw	r12,160(sp)
210921d8:	d8c03117 	ldw	r3,196(sp)
210921dc:	60e5c83a 	sub	r18,r12,r3
210921e0:	003ac106 	br	21090ce8 <__flash_rwdata_start+0xfffeeaa0>
210921e4:	b009883a 	mov	r4,r22
210921e8:	b80b883a 	mov	r5,r23
210921ec:	d9801e04 	addi	r6,sp,120
210921f0:	10987140 	call	21098714 <__sprint_r>
210921f4:	103a621e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
210921f8:	d8c02017 	ldw	r3,128(sp)
210921fc:	d8801f17 	ldw	r2,124(sp)
21092200:	da000404 	addi	r8,sp,16
21092204:	db003317 	ldw	r12,204(sp)
21092208:	dac03117 	ldw	r11,196(sp)
2109220c:	10800044 	addi	r2,r2,1
21092210:	1b07883a 	add	r3,r3,r12
21092214:	42c00015 	stw	r11,0(r8)
21092218:	43000115 	stw	r12,4(r8)
2109221c:	d8c02015 	stw	r3,128(sp)
21092220:	d8801f15 	stw	r2,124(sp)
21092224:	010001c4 	movi	r4,7
21092228:	20bb460e 	bge	r4,r2,21090f44 <__flash_rwdata_start+0xfffeecfc>
2109222c:	003d8506 	br	21091844 <__flash_rwdata_start+0xfffef5fc>
21092230:	da003f15 	stw	r8,252(sp)
21092234:	108e7200 	call	2108e720 <strlen>
21092238:	1025883a 	mov	r18,r2
2109223c:	da003f17 	ldw	r8,252(sp)
21092240:	903c540e 	bge	r18,zero,21091394 <__flash_rwdata_start+0xfffef14c>
21092244:	0005883a 	mov	r2,zero
21092248:	003c5206 	br	21091394 <__flash_rwdata_start+0xfffef14c>
2109224c:	01000034 	movhi	r4,0
21092250:	210ee584 	addi	r4,r4,15254
21092254:	d9003615 	stw	r4,216(sp)
21092258:	003adc06 	br	21090dcc <__flash_rwdata_start+0xfffeeb84>
2109225c:	d8802604 	addi	r2,sp,152
21092260:	d8800115 	stw	r2,4(sp)
21092264:	d9403717 	ldw	r5,220(sp)
21092268:	d8802504 	addi	r2,sp,148
2109226c:	d8800215 	stw	r2,8(sp)
21092270:	d8802104 	addi	r2,sp,132
21092274:	da400015 	stw	r9,0(sp)
21092278:	d8800315 	stw	r2,12(sp)
2109227c:	b009883a 	mov	r4,r22
21092280:	900d883a 	mov	r6,r18
21092284:	01c000c4 	movi	r7,3
21092288:	da003f15 	stw	r8,252(sp)
2109228c:	da403e15 	stw	r9,248(sp)
21092290:	1092df80 	call	21092df8 <_dtoa_r>
21092294:	da403e17 	ldw	r9,248(sp)
21092298:	da003f17 	ldw	r8,252(sp)
2109229c:	d8803115 	stw	r2,196(sp)
210922a0:	4839883a 	mov	fp,r9
210922a4:	dac03117 	ldw	r11,196(sp)
210922a8:	00801184 	movi	r2,70
210922ac:	5f15883a 	add	r10,r11,fp
210922b0:	a8bef01e 	bne	r21,r2,21091e74 <__flash_rwdata_start+0xfffefc2c>
210922b4:	59000007 	ldb	r4,0(r11)
210922b8:	00800c04 	movi	r2,48
210922bc:	2080d526 	beq	r4,r2,21092614 <___vfprintf_internal_r+0x1e64>
210922c0:	d8c02617 	ldw	r3,152(sp)
210922c4:	50d5883a 	add	r10,r10,r3
210922c8:	003eea06 	br	21091e74 <__flash_rwdata_start+0xfffefc2c>
210922cc:	0025883a 	mov	r18,zero
210922d0:	003db306 	br	210919a0 <__flash_rwdata_start+0xfffef758>
210922d4:	b009883a 	mov	r4,r22
210922d8:	b80b883a 	mov	r5,r23
210922dc:	d9801e04 	addi	r6,sp,120
210922e0:	10987140 	call	21098714 <__sprint_r>
210922e4:	103a261e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
210922e8:	d8c02017 	ldw	r3,128(sp)
210922ec:	da000404 	addi	r8,sp,16
210922f0:	003daa06 	br	2109199c <__flash_rwdata_start+0xfffef754>
210922f4:	b009883a 	mov	r4,r22
210922f8:	b80b883a 	mov	r5,r23
210922fc:	d9801e04 	addi	r6,sp,120
21092300:	10987140 	call	21098714 <__sprint_r>
21092304:	103a1e1e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
21092308:	d8802617 	ldw	r2,152(sp)
2109230c:	d8c02017 	ldw	r3,128(sp)
21092310:	da000404 	addi	r8,sp,16
21092314:	003e2c06 	br	21091bc8 <__flash_rwdata_start+0xfffef980>
21092318:	03000034 	movhi	r12,0
2109231c:	630ee184 	addi	r12,r12,15238
21092320:	db002c15 	stw	r12,176(sp)
21092324:	dac02c17 	ldw	r11,176(sp)
21092328:	1c07883a 	add	r3,r3,r16
2109232c:	10800044 	addi	r2,r2,1
21092330:	42c00015 	stw	r11,0(r8)
21092334:	44000115 	stw	r16,4(r8)
21092338:	d8c02015 	stw	r3,128(sp)
2109233c:	d8801f15 	stw	r2,124(sp)
21092340:	010001c4 	movi	r4,7
21092344:	20bfa716 	blt	r4,r2,210921e4 <__flash_rwdata_start+0xfffeff9c>
21092348:	42000204 	addi	r8,r8,8
2109234c:	003fad06 	br	21092204 <__flash_rwdata_start+0xfffeffbc>
21092350:	00800184 	movi	r2,6
21092354:	1240012e 	bgeu	r2,r9,2109235c <___vfprintf_internal_r+0x1bac>
21092358:	1013883a 	mov	r9,r2
2109235c:	4825883a 	mov	r18,r9
21092360:	4805883a 	mov	r2,r9
21092364:	4800c216 	blt	r9,zero,21092670 <___vfprintf_internal_r+0x1ec0>
21092368:	d8802b15 	stw	r2,172(sp)
2109236c:	00800034 	movhi	r2,0
21092370:	108ed704 	addi	r2,r2,15196
21092374:	d8803115 	stw	r2,196(sp)
21092378:	dcc02d15 	stw	r19,180(sp)
2109237c:	d8003215 	stw	zero,200(sp)
21092380:	d8003415 	stw	zero,208(sp)
21092384:	0005883a 	mov	r2,zero
21092388:	003a6306 	br	21090d18 <__flash_rwdata_start+0xfffeead0>
2109238c:	0021883a 	mov	r16,zero
21092390:	003e1f06 	br	21091c10 <__flash_rwdata_start+0xfffef9c8>
21092394:	b009883a 	mov	r4,r22
21092398:	b80b883a 	mov	r5,r23
2109239c:	d9801e04 	addi	r6,sp,120
210923a0:	10987140 	call	21098714 <__sprint_r>
210923a4:	1039f61e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
210923a8:	d8802617 	ldw	r2,152(sp)
210923ac:	db003317 	ldw	r12,204(sp)
210923b0:	d8c02017 	ldw	r3,128(sp)
210923b4:	da000404 	addi	r8,sp,16
210923b8:	6085c83a 	sub	r2,r12,r2
210923bc:	003e1306 	br	21091c0c <__flash_rwdata_start+0xfffef9c4>
210923c0:	03000034 	movhi	r12,0
210923c4:	630ee584 	addi	r12,r12,15254
210923c8:	db003615 	stw	r12,216(sp)
210923cc:	003b0206 	br	21090fd8 <__flash_rwdata_start+0xfffeed90>
210923d0:	00c00b44 	movi	r3,45
210923d4:	d8802b15 	stw	r2,172(sp)
210923d8:	dc402d17 	ldw	r17,180(sp)
210923dc:	d8c02785 	stb	r3,158(sp)
210923e0:	dcc02d15 	stw	r19,180(sp)
210923e4:	d8003215 	stw	zero,200(sp)
210923e8:	00800b44 	movi	r2,45
210923ec:	003a4706 	br	21090d0c <__flash_rwdata_start+0xfffeeac4>
210923f0:	05400b44 	movi	r21,45
210923f4:	dd402785 	stb	r21,158(sp)
210923f8:	003b4706 	br	21091118 <__flash_rwdata_start+0xfffeeed0>
210923fc:	00800034 	movhi	r2,0
21092400:	108ecc04 	addi	r2,r2,15152
21092404:	d8803115 	stw	r2,196(sp)
21092408:	003f4106 	br	21092110 <__flash_rwdata_start+0xfffefec8>
2109240c:	d8c02617 	ldw	r3,152(sp)
21092410:	00bfff44 	movi	r2,-3
21092414:	18801116 	blt	r3,r2,2109245c <___vfprintf_internal_r+0x1cac>
21092418:	48c01016 	blt	r9,r3,2109245c <___vfprintf_internal_r+0x1cac>
2109241c:	d8c03415 	stw	r3,208(sp)
21092420:	040019c4 	movi	r16,103
21092424:	003eb206 	br	21091ef0 <__flash_rwdata_start+0xfffefca8>
21092428:	01000034 	movhi	r4,0
2109242c:	210ee184 	addi	r4,r4,15238
21092430:	d9002c15 	stw	r4,176(sp)
21092434:	003cb106 	br	210916fc <__flash_rwdata_start+0xfffef4b4>
21092438:	5005883a 	mov	r2,r10
2109243c:	003ea106 	br	21091ec4 <__flash_rwdata_start+0xfffefc7c>
21092440:	da402b15 	stw	r9,172(sp)
21092444:	dd402783 	ldbu	r21,158(sp)
21092448:	4825883a 	mov	r18,r9
2109244c:	dcc02d15 	stw	r19,180(sp)
21092450:	d8003215 	stw	zero,200(sp)
21092454:	d8003415 	stw	zero,208(sp)
21092458:	003a2806 	br	21090cfc <__flash_rwdata_start+0xfffeeab4>
2109245c:	843fff84 	addi	r16,r16,-2
21092460:	1f3fffc4 	addi	fp,r3,-1
21092464:	df002615 	stw	fp,152(sp)
21092468:	dc0022c5 	stb	r16,139(sp)
2109246c:	e0009816 	blt	fp,zero,210926d0 <___vfprintf_internal_r+0x1f20>
21092470:	00800ac4 	movi	r2,43
21092474:	d8802305 	stb	r2,140(sp)
21092478:	00800244 	movi	r2,9
2109247c:	1700750e 	bge	r2,fp,21092654 <___vfprintf_internal_r+0x1ea4>
21092480:	dd4022c4 	addi	r21,sp,139
21092484:	dc002c15 	stw	r16,176(sp)
21092488:	4025883a 	mov	r18,r8
2109248c:	a821883a 	mov	r16,r21
21092490:	e009883a 	mov	r4,fp
21092494:	01400284 	movi	r5,10
21092498:	108d51c0 	call	2108d51c <__modsi3>
2109249c:	10800c04 	addi	r2,r2,48
210924a0:	843fffc4 	addi	r16,r16,-1
210924a4:	e009883a 	mov	r4,fp
210924a8:	01400284 	movi	r5,10
210924ac:	80800005 	stb	r2,0(r16)
210924b0:	108d4c80 	call	2108d4c8 <__divsi3>
210924b4:	1039883a 	mov	fp,r2
210924b8:	00800244 	movi	r2,9
210924bc:	173ff416 	blt	r2,fp,21092490 <__flash_rwdata_start+0xffff0248>
210924c0:	9011883a 	mov	r8,r18
210924c4:	e0800c04 	addi	r2,fp,48
210924c8:	8025883a 	mov	r18,r16
210924cc:	913fffc4 	addi	r4,r18,-1
210924d0:	90bfffc5 	stb	r2,-1(r18)
210924d4:	dc002c17 	ldw	r16,176(sp)
210924d8:	2540852e 	bgeu	r4,r21,210926f0 <___vfprintf_internal_r+0x1f40>
210924dc:	d9402384 	addi	r5,sp,142
210924e0:	2c8bc83a 	sub	r5,r5,r18
210924e4:	d8c02344 	addi	r3,sp,141
210924e8:	a94b883a 	add	r5,r21,r5
210924ec:	00000106 	br	210924f4 <___vfprintf_internal_r+0x1d44>
210924f0:	20800003 	ldbu	r2,0(r4)
210924f4:	18800005 	stb	r2,0(r3)
210924f8:	18c00044 	addi	r3,r3,1
210924fc:	21000044 	addi	r4,r4,1
21092500:	197ffb1e 	bne	r3,r5,210924f0 <__flash_rwdata_start+0xffff02a8>
21092504:	d8802304 	addi	r2,sp,140
21092508:	1485c83a 	sub	r2,r2,r18
2109250c:	d8c02344 	addi	r3,sp,141
21092510:	1885883a 	add	r2,r3,r2
21092514:	dac03317 	ldw	r11,204(sp)
21092518:	156bc83a 	sub	r21,r2,r21
2109251c:	dd403a15 	stw	r21,232(sp)
21092520:	00800044 	movi	r2,1
21092524:	5d65883a 	add	r18,r11,r21
21092528:	12c0660e 	bge	r2,r11,210926c4 <___vfprintf_internal_r+0x1f14>
2109252c:	94800044 	addi	r18,r18,1
21092530:	9005883a 	mov	r2,r18
21092534:	90006116 	blt	r18,zero,210926bc <___vfprintf_internal_r+0x1f0c>
21092538:	d8003415 	stw	zero,208(sp)
2109253c:	003e7406 	br	21091f10 <__flash_rwdata_start+0xfffefcc8>
21092540:	b009883a 	mov	r4,r22
21092544:	b80b883a 	mov	r5,r23
21092548:	d9801e04 	addi	r6,sp,120
2109254c:	10987140 	call	21098714 <__sprint_r>
21092550:	10398b1e 	bne	r2,zero,21090b80 <__flash_rwdata_start+0xfffee938>
21092554:	dc002617 	ldw	r16,152(sp)
21092558:	d8c02017 	ldw	r3,128(sp)
2109255c:	d8801f17 	ldw	r2,124(sp)
21092560:	da000404 	addi	r8,sp,16
21092564:	003ec906 	br	2109208c <__flash_rwdata_start+0xfffefe44>
21092568:	483e1c1e 	bne	r9,zero,21091ddc <__flash_rwdata_start+0xfffefb94>
2109256c:	9013883a 	mov	r9,r18
21092570:	003e1a06 	br	21091ddc <__flash_rwdata_start+0xfffefb94>
21092574:	02400184 	movi	r9,6
21092578:	003e1806 	br	21091ddc <__flash_rwdata_start+0xfffefb94>
2109257c:	d8c03417 	ldw	r3,208(sp)
21092580:	00c04b0e 	bge	zero,r3,210926b0 <___vfprintf_internal_r+0x1f00>
21092584:	04800044 	movi	r18,1
21092588:	dac03317 	ldw	r11,204(sp)
2109258c:	92e5883a 	add	r18,r18,r11
21092590:	9005883a 	mov	r2,r18
21092594:	903e5e0e 	bge	r18,zero,21091f10 <__flash_rwdata_start+0xfffefcc8>
21092598:	0005883a 	mov	r2,zero
2109259c:	003e5c06 	br	21091f10 <__flash_rwdata_start+0xfffefcc8>
210925a0:	00c00b44 	movi	r3,45
210925a4:	64a0003c 	xorhi	r18,r12,32768
210925a8:	d8c02b05 	stb	r3,172(sp)
210925ac:	003e1106 	br	21091df4 <__flash_rwdata_start+0xfffefbac>
210925b0:	4f000044 	addi	fp,r9,1
210925b4:	003e1606 	br	21091e10 <__flash_rwdata_start+0xfffefbc8>
210925b8:	d8c02617 	ldw	r3,152(sp)
210925bc:	d8c03415 	stw	r3,208(sp)
210925c0:	00c0350e 	bge	zero,r3,21092698 <___vfprintf_internal_r+0x1ee8>
210925c4:	4800081e 	bne	r9,zero,210925e8 <___vfprintf_internal_r+0x1e38>
210925c8:	8c40004c 	andi	r17,r17,1
210925cc:	8800061e 	bne	r17,zero,210925e8 <___vfprintf_internal_r+0x1e38>
210925d0:	1805883a 	mov	r2,r3
210925d4:	183e4d0e 	bge	r3,zero,21091f0c <__flash_rwdata_start+0xfffefcc4>
210925d8:	0005883a 	mov	r2,zero
210925dc:	003e4b06 	br	21091f0c <__flash_rwdata_start+0xfffefcc4>
210925e0:	d8802117 	ldw	r2,132(sp)
210925e4:	003e3706 	br	21091ec4 <__flash_rwdata_start+0xfffefc7c>
210925e8:	dac03417 	ldw	r11,208(sp)
210925ec:	4a400044 	addi	r9,r9,1
210925f0:	5a65883a 	add	r18,r11,r9
210925f4:	9005883a 	mov	r2,r18
210925f8:	903e450e 	bge	r18,zero,21091f10 <__flash_rwdata_start+0xfffefcc8>
210925fc:	003fe606 	br	21092598 <__flash_rwdata_start+0xffff0350>
21092600:	db003417 	ldw	r12,208(sp)
21092604:	64800044 	addi	r18,r12,1
21092608:	9005883a 	mov	r2,r18
2109260c:	903e400e 	bge	r18,zero,21091f10 <__flash_rwdata_start+0xfffefcc8>
21092610:	003fe106 	br	21092598 <__flash_rwdata_start+0xffff0350>
21092614:	d9003717 	ldw	r4,220(sp)
21092618:	900b883a 	mov	r5,r18
2109261c:	000d883a 	mov	r6,zero
21092620:	000f883a 	mov	r7,zero
21092624:	da003f15 	stw	r8,252(sp)
21092628:	da403e15 	stw	r9,248(sp)
2109262c:	da803d15 	stw	r10,244(sp)
21092630:	109af240 	call	2109af24 <__eqdf2>
21092634:	da003f17 	ldw	r8,252(sp)
21092638:	da403e17 	ldw	r9,248(sp)
2109263c:	da803d17 	ldw	r10,244(sp)
21092640:	103f1f26 	beq	r2,zero,210922c0 <__flash_rwdata_start+0xffff0078>
21092644:	00800044 	movi	r2,1
21092648:	1707c83a 	sub	r3,r2,fp
2109264c:	d8c02615 	stw	r3,152(sp)
21092650:	003f1c06 	br	210922c4 <__flash_rwdata_start+0xffff007c>
21092654:	00800c04 	movi	r2,48
21092658:	e0c00c04 	addi	r3,fp,48
2109265c:	d8802345 	stb	r2,141(sp)
21092660:	d8c02385 	stb	r3,142(sp)
21092664:	d88023c4 	addi	r2,sp,143
21092668:	dd4022c4 	addi	r21,sp,139
2109266c:	003fa906 	br	21092514 <__flash_rwdata_start+0xffff02cc>
21092670:	0005883a 	mov	r2,zero
21092674:	003f3c06 	br	21092368 <__flash_rwdata_start+0xffff0120>
21092678:	dac02d17 	ldw	r11,180(sp)
2109267c:	5a400017 	ldw	r9,0(r11)
21092680:	5ac00104 	addi	r11,r11,4
21092684:	dac02d15 	stw	r11,180(sp)
21092688:	483ec80e 	bge	r9,zero,210921ac <__flash_rwdata_start+0xfffeff64>
2109268c:	027fffc4 	movi	r9,-1
21092690:	1c000047 	ldb	r16,1(r3)
21092694:	0038ab06 	br	21090944 <__flash_rwdata_start+0xfffee6fc>
21092698:	4800111e 	bne	r9,zero,210926e0 <___vfprintf_internal_r+0x1f30>
2109269c:	8c40004c 	andi	r17,r17,1
210926a0:	88000f1e 	bne	r17,zero,210926e0 <___vfprintf_internal_r+0x1f30>
210926a4:	00800044 	movi	r2,1
210926a8:	1025883a 	mov	r18,r2
210926ac:	003e1806 	br	21091f10 <__flash_rwdata_start+0xfffefcc8>
210926b0:	04800084 	movi	r18,2
210926b4:	90e5c83a 	sub	r18,r18,r3
210926b8:	003fb306 	br	21092588 <__flash_rwdata_start+0xffff0340>
210926bc:	0005883a 	mov	r2,zero
210926c0:	003f9d06 	br	21092538 <__flash_rwdata_start+0xffff02f0>
210926c4:	88a2703a 	and	r17,r17,r2
210926c8:	883f9926 	beq	r17,zero,21092530 <__flash_rwdata_start+0xffff02e8>
210926cc:	003f9706 	br	2109252c <__flash_rwdata_start+0xffff02e4>
210926d0:	00800b44 	movi	r2,45
210926d4:	0739c83a 	sub	fp,zero,fp
210926d8:	d8802305 	stb	r2,140(sp)
210926dc:	003f6606 	br	21092478 <__flash_rwdata_start+0xffff0230>
210926e0:	4c800084 	addi	r18,r9,2
210926e4:	9005883a 	mov	r2,r18
210926e8:	903e090e 	bge	r18,zero,21091f10 <__flash_rwdata_start+0xfffefcc8>
210926ec:	003faa06 	br	21092598 <__flash_rwdata_start+0xffff0350>
210926f0:	d8802344 	addi	r2,sp,141
210926f4:	003f8706 	br	21092514 <__flash_rwdata_start+0xffff02cc>
210926f8:	d8c02617 	ldw	r3,152(sp)
210926fc:	003f5806 	br	21092460 <__flash_rwdata_start+0xffff0218>

21092700 <__vfprintf_internal>:
21092700:	2007883a 	mov	r3,r4
21092704:	01000034 	movhi	r4,0
21092708:	21176b04 	addi	r4,r4,23980
2109270c:	21000017 	ldw	r4,0(r4)
21092710:	2805883a 	mov	r2,r5
21092714:	300f883a 	mov	r7,r6
21092718:	180b883a 	mov	r5,r3
2109271c:	100d883a 	mov	r6,r2
21092720:	10907b01 	jmpi	210907b0 <___vfprintf_internal_r>

21092724 <__sbprintf>:
21092724:	2880030b 	ldhu	r2,12(r5)
21092728:	2ac01917 	ldw	r11,100(r5)
2109272c:	2a80038b 	ldhu	r10,14(r5)
21092730:	2a400717 	ldw	r9,28(r5)
21092734:	2a000917 	ldw	r8,36(r5)
21092738:	defee204 	addi	sp,sp,-1144
2109273c:	00c10004 	movi	r3,1024
21092740:	dc011a15 	stw	r16,1128(sp)
21092744:	10bfff4c 	andi	r2,r2,65533
21092748:	2821883a 	mov	r16,r5
2109274c:	d8cb883a 	add	r5,sp,r3
21092750:	dc811c15 	stw	r18,1136(sp)
21092754:	dc411b15 	stw	r17,1132(sp)
21092758:	dfc11d15 	stw	ra,1140(sp)
2109275c:	2025883a 	mov	r18,r4
21092760:	d881030d 	sth	r2,1036(sp)
21092764:	dac11915 	stw	r11,1124(sp)
21092768:	da81038d 	sth	r10,1038(sp)
2109276c:	da410715 	stw	r9,1052(sp)
21092770:	da010915 	stw	r8,1060(sp)
21092774:	dec10015 	stw	sp,1024(sp)
21092778:	dec10415 	stw	sp,1040(sp)
2109277c:	d8c10215 	stw	r3,1032(sp)
21092780:	d8c10515 	stw	r3,1044(sp)
21092784:	d8010615 	stw	zero,1048(sp)
21092788:	10907b00 	call	210907b0 <___vfprintf_internal_r>
2109278c:	1023883a 	mov	r17,r2
21092790:	10000416 	blt	r2,zero,210927a4 <__sbprintf+0x80>
21092794:	9009883a 	mov	r4,r18
21092798:	d9410004 	addi	r5,sp,1024
2109279c:	10947280 	call	21094728 <_fflush_r>
210927a0:	10000d1e 	bne	r2,zero,210927d8 <__sbprintf+0xb4>
210927a4:	d8c1030b 	ldhu	r3,1036(sp)
210927a8:	18c0100c 	andi	r3,r3,64
210927ac:	18000326 	beq	r3,zero,210927bc <__sbprintf+0x98>
210927b0:	8080030b 	ldhu	r2,12(r16)
210927b4:	10801014 	ori	r2,r2,64
210927b8:	8080030d 	sth	r2,12(r16)
210927bc:	8805883a 	mov	r2,r17
210927c0:	dfc11d17 	ldw	ra,1140(sp)
210927c4:	dc811c17 	ldw	r18,1136(sp)
210927c8:	dc411b17 	ldw	r17,1132(sp)
210927cc:	dc011a17 	ldw	r16,1128(sp)
210927d0:	dec11e04 	addi	sp,sp,1144
210927d4:	f800283a 	ret
210927d8:	047fffc4 	movi	r17,-1
210927dc:	003ff106 	br	210927a4 <__flash_rwdata_start+0xffff055c>

210927e0 <_vsnprintf_r>:
210927e0:	3005883a 	mov	r2,r6
210927e4:	30003616 	blt	r6,zero,210928c0 <_vsnprintf_r+0xe0>
210927e8:	deffe404 	addi	sp,sp,-112
210927ec:	00c08204 	movi	r3,520
210927f0:	dc001a15 	stw	r16,104(sp)
210927f4:	dfc01b15 	stw	ra,108(sp)
210927f8:	d8c0030d 	sth	r3,12(sp)
210927fc:	d9400015 	stw	r5,0(sp)
21092800:	d9400415 	stw	r5,16(sp)
21092804:	380d883a 	mov	r6,r7
21092808:	2021883a 	mov	r16,r4
2109280c:	10001326 	beq	r2,zero,2109285c <_vsnprintf_r+0x7c>
21092810:	00c00034 	movhi	r3,0
21092814:	18d76b04 	addi	r3,r3,23980
21092818:	19000017 	ldw	r4,0(r3)
2109281c:	d9c01c17 	ldw	r7,112(sp)
21092820:	10bfffc4 	addi	r2,r2,-1
21092824:	d8800215 	stw	r2,8(sp)
21092828:	d8800515 	stw	r2,20(sp)
2109282c:	d80b883a 	mov	r5,sp
21092830:	00bfffc4 	movi	r2,-1
21092834:	d880038d 	sth	r2,14(sp)
21092838:	108e8200 	call	2108e820 <___svfprintf_internal_r>
2109283c:	00ffffc4 	movi	r3,-1
21092840:	10c01c16 	blt	r2,r3,210928b4 <_vsnprintf_r+0xd4>
21092844:	d8c00017 	ldw	r3,0(sp)
21092848:	18000005 	stb	zero,0(r3)
2109284c:	dfc01b17 	ldw	ra,108(sp)
21092850:	dc001a17 	ldw	r16,104(sp)
21092854:	dec01c04 	addi	sp,sp,112
21092858:	f800283a 	ret
2109285c:	00800034 	movhi	r2,0
21092860:	10976b04 	addi	r2,r2,23980
21092864:	11000017 	ldw	r4,0(r2)
21092868:	d9c01c17 	ldw	r7,112(sp)
2109286c:	00bfffc4 	movi	r2,-1
21092870:	d80b883a 	mov	r5,sp
21092874:	d8000215 	stw	zero,8(sp)
21092878:	d8000515 	stw	zero,20(sp)
2109287c:	d880038d 	sth	r2,14(sp)
21092880:	108e8200 	call	2108e820 <___svfprintf_internal_r>
21092884:	00ffffc4 	movi	r3,-1
21092888:	10c00416 	blt	r2,r3,2109289c <_vsnprintf_r+0xbc>
2109288c:	dfc01b17 	ldw	ra,108(sp)
21092890:	dc001a17 	ldw	r16,104(sp)
21092894:	dec01c04 	addi	sp,sp,112
21092898:	f800283a 	ret
2109289c:	00c022c4 	movi	r3,139
210928a0:	80c00015 	stw	r3,0(r16)
210928a4:	dfc01b17 	ldw	ra,108(sp)
210928a8:	dc001a17 	ldw	r16,104(sp)
210928ac:	dec01c04 	addi	sp,sp,112
210928b0:	f800283a 	ret
210928b4:	00c022c4 	movi	r3,139
210928b8:	80c00015 	stw	r3,0(r16)
210928bc:	003fe106 	br	21092844 <__flash_rwdata_start+0xffff05fc>
210928c0:	008022c4 	movi	r2,139
210928c4:	20800015 	stw	r2,0(r4)
210928c8:	00bfffc4 	movi	r2,-1
210928cc:	f800283a 	ret

210928d0 <vsnprintf>:
210928d0:	00800034 	movhi	r2,0
210928d4:	10976b04 	addi	r2,r2,23980
210928d8:	2011883a 	mov	r8,r4
210928dc:	11000017 	ldw	r4,0(r2)
210928e0:	defffe04 	addi	sp,sp,-8
210928e4:	2807883a 	mov	r3,r5
210928e8:	3005883a 	mov	r2,r6
210928ec:	d9c00015 	stw	r7,0(sp)
210928f0:	400b883a 	mov	r5,r8
210928f4:	180d883a 	mov	r6,r3
210928f8:	100f883a 	mov	r7,r2
210928fc:	dfc00115 	stw	ra,4(sp)
21092900:	10927e00 	call	210927e0 <_vsnprintf_r>
21092904:	dfc00117 	ldw	ra,4(sp)
21092908:	dec00204 	addi	sp,sp,8
2109290c:	f800283a 	ret

21092910 <__swsetup_r>:
21092910:	00800034 	movhi	r2,0
21092914:	defffd04 	addi	sp,sp,-12
21092918:	10976b04 	addi	r2,r2,23980
2109291c:	dc400115 	stw	r17,4(sp)
21092920:	2023883a 	mov	r17,r4
21092924:	11000017 	ldw	r4,0(r2)
21092928:	dc000015 	stw	r16,0(sp)
2109292c:	dfc00215 	stw	ra,8(sp)
21092930:	2821883a 	mov	r16,r5
21092934:	20000226 	beq	r4,zero,21092940 <__swsetup_r+0x30>
21092938:	20c00e17 	ldw	r3,56(r4)
2109293c:	18003126 	beq	r3,zero,21092a04 <__swsetup_r+0xf4>
21092940:	8080030b 	ldhu	r2,12(r16)
21092944:	10c0020c 	andi	r3,r2,8
21092948:	100d883a 	mov	r6,r2
2109294c:	18000f26 	beq	r3,zero,2109298c <__swsetup_r+0x7c>
21092950:	80c00417 	ldw	r3,16(r16)
21092954:	18001526 	beq	r3,zero,210929ac <__swsetup_r+0x9c>
21092958:	1100004c 	andi	r4,r2,1
2109295c:	20001c1e 	bne	r4,zero,210929d0 <__swsetup_r+0xc0>
21092960:	1080008c 	andi	r2,r2,2
21092964:	1000291e 	bne	r2,zero,21092a0c <__swsetup_r+0xfc>
21092968:	80800517 	ldw	r2,20(r16)
2109296c:	80800215 	stw	r2,8(r16)
21092970:	18001c26 	beq	r3,zero,210929e4 <__swsetup_r+0xd4>
21092974:	0005883a 	mov	r2,zero
21092978:	dfc00217 	ldw	ra,8(sp)
2109297c:	dc400117 	ldw	r17,4(sp)
21092980:	dc000017 	ldw	r16,0(sp)
21092984:	dec00304 	addi	sp,sp,12
21092988:	f800283a 	ret
2109298c:	3080040c 	andi	r2,r6,16
21092990:	10002e26 	beq	r2,zero,21092a4c <__swsetup_r+0x13c>
21092994:	3080010c 	andi	r2,r6,4
21092998:	10001e1e 	bne	r2,zero,21092a14 <__swsetup_r+0x104>
2109299c:	80c00417 	ldw	r3,16(r16)
210929a0:	30800214 	ori	r2,r6,8
210929a4:	8080030d 	sth	r2,12(r16)
210929a8:	183feb1e 	bne	r3,zero,21092958 <__flash_rwdata_start+0xffff0710>
210929ac:	1140a00c 	andi	r5,r2,640
210929b0:	01008004 	movi	r4,512
210929b4:	293fe826 	beq	r5,r4,21092958 <__flash_rwdata_start+0xffff0710>
210929b8:	8809883a 	mov	r4,r17
210929bc:	800b883a 	mov	r5,r16
210929c0:	10956900 	call	21095690 <__smakebuf_r>
210929c4:	8080030b 	ldhu	r2,12(r16)
210929c8:	80c00417 	ldw	r3,16(r16)
210929cc:	003fe206 	br	21092958 <__flash_rwdata_start+0xffff0710>
210929d0:	80800517 	ldw	r2,20(r16)
210929d4:	80000215 	stw	zero,8(r16)
210929d8:	0085c83a 	sub	r2,zero,r2
210929dc:	80800615 	stw	r2,24(r16)
210929e0:	183fe41e 	bne	r3,zero,21092974 <__flash_rwdata_start+0xffff072c>
210929e4:	80c0030b 	ldhu	r3,12(r16)
210929e8:	0005883a 	mov	r2,zero
210929ec:	1900200c 	andi	r4,r3,128
210929f0:	203fe126 	beq	r4,zero,21092978 <__flash_rwdata_start+0xffff0730>
210929f4:	18c01014 	ori	r3,r3,64
210929f8:	80c0030d 	sth	r3,12(r16)
210929fc:	00bfffc4 	movi	r2,-1
21092a00:	003fdd06 	br	21092978 <__flash_rwdata_start+0xffff0730>
21092a04:	1094b040 	call	21094b04 <__sinit>
21092a08:	003fcd06 	br	21092940 <__flash_rwdata_start+0xffff06f8>
21092a0c:	0005883a 	mov	r2,zero
21092a10:	003fd606 	br	2109296c <__flash_rwdata_start+0xffff0724>
21092a14:	81400c17 	ldw	r5,48(r16)
21092a18:	28000626 	beq	r5,zero,21092a34 <__swsetup_r+0x124>
21092a1c:	80801004 	addi	r2,r16,64
21092a20:	28800326 	beq	r5,r2,21092a30 <__swsetup_r+0x120>
21092a24:	8809883a 	mov	r4,r17
21092a28:	1094c780 	call	21094c78 <_free_r>
21092a2c:	8180030b 	ldhu	r6,12(r16)
21092a30:	80000c15 	stw	zero,48(r16)
21092a34:	80c00417 	ldw	r3,16(r16)
21092a38:	00bff6c4 	movi	r2,-37
21092a3c:	118c703a 	and	r6,r2,r6
21092a40:	80000115 	stw	zero,4(r16)
21092a44:	80c00015 	stw	r3,0(r16)
21092a48:	003fd506 	br	210929a0 <__flash_rwdata_start+0xffff0758>
21092a4c:	00800244 	movi	r2,9
21092a50:	88800015 	stw	r2,0(r17)
21092a54:	30801014 	ori	r2,r6,64
21092a58:	8080030d 	sth	r2,12(r16)
21092a5c:	00bfffc4 	movi	r2,-1
21092a60:	003fc506 	br	21092978 <__flash_rwdata_start+0xffff0730>

21092a64 <__call_exitprocs>:
21092a64:	00800034 	movhi	r2,0
21092a68:	10976a04 	addi	r2,r2,23976
21092a6c:	10800017 	ldw	r2,0(r2)
21092a70:	defff404 	addi	sp,sp,-48
21092a74:	dd800815 	stw	r22,32(sp)
21092a78:	d8800015 	stw	r2,0(sp)
21092a7c:	10805204 	addi	r2,r2,328
21092a80:	dd000615 	stw	r20,24(sp)
21092a84:	dc800415 	stw	r18,16(sp)
21092a88:	dfc00b15 	stw	ra,44(sp)
21092a8c:	df000a15 	stw	fp,40(sp)
21092a90:	ddc00915 	stw	r23,36(sp)
21092a94:	dd400715 	stw	r21,28(sp)
21092a98:	dcc00515 	stw	r19,20(sp)
21092a9c:	dc400315 	stw	r17,12(sp)
21092aa0:	dc000215 	stw	r16,8(sp)
21092aa4:	2025883a 	mov	r18,r4
21092aa8:	2829883a 	mov	r20,r5
21092aac:	d8800115 	stw	r2,4(sp)
21092ab0:	05bfffc4 	movi	r22,-1
21092ab4:	d8800017 	ldw	r2,0(sp)
21092ab8:	14c05217 	ldw	r19,328(r2)
21092abc:	98001d26 	beq	r19,zero,21092b34 <__call_exitprocs+0xd0>
21092ac0:	dd400117 	ldw	r21,4(sp)
21092ac4:	98800117 	ldw	r2,4(r19)
21092ac8:	173fffc4 	addi	fp,r2,-1
21092acc:	e0000d16 	blt	fp,zero,21092b04 <__call_exitprocs+0xa0>
21092ad0:	14000044 	addi	r16,r2,1
21092ad4:	8421883a 	add	r16,r16,r16
21092ad8:	8421883a 	add	r16,r16,r16
21092adc:	84402004 	addi	r17,r16,128
21092ae0:	9c63883a 	add	r17,r19,r17
21092ae4:	9c21883a 	add	r16,r19,r16
21092ae8:	a0001e26 	beq	r20,zero,21092b64 <__call_exitprocs+0x100>
21092aec:	80804017 	ldw	r2,256(r16)
21092af0:	15001c26 	beq	r2,r20,21092b64 <__call_exitprocs+0x100>
21092af4:	e73fffc4 	addi	fp,fp,-1
21092af8:	843fff04 	addi	r16,r16,-4
21092afc:	8c7fff04 	addi	r17,r17,-4
21092b00:	e5bff91e 	bne	fp,r22,21092ae8 <__flash_rwdata_start+0xffff08a0>
21092b04:	00884274 	movhi	r2,8457
21092b08:	10b63f04 	addi	r2,r2,-9988
21092b0c:	10000926 	beq	r2,zero,21092b34 <__call_exitprocs+0xd0>
21092b10:	98800117 	ldw	r2,4(r19)
21092b14:	1000311e 	bne	r2,zero,21092bdc <__call_exitprocs+0x178>
21092b18:	98800017 	ldw	r2,0(r19)
21092b1c:	10003426 	beq	r2,zero,21092bf0 <__call_exitprocs+0x18c>
21092b20:	9809883a 	mov	r4,r19
21092b24:	a8800015 	stw	r2,0(r21)
21092b28:	108d8fc0 	call	2108d8fc <free>
21092b2c:	acc00017 	ldw	r19,0(r21)
21092b30:	983fe41e 	bne	r19,zero,21092ac4 <__flash_rwdata_start+0xffff087c>
21092b34:	dfc00b17 	ldw	ra,44(sp)
21092b38:	df000a17 	ldw	fp,40(sp)
21092b3c:	ddc00917 	ldw	r23,36(sp)
21092b40:	dd800817 	ldw	r22,32(sp)
21092b44:	dd400717 	ldw	r21,28(sp)
21092b48:	dd000617 	ldw	r20,24(sp)
21092b4c:	dcc00517 	ldw	r19,20(sp)
21092b50:	dc800417 	ldw	r18,16(sp)
21092b54:	dc400317 	ldw	r17,12(sp)
21092b58:	dc000217 	ldw	r16,8(sp)
21092b5c:	dec00c04 	addi	sp,sp,48
21092b60:	f800283a 	ret
21092b64:	98800117 	ldw	r2,4(r19)
21092b68:	80c00017 	ldw	r3,0(r16)
21092b6c:	10bfffc4 	addi	r2,r2,-1
21092b70:	17001526 	beq	r2,fp,21092bc8 <__call_exitprocs+0x164>
21092b74:	80000015 	stw	zero,0(r16)
21092b78:	183fde26 	beq	r3,zero,21092af4 <__flash_rwdata_start+0xffff08ac>
21092b7c:	00800044 	movi	r2,1
21092b80:	1708983a 	sll	r4,r2,fp
21092b84:	98806217 	ldw	r2,392(r19)
21092b88:	9dc00117 	ldw	r23,4(r19)
21092b8c:	2084703a 	and	r2,r4,r2
21092b90:	1000061e 	bne	r2,zero,21092bac <__call_exitprocs+0x148>
21092b94:	183ee83a 	callr	r3
21092b98:	98800117 	ldw	r2,4(r19)
21092b9c:	15ffc51e 	bne	r2,r23,21092ab4 <__flash_rwdata_start+0xffff086c>
21092ba0:	a8800017 	ldw	r2,0(r21)
21092ba4:	14ffd326 	beq	r2,r19,21092af4 <__flash_rwdata_start+0xffff08ac>
21092ba8:	003fc206 	br	21092ab4 <__flash_rwdata_start+0xffff086c>
21092bac:	98806317 	ldw	r2,396(r19)
21092bb0:	2084703a 	and	r2,r4,r2
21092bb4:	1000061e 	bne	r2,zero,21092bd0 <__call_exitprocs+0x16c>
21092bb8:	89400017 	ldw	r5,0(r17)
21092bbc:	9009883a 	mov	r4,r18
21092bc0:	183ee83a 	callr	r3
21092bc4:	003ff406 	br	21092b98 <__flash_rwdata_start+0xffff0950>
21092bc8:	9f000115 	stw	fp,4(r19)
21092bcc:	003fea06 	br	21092b78 <__flash_rwdata_start+0xffff0930>
21092bd0:	89000017 	ldw	r4,0(r17)
21092bd4:	183ee83a 	callr	r3
21092bd8:	003fef06 	br	21092b98 <__flash_rwdata_start+0xffff0950>
21092bdc:	98800017 	ldw	r2,0(r19)
21092be0:	982b883a 	mov	r21,r19
21092be4:	1027883a 	mov	r19,r2
21092be8:	983fb61e 	bne	r19,zero,21092ac4 <__flash_rwdata_start+0xffff087c>
21092bec:	003fd106 	br	21092b34 <__flash_rwdata_start+0xffff08ec>
21092bf0:	0005883a 	mov	r2,zero
21092bf4:	003ffa06 	br	21092be0 <__flash_rwdata_start+0xffff0998>

21092bf8 <quorem>:
21092bf8:	defff704 	addi	sp,sp,-36
21092bfc:	dc800215 	stw	r18,8(sp)
21092c00:	20800417 	ldw	r2,16(r4)
21092c04:	2c800417 	ldw	r18,16(r5)
21092c08:	dfc00815 	stw	ra,32(sp)
21092c0c:	ddc00715 	stw	r23,28(sp)
21092c10:	dd800615 	stw	r22,24(sp)
21092c14:	dd400515 	stw	r21,20(sp)
21092c18:	dd000415 	stw	r20,16(sp)
21092c1c:	dcc00315 	stw	r19,12(sp)
21092c20:	dc400115 	stw	r17,4(sp)
21092c24:	dc000015 	stw	r16,0(sp)
21092c28:	14807116 	blt	r2,r18,21092df0 <quorem+0x1f8>
21092c2c:	94bfffc4 	addi	r18,r18,-1
21092c30:	94ad883a 	add	r22,r18,r18
21092c34:	b5ad883a 	add	r22,r22,r22
21092c38:	2c400504 	addi	r17,r5,20
21092c3c:	8da9883a 	add	r20,r17,r22
21092c40:	25400504 	addi	r21,r4,20
21092c44:	282f883a 	mov	r23,r5
21092c48:	adad883a 	add	r22,r21,r22
21092c4c:	a1400017 	ldw	r5,0(r20)
21092c50:	2021883a 	mov	r16,r4
21092c54:	b1000017 	ldw	r4,0(r22)
21092c58:	29400044 	addi	r5,r5,1
21092c5c:	108d5780 	call	2108d578 <__udivsi3>
21092c60:	1027883a 	mov	r19,r2
21092c64:	10002c26 	beq	r2,zero,21092d18 <quorem+0x120>
21092c68:	a813883a 	mov	r9,r21
21092c6c:	8811883a 	mov	r8,r17
21092c70:	0009883a 	mov	r4,zero
21092c74:	000d883a 	mov	r6,zero
21092c78:	41c00017 	ldw	r7,0(r8)
21092c7c:	49400017 	ldw	r5,0(r9)
21092c80:	42000104 	addi	r8,r8,4
21092c84:	38bfffcc 	andi	r2,r7,65535
21092c88:	14c5383a 	mul	r2,r2,r19
21092c8c:	380ed43a 	srli	r7,r7,16
21092c90:	28ffffcc 	andi	r3,r5,65535
21092c94:	2085883a 	add	r2,r4,r2
21092c98:	1008d43a 	srli	r4,r2,16
21092c9c:	3ccf383a 	mul	r7,r7,r19
21092ca0:	198d883a 	add	r6,r3,r6
21092ca4:	10ffffcc 	andi	r3,r2,65535
21092ca8:	30c7c83a 	sub	r3,r6,r3
21092cac:	280ad43a 	srli	r5,r5,16
21092cb0:	21c9883a 	add	r4,r4,r7
21092cb4:	180dd43a 	srai	r6,r3,16
21092cb8:	20bfffcc 	andi	r2,r4,65535
21092cbc:	288bc83a 	sub	r5,r5,r2
21092cc0:	298b883a 	add	r5,r5,r6
21092cc4:	280e943a 	slli	r7,r5,16
21092cc8:	18ffffcc 	andi	r3,r3,65535
21092ccc:	2008d43a 	srli	r4,r4,16
21092cd0:	38ceb03a 	or	r7,r7,r3
21092cd4:	49c00015 	stw	r7,0(r9)
21092cd8:	280dd43a 	srai	r6,r5,16
21092cdc:	4a400104 	addi	r9,r9,4
21092ce0:	a23fe52e 	bgeu	r20,r8,21092c78 <__flash_rwdata_start+0xffff0a30>
21092ce4:	b0800017 	ldw	r2,0(r22)
21092ce8:	10000b1e 	bne	r2,zero,21092d18 <quorem+0x120>
21092cec:	b0bfff04 	addi	r2,r22,-4
21092cf0:	a880082e 	bgeu	r21,r2,21092d14 <quorem+0x11c>
21092cf4:	b0ffff17 	ldw	r3,-4(r22)
21092cf8:	18000326 	beq	r3,zero,21092d08 <quorem+0x110>
21092cfc:	00000506 	br	21092d14 <quorem+0x11c>
21092d00:	10c00017 	ldw	r3,0(r2)
21092d04:	1800031e 	bne	r3,zero,21092d14 <quorem+0x11c>
21092d08:	10bfff04 	addi	r2,r2,-4
21092d0c:	94bfffc4 	addi	r18,r18,-1
21092d10:	a8bffb36 	bltu	r21,r2,21092d00 <__flash_rwdata_start+0xffff0ab8>
21092d14:	84800415 	stw	r18,16(r16)
21092d18:	8009883a 	mov	r4,r16
21092d1c:	b80b883a 	mov	r5,r23
21092d20:	10963600 	call	21096360 <__mcmp>
21092d24:	10002616 	blt	r2,zero,21092dc0 <quorem+0x1c8>
21092d28:	9cc00044 	addi	r19,r19,1
21092d2c:	a80d883a 	mov	r6,r21
21092d30:	000b883a 	mov	r5,zero
21092d34:	31000017 	ldw	r4,0(r6)
21092d38:	88800017 	ldw	r2,0(r17)
21092d3c:	31800104 	addi	r6,r6,4
21092d40:	20ffffcc 	andi	r3,r4,65535
21092d44:	194b883a 	add	r5,r3,r5
21092d48:	10ffffcc 	andi	r3,r2,65535
21092d4c:	28c7c83a 	sub	r3,r5,r3
21092d50:	1004d43a 	srli	r2,r2,16
21092d54:	2008d43a 	srli	r4,r4,16
21092d58:	180bd43a 	srai	r5,r3,16
21092d5c:	18ffffcc 	andi	r3,r3,65535
21092d60:	2089c83a 	sub	r4,r4,r2
21092d64:	2149883a 	add	r4,r4,r5
21092d68:	2004943a 	slli	r2,r4,16
21092d6c:	8c400104 	addi	r17,r17,4
21092d70:	200bd43a 	srai	r5,r4,16
21092d74:	10c6b03a 	or	r3,r2,r3
21092d78:	30ffff15 	stw	r3,-4(r6)
21092d7c:	a47fed2e 	bgeu	r20,r17,21092d34 <__flash_rwdata_start+0xffff0aec>
21092d80:	9485883a 	add	r2,r18,r18
21092d84:	1085883a 	add	r2,r2,r2
21092d88:	a887883a 	add	r3,r21,r2
21092d8c:	18800017 	ldw	r2,0(r3)
21092d90:	10000b1e 	bne	r2,zero,21092dc0 <quorem+0x1c8>
21092d94:	18bfff04 	addi	r2,r3,-4
21092d98:	a880082e 	bgeu	r21,r2,21092dbc <quorem+0x1c4>
21092d9c:	18ffff17 	ldw	r3,-4(r3)
21092da0:	18000326 	beq	r3,zero,21092db0 <quorem+0x1b8>
21092da4:	00000506 	br	21092dbc <quorem+0x1c4>
21092da8:	10c00017 	ldw	r3,0(r2)
21092dac:	1800031e 	bne	r3,zero,21092dbc <quorem+0x1c4>
21092db0:	10bfff04 	addi	r2,r2,-4
21092db4:	94bfffc4 	addi	r18,r18,-1
21092db8:	a8bffb36 	bltu	r21,r2,21092da8 <__flash_rwdata_start+0xffff0b60>
21092dbc:	84800415 	stw	r18,16(r16)
21092dc0:	9805883a 	mov	r2,r19
21092dc4:	dfc00817 	ldw	ra,32(sp)
21092dc8:	ddc00717 	ldw	r23,28(sp)
21092dcc:	dd800617 	ldw	r22,24(sp)
21092dd0:	dd400517 	ldw	r21,20(sp)
21092dd4:	dd000417 	ldw	r20,16(sp)
21092dd8:	dcc00317 	ldw	r19,12(sp)
21092ddc:	dc800217 	ldw	r18,8(sp)
21092de0:	dc400117 	ldw	r17,4(sp)
21092de4:	dc000017 	ldw	r16,0(sp)
21092de8:	dec00904 	addi	sp,sp,36
21092dec:	f800283a 	ret
21092df0:	0005883a 	mov	r2,zero
21092df4:	003ff306 	br	21092dc4 <__flash_rwdata_start+0xffff0b7c>

21092df8 <_dtoa_r>:
21092df8:	20801017 	ldw	r2,64(r4)
21092dfc:	deffde04 	addi	sp,sp,-136
21092e00:	dd401d15 	stw	r21,116(sp)
21092e04:	dcc01b15 	stw	r19,108(sp)
21092e08:	dc801a15 	stw	r18,104(sp)
21092e0c:	dc401915 	stw	r17,100(sp)
21092e10:	dc001815 	stw	r16,96(sp)
21092e14:	dfc02115 	stw	ra,132(sp)
21092e18:	df002015 	stw	fp,128(sp)
21092e1c:	ddc01f15 	stw	r23,124(sp)
21092e20:	dd801e15 	stw	r22,120(sp)
21092e24:	dd001c15 	stw	r20,112(sp)
21092e28:	d9c00315 	stw	r7,12(sp)
21092e2c:	2021883a 	mov	r16,r4
21092e30:	302b883a 	mov	r21,r6
21092e34:	2825883a 	mov	r18,r5
21092e38:	dc402417 	ldw	r17,144(sp)
21092e3c:	3027883a 	mov	r19,r6
21092e40:	10000826 	beq	r2,zero,21092e64 <_dtoa_r+0x6c>
21092e44:	21801117 	ldw	r6,68(r4)
21092e48:	00c00044 	movi	r3,1
21092e4c:	100b883a 	mov	r5,r2
21092e50:	1986983a 	sll	r3,r3,r6
21092e54:	11800115 	stw	r6,4(r2)
21092e58:	10c00215 	stw	r3,8(r2)
21092e5c:	1095b340 	call	21095b34 <_Bfree>
21092e60:	80001015 	stw	zero,64(r16)
21092e64:	a8002d16 	blt	r21,zero,21092f1c <_dtoa_r+0x124>
21092e68:	88000015 	stw	zero,0(r17)
21092e6c:	a8dffc2c 	andhi	r3,r21,32752
21092e70:	009ffc34 	movhi	r2,32752
21092e74:	18801b26 	beq	r3,r2,21092ee4 <_dtoa_r+0xec>
21092e78:	9009883a 	mov	r4,r18
21092e7c:	980b883a 	mov	r5,r19
21092e80:	000d883a 	mov	r6,zero
21092e84:	000f883a 	mov	r7,zero
21092e88:	109af240 	call	2109af24 <__eqdf2>
21092e8c:	10002a1e 	bne	r2,zero,21092f38 <_dtoa_r+0x140>
21092e90:	d8c02317 	ldw	r3,140(sp)
21092e94:	d9002517 	ldw	r4,148(sp)
21092e98:	00800044 	movi	r2,1
21092e9c:	18800015 	stw	r2,0(r3)
21092ea0:	2001a226 	beq	r4,zero,2109352c <_dtoa_r+0x734>
21092ea4:	00800034 	movhi	r2,0
21092ea8:	108ed944 	addi	r2,r2,15205
21092eac:	20800015 	stw	r2,0(r4)
21092eb0:	10bfffc4 	addi	r2,r2,-1
21092eb4:	dfc02117 	ldw	ra,132(sp)
21092eb8:	df002017 	ldw	fp,128(sp)
21092ebc:	ddc01f17 	ldw	r23,124(sp)
21092ec0:	dd801e17 	ldw	r22,120(sp)
21092ec4:	dd401d17 	ldw	r21,116(sp)
21092ec8:	dd001c17 	ldw	r20,112(sp)
21092ecc:	dcc01b17 	ldw	r19,108(sp)
21092ed0:	dc801a17 	ldw	r18,104(sp)
21092ed4:	dc401917 	ldw	r17,100(sp)
21092ed8:	dc001817 	ldw	r16,96(sp)
21092edc:	dec02204 	addi	sp,sp,136
21092ee0:	f800283a 	ret
21092ee4:	d8c02317 	ldw	r3,140(sp)
21092ee8:	0089c3c4 	movi	r2,9999
21092eec:	18800015 	stw	r2,0(r3)
21092ef0:	90017c26 	beq	r18,zero,210934e4 <_dtoa_r+0x6ec>
21092ef4:	00800034 	movhi	r2,0
21092ef8:	108eed04 	addi	r2,r2,15284
21092efc:	d9002517 	ldw	r4,148(sp)
21092f00:	203fec26 	beq	r4,zero,21092eb4 <__flash_rwdata_start+0xffff0c6c>
21092f04:	10c000c7 	ldb	r3,3(r2)
21092f08:	18017d1e 	bne	r3,zero,21093500 <_dtoa_r+0x708>
21092f0c:	10c000c4 	addi	r3,r2,3
21092f10:	d9802517 	ldw	r6,148(sp)
21092f14:	30c00015 	stw	r3,0(r6)
21092f18:	003fe606 	br	21092eb4 <__flash_rwdata_start+0xffff0c6c>
21092f1c:	04e00034 	movhi	r19,32768
21092f20:	9cffffc4 	addi	r19,r19,-1
21092f24:	00800044 	movi	r2,1
21092f28:	ace6703a 	and	r19,r21,r19
21092f2c:	88800015 	stw	r2,0(r17)
21092f30:	982b883a 	mov	r21,r19
21092f34:	003fcd06 	br	21092e6c <__flash_rwdata_start+0xffff0c24>
21092f38:	d8800204 	addi	r2,sp,8
21092f3c:	a822d53a 	srli	r17,r21,20
21092f40:	d8800015 	stw	r2,0(sp)
21092f44:	8009883a 	mov	r4,r16
21092f48:	900b883a 	mov	r5,r18
21092f4c:	980d883a 	mov	r6,r19
21092f50:	d9c00104 	addi	r7,sp,4
21092f54:	10966d40 	call	210966d4 <__d2b>
21092f58:	1039883a 	mov	fp,r2
21092f5c:	88016a1e 	bne	r17,zero,21093508 <_dtoa_r+0x710>
21092f60:	dd000217 	ldw	r20,8(sp)
21092f64:	dc400117 	ldw	r17,4(sp)
21092f68:	00befbc4 	movi	r2,-1041
21092f6c:	a463883a 	add	r17,r20,r17
21092f70:	8882ea16 	blt	r17,r2,21093b1c <_dtoa_r+0xd24>
21092f74:	00bf0384 	movi	r2,-1010
21092f78:	1445c83a 	sub	r2,r2,r17
21092f7c:	89010484 	addi	r4,r17,1042
21092f80:	a8aa983a 	sll	r21,r21,r2
21092f84:	9108d83a 	srl	r4,r18,r4
21092f88:	a908b03a 	or	r4,r21,r4
21092f8c:	108d0ac0 	call	2108d0ac <__floatunsidf>
21092f90:	017f8434 	movhi	r5,65040
21092f94:	01800044 	movi	r6,1
21092f98:	1009883a 	mov	r4,r2
21092f9c:	194b883a 	add	r5,r3,r5
21092fa0:	8c7fffc4 	addi	r17,r17,-1
21092fa4:	d9800f15 	stw	r6,60(sp)
21092fa8:	000d883a 	mov	r6,zero
21092fac:	01cffe34 	movhi	r7,16376
21092fb0:	108c6840 	call	2108c684 <__subdf3>
21092fb4:	0198dbf4 	movhi	r6,25455
21092fb8:	01cff4f4 	movhi	r7,16339
21092fbc:	1009883a 	mov	r4,r2
21092fc0:	180b883a 	mov	r5,r3
21092fc4:	3190d844 	addi	r6,r6,17249
21092fc8:	39e1e9c4 	addi	r7,r7,-30809
21092fcc:	108bf600 	call	2108bf60 <__muldf3>
21092fd0:	01a2d874 	movhi	r6,35681
21092fd4:	01cff1f4 	movhi	r7,16327
21092fd8:	180b883a 	mov	r5,r3
21092fdc:	31b22cc4 	addi	r6,r6,-14157
21092fe0:	39e28a04 	addi	r7,r7,-30168
21092fe4:	1009883a 	mov	r4,r2
21092fe8:	108ad180 	call	2108ad18 <__adddf3>
21092fec:	8809883a 	mov	r4,r17
21092ff0:	102d883a 	mov	r22,r2
21092ff4:	182b883a 	mov	r21,r3
21092ff8:	108cfdc0 	call	2108cfdc <__floatsidf>
21092ffc:	019427f4 	movhi	r6,20639
21093000:	01cff4f4 	movhi	r7,16339
21093004:	1009883a 	mov	r4,r2
21093008:	180b883a 	mov	r5,r3
2109300c:	319e7ec4 	addi	r6,r6,31227
21093010:	39d104c4 	addi	r7,r7,17427
21093014:	108bf600 	call	2108bf60 <__muldf3>
21093018:	b009883a 	mov	r4,r22
2109301c:	a80b883a 	mov	r5,r21
21093020:	100d883a 	mov	r6,r2
21093024:	180f883a 	mov	r7,r3
21093028:	108ad180 	call	2108ad18 <__adddf3>
2109302c:	1009883a 	mov	r4,r2
21093030:	180b883a 	mov	r5,r3
21093034:	102d883a 	mov	r22,r2
21093038:	182b883a 	mov	r21,r3
2109303c:	108cf540 	call	2108cf54 <__fixdfsi>
21093040:	b009883a 	mov	r4,r22
21093044:	a80b883a 	mov	r5,r21
21093048:	000d883a 	mov	r6,zero
2109304c:	000f883a 	mov	r7,zero
21093050:	d8800515 	stw	r2,20(sp)
21093054:	109afa80 	call	2109afa8 <__ledf2>
21093058:	10023116 	blt	r2,zero,21093920 <_dtoa_r+0xb28>
2109305c:	d8c00517 	ldw	r3,20(sp)
21093060:	00800584 	movi	r2,22
21093064:	10c21f36 	bltu	r2,r3,210938e4 <_dtoa_r+0xaec>
21093068:	180490fa 	slli	r2,r3,3
2109306c:	00c00034 	movhi	r3,0
21093070:	18cf0804 	addi	r3,r3,15392
21093074:	1885883a 	add	r2,r3,r2
21093078:	11000017 	ldw	r4,0(r2)
2109307c:	11400117 	ldw	r5,4(r2)
21093080:	900d883a 	mov	r6,r18
21093084:	980f883a 	mov	r7,r19
21093088:	108be800 	call	2108be80 <__gedf2>
2109308c:	0082a70e 	bge	zero,r2,21093b2c <_dtoa_r+0xd34>
21093090:	d9000517 	ldw	r4,20(sp)
21093094:	d8000d15 	stw	zero,52(sp)
21093098:	213fffc4 	addi	r4,r4,-1
2109309c:	d9000515 	stw	r4,20(sp)
210930a0:	a463c83a 	sub	r17,r20,r17
210930a4:	8dbfffc4 	addi	r22,r17,-1
210930a8:	b0021916 	blt	r22,zero,21093910 <_dtoa_r+0xb18>
210930ac:	d8000815 	stw	zero,32(sp)
210930b0:	d8800517 	ldw	r2,20(sp)
210930b4:	10020e16 	blt	r2,zero,210938f0 <_dtoa_r+0xaf8>
210930b8:	b0ad883a 	add	r22,r22,r2
210930bc:	d8800a15 	stw	r2,40(sp)
210930c0:	d8000915 	stw	zero,36(sp)
210930c4:	d8c00317 	ldw	r3,12(sp)
210930c8:	00800244 	movi	r2,9
210930cc:	10c11a36 	bltu	r2,r3,21093538 <_dtoa_r+0x740>
210930d0:	00800144 	movi	r2,5
210930d4:	10c4fc0e 	bge	r2,r3,210944c8 <_dtoa_r+0x16d0>
210930d8:	18ffff04 	addi	r3,r3,-4
210930dc:	d8c00315 	stw	r3,12(sp)
210930e0:	0029883a 	mov	r20,zero
210930e4:	d9800317 	ldw	r6,12(sp)
210930e8:	008000c4 	movi	r2,3
210930ec:	3083bd26 	beq	r6,r2,21093fe4 <_dtoa_r+0x11ec>
210930f0:	1183670e 	bge	r2,r6,21093e90 <_dtoa_r+0x1098>
210930f4:	d8c00317 	ldw	r3,12(sp)
210930f8:	00800104 	movi	r2,4
210930fc:	1882e726 	beq	r3,r2,21093c9c <_dtoa_r+0xea4>
21093100:	00800144 	movi	r2,5
21093104:	1884f21e 	bne	r3,r2,210944d0 <_dtoa_r+0x16d8>
21093108:	00800044 	movi	r2,1
2109310c:	d8800b15 	stw	r2,44(sp)
21093110:	d8c02217 	ldw	r3,136(sp)
21093114:	d9000517 	ldw	r4,20(sp)
21093118:	1907883a 	add	r3,r3,r4
2109311c:	19800044 	addi	r6,r3,1
21093120:	d8c00c15 	stw	r3,48(sp)
21093124:	d9800615 	stw	r6,24(sp)
21093128:	0183c30e 	bge	zero,r6,21094038 <_dtoa_r+0x1240>
2109312c:	d9800617 	ldw	r6,24(sp)
21093130:	3023883a 	mov	r17,r6
21093134:	80001115 	stw	zero,68(r16)
21093138:	008005c4 	movi	r2,23
2109313c:	1184f62e 	bgeu	r2,r6,21094518 <_dtoa_r+0x1720>
21093140:	00c00044 	movi	r3,1
21093144:	00800104 	movi	r2,4
21093148:	1085883a 	add	r2,r2,r2
2109314c:	11000504 	addi	r4,r2,20
21093150:	180b883a 	mov	r5,r3
21093154:	18c00044 	addi	r3,r3,1
21093158:	313ffb2e 	bgeu	r6,r4,21093148 <__flash_rwdata_start+0xffff0f00>
2109315c:	81401115 	stw	r5,68(r16)
21093160:	8009883a 	mov	r4,r16
21093164:	1095a8c0 	call	21095a8c <_Balloc>
21093168:	d8800715 	stw	r2,28(sp)
2109316c:	80801015 	stw	r2,64(r16)
21093170:	00800384 	movi	r2,14
21093174:	1440fd36 	bltu	r2,r17,2109356c <_dtoa_r+0x774>
21093178:	a000fc26 	beq	r20,zero,2109356c <_dtoa_r+0x774>
2109317c:	d8800517 	ldw	r2,20(sp)
21093180:	0083b90e 	bge	zero,r2,21094068 <_dtoa_r+0x1270>
21093184:	d8c00517 	ldw	r3,20(sp)
21093188:	108003cc 	andi	r2,r2,15
2109318c:	100490fa 	slli	r2,r2,3
21093190:	182fd13a 	srai	r23,r3,4
21093194:	00c00034 	movhi	r3,0
21093198:	18cf0804 	addi	r3,r3,15392
2109319c:	1885883a 	add	r2,r3,r2
210931a0:	b8c0040c 	andi	r3,r23,16
210931a4:	12c00017 	ldw	r11,0(r2)
210931a8:	12800117 	ldw	r10,4(r2)
210931ac:	18039726 	beq	r3,zero,2109400c <_dtoa_r+0x1214>
210931b0:	00800034 	movhi	r2,0
210931b4:	108efe04 	addi	r2,r2,15352
210931b8:	11800817 	ldw	r6,32(r2)
210931bc:	11c00917 	ldw	r7,36(r2)
210931c0:	9009883a 	mov	r4,r18
210931c4:	980b883a 	mov	r5,r19
210931c8:	da801615 	stw	r10,88(sp)
210931cc:	dac01515 	stw	r11,84(sp)
210931d0:	108b5b40 	call	2108b5b4 <__divdf3>
210931d4:	da801617 	ldw	r10,88(sp)
210931d8:	dac01517 	ldw	r11,84(sp)
210931dc:	bdc003cc 	andi	r23,r23,15
210931e0:	044000c4 	movi	r17,3
210931e4:	d8800e15 	stw	r2,56(sp)
210931e8:	182b883a 	mov	r21,r3
210931ec:	b8001126 	beq	r23,zero,21093234 <_dtoa_r+0x43c>
210931f0:	05000034 	movhi	r20,0
210931f4:	a50efe04 	addi	r20,r20,15352
210931f8:	5805883a 	mov	r2,r11
210931fc:	5007883a 	mov	r3,r10
21093200:	b980004c 	andi	r6,r23,1
21093204:	1009883a 	mov	r4,r2
21093208:	b82fd07a 	srai	r23,r23,1
2109320c:	180b883a 	mov	r5,r3
21093210:	30000426 	beq	r6,zero,21093224 <_dtoa_r+0x42c>
21093214:	a1800017 	ldw	r6,0(r20)
21093218:	a1c00117 	ldw	r7,4(r20)
2109321c:	8c400044 	addi	r17,r17,1
21093220:	108bf600 	call	2108bf60 <__muldf3>
21093224:	a5000204 	addi	r20,r20,8
21093228:	b83ff51e 	bne	r23,zero,21093200 <__flash_rwdata_start+0xffff0fb8>
2109322c:	1017883a 	mov	r11,r2
21093230:	1815883a 	mov	r10,r3
21093234:	d9000e17 	ldw	r4,56(sp)
21093238:	a80b883a 	mov	r5,r21
2109323c:	580d883a 	mov	r6,r11
21093240:	500f883a 	mov	r7,r10
21093244:	108b5b40 	call	2108b5b4 <__divdf3>
21093248:	1029883a 	mov	r20,r2
2109324c:	182b883a 	mov	r21,r3
21093250:	d9800d17 	ldw	r6,52(sp)
21093254:	30000626 	beq	r6,zero,21093270 <_dtoa_r+0x478>
21093258:	a009883a 	mov	r4,r20
2109325c:	a80b883a 	mov	r5,r21
21093260:	000d883a 	mov	r6,zero
21093264:	01cffc34 	movhi	r7,16368
21093268:	109afa80 	call	2109afa8 <__ledf2>
2109326c:	10043216 	blt	r2,zero,21094338 <_dtoa_r+0x1540>
21093270:	8809883a 	mov	r4,r17
21093274:	108cfdc0 	call	2108cfdc <__floatsidf>
21093278:	1009883a 	mov	r4,r2
2109327c:	180b883a 	mov	r5,r3
21093280:	a00d883a 	mov	r6,r20
21093284:	a80f883a 	mov	r7,r21
21093288:	108bf600 	call	2108bf60 <__muldf3>
2109328c:	000d883a 	mov	r6,zero
21093290:	1009883a 	mov	r4,r2
21093294:	180b883a 	mov	r5,r3
21093298:	01d00734 	movhi	r7,16412
2109329c:	108ad180 	call	2108ad18 <__adddf3>
210932a0:	1023883a 	mov	r17,r2
210932a4:	d9800617 	ldw	r6,24(sp)
210932a8:	00bf3034 	movhi	r2,64704
210932ac:	1885883a 	add	r2,r3,r2
210932b0:	d8800e15 	stw	r2,56(sp)
210932b4:	30032e26 	beq	r6,zero,21093f70 <_dtoa_r+0x1178>
210932b8:	d8c00517 	ldw	r3,20(sp)
210932bc:	da800617 	ldw	r10,24(sp)
210932c0:	d8c01215 	stw	r3,72(sp)
210932c4:	d9000b17 	ldw	r4,44(sp)
210932c8:	2003b026 	beq	r4,zero,2109418c <_dtoa_r+0x1394>
210932cc:	50bfffc4 	addi	r2,r10,-1
210932d0:	100490fa 	slli	r2,r2,3
210932d4:	00c00034 	movhi	r3,0
210932d8:	18cf0804 	addi	r3,r3,15392
210932dc:	1885883a 	add	r2,r3,r2
210932e0:	11800017 	ldw	r6,0(r2)
210932e4:	11c00117 	ldw	r7,4(r2)
210932e8:	d8800717 	ldw	r2,28(sp)
210932ec:	0009883a 	mov	r4,zero
210932f0:	014ff834 	movhi	r5,16352
210932f4:	da801615 	stw	r10,88(sp)
210932f8:	15c00044 	addi	r23,r2,1
210932fc:	108b5b40 	call	2108b5b4 <__divdf3>
21093300:	d9c00e17 	ldw	r7,56(sp)
21093304:	880d883a 	mov	r6,r17
21093308:	1009883a 	mov	r4,r2
2109330c:	180b883a 	mov	r5,r3
21093310:	108c6840 	call	2108c684 <__subdf3>
21093314:	a80b883a 	mov	r5,r21
21093318:	a009883a 	mov	r4,r20
2109331c:	d8c01015 	stw	r3,64(sp)
21093320:	d8800e15 	stw	r2,56(sp)
21093324:	108cf540 	call	2108cf54 <__fixdfsi>
21093328:	1009883a 	mov	r4,r2
2109332c:	d8801715 	stw	r2,92(sp)
21093330:	108cfdc0 	call	2108cfdc <__floatsidf>
21093334:	a009883a 	mov	r4,r20
21093338:	a80b883a 	mov	r5,r21
2109333c:	100d883a 	mov	r6,r2
21093340:	180f883a 	mov	r7,r3
21093344:	108c6840 	call	2108c684 <__subdf3>
21093348:	da001717 	ldw	r8,92(sp)
2109334c:	1829883a 	mov	r20,r3
21093350:	d8c00717 	ldw	r3,28(sp)
21093354:	d9000e17 	ldw	r4,56(sp)
21093358:	d9401017 	ldw	r5,64(sp)
2109335c:	42000c04 	addi	r8,r8,48
21093360:	1023883a 	mov	r17,r2
21093364:	1a000005 	stb	r8,0(r3)
21093368:	880d883a 	mov	r6,r17
2109336c:	a00f883a 	mov	r7,r20
21093370:	402b883a 	mov	r21,r8
21093374:	108be800 	call	2108be80 <__gedf2>
21093378:	00844516 	blt	zero,r2,21094490 <_dtoa_r+0x1698>
2109337c:	0009883a 	mov	r4,zero
21093380:	014ffc34 	movhi	r5,16368
21093384:	880d883a 	mov	r6,r17
21093388:	a00f883a 	mov	r7,r20
2109338c:	108c6840 	call	2108c684 <__subdf3>
21093390:	d9000e17 	ldw	r4,56(sp)
21093394:	d9401017 	ldw	r5,64(sp)
21093398:	100d883a 	mov	r6,r2
2109339c:	180f883a 	mov	r7,r3
210933a0:	108be800 	call	2108be80 <__gedf2>
210933a4:	da801617 	ldw	r10,88(sp)
210933a8:	00843616 	blt	zero,r2,21094484 <_dtoa_r+0x168c>
210933ac:	00800044 	movi	r2,1
210933b0:	12806e0e 	bge	r2,r10,2109356c <_dtoa_r+0x774>
210933b4:	d9000717 	ldw	r4,28(sp)
210933b8:	dd801315 	stw	r22,76(sp)
210933bc:	dc001115 	stw	r16,68(sp)
210933c0:	2295883a 	add	r10,r4,r10
210933c4:	dcc01415 	stw	r19,80(sp)
210933c8:	502d883a 	mov	r22,r10
210933cc:	dcc01017 	ldw	r19,64(sp)
210933d0:	b821883a 	mov	r16,r23
210933d4:	dc801015 	stw	r18,64(sp)
210933d8:	dc800e17 	ldw	r18,56(sp)
210933dc:	00000906 	br	21093404 <_dtoa_r+0x60c>
210933e0:	108c6840 	call	2108c684 <__subdf3>
210933e4:	1009883a 	mov	r4,r2
210933e8:	180b883a 	mov	r5,r3
210933ec:	900d883a 	mov	r6,r18
210933f0:	980f883a 	mov	r7,r19
210933f4:	109afa80 	call	2109afa8 <__ledf2>
210933f8:	10040e16 	blt	r2,zero,21094434 <_dtoa_r+0x163c>
210933fc:	b821883a 	mov	r16,r23
21093400:	bd841026 	beq	r23,r22,21094444 <_dtoa_r+0x164c>
21093404:	9009883a 	mov	r4,r18
21093408:	980b883a 	mov	r5,r19
2109340c:	000d883a 	mov	r6,zero
21093410:	01d00934 	movhi	r7,16420
21093414:	108bf600 	call	2108bf60 <__muldf3>
21093418:	000d883a 	mov	r6,zero
2109341c:	01d00934 	movhi	r7,16420
21093420:	8809883a 	mov	r4,r17
21093424:	a00b883a 	mov	r5,r20
21093428:	1025883a 	mov	r18,r2
2109342c:	1827883a 	mov	r19,r3
21093430:	108bf600 	call	2108bf60 <__muldf3>
21093434:	180b883a 	mov	r5,r3
21093438:	1009883a 	mov	r4,r2
2109343c:	1823883a 	mov	r17,r3
21093440:	1029883a 	mov	r20,r2
21093444:	108cf540 	call	2108cf54 <__fixdfsi>
21093448:	1009883a 	mov	r4,r2
2109344c:	102b883a 	mov	r21,r2
21093450:	108cfdc0 	call	2108cfdc <__floatsidf>
21093454:	a009883a 	mov	r4,r20
21093458:	880b883a 	mov	r5,r17
2109345c:	100d883a 	mov	r6,r2
21093460:	180f883a 	mov	r7,r3
21093464:	108c6840 	call	2108c684 <__subdf3>
21093468:	ad400c04 	addi	r21,r21,48
2109346c:	1009883a 	mov	r4,r2
21093470:	180b883a 	mov	r5,r3
21093474:	900d883a 	mov	r6,r18
21093478:	980f883a 	mov	r7,r19
2109347c:	85400005 	stb	r21,0(r16)
21093480:	1023883a 	mov	r17,r2
21093484:	1829883a 	mov	r20,r3
21093488:	109afa80 	call	2109afa8 <__ledf2>
2109348c:	bdc00044 	addi	r23,r23,1
21093490:	0009883a 	mov	r4,zero
21093494:	014ffc34 	movhi	r5,16368
21093498:	880d883a 	mov	r6,r17
2109349c:	a00f883a 	mov	r7,r20
210934a0:	103fcf0e 	bge	r2,zero,210933e0 <__flash_rwdata_start+0xffff1198>
210934a4:	d9801217 	ldw	r6,72(sp)
210934a8:	dc001117 	ldw	r16,68(sp)
210934ac:	d9800515 	stw	r6,20(sp)
210934b0:	8009883a 	mov	r4,r16
210934b4:	e00b883a 	mov	r5,fp
210934b8:	1095b340 	call	21095b34 <_Bfree>
210934bc:	d8c00517 	ldw	r3,20(sp)
210934c0:	d9002317 	ldw	r4,140(sp)
210934c4:	d9802517 	ldw	r6,148(sp)
210934c8:	b8000005 	stb	zero,0(r23)
210934cc:	18800044 	addi	r2,r3,1
210934d0:	20800015 	stw	r2,0(r4)
210934d4:	30027226 	beq	r6,zero,21093ea0 <_dtoa_r+0x10a8>
210934d8:	35c00015 	stw	r23,0(r6)
210934dc:	d8800717 	ldw	r2,28(sp)
210934e0:	003e7406 	br	21092eb4 <__flash_rwdata_start+0xffff0c6c>
210934e4:	00800434 	movhi	r2,16
210934e8:	10bfffc4 	addi	r2,r2,-1
210934ec:	a8aa703a 	and	r21,r21,r2
210934f0:	a83e801e 	bne	r21,zero,21092ef4 <__flash_rwdata_start+0xffff0cac>
210934f4:	00800034 	movhi	r2,0
210934f8:	108eea04 	addi	r2,r2,15272
210934fc:	003e7f06 	br	21092efc <__flash_rwdata_start+0xffff0cb4>
21093500:	10c00204 	addi	r3,r2,8
21093504:	003e8206 	br	21092f10 <__flash_rwdata_start+0xffff0cc8>
21093508:	01400434 	movhi	r5,16
2109350c:	297fffc4 	addi	r5,r5,-1
21093510:	994a703a 	and	r5,r19,r5
21093514:	9009883a 	mov	r4,r18
21093518:	8c7f0044 	addi	r17,r17,-1023
2109351c:	294ffc34 	orhi	r5,r5,16368
21093520:	dd000217 	ldw	r20,8(sp)
21093524:	d8000f15 	stw	zero,60(sp)
21093528:	003e9f06 	br	21092fa8 <__flash_rwdata_start+0xffff0d60>
2109352c:	00800034 	movhi	r2,0
21093530:	108ed904 	addi	r2,r2,15204
21093534:	003e5f06 	br	21092eb4 <__flash_rwdata_start+0xffff0c6c>
21093538:	80001115 	stw	zero,68(r16)
2109353c:	8009883a 	mov	r4,r16
21093540:	000b883a 	mov	r5,zero
21093544:	1095a8c0 	call	21095a8c <_Balloc>
21093548:	01bfffc4 	movi	r6,-1
2109354c:	d8800715 	stw	r2,28(sp)
21093550:	80801015 	stw	r2,64(r16)
21093554:	00800044 	movi	r2,1
21093558:	d9800c15 	stw	r6,48(sp)
2109355c:	d8800b15 	stw	r2,44(sp)
21093560:	d9800615 	stw	r6,24(sp)
21093564:	d8002215 	stw	zero,136(sp)
21093568:	d8000315 	stw	zero,12(sp)
2109356c:	d8800117 	ldw	r2,4(sp)
21093570:	10008e16 	blt	r2,zero,210937ac <_dtoa_r+0x9b4>
21093574:	d9000517 	ldw	r4,20(sp)
21093578:	00c00384 	movi	r3,14
2109357c:	19008b16 	blt	r3,r4,210937ac <_dtoa_r+0x9b4>
21093580:	200490fa 	slli	r2,r4,3
21093584:	00c00034 	movhi	r3,0
21093588:	d9802217 	ldw	r6,136(sp)
2109358c:	18cf0804 	addi	r3,r3,15392
21093590:	1885883a 	add	r2,r3,r2
21093594:	14400017 	ldw	r17,0(r2)
21093598:	15000117 	ldw	r20,4(r2)
2109359c:	3001c716 	blt	r6,zero,21093cbc <_dtoa_r+0xec4>
210935a0:	880d883a 	mov	r6,r17
210935a4:	a00f883a 	mov	r7,r20
210935a8:	9009883a 	mov	r4,r18
210935ac:	980b883a 	mov	r5,r19
210935b0:	108b5b40 	call	2108b5b4 <__divdf3>
210935b4:	180b883a 	mov	r5,r3
210935b8:	1009883a 	mov	r4,r2
210935bc:	108cf540 	call	2108cf54 <__fixdfsi>
210935c0:	1009883a 	mov	r4,r2
210935c4:	102d883a 	mov	r22,r2
210935c8:	108cfdc0 	call	2108cfdc <__floatsidf>
210935cc:	1009883a 	mov	r4,r2
210935d0:	180b883a 	mov	r5,r3
210935d4:	880d883a 	mov	r6,r17
210935d8:	a00f883a 	mov	r7,r20
210935dc:	108bf600 	call	2108bf60 <__muldf3>
210935e0:	9009883a 	mov	r4,r18
210935e4:	980b883a 	mov	r5,r19
210935e8:	100d883a 	mov	r6,r2
210935ec:	180f883a 	mov	r7,r3
210935f0:	108c6840 	call	2108c684 <__subdf3>
210935f4:	d9000717 	ldw	r4,28(sp)
210935f8:	d9800617 	ldw	r6,24(sp)
210935fc:	180b883a 	mov	r5,r3
21093600:	b0c00c04 	addi	r3,r22,48
21093604:	20c00005 	stb	r3,0(r4)
21093608:	25c00044 	addi	r23,r4,1
2109360c:	01000044 	movi	r4,1
21093610:	1011883a 	mov	r8,r2
21093614:	2807883a 	mov	r3,r5
21093618:	31003d26 	beq	r6,r4,21093710 <_dtoa_r+0x918>
2109361c:	000d883a 	mov	r6,zero
21093620:	01d00934 	movhi	r7,16420
21093624:	1009883a 	mov	r4,r2
21093628:	108bf600 	call	2108bf60 <__muldf3>
2109362c:	1009883a 	mov	r4,r2
21093630:	180b883a 	mov	r5,r3
21093634:	000d883a 	mov	r6,zero
21093638:	000f883a 	mov	r7,zero
2109363c:	1027883a 	mov	r19,r2
21093640:	182b883a 	mov	r21,r3
21093644:	109af240 	call	2109af24 <__eqdf2>
21093648:	103f9926 	beq	r2,zero,210934b0 <__flash_rwdata_start+0xffff1268>
2109364c:	d8c00617 	ldw	r3,24(sp)
21093650:	d9000717 	ldw	r4,28(sp)
21093654:	b825883a 	mov	r18,r23
21093658:	18bfffc4 	addi	r2,r3,-1
2109365c:	20ad883a 	add	r22,r4,r2
21093660:	dc000315 	stw	r16,12(sp)
21093664:	00000a06 	br	21093690 <_dtoa_r+0x898>
21093668:	108bf600 	call	2108bf60 <__muldf3>
2109366c:	1009883a 	mov	r4,r2
21093670:	180b883a 	mov	r5,r3
21093674:	000d883a 	mov	r6,zero
21093678:	000f883a 	mov	r7,zero
2109367c:	1027883a 	mov	r19,r2
21093680:	182b883a 	mov	r21,r3
21093684:	b825883a 	mov	r18,r23
21093688:	109af240 	call	2109af24 <__eqdf2>
2109368c:	10022626 	beq	r2,zero,21093f28 <_dtoa_r+0x1130>
21093690:	880d883a 	mov	r6,r17
21093694:	a00f883a 	mov	r7,r20
21093698:	9809883a 	mov	r4,r19
2109369c:	a80b883a 	mov	r5,r21
210936a0:	108b5b40 	call	2108b5b4 <__divdf3>
210936a4:	180b883a 	mov	r5,r3
210936a8:	1009883a 	mov	r4,r2
210936ac:	108cf540 	call	2108cf54 <__fixdfsi>
210936b0:	1009883a 	mov	r4,r2
210936b4:	1021883a 	mov	r16,r2
210936b8:	108cfdc0 	call	2108cfdc <__floatsidf>
210936bc:	1009883a 	mov	r4,r2
210936c0:	180b883a 	mov	r5,r3
210936c4:	880d883a 	mov	r6,r17
210936c8:	a00f883a 	mov	r7,r20
210936cc:	108bf600 	call	2108bf60 <__muldf3>
210936d0:	9809883a 	mov	r4,r19
210936d4:	a80b883a 	mov	r5,r21
210936d8:	100d883a 	mov	r6,r2
210936dc:	180f883a 	mov	r7,r3
210936e0:	108c6840 	call	2108c684 <__subdf3>
210936e4:	82000c04 	addi	r8,r16,48
210936e8:	92000005 	stb	r8,0(r18)
210936ec:	1009883a 	mov	r4,r2
210936f0:	180b883a 	mov	r5,r3
210936f4:	000d883a 	mov	r6,zero
210936f8:	01d00934 	movhi	r7,16420
210936fc:	1011883a 	mov	r8,r2
21093700:	bdc00044 	addi	r23,r23,1
21093704:	95bfd81e 	bne	r18,r22,21093668 <__flash_rwdata_start+0xffff1420>
21093708:	802d883a 	mov	r22,r16
2109370c:	dc000317 	ldw	r16,12(sp)
21093710:	4009883a 	mov	r4,r8
21093714:	180b883a 	mov	r5,r3
21093718:	400d883a 	mov	r6,r8
2109371c:	180f883a 	mov	r7,r3
21093720:	108ad180 	call	2108ad18 <__adddf3>
21093724:	8809883a 	mov	r4,r17
21093728:	a00b883a 	mov	r5,r20
2109372c:	100d883a 	mov	r6,r2
21093730:	180f883a 	mov	r7,r3
21093734:	1027883a 	mov	r19,r2
21093738:	1825883a 	mov	r18,r3
2109373c:	109afa80 	call	2109afa8 <__ledf2>
21093740:	10000816 	blt	r2,zero,21093764 <_dtoa_r+0x96c>
21093744:	8809883a 	mov	r4,r17
21093748:	a00b883a 	mov	r5,r20
2109374c:	980d883a 	mov	r6,r19
21093750:	900f883a 	mov	r7,r18
21093754:	109af240 	call	2109af24 <__eqdf2>
21093758:	103f551e 	bne	r2,zero,210934b0 <__flash_rwdata_start+0xffff1268>
2109375c:	b580004c 	andi	r22,r22,1
21093760:	b03f5326 	beq	r22,zero,210934b0 <__flash_rwdata_start+0xffff1268>
21093764:	bd7fffc3 	ldbu	r21,-1(r23)
21093768:	b8bfffc4 	addi	r2,r23,-1
2109376c:	1007883a 	mov	r3,r2
21093770:	01400e44 	movi	r5,57
21093774:	d9800717 	ldw	r6,28(sp)
21093778:	00000506 	br	21093790 <_dtoa_r+0x998>
2109377c:	18ffffc4 	addi	r3,r3,-1
21093780:	30825e26 	beq	r6,r2,210940fc <_dtoa_r+0x1304>
21093784:	1d400003 	ldbu	r21,0(r3)
21093788:	102f883a 	mov	r23,r2
2109378c:	10bfffc4 	addi	r2,r2,-1
21093790:	a9003fcc 	andi	r4,r21,255
21093794:	2100201c 	xori	r4,r4,128
21093798:	213fe004 	addi	r4,r4,-128
2109379c:	217ff726 	beq	r4,r5,2109377c <__flash_rwdata_start+0xffff1534>
210937a0:	aa000044 	addi	r8,r21,1
210937a4:	12000005 	stb	r8,0(r2)
210937a8:	003f4106 	br	210934b0 <__flash_rwdata_start+0xffff1268>
210937ac:	d8c00b17 	ldw	r3,44(sp)
210937b0:	18006726 	beq	r3,zero,21093950 <_dtoa_r+0xb58>
210937b4:	d9000317 	ldw	r4,12(sp)
210937b8:	00c00044 	movi	r3,1
210937bc:	19016a0e 	bge	r3,r4,21093d68 <_dtoa_r+0xf70>
210937c0:	d8800617 	ldw	r2,24(sp)
210937c4:	d8c00917 	ldw	r3,36(sp)
210937c8:	157fffc4 	addi	r21,r2,-1
210937cc:	1d420716 	blt	r3,r21,21093fec <_dtoa_r+0x11f4>
210937d0:	1d6bc83a 	sub	r21,r3,r21
210937d4:	d8800617 	ldw	r2,24(sp)
210937d8:	1002c716 	blt	r2,zero,210942f8 <_dtoa_r+0x1500>
210937dc:	dd000817 	ldw	r20,32(sp)
210937e0:	d8800617 	ldw	r2,24(sp)
210937e4:	d9800817 	ldw	r6,32(sp)
210937e8:	8009883a 	mov	r4,r16
210937ec:	01400044 	movi	r5,1
210937f0:	308d883a 	add	r6,r6,r2
210937f4:	d9800815 	stw	r6,32(sp)
210937f8:	b0ad883a 	add	r22,r22,r2
210937fc:	1095e980 	call	21095e98 <__i2b>
21093800:	1023883a 	mov	r17,r2
21093804:	a0000826 	beq	r20,zero,21093828 <_dtoa_r+0xa30>
21093808:	0580070e 	bge	zero,r22,21093828 <_dtoa_r+0xa30>
2109380c:	b005883a 	mov	r2,r22
21093810:	a5812016 	blt	r20,r22,21093c94 <_dtoa_r+0xe9c>
21093814:	d8c00817 	ldw	r3,32(sp)
21093818:	a0a9c83a 	sub	r20,r20,r2
2109381c:	b0adc83a 	sub	r22,r22,r2
21093820:	1887c83a 	sub	r3,r3,r2
21093824:	d8c00815 	stw	r3,32(sp)
21093828:	d9000917 	ldw	r4,36(sp)
2109382c:	0100140e 	bge	zero,r4,21093880 <_dtoa_r+0xa88>
21093830:	d9800b17 	ldw	r6,44(sp)
21093834:	3001e526 	beq	r6,zero,21093fcc <_dtoa_r+0x11d4>
21093838:	05400e0e 	bge	zero,r21,21093874 <_dtoa_r+0xa7c>
2109383c:	880b883a 	mov	r5,r17
21093840:	8009883a 	mov	r4,r16
21093844:	a80d883a 	mov	r6,r21
21093848:	10960d00 	call	210960d0 <__pow5mult>
2109384c:	e00d883a 	mov	r6,fp
21093850:	8009883a 	mov	r4,r16
21093854:	100b883a 	mov	r5,r2
21093858:	1023883a 	mov	r17,r2
2109385c:	1095ed40 	call	21095ed4 <__multiply>
21093860:	102f883a 	mov	r23,r2
21093864:	e00b883a 	mov	r5,fp
21093868:	8009883a 	mov	r4,r16
2109386c:	1095b340 	call	21095b34 <_Bfree>
21093870:	b839883a 	mov	fp,r23
21093874:	d8800917 	ldw	r2,36(sp)
21093878:	154dc83a 	sub	r6,r2,r21
2109387c:	3001281e 	bne	r6,zero,21093d20 <_dtoa_r+0xf28>
21093880:	05c00044 	movi	r23,1
21093884:	8009883a 	mov	r4,r16
21093888:	b80b883a 	mov	r5,r23
2109388c:	1095e980 	call	21095e98 <__i2b>
21093890:	d8c00a17 	ldw	r3,40(sp)
21093894:	102b883a 	mov	r21,r2
21093898:	00c0310e 	bge	zero,r3,21093960 <_dtoa_r+0xb68>
2109389c:	8009883a 	mov	r4,r16
210938a0:	100b883a 	mov	r5,r2
210938a4:	180d883a 	mov	r6,r3
210938a8:	10960d00 	call	210960d0 <__pow5mult>
210938ac:	d9000317 	ldw	r4,12(sp)
210938b0:	102b883a 	mov	r21,r2
210938b4:	b9011f0e 	bge	r23,r4,21093d34 <_dtoa_r+0xf3c>
210938b8:	0027883a 	mov	r19,zero
210938bc:	a8800417 	ldw	r2,16(r21)
210938c0:	10800104 	addi	r2,r2,4
210938c4:	1085883a 	add	r2,r2,r2
210938c8:	1085883a 	add	r2,r2,r2
210938cc:	a885883a 	add	r2,r21,r2
210938d0:	11000017 	ldw	r4,0(r2)
210938d4:	1095d800 	call	21095d80 <__hi0bits>
210938d8:	00c00804 	movi	r3,32
210938dc:	1885c83a 	sub	r2,r3,r2
210938e0:	00002506 	br	21093978 <_dtoa_r+0xb80>
210938e4:	01800044 	movi	r6,1
210938e8:	d9800d15 	stw	r6,52(sp)
210938ec:	003dec06 	br	210930a0 <__flash_rwdata_start+0xffff0e58>
210938f0:	d8c00817 	ldw	r3,32(sp)
210938f4:	d9000517 	ldw	r4,20(sp)
210938f8:	d8000a15 	stw	zero,40(sp)
210938fc:	1907c83a 	sub	r3,r3,r4
21093900:	010dc83a 	sub	r6,zero,r4
21093904:	d8c00815 	stw	r3,32(sp)
21093908:	d9800915 	stw	r6,36(sp)
2109390c:	003ded06 	br	210930c4 <__flash_rwdata_start+0xffff0e7c>
21093910:	05adc83a 	sub	r22,zero,r22
21093914:	dd800815 	stw	r22,32(sp)
21093918:	002d883a 	mov	r22,zero
2109391c:	003de406 	br	210930b0 <__flash_rwdata_start+0xffff0e68>
21093920:	d9000517 	ldw	r4,20(sp)
21093924:	108cfdc0 	call	2108cfdc <__floatsidf>
21093928:	1009883a 	mov	r4,r2
2109392c:	180b883a 	mov	r5,r3
21093930:	b00d883a 	mov	r6,r22
21093934:	a80f883a 	mov	r7,r21
21093938:	109af240 	call	2109af24 <__eqdf2>
2109393c:	103dc726 	beq	r2,zero,2109305c <__flash_rwdata_start+0xffff0e14>
21093940:	d8800517 	ldw	r2,20(sp)
21093944:	10bfffc4 	addi	r2,r2,-1
21093948:	d8800515 	stw	r2,20(sp)
2109394c:	003dc306 	br	2109305c <__flash_rwdata_start+0xffff0e14>
21093950:	dd400917 	ldw	r21,36(sp)
21093954:	dd000817 	ldw	r20,32(sp)
21093958:	0023883a 	mov	r17,zero
2109395c:	003fa906 	br	21093804 <__flash_rwdata_start+0xffff15bc>
21093960:	d9800317 	ldw	r6,12(sp)
21093964:	b981670e 	bge	r23,r6,21093f04 <_dtoa_r+0x110c>
21093968:	0027883a 	mov	r19,zero
2109396c:	d8c00a17 	ldw	r3,40(sp)
21093970:	183fd21e 	bne	r3,zero,210938bc <__flash_rwdata_start+0xffff1674>
21093974:	00800044 	movi	r2,1
21093978:	1585883a 	add	r2,r2,r22
2109397c:	108007cc 	andi	r2,r2,31
21093980:	10005f26 	beq	r2,zero,21093b00 <_dtoa_r+0xd08>
21093984:	00c00804 	movi	r3,32
21093988:	1887c83a 	sub	r3,r3,r2
2109398c:	01000104 	movi	r4,4
21093990:	20c2dd0e 	bge	r4,r3,21094508 <_dtoa_r+0x1710>
21093994:	d9000817 	ldw	r4,32(sp)
21093998:	00c00704 	movi	r3,28
2109399c:	1885c83a 	sub	r2,r3,r2
210939a0:	2089883a 	add	r4,r4,r2
210939a4:	d9000815 	stw	r4,32(sp)
210939a8:	a0a9883a 	add	r20,r20,r2
210939ac:	b0ad883a 	add	r22,r22,r2
210939b0:	d8800817 	ldw	r2,32(sp)
210939b4:	0080050e 	bge	zero,r2,210939cc <_dtoa_r+0xbd4>
210939b8:	e00b883a 	mov	r5,fp
210939bc:	8009883a 	mov	r4,r16
210939c0:	100d883a 	mov	r6,r2
210939c4:	10962100 	call	21096210 <__lshift>
210939c8:	1039883a 	mov	fp,r2
210939cc:	0580050e 	bge	zero,r22,210939e4 <_dtoa_r+0xbec>
210939d0:	a80b883a 	mov	r5,r21
210939d4:	8009883a 	mov	r4,r16
210939d8:	b00d883a 	mov	r6,r22
210939dc:	10962100 	call	21096210 <__lshift>
210939e0:	102b883a 	mov	r21,r2
210939e4:	d8c00d17 	ldw	r3,52(sp)
210939e8:	1801161e 	bne	r3,zero,21093e44 <_dtoa_r+0x104c>
210939ec:	d8c00617 	ldw	r3,24(sp)
210939f0:	00c12d0e 	bge	zero,r3,21093ea8 <_dtoa_r+0x10b0>
210939f4:	d8c00b17 	ldw	r3,44(sp)
210939f8:	1800571e 	bne	r3,zero,21093b58 <_dtoa_r+0xd60>
210939fc:	dc800717 	ldw	r18,28(sp)
21093a00:	dcc00617 	ldw	r19,24(sp)
21093a04:	9029883a 	mov	r20,r18
21093a08:	00000206 	br	21093a14 <_dtoa_r+0xc1c>
21093a0c:	1095b5c0 	call	21095b5c <__multadd>
21093a10:	1039883a 	mov	fp,r2
21093a14:	e009883a 	mov	r4,fp
21093a18:	a80b883a 	mov	r5,r21
21093a1c:	1092bf80 	call	21092bf8 <quorem>
21093a20:	10800c04 	addi	r2,r2,48
21093a24:	90800005 	stb	r2,0(r18)
21093a28:	94800044 	addi	r18,r18,1
21093a2c:	9507c83a 	sub	r3,r18,r20
21093a30:	8009883a 	mov	r4,r16
21093a34:	e00b883a 	mov	r5,fp
21093a38:	01800284 	movi	r6,10
21093a3c:	000f883a 	mov	r7,zero
21093a40:	1cfff216 	blt	r3,r19,21093a0c <__flash_rwdata_start+0xffff17c4>
21093a44:	1011883a 	mov	r8,r2
21093a48:	d8800617 	ldw	r2,24(sp)
21093a4c:	00822e0e 	bge	zero,r2,21094308 <_dtoa_r+0x1510>
21093a50:	d9000717 	ldw	r4,28(sp)
21093a54:	0025883a 	mov	r18,zero
21093a58:	20af883a 	add	r23,r4,r2
21093a5c:	e00b883a 	mov	r5,fp
21093a60:	01800044 	movi	r6,1
21093a64:	8009883a 	mov	r4,r16
21093a68:	da001715 	stw	r8,92(sp)
21093a6c:	10962100 	call	21096210 <__lshift>
21093a70:	1009883a 	mov	r4,r2
21093a74:	a80b883a 	mov	r5,r21
21093a78:	1039883a 	mov	fp,r2
21093a7c:	10963600 	call	21096360 <__mcmp>
21093a80:	da001717 	ldw	r8,92(sp)
21093a84:	00816e0e 	bge	zero,r2,21094040 <_dtoa_r+0x1248>
21093a88:	b93fffc3 	ldbu	r4,-1(r23)
21093a8c:	b8bfffc4 	addi	r2,r23,-1
21093a90:	1007883a 	mov	r3,r2
21093a94:	01800e44 	movi	r6,57
21093a98:	d9c00717 	ldw	r7,28(sp)
21093a9c:	00000506 	br	21093ab4 <_dtoa_r+0xcbc>
21093aa0:	18ffffc4 	addi	r3,r3,-1
21093aa4:	38811926 	beq	r7,r2,21093f0c <_dtoa_r+0x1114>
21093aa8:	19000003 	ldbu	r4,0(r3)
21093aac:	102f883a 	mov	r23,r2
21093ab0:	10bfffc4 	addi	r2,r2,-1
21093ab4:	21403fcc 	andi	r5,r4,255
21093ab8:	2940201c 	xori	r5,r5,128
21093abc:	297fe004 	addi	r5,r5,-128
21093ac0:	29bff726 	beq	r5,r6,21093aa0 <__flash_rwdata_start+0xffff1858>
21093ac4:	21000044 	addi	r4,r4,1
21093ac8:	11000005 	stb	r4,0(r2)
21093acc:	8009883a 	mov	r4,r16
21093ad0:	a80b883a 	mov	r5,r21
21093ad4:	1095b340 	call	21095b34 <_Bfree>
21093ad8:	883e7526 	beq	r17,zero,210934b0 <__flash_rwdata_start+0xffff1268>
21093adc:	90000426 	beq	r18,zero,21093af0 <_dtoa_r+0xcf8>
21093ae0:	94400326 	beq	r18,r17,21093af0 <_dtoa_r+0xcf8>
21093ae4:	8009883a 	mov	r4,r16
21093ae8:	900b883a 	mov	r5,r18
21093aec:	1095b340 	call	21095b34 <_Bfree>
21093af0:	8009883a 	mov	r4,r16
21093af4:	880b883a 	mov	r5,r17
21093af8:	1095b340 	call	21095b34 <_Bfree>
21093afc:	003e6c06 	br	210934b0 <__flash_rwdata_start+0xffff1268>
21093b00:	00800704 	movi	r2,28
21093b04:	d9800817 	ldw	r6,32(sp)
21093b08:	a0a9883a 	add	r20,r20,r2
21093b0c:	b0ad883a 	add	r22,r22,r2
21093b10:	308d883a 	add	r6,r6,r2
21093b14:	d9800815 	stw	r6,32(sp)
21093b18:	003fa506 	br	210939b0 <__flash_rwdata_start+0xffff1768>
21093b1c:	013efb84 	movi	r4,-1042
21093b20:	246bc83a 	sub	r21,r4,r17
21093b24:	9548983a 	sll	r4,r18,r21
21093b28:	003d1806 	br	21092f8c <__flash_rwdata_start+0xffff0d44>
21093b2c:	d8000d15 	stw	zero,52(sp)
21093b30:	003d5b06 	br	210930a0 <__flash_rwdata_start+0xffff0e58>
21093b34:	880b883a 	mov	r5,r17
21093b38:	8009883a 	mov	r4,r16
21093b3c:	01800284 	movi	r6,10
21093b40:	000f883a 	mov	r7,zero
21093b44:	1095b5c0 	call	21095b5c <__multadd>
21093b48:	1023883a 	mov	r17,r2
21093b4c:	d8800c17 	ldw	r2,48(sp)
21093b50:	0082550e 	bge	zero,r2,210944a8 <_dtoa_r+0x16b0>
21093b54:	d8800615 	stw	r2,24(sp)
21093b58:	0500050e 	bge	zero,r20,21093b70 <_dtoa_r+0xd78>
21093b5c:	880b883a 	mov	r5,r17
21093b60:	8009883a 	mov	r4,r16
21093b64:	a00d883a 	mov	r6,r20
21093b68:	10962100 	call	21096210 <__lshift>
21093b6c:	1023883a 	mov	r17,r2
21093b70:	98016a1e 	bne	r19,zero,2109411c <_dtoa_r+0x1324>
21093b74:	8829883a 	mov	r20,r17
21093b78:	d9000617 	ldw	r4,24(sp)
21093b7c:	dcc00717 	ldw	r19,28(sp)
21093b80:	9480004c 	andi	r18,r18,1
21093b84:	20bfffc4 	addi	r2,r4,-1
21093b88:	9885883a 	add	r2,r19,r2
21093b8c:	d8800415 	stw	r2,16(sp)
21093b90:	dc800615 	stw	r18,24(sp)
21093b94:	e009883a 	mov	r4,fp
21093b98:	a80b883a 	mov	r5,r21
21093b9c:	1092bf80 	call	21092bf8 <quorem>
21093ba0:	e009883a 	mov	r4,fp
21093ba4:	880b883a 	mov	r5,r17
21093ba8:	102f883a 	mov	r23,r2
21093bac:	10963600 	call	21096360 <__mcmp>
21093bb0:	8009883a 	mov	r4,r16
21093bb4:	a80b883a 	mov	r5,r21
21093bb8:	a00d883a 	mov	r6,r20
21093bbc:	102d883a 	mov	r22,r2
21093bc0:	10963c00 	call	210963c0 <__mdiff>
21093bc4:	1007883a 	mov	r3,r2
21093bc8:	10800317 	ldw	r2,12(r2)
21093bcc:	bc800c04 	addi	r18,r23,48
21093bd0:	1000971e 	bne	r2,zero,21093e30 <_dtoa_r+0x1038>
21093bd4:	180b883a 	mov	r5,r3
21093bd8:	e009883a 	mov	r4,fp
21093bdc:	d8c01515 	stw	r3,84(sp)
21093be0:	10963600 	call	21096360 <__mcmp>
21093be4:	d8c01517 	ldw	r3,84(sp)
21093be8:	8009883a 	mov	r4,r16
21093bec:	d8801515 	stw	r2,84(sp)
21093bf0:	180b883a 	mov	r5,r3
21093bf4:	1095b340 	call	21095b34 <_Bfree>
21093bf8:	d8801517 	ldw	r2,84(sp)
21093bfc:	1000041e 	bne	r2,zero,21093c10 <_dtoa_r+0xe18>
21093c00:	d9800317 	ldw	r6,12(sp)
21093c04:	3000021e 	bne	r6,zero,21093c10 <_dtoa_r+0xe18>
21093c08:	d8c00617 	ldw	r3,24(sp)
21093c0c:	18007626 	beq	r3,zero,21093de8 <_dtoa_r+0xff0>
21093c10:	b0005b16 	blt	r22,zero,21093d80 <_dtoa_r+0xf88>
21093c14:	b000041e 	bne	r22,zero,21093c28 <_dtoa_r+0xe30>
21093c18:	d9000317 	ldw	r4,12(sp)
21093c1c:	2000021e 	bne	r4,zero,21093c28 <_dtoa_r+0xe30>
21093c20:	d8c00617 	ldw	r3,24(sp)
21093c24:	18005626 	beq	r3,zero,21093d80 <_dtoa_r+0xf88>
21093c28:	00814d16 	blt	zero,r2,21094160 <_dtoa_r+0x1368>
21093c2c:	d8c00417 	ldw	r3,16(sp)
21093c30:	9d800044 	addi	r22,r19,1
21093c34:	9c800005 	stb	r18,0(r19)
21093c38:	b02f883a 	mov	r23,r22
21093c3c:	98c14c26 	beq	r19,r3,21094170 <_dtoa_r+0x1378>
21093c40:	e00b883a 	mov	r5,fp
21093c44:	8009883a 	mov	r4,r16
21093c48:	01800284 	movi	r6,10
21093c4c:	000f883a 	mov	r7,zero
21093c50:	1095b5c0 	call	21095b5c <__multadd>
21093c54:	1039883a 	mov	fp,r2
21093c58:	8d006d26 	beq	r17,r20,21093e10 <_dtoa_r+0x1018>
21093c5c:	880b883a 	mov	r5,r17
21093c60:	01800284 	movi	r6,10
21093c64:	000f883a 	mov	r7,zero
21093c68:	8009883a 	mov	r4,r16
21093c6c:	1095b5c0 	call	21095b5c <__multadd>
21093c70:	a00b883a 	mov	r5,r20
21093c74:	8009883a 	mov	r4,r16
21093c78:	01800284 	movi	r6,10
21093c7c:	000f883a 	mov	r7,zero
21093c80:	1023883a 	mov	r17,r2
21093c84:	1095b5c0 	call	21095b5c <__multadd>
21093c88:	1029883a 	mov	r20,r2
21093c8c:	b027883a 	mov	r19,r22
21093c90:	003fc006 	br	21093b94 <__flash_rwdata_start+0xffff194c>
21093c94:	a005883a 	mov	r2,r20
21093c98:	003ede06 	br	21093814 <__flash_rwdata_start+0xffff15cc>
21093c9c:	01000044 	movi	r4,1
21093ca0:	d9000b15 	stw	r4,44(sp)
21093ca4:	d9802217 	ldw	r6,136(sp)
21093ca8:	0180dc0e 	bge	zero,r6,2109401c <_dtoa_r+0x1224>
21093cac:	3023883a 	mov	r17,r6
21093cb0:	d9800c15 	stw	r6,48(sp)
21093cb4:	d9800615 	stw	r6,24(sp)
21093cb8:	003d1e06 	br	21093134 <__flash_rwdata_start+0xffff0eec>
21093cbc:	d8800617 	ldw	r2,24(sp)
21093cc0:	00be3716 	blt	zero,r2,210935a0 <__flash_rwdata_start+0xffff1358>
21093cc4:	1000be1e 	bne	r2,zero,21093fc0 <_dtoa_r+0x11c8>
21093cc8:	8809883a 	mov	r4,r17
21093ccc:	a00b883a 	mov	r5,r20
21093cd0:	000d883a 	mov	r6,zero
21093cd4:	01d00534 	movhi	r7,16404
21093cd8:	108bf600 	call	2108bf60 <__muldf3>
21093cdc:	1009883a 	mov	r4,r2
21093ce0:	180b883a 	mov	r5,r3
21093ce4:	900d883a 	mov	r6,r18
21093ce8:	980f883a 	mov	r7,r19
21093cec:	108be800 	call	2108be80 <__gedf2>
21093cf0:	002b883a 	mov	r21,zero
21093cf4:	0023883a 	mov	r17,zero
21093cf8:	10007a16 	blt	r2,zero,21093ee4 <_dtoa_r+0x10ec>
21093cfc:	d9002217 	ldw	r4,136(sp)
21093d00:	ddc00717 	ldw	r23,28(sp)
21093d04:	0108303a 	nor	r4,zero,r4
21093d08:	d9000515 	stw	r4,20(sp)
21093d0c:	8009883a 	mov	r4,r16
21093d10:	a80b883a 	mov	r5,r21
21093d14:	1095b340 	call	21095b34 <_Bfree>
21093d18:	883f751e 	bne	r17,zero,21093af0 <__flash_rwdata_start+0xffff18a8>
21093d1c:	003de406 	br	210934b0 <__flash_rwdata_start+0xffff1268>
21093d20:	e00b883a 	mov	r5,fp
21093d24:	8009883a 	mov	r4,r16
21093d28:	10960d00 	call	210960d0 <__pow5mult>
21093d2c:	1039883a 	mov	fp,r2
21093d30:	003ed306 	br	21093880 <__flash_rwdata_start+0xffff1638>
21093d34:	903ee01e 	bne	r18,zero,210938b8 <__flash_rwdata_start+0xffff1670>
21093d38:	00800434 	movhi	r2,16
21093d3c:	10bfffc4 	addi	r2,r2,-1
21093d40:	9884703a 	and	r2,r19,r2
21093d44:	103f081e 	bne	r2,zero,21093968 <__flash_rwdata_start+0xffff1720>
21093d48:	9cdffc2c 	andhi	r19,r19,32752
21093d4c:	983f0626 	beq	r19,zero,21093968 <__flash_rwdata_start+0xffff1720>
21093d50:	d8800817 	ldw	r2,32(sp)
21093d54:	b5800044 	addi	r22,r22,1
21093d58:	04c00044 	movi	r19,1
21093d5c:	10800044 	addi	r2,r2,1
21093d60:	d8800815 	stw	r2,32(sp)
21093d64:	003f0106 	br	2109396c <__flash_rwdata_start+0xffff1724>
21093d68:	d9800f17 	ldw	r6,60(sp)
21093d6c:	30016826 	beq	r6,zero,21094310 <_dtoa_r+0x1518>
21093d70:	10810cc4 	addi	r2,r2,1075
21093d74:	dd400917 	ldw	r21,36(sp)
21093d78:	dd000817 	ldw	r20,32(sp)
21093d7c:	003e9906 	br	210937e4 <__flash_rwdata_start+0xffff159c>
21093d80:	9011883a 	mov	r8,r18
21093d84:	4007883a 	mov	r3,r8
21093d88:	e02d883a 	mov	r22,fp
21093d8c:	0080100e 	bge	zero,r2,21093dd0 <_dtoa_r+0xfd8>
21093d90:	01800044 	movi	r6,1
21093d94:	8009883a 	mov	r4,r16
21093d98:	e00b883a 	mov	r5,fp
21093d9c:	da001515 	stw	r8,84(sp)
21093da0:	da001715 	stw	r8,92(sp)
21093da4:	10962100 	call	21096210 <__lshift>
21093da8:	1009883a 	mov	r4,r2
21093dac:	a80b883a 	mov	r5,r21
21093db0:	102d883a 	mov	r22,r2
21093db4:	10963600 	call	21096360 <__mcmp>
21093db8:	d8c01517 	ldw	r3,84(sp)
21093dbc:	da001717 	ldw	r8,92(sp)
21093dc0:	0081a50e 	bge	zero,r2,21094458 <_dtoa_r+0x1660>
21093dc4:	00800e44 	movi	r2,57
21093dc8:	40817b26 	beq	r8,r2,210943b8 <_dtoa_r+0x15c0>
21093dcc:	40c00044 	addi	r3,r8,1
21093dd0:	8825883a 	mov	r18,r17
21093dd4:	9dc00044 	addi	r23,r19,1
21093dd8:	98c00005 	stb	r3,0(r19)
21093ddc:	a023883a 	mov	r17,r20
21093de0:	b039883a 	mov	fp,r22
21093de4:	003f3906 	br	21093acc <__flash_rwdata_start+0xffff1884>
21093de8:	00800e44 	movi	r2,57
21093dec:	9011883a 	mov	r8,r18
21093df0:	90817226 	beq	r18,r2,210943bc <_dtoa_r+0x15c4>
21093df4:	0580010e 	bge	zero,r22,21093dfc <_dtoa_r+0x1004>
21093df8:	ba000c44 	addi	r8,r23,49
21093dfc:	8825883a 	mov	r18,r17
21093e00:	9dc00044 	addi	r23,r19,1
21093e04:	9a000005 	stb	r8,0(r19)
21093e08:	a023883a 	mov	r17,r20
21093e0c:	003f2f06 	br	21093acc <__flash_rwdata_start+0xffff1884>
21093e10:	880b883a 	mov	r5,r17
21093e14:	8009883a 	mov	r4,r16
21093e18:	01800284 	movi	r6,10
21093e1c:	000f883a 	mov	r7,zero
21093e20:	1095b5c0 	call	21095b5c <__multadd>
21093e24:	1023883a 	mov	r17,r2
21093e28:	1029883a 	mov	r20,r2
21093e2c:	003f9706 	br	21093c8c <__flash_rwdata_start+0xffff1a44>
21093e30:	8009883a 	mov	r4,r16
21093e34:	180b883a 	mov	r5,r3
21093e38:	1095b340 	call	21095b34 <_Bfree>
21093e3c:	00800044 	movi	r2,1
21093e40:	003f7306 	br	21093c10 <__flash_rwdata_start+0xffff19c8>
21093e44:	e009883a 	mov	r4,fp
21093e48:	a80b883a 	mov	r5,r21
21093e4c:	10963600 	call	21096360 <__mcmp>
21093e50:	103ee60e 	bge	r2,zero,210939ec <__flash_rwdata_start+0xffff17a4>
21093e54:	8009883a 	mov	r4,r16
21093e58:	e00b883a 	mov	r5,fp
21093e5c:	01800284 	movi	r6,10
21093e60:	000f883a 	mov	r7,zero
21093e64:	1095b5c0 	call	21095b5c <__multadd>
21093e68:	d9000517 	ldw	r4,20(sp)
21093e6c:	d9800b17 	ldw	r6,44(sp)
21093e70:	1039883a 	mov	fp,r2
21093e74:	213fffc4 	addi	r4,r4,-1
21093e78:	d9000515 	stw	r4,20(sp)
21093e7c:	303f2d1e 	bne	r6,zero,21093b34 <__flash_rwdata_start+0xffff18ec>
21093e80:	d9000c17 	ldw	r4,48(sp)
21093e84:	0101780e 	bge	zero,r4,21094468 <_dtoa_r+0x1670>
21093e88:	d9000615 	stw	r4,24(sp)
21093e8c:	003edb06 	br	210939fc <__flash_rwdata_start+0xffff17b4>
21093e90:	00800084 	movi	r2,2
21093e94:	30818e1e 	bne	r6,r2,210944d0 <_dtoa_r+0x16d8>
21093e98:	d8000b15 	stw	zero,44(sp)
21093e9c:	003f8106 	br	21093ca4 <__flash_rwdata_start+0xffff1a5c>
21093ea0:	d8800717 	ldw	r2,28(sp)
21093ea4:	003c0306 	br	21092eb4 <__flash_rwdata_start+0xffff0c6c>
21093ea8:	d9000317 	ldw	r4,12(sp)
21093eac:	00800084 	movi	r2,2
21093eb0:	113ed00e 	bge	r2,r4,210939f4 <__flash_rwdata_start+0xffff17ac>
21093eb4:	d8c00617 	ldw	r3,24(sp)
21093eb8:	183f901e 	bne	r3,zero,21093cfc <__flash_rwdata_start+0xffff1ab4>
21093ebc:	a80b883a 	mov	r5,r21
21093ec0:	8009883a 	mov	r4,r16
21093ec4:	01800144 	movi	r6,5
21093ec8:	000f883a 	mov	r7,zero
21093ecc:	1095b5c0 	call	21095b5c <__multadd>
21093ed0:	e009883a 	mov	r4,fp
21093ed4:	100b883a 	mov	r5,r2
21093ed8:	102b883a 	mov	r21,r2
21093edc:	10963600 	call	21096360 <__mcmp>
21093ee0:	00bf860e 	bge	zero,r2,21093cfc <__flash_rwdata_start+0xffff1ab4>
21093ee4:	d9800717 	ldw	r6,28(sp)
21093ee8:	00800c44 	movi	r2,49
21093eec:	30800005 	stb	r2,0(r6)
21093ef0:	d8800517 	ldw	r2,20(sp)
21093ef4:	35c00044 	addi	r23,r6,1
21093ef8:	10800044 	addi	r2,r2,1
21093efc:	d8800515 	stw	r2,20(sp)
21093f00:	003f8206 	br	21093d0c <__flash_rwdata_start+0xffff1ac4>
21093f04:	903e981e 	bne	r18,zero,21093968 <__flash_rwdata_start+0xffff1720>
21093f08:	003f8b06 	br	21093d38 <__flash_rwdata_start+0xffff1af0>
21093f0c:	d9800517 	ldw	r6,20(sp)
21093f10:	d8c00717 	ldw	r3,28(sp)
21093f14:	00800c44 	movi	r2,49
21093f18:	31800044 	addi	r6,r6,1
21093f1c:	d9800515 	stw	r6,20(sp)
21093f20:	18800005 	stb	r2,0(r3)
21093f24:	003ee906 	br	21093acc <__flash_rwdata_start+0xffff1884>
21093f28:	dc000317 	ldw	r16,12(sp)
21093f2c:	003d6006 	br	210934b0 <__flash_rwdata_start+0xffff1268>
21093f30:	8809883a 	mov	r4,r17
21093f34:	108cfdc0 	call	2108cfdc <__floatsidf>
21093f38:	a009883a 	mov	r4,r20
21093f3c:	a80b883a 	mov	r5,r21
21093f40:	100d883a 	mov	r6,r2
21093f44:	180f883a 	mov	r7,r3
21093f48:	108bf600 	call	2108bf60 <__muldf3>
21093f4c:	1009883a 	mov	r4,r2
21093f50:	180b883a 	mov	r5,r3
21093f54:	000d883a 	mov	r6,zero
21093f58:	01d00734 	movhi	r7,16412
21093f5c:	108ad180 	call	2108ad18 <__adddf3>
21093f60:	1023883a 	mov	r17,r2
21093f64:	00bf3034 	movhi	r2,64704
21093f68:	1885883a 	add	r2,r3,r2
21093f6c:	d8800e15 	stw	r2,56(sp)
21093f70:	a009883a 	mov	r4,r20
21093f74:	a80b883a 	mov	r5,r21
21093f78:	000d883a 	mov	r6,zero
21093f7c:	01d00534 	movhi	r7,16404
21093f80:	108c6840 	call	2108c684 <__subdf3>
21093f84:	d9c00e17 	ldw	r7,56(sp)
21093f88:	1009883a 	mov	r4,r2
21093f8c:	180b883a 	mov	r5,r3
21093f90:	880d883a 	mov	r6,r17
21093f94:	102b883a 	mov	r21,r2
21093f98:	1829883a 	mov	r20,r3
21093f9c:	108be800 	call	2108be80 <__gedf2>
21093fa0:	00807716 	blt	zero,r2,21094180 <_dtoa_r+0x1388>
21093fa4:	d8800e17 	ldw	r2,56(sp)
21093fa8:	a809883a 	mov	r4,r21
21093fac:	a00b883a 	mov	r5,r20
21093fb0:	11e0003c 	xorhi	r7,r2,32768
21093fb4:	880d883a 	mov	r6,r17
21093fb8:	109afa80 	call	2109afa8 <__ledf2>
21093fbc:	103d6b0e 	bge	r2,zero,2109356c <__flash_rwdata_start+0xffff1324>
21093fc0:	002b883a 	mov	r21,zero
21093fc4:	0023883a 	mov	r17,zero
21093fc8:	003f4c06 	br	21093cfc <__flash_rwdata_start+0xffff1ab4>
21093fcc:	d9800917 	ldw	r6,36(sp)
21093fd0:	e00b883a 	mov	r5,fp
21093fd4:	8009883a 	mov	r4,r16
21093fd8:	10960d00 	call	210960d0 <__pow5mult>
21093fdc:	1039883a 	mov	fp,r2
21093fe0:	003e2706 	br	21093880 <__flash_rwdata_start+0xffff1638>
21093fe4:	d8000b15 	stw	zero,44(sp)
21093fe8:	003c4906 	br	21093110 <__flash_rwdata_start+0xffff0ec8>
21093fec:	d9000917 	ldw	r4,36(sp)
21093ff0:	d9800a17 	ldw	r6,40(sp)
21093ff4:	dd400915 	stw	r21,36(sp)
21093ff8:	a905c83a 	sub	r2,r21,r4
21093ffc:	308d883a 	add	r6,r6,r2
21094000:	d9800a15 	stw	r6,40(sp)
21094004:	002b883a 	mov	r21,zero
21094008:	003df206 	br	210937d4 <__flash_rwdata_start+0xffff158c>
2109400c:	dc800e15 	stw	r18,56(sp)
21094010:	982b883a 	mov	r21,r19
21094014:	04400084 	movi	r17,2
21094018:	003c7406 	br	210931ec <__flash_rwdata_start+0xffff0fa4>
2109401c:	04400044 	movi	r17,1
21094020:	dc400c15 	stw	r17,48(sp)
21094024:	dc400615 	stw	r17,24(sp)
21094028:	dc402215 	stw	r17,136(sp)
2109402c:	80001115 	stw	zero,68(r16)
21094030:	000b883a 	mov	r5,zero
21094034:	003c4a06 	br	21093160 <__flash_rwdata_start+0xffff0f18>
21094038:	3023883a 	mov	r17,r6
2109403c:	003ffb06 	br	2109402c <__flash_rwdata_start+0xffff1de4>
21094040:	1000021e 	bne	r2,zero,2109404c <_dtoa_r+0x1254>
21094044:	4200004c 	andi	r8,r8,1
21094048:	403e8f1e 	bne	r8,zero,21093a88 <__flash_rwdata_start+0xffff1840>
2109404c:	01000c04 	movi	r4,48
21094050:	00000106 	br	21094058 <_dtoa_r+0x1260>
21094054:	102f883a 	mov	r23,r2
21094058:	b8bfffc4 	addi	r2,r23,-1
2109405c:	10c00007 	ldb	r3,0(r2)
21094060:	193ffc26 	beq	r3,r4,21094054 <__flash_rwdata_start+0xffff1e0c>
21094064:	003e9906 	br	21093acc <__flash_rwdata_start+0xffff1884>
21094068:	d9000517 	ldw	r4,20(sp)
2109406c:	012fc83a 	sub	r23,zero,r4
21094070:	b800ad26 	beq	r23,zero,21094328 <_dtoa_r+0x1530>
21094074:	b88003cc 	andi	r2,r23,15
21094078:	100490fa 	slli	r2,r2,3
2109407c:	00c00034 	movhi	r3,0
21094080:	18cf0804 	addi	r3,r3,15392
21094084:	1885883a 	add	r2,r3,r2
21094088:	11800017 	ldw	r6,0(r2)
2109408c:	11c00117 	ldw	r7,4(r2)
21094090:	b82fd13a 	srai	r23,r23,4
21094094:	9009883a 	mov	r4,r18
21094098:	980b883a 	mov	r5,r19
2109409c:	108bf600 	call	2108bf60 <__muldf3>
210940a0:	1029883a 	mov	r20,r2
210940a4:	182b883a 	mov	r21,r3
210940a8:	b800f426 	beq	r23,zero,2109447c <_dtoa_r+0x1684>
210940ac:	02000034 	movhi	r8,0
210940b0:	420efe04 	addi	r8,r8,15352
210940b4:	8029883a 	mov	r20,r16
210940b8:	04400084 	movi	r17,2
210940bc:	4021883a 	mov	r16,r8
210940c0:	b980004c 	andi	r6,r23,1
210940c4:	1009883a 	mov	r4,r2
210940c8:	b82fd07a 	srai	r23,r23,1
210940cc:	180b883a 	mov	r5,r3
210940d0:	30000426 	beq	r6,zero,210940e4 <_dtoa_r+0x12ec>
210940d4:	81800017 	ldw	r6,0(r16)
210940d8:	81c00117 	ldw	r7,4(r16)
210940dc:	8c400044 	addi	r17,r17,1
210940e0:	108bf600 	call	2108bf60 <__muldf3>
210940e4:	84000204 	addi	r16,r16,8
210940e8:	b83ff51e 	bne	r23,zero,210940c0 <__flash_rwdata_start+0xffff1e78>
210940ec:	a021883a 	mov	r16,r20
210940f0:	182b883a 	mov	r21,r3
210940f4:	1029883a 	mov	r20,r2
210940f8:	003c5506 	br	21093250 <__flash_rwdata_start+0xffff1008>
210940fc:	d9800517 	ldw	r6,20(sp)
21094100:	d9000717 	ldw	r4,28(sp)
21094104:	00c00c04 	movi	r3,48
21094108:	31800044 	addi	r6,r6,1
2109410c:	d9800515 	stw	r6,20(sp)
21094110:	20c00005 	stb	r3,0(r4)
21094114:	02000c44 	movi	r8,49
21094118:	003da206 	br	210937a4 <__flash_rwdata_start+0xffff155c>
2109411c:	89400117 	ldw	r5,4(r17)
21094120:	8009883a 	mov	r4,r16
21094124:	1095a8c0 	call	21095a8c <_Balloc>
21094128:	89800417 	ldw	r6,16(r17)
2109412c:	11000304 	addi	r4,r2,12
21094130:	89400304 	addi	r5,r17,12
21094134:	31800084 	addi	r6,r6,2
21094138:	318d883a 	add	r6,r6,r6
2109413c:	318d883a 	add	r6,r6,r6
21094140:	1027883a 	mov	r19,r2
21094144:	108e1340 	call	2108e134 <memcpy>
21094148:	8009883a 	mov	r4,r16
2109414c:	980b883a 	mov	r5,r19
21094150:	01800044 	movi	r6,1
21094154:	10962100 	call	21096210 <__lshift>
21094158:	1029883a 	mov	r20,r2
2109415c:	003e8606 	br	21093b78 <__flash_rwdata_start+0xffff1930>
21094160:	00800e44 	movi	r2,57
21094164:	90809526 	beq	r18,r2,210943bc <_dtoa_r+0x15c4>
21094168:	92000044 	addi	r8,r18,1
2109416c:	003f2306 	br	21093dfc <__flash_rwdata_start+0xffff1bb4>
21094170:	9011883a 	mov	r8,r18
21094174:	8825883a 	mov	r18,r17
21094178:	a023883a 	mov	r17,r20
2109417c:	003e3706 	br	21093a5c <__flash_rwdata_start+0xffff1814>
21094180:	002b883a 	mov	r21,zero
21094184:	0023883a 	mov	r17,zero
21094188:	003f5606 	br	21093ee4 <__flash_rwdata_start+0xffff1c9c>
2109418c:	51bfffc4 	addi	r6,r10,-1
21094190:	300490fa 	slli	r2,r6,3
21094194:	00c00034 	movhi	r3,0
21094198:	18cf0804 	addi	r3,r3,15392
2109419c:	1885883a 	add	r2,r3,r2
210941a0:	d9c00e17 	ldw	r7,56(sp)
210941a4:	11000017 	ldw	r4,0(r2)
210941a8:	11400117 	ldw	r5,4(r2)
210941ac:	d8800717 	ldw	r2,28(sp)
210941b0:	d9801015 	stw	r6,64(sp)
210941b4:	880d883a 	mov	r6,r17
210941b8:	da801615 	stw	r10,88(sp)
210941bc:	15c00044 	addi	r23,r2,1
210941c0:	108bf600 	call	2108bf60 <__muldf3>
210941c4:	a80b883a 	mov	r5,r21
210941c8:	a009883a 	mov	r4,r20
210941cc:	d8c01115 	stw	r3,68(sp)
210941d0:	d8800e15 	stw	r2,56(sp)
210941d4:	108cf540 	call	2108cf54 <__fixdfsi>
210941d8:	1009883a 	mov	r4,r2
210941dc:	1023883a 	mov	r17,r2
210941e0:	108cfdc0 	call	2108cfdc <__floatsidf>
210941e4:	a009883a 	mov	r4,r20
210941e8:	a80b883a 	mov	r5,r21
210941ec:	100d883a 	mov	r6,r2
210941f0:	180f883a 	mov	r7,r3
210941f4:	108c6840 	call	2108c684 <__subdf3>
210941f8:	1813883a 	mov	r9,r3
210941fc:	d8c00717 	ldw	r3,28(sp)
21094200:	8c400c04 	addi	r17,r17,48
21094204:	1011883a 	mov	r8,r2
21094208:	1c400005 	stb	r17,0(r3)
2109420c:	da801617 	ldw	r10,88(sp)
21094210:	00800044 	movi	r2,1
21094214:	50802326 	beq	r10,r2,210942a4 <_dtoa_r+0x14ac>
21094218:	d8800717 	ldw	r2,28(sp)
2109421c:	b82b883a 	mov	r21,r23
21094220:	dc001315 	stw	r16,76(sp)
21094224:	12a9883a 	add	r20,r2,r10
21094228:	4807883a 	mov	r3,r9
2109422c:	4005883a 	mov	r2,r8
21094230:	dc801415 	stw	r18,80(sp)
21094234:	000d883a 	mov	r6,zero
21094238:	01d00934 	movhi	r7,16420
2109423c:	1009883a 	mov	r4,r2
21094240:	180b883a 	mov	r5,r3
21094244:	108bf600 	call	2108bf60 <__muldf3>
21094248:	180b883a 	mov	r5,r3
2109424c:	1009883a 	mov	r4,r2
21094250:	1821883a 	mov	r16,r3
21094254:	1025883a 	mov	r18,r2
21094258:	108cf540 	call	2108cf54 <__fixdfsi>
2109425c:	1009883a 	mov	r4,r2
21094260:	1023883a 	mov	r17,r2
21094264:	108cfdc0 	call	2108cfdc <__floatsidf>
21094268:	9009883a 	mov	r4,r18
2109426c:	800b883a 	mov	r5,r16
21094270:	100d883a 	mov	r6,r2
21094274:	180f883a 	mov	r7,r3
21094278:	8c400c04 	addi	r17,r17,48
2109427c:	108c6840 	call	2108c684 <__subdf3>
21094280:	ad400044 	addi	r21,r21,1
21094284:	ac7fffc5 	stb	r17,-1(r21)
21094288:	ad3fea1e 	bne	r21,r20,21094234 <__flash_rwdata_start+0xffff1fec>
2109428c:	1813883a 	mov	r9,r3
21094290:	d8c01017 	ldw	r3,64(sp)
21094294:	dc001317 	ldw	r16,76(sp)
21094298:	dc801417 	ldw	r18,80(sp)
2109429c:	1011883a 	mov	r8,r2
210942a0:	b8ef883a 	add	r23,r23,r3
210942a4:	d9000e17 	ldw	r4,56(sp)
210942a8:	d9401117 	ldw	r5,68(sp)
210942ac:	000d883a 	mov	r6,zero
210942b0:	01cff834 	movhi	r7,16352
210942b4:	da001715 	stw	r8,92(sp)
210942b8:	da401515 	stw	r9,84(sp)
210942bc:	108ad180 	call	2108ad18 <__adddf3>
210942c0:	da001717 	ldw	r8,92(sp)
210942c4:	da401517 	ldw	r9,84(sp)
210942c8:	1009883a 	mov	r4,r2
210942cc:	400d883a 	mov	r6,r8
210942d0:	480f883a 	mov	r7,r9
210942d4:	180b883a 	mov	r5,r3
210942d8:	109afa80 	call	2109afa8 <__ledf2>
210942dc:	da001717 	ldw	r8,92(sp)
210942e0:	da401517 	ldw	r9,84(sp)
210942e4:	10003b0e 	bge	r2,zero,210943d4 <_dtoa_r+0x15dc>
210942e8:	d9001217 	ldw	r4,72(sp)
210942ec:	bd7fffc3 	ldbu	r21,-1(r23)
210942f0:	d9000515 	stw	r4,20(sp)
210942f4:	003d1c06 	br	21093768 <__flash_rwdata_start+0xffff1520>
210942f8:	d8c00817 	ldw	r3,32(sp)
210942fc:	18a9c83a 	sub	r20,r3,r2
21094300:	0005883a 	mov	r2,zero
21094304:	003d3706 	br	210937e4 <__flash_rwdata_start+0xffff159c>
21094308:	00800044 	movi	r2,1
2109430c:	003dd006 	br	21093a50 <__flash_rwdata_start+0xffff1808>
21094310:	d8c00217 	ldw	r3,8(sp)
21094314:	00800d84 	movi	r2,54
21094318:	dd400917 	ldw	r21,36(sp)
2109431c:	10c5c83a 	sub	r2,r2,r3
21094320:	dd000817 	ldw	r20,32(sp)
21094324:	003d2f06 	br	210937e4 <__flash_rwdata_start+0xffff159c>
21094328:	9029883a 	mov	r20,r18
2109432c:	982b883a 	mov	r21,r19
21094330:	04400084 	movi	r17,2
21094334:	003bc606 	br	21093250 <__flash_rwdata_start+0xffff1008>
21094338:	d8800617 	ldw	r2,24(sp)
2109433c:	103efc26 	beq	r2,zero,21093f30 <__flash_rwdata_start+0xffff1ce8>
21094340:	d8c00c17 	ldw	r3,48(sp)
21094344:	00fc890e 	bge	zero,r3,2109356c <__flash_rwdata_start+0xffff1324>
21094348:	a80b883a 	mov	r5,r21
2109434c:	a009883a 	mov	r4,r20
21094350:	000d883a 	mov	r6,zero
21094354:	01d00934 	movhi	r7,16420
21094358:	108bf600 	call	2108bf60 <__muldf3>
2109435c:	89000044 	addi	r4,r17,1
21094360:	1029883a 	mov	r20,r2
21094364:	182b883a 	mov	r21,r3
21094368:	108cfdc0 	call	2108cfdc <__floatsidf>
2109436c:	a009883a 	mov	r4,r20
21094370:	a80b883a 	mov	r5,r21
21094374:	100d883a 	mov	r6,r2
21094378:	180f883a 	mov	r7,r3
2109437c:	108bf600 	call	2108bf60 <__muldf3>
21094380:	1009883a 	mov	r4,r2
21094384:	180b883a 	mov	r5,r3
21094388:	000d883a 	mov	r6,zero
2109438c:	01d00734 	movhi	r7,16412
21094390:	108ad180 	call	2108ad18 <__adddf3>
21094394:	d9000517 	ldw	r4,20(sp)
21094398:	1023883a 	mov	r17,r2
2109439c:	00bf3034 	movhi	r2,64704
210943a0:	213fffc4 	addi	r4,r4,-1
210943a4:	1885883a 	add	r2,r3,r2
210943a8:	d9001215 	stw	r4,72(sp)
210943ac:	d8800e15 	stw	r2,56(sp)
210943b0:	da800c17 	ldw	r10,48(sp)
210943b4:	003bc306 	br	210932c4 <__flash_rwdata_start+0xffff107c>
210943b8:	b039883a 	mov	fp,r22
210943bc:	01000e44 	movi	r4,57
210943c0:	8825883a 	mov	r18,r17
210943c4:	9dc00044 	addi	r23,r19,1
210943c8:	99000005 	stb	r4,0(r19)
210943cc:	a023883a 	mov	r17,r20
210943d0:	003dae06 	br	21093a8c <__flash_rwdata_start+0xffff1844>
210943d4:	d9800e17 	ldw	r6,56(sp)
210943d8:	d9c01117 	ldw	r7,68(sp)
210943dc:	0009883a 	mov	r4,zero
210943e0:	014ff834 	movhi	r5,16352
210943e4:	da001715 	stw	r8,92(sp)
210943e8:	da401515 	stw	r9,84(sp)
210943ec:	108c6840 	call	2108c684 <__subdf3>
210943f0:	da001717 	ldw	r8,92(sp)
210943f4:	da401517 	ldw	r9,84(sp)
210943f8:	1009883a 	mov	r4,r2
210943fc:	180b883a 	mov	r5,r3
21094400:	400d883a 	mov	r6,r8
21094404:	480f883a 	mov	r7,r9
21094408:	108be800 	call	2108be80 <__gedf2>
2109440c:	00bc570e 	bge	zero,r2,2109356c <__flash_rwdata_start+0xffff1324>
21094410:	01000c04 	movi	r4,48
21094414:	00000106 	br	2109441c <_dtoa_r+0x1624>
21094418:	102f883a 	mov	r23,r2
2109441c:	b8bfffc4 	addi	r2,r23,-1
21094420:	10c00007 	ldb	r3,0(r2)
21094424:	193ffc26 	beq	r3,r4,21094418 <__flash_rwdata_start+0xffff21d0>
21094428:	d9801217 	ldw	r6,72(sp)
2109442c:	d9800515 	stw	r6,20(sp)
21094430:	003c1f06 	br	210934b0 <__flash_rwdata_start+0xffff1268>
21094434:	d8801217 	ldw	r2,72(sp)
21094438:	dc001117 	ldw	r16,68(sp)
2109443c:	d8800515 	stw	r2,20(sp)
21094440:	003cc906 	br	21093768 <__flash_rwdata_start+0xffff1520>
21094444:	dd801317 	ldw	r22,76(sp)
21094448:	dc001117 	ldw	r16,68(sp)
2109444c:	dcc01417 	ldw	r19,80(sp)
21094450:	dc801017 	ldw	r18,64(sp)
21094454:	003c4506 	br	2109356c <__flash_rwdata_start+0xffff1324>
21094458:	103e5d1e 	bne	r2,zero,21093dd0 <__flash_rwdata_start+0xffff1b88>
2109445c:	4080004c 	andi	r2,r8,1
21094460:	103e5b26 	beq	r2,zero,21093dd0 <__flash_rwdata_start+0xffff1b88>
21094464:	003e5706 	br	21093dc4 <__flash_rwdata_start+0xffff1b7c>
21094468:	d8c00317 	ldw	r3,12(sp)
2109446c:	00800084 	movi	r2,2
21094470:	10c00a16 	blt	r2,r3,2109449c <_dtoa_r+0x16a4>
21094474:	d9000c17 	ldw	r4,48(sp)
21094478:	003e8306 	br	21093e88 <__flash_rwdata_start+0xffff1c40>
2109447c:	04400084 	movi	r17,2
21094480:	003b7306 	br	21093250 <__flash_rwdata_start+0xffff1008>
21094484:	d9801217 	ldw	r6,72(sp)
21094488:	d9800515 	stw	r6,20(sp)
2109448c:	003cb606 	br	21093768 <__flash_rwdata_start+0xffff1520>
21094490:	d9001217 	ldw	r4,72(sp)
21094494:	d9000515 	stw	r4,20(sp)
21094498:	003c0506 	br	210934b0 <__flash_rwdata_start+0xffff1268>
2109449c:	d9800c17 	ldw	r6,48(sp)
210944a0:	d9800615 	stw	r6,24(sp)
210944a4:	003e8306 	br	21093eb4 <__flash_rwdata_start+0xffff1c6c>
210944a8:	d9800317 	ldw	r6,12(sp)
210944ac:	00800084 	movi	r2,2
210944b0:	11800216 	blt	r2,r6,210944bc <_dtoa_r+0x16c4>
210944b4:	d8800c17 	ldw	r2,48(sp)
210944b8:	003da606 	br	21093b54 <__flash_rwdata_start+0xffff190c>
210944bc:	d8800c17 	ldw	r2,48(sp)
210944c0:	d8800615 	stw	r2,24(sp)
210944c4:	003e7b06 	br	21093eb4 <__flash_rwdata_start+0xffff1c6c>
210944c8:	05000044 	movi	r20,1
210944cc:	003b0506 	br	210930e4 <__flash_rwdata_start+0xffff0e9c>
210944d0:	8009883a 	mov	r4,r16
210944d4:	80001115 	stw	zero,68(r16)
210944d8:	000b883a 	mov	r5,zero
210944dc:	1095a8c0 	call	21095a8c <_Balloc>
210944e0:	d8800715 	stw	r2,28(sp)
210944e4:	d8c00717 	ldw	r3,28(sp)
210944e8:	00bfffc4 	movi	r2,-1
210944ec:	01000044 	movi	r4,1
210944f0:	d8800c15 	stw	r2,48(sp)
210944f4:	80c01015 	stw	r3,64(r16)
210944f8:	d9000b15 	stw	r4,44(sp)
210944fc:	d8800615 	stw	r2,24(sp)
21094500:	d8002215 	stw	zero,136(sp)
21094504:	003c1906 	br	2109356c <__flash_rwdata_start+0xffff1324>
21094508:	193d2926 	beq	r3,r4,210939b0 <__flash_rwdata_start+0xffff1768>
2109450c:	00c00f04 	movi	r3,60
21094510:	1885c83a 	sub	r2,r3,r2
21094514:	003d7b06 	br	21093b04 <__flash_rwdata_start+0xffff18bc>
21094518:	000b883a 	mov	r5,zero
2109451c:	003b1006 	br	21093160 <__flash_rwdata_start+0xffff0f18>

21094520 <__sflush_r>:
21094520:	2880030b 	ldhu	r2,12(r5)
21094524:	defffb04 	addi	sp,sp,-20
21094528:	dcc00315 	stw	r19,12(sp)
2109452c:	dc400115 	stw	r17,4(sp)
21094530:	dfc00415 	stw	ra,16(sp)
21094534:	dc800215 	stw	r18,8(sp)
21094538:	dc000015 	stw	r16,0(sp)
2109453c:	10c0020c 	andi	r3,r2,8
21094540:	2823883a 	mov	r17,r5
21094544:	2027883a 	mov	r19,r4
21094548:	1800311e 	bne	r3,zero,21094610 <__sflush_r+0xf0>
2109454c:	28c00117 	ldw	r3,4(r5)
21094550:	10820014 	ori	r2,r2,2048
21094554:	2880030d 	sth	r2,12(r5)
21094558:	00c04b0e 	bge	zero,r3,21094688 <__sflush_r+0x168>
2109455c:	8a000a17 	ldw	r8,40(r17)
21094560:	40002326 	beq	r8,zero,210945f0 <__sflush_r+0xd0>
21094564:	9c000017 	ldw	r16,0(r19)
21094568:	10c4000c 	andi	r3,r2,4096
2109456c:	98000015 	stw	zero,0(r19)
21094570:	18004826 	beq	r3,zero,21094694 <__sflush_r+0x174>
21094574:	89801417 	ldw	r6,80(r17)
21094578:	10c0010c 	andi	r3,r2,4
2109457c:	18000626 	beq	r3,zero,21094598 <__sflush_r+0x78>
21094580:	88c00117 	ldw	r3,4(r17)
21094584:	88800c17 	ldw	r2,48(r17)
21094588:	30cdc83a 	sub	r6,r6,r3
2109458c:	10000226 	beq	r2,zero,21094598 <__sflush_r+0x78>
21094590:	88800f17 	ldw	r2,60(r17)
21094594:	308dc83a 	sub	r6,r6,r2
21094598:	89400717 	ldw	r5,28(r17)
2109459c:	9809883a 	mov	r4,r19
210945a0:	000f883a 	mov	r7,zero
210945a4:	403ee83a 	callr	r8
210945a8:	00ffffc4 	movi	r3,-1
210945ac:	10c04426 	beq	r2,r3,210946c0 <__sflush_r+0x1a0>
210945b0:	88c0030b 	ldhu	r3,12(r17)
210945b4:	89000417 	ldw	r4,16(r17)
210945b8:	88000115 	stw	zero,4(r17)
210945bc:	197dffcc 	andi	r5,r3,63487
210945c0:	8940030d 	sth	r5,12(r17)
210945c4:	89000015 	stw	r4,0(r17)
210945c8:	18c4000c 	andi	r3,r3,4096
210945cc:	18002c1e 	bne	r3,zero,21094680 <__sflush_r+0x160>
210945d0:	89400c17 	ldw	r5,48(r17)
210945d4:	9c000015 	stw	r16,0(r19)
210945d8:	28000526 	beq	r5,zero,210945f0 <__sflush_r+0xd0>
210945dc:	88801004 	addi	r2,r17,64
210945e0:	28800226 	beq	r5,r2,210945ec <__sflush_r+0xcc>
210945e4:	9809883a 	mov	r4,r19
210945e8:	1094c780 	call	21094c78 <_free_r>
210945ec:	88000c15 	stw	zero,48(r17)
210945f0:	0005883a 	mov	r2,zero
210945f4:	dfc00417 	ldw	ra,16(sp)
210945f8:	dcc00317 	ldw	r19,12(sp)
210945fc:	dc800217 	ldw	r18,8(sp)
21094600:	dc400117 	ldw	r17,4(sp)
21094604:	dc000017 	ldw	r16,0(sp)
21094608:	dec00504 	addi	sp,sp,20
2109460c:	f800283a 	ret
21094610:	2c800417 	ldw	r18,16(r5)
21094614:	903ff626 	beq	r18,zero,210945f0 <__flash_rwdata_start+0xffff23a8>
21094618:	2c000017 	ldw	r16,0(r5)
2109461c:	108000cc 	andi	r2,r2,3
21094620:	2c800015 	stw	r18,0(r5)
21094624:	84a1c83a 	sub	r16,r16,r18
21094628:	1000131e 	bne	r2,zero,21094678 <__sflush_r+0x158>
2109462c:	28800517 	ldw	r2,20(r5)
21094630:	88800215 	stw	r2,8(r17)
21094634:	04000316 	blt	zero,r16,21094644 <__sflush_r+0x124>
21094638:	003fed06 	br	210945f0 <__flash_rwdata_start+0xffff23a8>
2109463c:	90a5883a 	add	r18,r18,r2
21094640:	043feb0e 	bge	zero,r16,210945f0 <__flash_rwdata_start+0xffff23a8>
21094644:	88800917 	ldw	r2,36(r17)
21094648:	89400717 	ldw	r5,28(r17)
2109464c:	800f883a 	mov	r7,r16
21094650:	900d883a 	mov	r6,r18
21094654:	9809883a 	mov	r4,r19
21094658:	103ee83a 	callr	r2
2109465c:	80a1c83a 	sub	r16,r16,r2
21094660:	00bff616 	blt	zero,r2,2109463c <__flash_rwdata_start+0xffff23f4>
21094664:	88c0030b 	ldhu	r3,12(r17)
21094668:	00bfffc4 	movi	r2,-1
2109466c:	18c01014 	ori	r3,r3,64
21094670:	88c0030d 	sth	r3,12(r17)
21094674:	003fdf06 	br	210945f4 <__flash_rwdata_start+0xffff23ac>
21094678:	0005883a 	mov	r2,zero
2109467c:	003fec06 	br	21094630 <__flash_rwdata_start+0xffff23e8>
21094680:	88801415 	stw	r2,80(r17)
21094684:	003fd206 	br	210945d0 <__flash_rwdata_start+0xffff2388>
21094688:	28c00f17 	ldw	r3,60(r5)
2109468c:	00ffb316 	blt	zero,r3,2109455c <__flash_rwdata_start+0xffff2314>
21094690:	003fd706 	br	210945f0 <__flash_rwdata_start+0xffff23a8>
21094694:	89400717 	ldw	r5,28(r17)
21094698:	000d883a 	mov	r6,zero
2109469c:	9809883a 	mov	r4,r19
210946a0:	01c00044 	movi	r7,1
210946a4:	403ee83a 	callr	r8
210946a8:	100d883a 	mov	r6,r2
210946ac:	00bfffc4 	movi	r2,-1
210946b0:	30801426 	beq	r6,r2,21094704 <__sflush_r+0x1e4>
210946b4:	8880030b 	ldhu	r2,12(r17)
210946b8:	8a000a17 	ldw	r8,40(r17)
210946bc:	003fae06 	br	21094578 <__flash_rwdata_start+0xffff2330>
210946c0:	98c00017 	ldw	r3,0(r19)
210946c4:	183fba26 	beq	r3,zero,210945b0 <__flash_rwdata_start+0xffff2368>
210946c8:	01000744 	movi	r4,29
210946cc:	19000626 	beq	r3,r4,210946e8 <__sflush_r+0x1c8>
210946d0:	01000584 	movi	r4,22
210946d4:	19000426 	beq	r3,r4,210946e8 <__sflush_r+0x1c8>
210946d8:	88c0030b 	ldhu	r3,12(r17)
210946dc:	18c01014 	ori	r3,r3,64
210946e0:	88c0030d 	sth	r3,12(r17)
210946e4:	003fc306 	br	210945f4 <__flash_rwdata_start+0xffff23ac>
210946e8:	8880030b 	ldhu	r2,12(r17)
210946ec:	88c00417 	ldw	r3,16(r17)
210946f0:	88000115 	stw	zero,4(r17)
210946f4:	10bdffcc 	andi	r2,r2,63487
210946f8:	8880030d 	sth	r2,12(r17)
210946fc:	88c00015 	stw	r3,0(r17)
21094700:	003fb306 	br	210945d0 <__flash_rwdata_start+0xffff2388>
21094704:	98800017 	ldw	r2,0(r19)
21094708:	103fea26 	beq	r2,zero,210946b4 <__flash_rwdata_start+0xffff246c>
2109470c:	00c00744 	movi	r3,29
21094710:	10c00226 	beq	r2,r3,2109471c <__sflush_r+0x1fc>
21094714:	00c00584 	movi	r3,22
21094718:	10ffd21e 	bne	r2,r3,21094664 <__flash_rwdata_start+0xffff241c>
2109471c:	9c000015 	stw	r16,0(r19)
21094720:	0005883a 	mov	r2,zero
21094724:	003fb306 	br	210945f4 <__flash_rwdata_start+0xffff23ac>

21094728 <_fflush_r>:
21094728:	defffd04 	addi	sp,sp,-12
2109472c:	dc000115 	stw	r16,4(sp)
21094730:	dfc00215 	stw	ra,8(sp)
21094734:	2021883a 	mov	r16,r4
21094738:	20000226 	beq	r4,zero,21094744 <_fflush_r+0x1c>
2109473c:	20800e17 	ldw	r2,56(r4)
21094740:	10000c26 	beq	r2,zero,21094774 <_fflush_r+0x4c>
21094744:	2880030f 	ldh	r2,12(r5)
21094748:	1000051e 	bne	r2,zero,21094760 <_fflush_r+0x38>
2109474c:	0005883a 	mov	r2,zero
21094750:	dfc00217 	ldw	ra,8(sp)
21094754:	dc000117 	ldw	r16,4(sp)
21094758:	dec00304 	addi	sp,sp,12
2109475c:	f800283a 	ret
21094760:	8009883a 	mov	r4,r16
21094764:	dfc00217 	ldw	ra,8(sp)
21094768:	dc000117 	ldw	r16,4(sp)
2109476c:	dec00304 	addi	sp,sp,12
21094770:	10945201 	jmpi	21094520 <__sflush_r>
21094774:	d9400015 	stw	r5,0(sp)
21094778:	1094b040 	call	21094b04 <__sinit>
2109477c:	d9400017 	ldw	r5,0(sp)
21094780:	003ff006 	br	21094744 <__flash_rwdata_start+0xffff24fc>

21094784 <fflush>:
21094784:	20000526 	beq	r4,zero,2109479c <fflush+0x18>
21094788:	00800034 	movhi	r2,0
2109478c:	10976b04 	addi	r2,r2,23980
21094790:	200b883a 	mov	r5,r4
21094794:	11000017 	ldw	r4,0(r2)
21094798:	10947281 	jmpi	21094728 <_fflush_r>
2109479c:	00800034 	movhi	r2,0
210947a0:	10976a04 	addi	r2,r2,23976
210947a4:	11000017 	ldw	r4,0(r2)
210947a8:	01484274 	movhi	r5,8457
210947ac:	2951ca04 	addi	r5,r5,18216
210947b0:	10954ec1 	jmpi	210954ec <_fwalk_reent>

210947b4 <__fp_lock>:
210947b4:	0005883a 	mov	r2,zero
210947b8:	f800283a 	ret

210947bc <__fp_unlock>:
210947bc:	0005883a 	mov	r2,zero
210947c0:	f800283a 	ret

210947c4 <_cleanup_r>:
210947c4:	014842b4 	movhi	r5,8458
210947c8:	29676904 	addi	r5,r5,-25180
210947cc:	10954ec1 	jmpi	210954ec <_fwalk_reent>

210947d0 <__sinit.part.1>:
210947d0:	defff704 	addi	sp,sp,-36
210947d4:	00c84274 	movhi	r3,8457
210947d8:	dfc00815 	stw	ra,32(sp)
210947dc:	ddc00715 	stw	r23,28(sp)
210947e0:	dd800615 	stw	r22,24(sp)
210947e4:	dd400515 	stw	r21,20(sp)
210947e8:	dd000415 	stw	r20,16(sp)
210947ec:	dcc00315 	stw	r19,12(sp)
210947f0:	dc800215 	stw	r18,8(sp)
210947f4:	dc400115 	stw	r17,4(sp)
210947f8:	dc000015 	stw	r16,0(sp)
210947fc:	18d1f104 	addi	r3,r3,18372
21094800:	24000117 	ldw	r16,4(r4)
21094804:	20c00f15 	stw	r3,60(r4)
21094808:	2080bb04 	addi	r2,r4,748
2109480c:	00c000c4 	movi	r3,3
21094810:	20c0b915 	stw	r3,740(r4)
21094814:	2080ba15 	stw	r2,744(r4)
21094818:	2000b815 	stw	zero,736(r4)
2109481c:	05c00204 	movi	r23,8
21094820:	00800104 	movi	r2,4
21094824:	2025883a 	mov	r18,r4
21094828:	b80d883a 	mov	r6,r23
2109482c:	81001704 	addi	r4,r16,92
21094830:	000b883a 	mov	r5,zero
21094834:	80000015 	stw	zero,0(r16)
21094838:	80000115 	stw	zero,4(r16)
2109483c:	80000215 	stw	zero,8(r16)
21094840:	8080030d 	sth	r2,12(r16)
21094844:	80001915 	stw	zero,100(r16)
21094848:	8000038d 	sth	zero,14(r16)
2109484c:	80000415 	stw	zero,16(r16)
21094850:	80000515 	stw	zero,20(r16)
21094854:	80000615 	stw	zero,24(r16)
21094858:	108e26c0 	call	2108e26c <memset>
2109485c:	05884274 	movhi	r22,8457
21094860:	94400217 	ldw	r17,8(r18)
21094864:	05484274 	movhi	r21,8457
21094868:	05084274 	movhi	r20,8457
2109486c:	04c84274 	movhi	r19,8457
21094870:	b59c5d04 	addi	r22,r22,29044
21094874:	ad5c7404 	addi	r21,r21,29136
21094878:	a51c9304 	addi	r20,r20,29260
2109487c:	9cdcaa04 	addi	r19,r19,29352
21094880:	85800815 	stw	r22,32(r16)
21094884:	85400915 	stw	r21,36(r16)
21094888:	85000a15 	stw	r20,40(r16)
2109488c:	84c00b15 	stw	r19,44(r16)
21094890:	84000715 	stw	r16,28(r16)
21094894:	00800284 	movi	r2,10
21094898:	8880030d 	sth	r2,12(r17)
2109489c:	00800044 	movi	r2,1
210948a0:	89001704 	addi	r4,r17,92
210948a4:	b80d883a 	mov	r6,r23
210948a8:	000b883a 	mov	r5,zero
210948ac:	88000015 	stw	zero,0(r17)
210948b0:	88000115 	stw	zero,4(r17)
210948b4:	88000215 	stw	zero,8(r17)
210948b8:	88001915 	stw	zero,100(r17)
210948bc:	8880038d 	sth	r2,14(r17)
210948c0:	88000415 	stw	zero,16(r17)
210948c4:	88000515 	stw	zero,20(r17)
210948c8:	88000615 	stw	zero,24(r17)
210948cc:	108e26c0 	call	2108e26c <memset>
210948d0:	94000317 	ldw	r16,12(r18)
210948d4:	00800484 	movi	r2,18
210948d8:	8c400715 	stw	r17,28(r17)
210948dc:	8d800815 	stw	r22,32(r17)
210948e0:	8d400915 	stw	r21,36(r17)
210948e4:	8d000a15 	stw	r20,40(r17)
210948e8:	8cc00b15 	stw	r19,44(r17)
210948ec:	8080030d 	sth	r2,12(r16)
210948f0:	00800084 	movi	r2,2
210948f4:	80000015 	stw	zero,0(r16)
210948f8:	80000115 	stw	zero,4(r16)
210948fc:	80000215 	stw	zero,8(r16)
21094900:	80001915 	stw	zero,100(r16)
21094904:	8080038d 	sth	r2,14(r16)
21094908:	80000415 	stw	zero,16(r16)
2109490c:	80000515 	stw	zero,20(r16)
21094910:	80000615 	stw	zero,24(r16)
21094914:	81001704 	addi	r4,r16,92
21094918:	000b883a 	mov	r5,zero
2109491c:	b80d883a 	mov	r6,r23
21094920:	108e26c0 	call	2108e26c <memset>
21094924:	00800044 	movi	r2,1
21094928:	84000715 	stw	r16,28(r16)
2109492c:	85800815 	stw	r22,32(r16)
21094930:	85400915 	stw	r21,36(r16)
21094934:	85000a15 	stw	r20,40(r16)
21094938:	84c00b15 	stw	r19,44(r16)
2109493c:	90800e15 	stw	r2,56(r18)
21094940:	dfc00817 	ldw	ra,32(sp)
21094944:	ddc00717 	ldw	r23,28(sp)
21094948:	dd800617 	ldw	r22,24(sp)
2109494c:	dd400517 	ldw	r21,20(sp)
21094950:	dd000417 	ldw	r20,16(sp)
21094954:	dcc00317 	ldw	r19,12(sp)
21094958:	dc800217 	ldw	r18,8(sp)
2109495c:	dc400117 	ldw	r17,4(sp)
21094960:	dc000017 	ldw	r16,0(sp)
21094964:	dec00904 	addi	sp,sp,36
21094968:	f800283a 	ret

2109496c <__sfmoreglue>:
2109496c:	defffc04 	addi	sp,sp,-16
21094970:	dc400115 	stw	r17,4(sp)
21094974:	2c7fffc4 	addi	r17,r5,-1
21094978:	8c401a24 	muli	r17,r17,104
2109497c:	dc800215 	stw	r18,8(sp)
21094980:	2825883a 	mov	r18,r5
21094984:	89401d04 	addi	r5,r17,116
21094988:	dc000015 	stw	r16,0(sp)
2109498c:	dfc00315 	stw	ra,12(sp)
21094990:	108d9100 	call	2108d910 <_malloc_r>
21094994:	1021883a 	mov	r16,r2
21094998:	10000726 	beq	r2,zero,210949b8 <__sfmoreglue+0x4c>
2109499c:	11000304 	addi	r4,r2,12
210949a0:	10000015 	stw	zero,0(r2)
210949a4:	14800115 	stw	r18,4(r2)
210949a8:	11000215 	stw	r4,8(r2)
210949ac:	000b883a 	mov	r5,zero
210949b0:	89801a04 	addi	r6,r17,104
210949b4:	108e26c0 	call	2108e26c <memset>
210949b8:	8005883a 	mov	r2,r16
210949bc:	dfc00317 	ldw	ra,12(sp)
210949c0:	dc800217 	ldw	r18,8(sp)
210949c4:	dc400117 	ldw	r17,4(sp)
210949c8:	dc000017 	ldw	r16,0(sp)
210949cc:	dec00404 	addi	sp,sp,16
210949d0:	f800283a 	ret

210949d4 <__sfp>:
210949d4:	00800034 	movhi	r2,0
210949d8:	defffb04 	addi	sp,sp,-20
210949dc:	10976a04 	addi	r2,r2,23976
210949e0:	dc800215 	stw	r18,8(sp)
210949e4:	14800017 	ldw	r18,0(r2)
210949e8:	dcc00315 	stw	r19,12(sp)
210949ec:	dfc00415 	stw	ra,16(sp)
210949f0:	90800e17 	ldw	r2,56(r18)
210949f4:	dc400115 	stw	r17,4(sp)
210949f8:	dc000015 	stw	r16,0(sp)
210949fc:	2027883a 	mov	r19,r4
21094a00:	1000021e 	bne	r2,zero,21094a0c <__sfp+0x38>
21094a04:	9009883a 	mov	r4,r18
21094a08:	10947d00 	call	210947d0 <__sinit.part.1>
21094a0c:	9480b804 	addi	r18,r18,736
21094a10:	047fffc4 	movi	r17,-1
21094a14:	91400117 	ldw	r5,4(r18)
21094a18:	94000217 	ldw	r16,8(r18)
21094a1c:	297fffc4 	addi	r5,r5,-1
21094a20:	28000a16 	blt	r5,zero,21094a4c <__sfp+0x78>
21094a24:	8080030f 	ldh	r2,12(r16)
21094a28:	10000c26 	beq	r2,zero,21094a5c <__sfp+0x88>
21094a2c:	80c01d04 	addi	r3,r16,116
21094a30:	00000206 	br	21094a3c <__sfp+0x68>
21094a34:	18bfe60f 	ldh	r2,-104(r3)
21094a38:	10000826 	beq	r2,zero,21094a5c <__sfp+0x88>
21094a3c:	297fffc4 	addi	r5,r5,-1
21094a40:	1c3ffd04 	addi	r16,r3,-12
21094a44:	18c01a04 	addi	r3,r3,104
21094a48:	2c7ffa1e 	bne	r5,r17,21094a34 <__flash_rwdata_start+0xffff27ec>
21094a4c:	90800017 	ldw	r2,0(r18)
21094a50:	10001d26 	beq	r2,zero,21094ac8 <__sfp+0xf4>
21094a54:	1025883a 	mov	r18,r2
21094a58:	003fee06 	br	21094a14 <__flash_rwdata_start+0xffff27cc>
21094a5c:	00bfffc4 	movi	r2,-1
21094a60:	8080038d 	sth	r2,14(r16)
21094a64:	00800044 	movi	r2,1
21094a68:	8080030d 	sth	r2,12(r16)
21094a6c:	80001915 	stw	zero,100(r16)
21094a70:	80000015 	stw	zero,0(r16)
21094a74:	80000215 	stw	zero,8(r16)
21094a78:	80000115 	stw	zero,4(r16)
21094a7c:	80000415 	stw	zero,16(r16)
21094a80:	80000515 	stw	zero,20(r16)
21094a84:	80000615 	stw	zero,24(r16)
21094a88:	81001704 	addi	r4,r16,92
21094a8c:	000b883a 	mov	r5,zero
21094a90:	01800204 	movi	r6,8
21094a94:	108e26c0 	call	2108e26c <memset>
21094a98:	8005883a 	mov	r2,r16
21094a9c:	80000c15 	stw	zero,48(r16)
21094aa0:	80000d15 	stw	zero,52(r16)
21094aa4:	80001115 	stw	zero,68(r16)
21094aa8:	80001215 	stw	zero,72(r16)
21094aac:	dfc00417 	ldw	ra,16(sp)
21094ab0:	dcc00317 	ldw	r19,12(sp)
21094ab4:	dc800217 	ldw	r18,8(sp)
21094ab8:	dc400117 	ldw	r17,4(sp)
21094abc:	dc000017 	ldw	r16,0(sp)
21094ac0:	dec00504 	addi	sp,sp,20
21094ac4:	f800283a 	ret
21094ac8:	9809883a 	mov	r4,r19
21094acc:	01400104 	movi	r5,4
21094ad0:	109496c0 	call	2109496c <__sfmoreglue>
21094ad4:	90800015 	stw	r2,0(r18)
21094ad8:	103fde1e 	bne	r2,zero,21094a54 <__flash_rwdata_start+0xffff280c>
21094adc:	00800304 	movi	r2,12
21094ae0:	98800015 	stw	r2,0(r19)
21094ae4:	0005883a 	mov	r2,zero
21094ae8:	003ff006 	br	21094aac <__flash_rwdata_start+0xffff2864>

21094aec <_cleanup>:
21094aec:	00800034 	movhi	r2,0
21094af0:	10976a04 	addi	r2,r2,23976
21094af4:	11000017 	ldw	r4,0(r2)
21094af8:	014842b4 	movhi	r5,8458
21094afc:	29676904 	addi	r5,r5,-25180
21094b00:	10954ec1 	jmpi	210954ec <_fwalk_reent>

21094b04 <__sinit>:
21094b04:	20800e17 	ldw	r2,56(r4)
21094b08:	10000126 	beq	r2,zero,21094b10 <__sinit+0xc>
21094b0c:	f800283a 	ret
21094b10:	10947d01 	jmpi	210947d0 <__sinit.part.1>

21094b14 <__sfp_lock_acquire>:
21094b14:	f800283a 	ret

21094b18 <__sfp_lock_release>:
21094b18:	f800283a 	ret

21094b1c <__sinit_lock_acquire>:
21094b1c:	f800283a 	ret

21094b20 <__sinit_lock_release>:
21094b20:	f800283a 	ret

21094b24 <__fp_lock_all>:
21094b24:	00800034 	movhi	r2,0
21094b28:	10976b04 	addi	r2,r2,23980
21094b2c:	11000017 	ldw	r4,0(r2)
21094b30:	01484274 	movhi	r5,8457
21094b34:	2951ed04 	addi	r5,r5,18356
21094b38:	10954281 	jmpi	21095428 <_fwalk>

21094b3c <__fp_unlock_all>:
21094b3c:	00800034 	movhi	r2,0
21094b40:	10976b04 	addi	r2,r2,23980
21094b44:	11000017 	ldw	r4,0(r2)
21094b48:	01484274 	movhi	r5,8457
21094b4c:	2951ef04 	addi	r5,r5,18364
21094b50:	10954281 	jmpi	21095428 <_fwalk>

21094b54 <_malloc_trim_r>:
21094b54:	defffb04 	addi	sp,sp,-20
21094b58:	dcc00315 	stw	r19,12(sp)
21094b5c:	04c00034 	movhi	r19,0
21094b60:	dc800215 	stw	r18,8(sp)
21094b64:	dc400115 	stw	r17,4(sp)
21094b68:	dc000015 	stw	r16,0(sp)
21094b6c:	dfc00415 	stw	ra,16(sp)
21094b70:	2821883a 	mov	r16,r5
21094b74:	9cd15504 	addi	r19,r19,17748
21094b78:	2025883a 	mov	r18,r4
21094b7c:	109b5540 	call	2109b554 <__malloc_lock>
21094b80:	98800217 	ldw	r2,8(r19)
21094b84:	14400117 	ldw	r17,4(r2)
21094b88:	00bfff04 	movi	r2,-4
21094b8c:	88a2703a 	and	r17,r17,r2
21094b90:	8c21c83a 	sub	r16,r17,r16
21094b94:	8403fbc4 	addi	r16,r16,4079
21094b98:	8020d33a 	srli	r16,r16,12
21094b9c:	0083ffc4 	movi	r2,4095
21094ba0:	843fffc4 	addi	r16,r16,-1
21094ba4:	8020933a 	slli	r16,r16,12
21094ba8:	1400060e 	bge	r2,r16,21094bc4 <_malloc_trim_r+0x70>
21094bac:	9009883a 	mov	r4,r18
21094bb0:	000b883a 	mov	r5,zero
21094bb4:	108e4d40 	call	2108e4d4 <_sbrk_r>
21094bb8:	98c00217 	ldw	r3,8(r19)
21094bbc:	1c47883a 	add	r3,r3,r17
21094bc0:	10c00a26 	beq	r2,r3,21094bec <_malloc_trim_r+0x98>
21094bc4:	9009883a 	mov	r4,r18
21094bc8:	109b5580 	call	2109b558 <__malloc_unlock>
21094bcc:	0005883a 	mov	r2,zero
21094bd0:	dfc00417 	ldw	ra,16(sp)
21094bd4:	dcc00317 	ldw	r19,12(sp)
21094bd8:	dc800217 	ldw	r18,8(sp)
21094bdc:	dc400117 	ldw	r17,4(sp)
21094be0:	dc000017 	ldw	r16,0(sp)
21094be4:	dec00504 	addi	sp,sp,20
21094be8:	f800283a 	ret
21094bec:	9009883a 	mov	r4,r18
21094bf0:	040bc83a 	sub	r5,zero,r16
21094bf4:	108e4d40 	call	2108e4d4 <_sbrk_r>
21094bf8:	00ffffc4 	movi	r3,-1
21094bfc:	10c00d26 	beq	r2,r3,21094c34 <_malloc_trim_r+0xe0>
21094c00:	00c00034 	movhi	r3,0
21094c04:	18d87204 	addi	r3,r3,25032
21094c08:	18800017 	ldw	r2,0(r3)
21094c0c:	99000217 	ldw	r4,8(r19)
21094c10:	8c23c83a 	sub	r17,r17,r16
21094c14:	8c400054 	ori	r17,r17,1
21094c18:	1421c83a 	sub	r16,r2,r16
21094c1c:	24400115 	stw	r17,4(r4)
21094c20:	9009883a 	mov	r4,r18
21094c24:	1c000015 	stw	r16,0(r3)
21094c28:	109b5580 	call	2109b558 <__malloc_unlock>
21094c2c:	00800044 	movi	r2,1
21094c30:	003fe706 	br	21094bd0 <__flash_rwdata_start+0xffff2988>
21094c34:	9009883a 	mov	r4,r18
21094c38:	000b883a 	mov	r5,zero
21094c3c:	108e4d40 	call	2108e4d4 <_sbrk_r>
21094c40:	99000217 	ldw	r4,8(r19)
21094c44:	014003c4 	movi	r5,15
21094c48:	1107c83a 	sub	r3,r2,r4
21094c4c:	28ffdd0e 	bge	r5,r3,21094bc4 <__flash_rwdata_start+0xffff297c>
21094c50:	01400034 	movhi	r5,0
21094c54:	29576c04 	addi	r5,r5,23984
21094c58:	29400017 	ldw	r5,0(r5)
21094c5c:	18c00054 	ori	r3,r3,1
21094c60:	20c00115 	stw	r3,4(r4)
21094c64:	00c00034 	movhi	r3,0
21094c68:	1145c83a 	sub	r2,r2,r5
21094c6c:	18d87204 	addi	r3,r3,25032
21094c70:	18800015 	stw	r2,0(r3)
21094c74:	003fd306 	br	21094bc4 <__flash_rwdata_start+0xffff297c>

21094c78 <_free_r>:
21094c78:	28004c26 	beq	r5,zero,21094dac <_free_r+0x134>
21094c7c:	defffd04 	addi	sp,sp,-12
21094c80:	dc400115 	stw	r17,4(sp)
21094c84:	dc000015 	stw	r16,0(sp)
21094c88:	2023883a 	mov	r17,r4
21094c8c:	2821883a 	mov	r16,r5
21094c90:	dfc00215 	stw	ra,8(sp)
21094c94:	109b5540 	call	2109b554 <__malloc_lock>
21094c98:	813fff17 	ldw	r4,-4(r16)
21094c9c:	00bfff84 	movi	r2,-2
21094ca0:	02400034 	movhi	r9,0
21094ca4:	81bffe04 	addi	r6,r16,-8
21094ca8:	2084703a 	and	r2,r4,r2
21094cac:	4a515504 	addi	r9,r9,17748
21094cb0:	308b883a 	add	r5,r6,r2
21094cb4:	2a000117 	ldw	r8,4(r5)
21094cb8:	49c00217 	ldw	r7,8(r9)
21094cbc:	00ffff04 	movi	r3,-4
21094cc0:	40c6703a 	and	r3,r8,r3
21094cc4:	39405326 	beq	r7,r5,21094e14 <_free_r+0x19c>
21094cc8:	28c00115 	stw	r3,4(r5)
21094ccc:	2100004c 	andi	r4,r4,1
21094cd0:	2000091e 	bne	r4,zero,21094cf8 <_free_r+0x80>
21094cd4:	81fffe17 	ldw	r7,-8(r16)
21094cd8:	4a000204 	addi	r8,r9,8
21094cdc:	31cdc83a 	sub	r6,r6,r7
21094ce0:	31000217 	ldw	r4,8(r6)
21094ce4:	11c5883a 	add	r2,r2,r7
21094ce8:	22006126 	beq	r4,r8,21094e70 <_free_r+0x1f8>
21094cec:	31c00317 	ldw	r7,12(r6)
21094cf0:	21c00315 	stw	r7,12(r4)
21094cf4:	39000215 	stw	r4,8(r7)
21094cf8:	28c9883a 	add	r4,r5,r3
21094cfc:	21c00117 	ldw	r7,4(r4)
21094d00:	39c0004c 	andi	r7,r7,1
21094d04:	38000d1e 	bne	r7,zero,21094d3c <_free_r+0xc4>
21094d08:	29000217 	ldw	r4,8(r5)
21094d0c:	10c5883a 	add	r2,r2,r3
21094d10:	00c00034 	movhi	r3,0
21094d14:	18d15704 	addi	r3,r3,17756
21094d18:	20c07526 	beq	r4,r3,21094ef0 <_free_r+0x278>
21094d1c:	29c00317 	ldw	r7,12(r5)
21094d20:	11400054 	ori	r5,r2,1
21094d24:	3087883a 	add	r3,r6,r2
21094d28:	21c00315 	stw	r7,12(r4)
21094d2c:	39000215 	stw	r4,8(r7)
21094d30:	31400115 	stw	r5,4(r6)
21094d34:	18800015 	stw	r2,0(r3)
21094d38:	00000406 	br	21094d4c <_free_r+0xd4>
21094d3c:	10c00054 	ori	r3,r2,1
21094d40:	30c00115 	stw	r3,4(r6)
21094d44:	3087883a 	add	r3,r6,r2
21094d48:	18800015 	stw	r2,0(r3)
21094d4c:	00c07fc4 	movi	r3,511
21094d50:	18801736 	bltu	r3,r2,21094db0 <_free_r+0x138>
21094d54:	1004d0fa 	srli	r2,r2,3
21094d58:	01400044 	movi	r5,1
21094d5c:	49000117 	ldw	r4,4(r9)
21094d60:	1087883a 	add	r3,r2,r2
21094d64:	18c7883a 	add	r3,r3,r3
21094d68:	1005d0ba 	srai	r2,r2,2
21094d6c:	18c7883a 	add	r3,r3,r3
21094d70:	1a47883a 	add	r3,r3,r9
21094d74:	19c00217 	ldw	r7,8(r3)
21094d78:	2884983a 	sll	r2,r5,r2
21094d7c:	30c00315 	stw	r3,12(r6)
21094d80:	31c00215 	stw	r7,8(r6)
21094d84:	1104b03a 	or	r2,r2,r4
21094d88:	19800215 	stw	r6,8(r3)
21094d8c:	48800115 	stw	r2,4(r9)
21094d90:	39800315 	stw	r6,12(r7)
21094d94:	8809883a 	mov	r4,r17
21094d98:	dfc00217 	ldw	ra,8(sp)
21094d9c:	dc400117 	ldw	r17,4(sp)
21094da0:	dc000017 	ldw	r16,0(sp)
21094da4:	dec00304 	addi	sp,sp,12
21094da8:	109b5581 	jmpi	2109b558 <__malloc_unlock>
21094dac:	f800283a 	ret
21094db0:	1006d27a 	srli	r3,r2,9
21094db4:	01000104 	movi	r4,4
21094db8:	20c04036 	bltu	r4,r3,21094ebc <_free_r+0x244>
21094dbc:	1006d1ba 	srli	r3,r2,6
21094dc0:	19400e04 	addi	r5,r3,56
21094dc4:	2947883a 	add	r3,r5,r5
21094dc8:	18c7883a 	add	r3,r3,r3
21094dcc:	18c7883a 	add	r3,r3,r3
21094dd0:	1a49883a 	add	r4,r3,r9
21094dd4:	20c00217 	ldw	r3,8(r4)
21094dd8:	01c00034 	movhi	r7,0
21094ddc:	39d15504 	addi	r7,r7,17748
21094de0:	19003b26 	beq	r3,r4,21094ed0 <_free_r+0x258>
21094de4:	01ffff04 	movi	r7,-4
21094de8:	19400117 	ldw	r5,4(r3)
21094dec:	29ca703a 	and	r5,r5,r7
21094df0:	1140022e 	bgeu	r2,r5,21094dfc <_free_r+0x184>
21094df4:	18c00217 	ldw	r3,8(r3)
21094df8:	20fffb1e 	bne	r4,r3,21094de8 <__flash_rwdata_start+0xffff2ba0>
21094dfc:	18800317 	ldw	r2,12(r3)
21094e00:	30800315 	stw	r2,12(r6)
21094e04:	30c00215 	stw	r3,8(r6)
21094e08:	11800215 	stw	r6,8(r2)
21094e0c:	19800315 	stw	r6,12(r3)
21094e10:	003fe006 	br	21094d94 <__flash_rwdata_start+0xffff2b4c>
21094e14:	2100004c 	andi	r4,r4,1
21094e18:	1885883a 	add	r2,r3,r2
21094e1c:	2000071e 	bne	r4,zero,21094e3c <_free_r+0x1c4>
21094e20:	817ffe17 	ldw	r5,-8(r16)
21094e24:	314dc83a 	sub	r6,r6,r5
21094e28:	30c00317 	ldw	r3,12(r6)
21094e2c:	31000217 	ldw	r4,8(r6)
21094e30:	1145883a 	add	r2,r2,r5
21094e34:	20c00315 	stw	r3,12(r4)
21094e38:	19000215 	stw	r4,8(r3)
21094e3c:	10c00054 	ori	r3,r2,1
21094e40:	30c00115 	stw	r3,4(r6)
21094e44:	00c00034 	movhi	r3,0
21094e48:	18d76d04 	addi	r3,r3,23988
21094e4c:	18c00017 	ldw	r3,0(r3)
21094e50:	49800215 	stw	r6,8(r9)
21094e54:	10ffcf36 	bltu	r2,r3,21094d94 <__flash_rwdata_start+0xffff2b4c>
21094e58:	00800034 	movhi	r2,0
21094e5c:	10978404 	addi	r2,r2,24080
21094e60:	11400017 	ldw	r5,0(r2)
21094e64:	8809883a 	mov	r4,r17
21094e68:	1094b540 	call	21094b54 <_malloc_trim_r>
21094e6c:	003fc906 	br	21094d94 <__flash_rwdata_start+0xffff2b4c>
21094e70:	28c9883a 	add	r4,r5,r3
21094e74:	21000117 	ldw	r4,4(r4)
21094e78:	2100004c 	andi	r4,r4,1
21094e7c:	20000a1e 	bne	r4,zero,21094ea8 <_free_r+0x230>
21094e80:	29000317 	ldw	r4,12(r5)
21094e84:	29400217 	ldw	r5,8(r5)
21094e88:	10c5883a 	add	r2,r2,r3
21094e8c:	10c00054 	ori	r3,r2,1
21094e90:	29000315 	stw	r4,12(r5)
21094e94:	21400215 	stw	r5,8(r4)
21094e98:	30c00115 	stw	r3,4(r6)
21094e9c:	308d883a 	add	r6,r6,r2
21094ea0:	30800015 	stw	r2,0(r6)
21094ea4:	003fbb06 	br	21094d94 <__flash_rwdata_start+0xffff2b4c>
21094ea8:	10c00054 	ori	r3,r2,1
21094eac:	30c00115 	stw	r3,4(r6)
21094eb0:	308d883a 	add	r6,r6,r2
21094eb4:	30800015 	stw	r2,0(r6)
21094eb8:	003fb606 	br	21094d94 <__flash_rwdata_start+0xffff2b4c>
21094ebc:	01000504 	movi	r4,20
21094ec0:	20c01436 	bltu	r4,r3,21094f14 <_free_r+0x29c>
21094ec4:	194016c4 	addi	r5,r3,91
21094ec8:	2947883a 	add	r3,r5,r5
21094ecc:	003fbe06 	br	21094dc8 <__flash_rwdata_start+0xffff2b80>
21094ed0:	280bd0ba 	srai	r5,r5,2
21094ed4:	00800044 	movi	r2,1
21094ed8:	39000117 	ldw	r4,4(r7)
21094edc:	114a983a 	sll	r5,r2,r5
21094ee0:	1805883a 	mov	r2,r3
21094ee4:	2908b03a 	or	r4,r5,r4
21094ee8:	39000115 	stw	r4,4(r7)
21094eec:	003fc406 	br	21094e00 <__flash_rwdata_start+0xffff2bb8>
21094ef0:	49800515 	stw	r6,20(r9)
21094ef4:	49800415 	stw	r6,16(r9)
21094ef8:	10c00054 	ori	r3,r2,1
21094efc:	31000315 	stw	r4,12(r6)
21094f00:	31000215 	stw	r4,8(r6)
21094f04:	30c00115 	stw	r3,4(r6)
21094f08:	308d883a 	add	r6,r6,r2
21094f0c:	30800015 	stw	r2,0(r6)
21094f10:	003fa006 	br	21094d94 <__flash_rwdata_start+0xffff2b4c>
21094f14:	01001504 	movi	r4,84
21094f18:	20c00436 	bltu	r4,r3,21094f2c <_free_r+0x2b4>
21094f1c:	1006d33a 	srli	r3,r2,12
21094f20:	19401b84 	addi	r5,r3,110
21094f24:	2947883a 	add	r3,r5,r5
21094f28:	003fa706 	br	21094dc8 <__flash_rwdata_start+0xffff2b80>
21094f2c:	01005504 	movi	r4,340
21094f30:	20c00436 	bltu	r4,r3,21094f44 <_free_r+0x2cc>
21094f34:	1006d3fa 	srli	r3,r2,15
21094f38:	19401dc4 	addi	r5,r3,119
21094f3c:	2947883a 	add	r3,r5,r5
21094f40:	003fa106 	br	21094dc8 <__flash_rwdata_start+0xffff2b80>
21094f44:	01015504 	movi	r4,1364
21094f48:	20c00436 	bltu	r4,r3,21094f5c <_free_r+0x2e4>
21094f4c:	1006d4ba 	srli	r3,r2,18
21094f50:	19401f04 	addi	r5,r3,124
21094f54:	2947883a 	add	r3,r5,r5
21094f58:	003f9b06 	br	21094dc8 <__flash_rwdata_start+0xffff2b80>
21094f5c:	00c03f04 	movi	r3,252
21094f60:	01401f84 	movi	r5,126
21094f64:	003f9806 	br	21094dc8 <__flash_rwdata_start+0xffff2b80>

21094f68 <__sfvwrite_r>:
21094f68:	30800217 	ldw	r2,8(r6)
21094f6c:	10006726 	beq	r2,zero,2109510c <__sfvwrite_r+0x1a4>
21094f70:	defff404 	addi	sp,sp,-48
21094f74:	dd000615 	stw	r20,24(sp)
21094f78:	2029883a 	mov	r20,r4
21094f7c:	2900030b 	ldhu	r4,12(r5)
21094f80:	ddc00915 	stw	r23,36(sp)
21094f84:	dc000215 	stw	r16,8(sp)
21094f88:	dfc00b15 	stw	ra,44(sp)
21094f8c:	df000a15 	stw	fp,40(sp)
21094f90:	dd800815 	stw	r22,32(sp)
21094f94:	dd400715 	stw	r21,28(sp)
21094f98:	dcc00515 	stw	r19,20(sp)
21094f9c:	dc800415 	stw	r18,16(sp)
21094fa0:	dc400315 	stw	r17,12(sp)
21094fa4:	2080020c 	andi	r2,r4,8
21094fa8:	2821883a 	mov	r16,r5
21094fac:	302f883a 	mov	r23,r6
21094fb0:	10002726 	beq	r2,zero,21095050 <__sfvwrite_r+0xe8>
21094fb4:	28800417 	ldw	r2,16(r5)
21094fb8:	10002526 	beq	r2,zero,21095050 <__sfvwrite_r+0xe8>
21094fbc:	2080008c 	andi	r2,r4,2
21094fc0:	bc400017 	ldw	r17,0(r23)
21094fc4:	10002a26 	beq	r2,zero,21095070 <__sfvwrite_r+0x108>
21094fc8:	05600034 	movhi	r21,32768
21094fcc:	0027883a 	mov	r19,zero
21094fd0:	0025883a 	mov	r18,zero
21094fd4:	ad7f0004 	addi	r21,r21,-1024
21094fd8:	980d883a 	mov	r6,r19
21094fdc:	a009883a 	mov	r4,r20
21094fe0:	90004626 	beq	r18,zero,210950fc <__sfvwrite_r+0x194>
21094fe4:	900f883a 	mov	r7,r18
21094fe8:	81400717 	ldw	r5,28(r16)
21094fec:	ac80022e 	bgeu	r21,r18,21094ff8 <__sfvwrite_r+0x90>
21094ff0:	01e00034 	movhi	r7,32768
21094ff4:	39ff0004 	addi	r7,r7,-1024
21094ff8:	80800917 	ldw	r2,36(r16)
21094ffc:	103ee83a 	callr	r2
21095000:	0080520e 	bge	zero,r2,2109514c <__sfvwrite_r+0x1e4>
21095004:	b8c00217 	ldw	r3,8(r23)
21095008:	98a7883a 	add	r19,r19,r2
2109500c:	90a5c83a 	sub	r18,r18,r2
21095010:	1885c83a 	sub	r2,r3,r2
21095014:	b8800215 	stw	r2,8(r23)
21095018:	103fef1e 	bne	r2,zero,21094fd8 <__flash_rwdata_start+0xffff2d90>
2109501c:	0005883a 	mov	r2,zero
21095020:	dfc00b17 	ldw	ra,44(sp)
21095024:	df000a17 	ldw	fp,40(sp)
21095028:	ddc00917 	ldw	r23,36(sp)
2109502c:	dd800817 	ldw	r22,32(sp)
21095030:	dd400717 	ldw	r21,28(sp)
21095034:	dd000617 	ldw	r20,24(sp)
21095038:	dcc00517 	ldw	r19,20(sp)
2109503c:	dc800417 	ldw	r18,16(sp)
21095040:	dc400317 	ldw	r17,12(sp)
21095044:	dc000217 	ldw	r16,8(sp)
21095048:	dec00c04 	addi	sp,sp,48
2109504c:	f800283a 	ret
21095050:	a009883a 	mov	r4,r20
21095054:	800b883a 	mov	r5,r16
21095058:	10929100 	call	21092910 <__swsetup_r>
2109505c:	1000ec1e 	bne	r2,zero,21095410 <__sfvwrite_r+0x4a8>
21095060:	8100030b 	ldhu	r4,12(r16)
21095064:	bc400017 	ldw	r17,0(r23)
21095068:	2080008c 	andi	r2,r4,2
2109506c:	103fd61e 	bne	r2,zero,21094fc8 <__flash_rwdata_start+0xffff2d80>
21095070:	2080004c 	andi	r2,r4,1
21095074:	10003a1e 	bne	r2,zero,21095160 <__sfvwrite_r+0x1f8>
21095078:	0039883a 	mov	fp,zero
2109507c:	0025883a 	mov	r18,zero
21095080:	90001a26 	beq	r18,zero,210950ec <__sfvwrite_r+0x184>
21095084:	2080800c 	andi	r2,r4,512
21095088:	85800217 	ldw	r22,8(r16)
2109508c:	10007626 	beq	r2,zero,21095268 <__sfvwrite_r+0x300>
21095090:	b027883a 	mov	r19,r22
21095094:	95809436 	bltu	r18,r22,210952e8 <__sfvwrite_r+0x380>
21095098:	2081200c 	andi	r2,r4,1152
2109509c:	10009f1e 	bne	r2,zero,2109531c <__sfvwrite_r+0x3b4>
210950a0:	81000017 	ldw	r4,0(r16)
210950a4:	e00b883a 	mov	r5,fp
210950a8:	980d883a 	mov	r6,r19
210950ac:	10959300 	call	21095930 <memmove>
210950b0:	81000217 	ldw	r4,8(r16)
210950b4:	81400017 	ldw	r5,0(r16)
210950b8:	9005883a 	mov	r2,r18
210950bc:	2587c83a 	sub	r3,r4,r22
210950c0:	2ce7883a 	add	r19,r5,r19
210950c4:	80c00215 	stw	r3,8(r16)
210950c8:	84c00015 	stw	r19,0(r16)
210950cc:	b8c00217 	ldw	r3,8(r23)
210950d0:	e0b9883a 	add	fp,fp,r2
210950d4:	90a5c83a 	sub	r18,r18,r2
210950d8:	1885c83a 	sub	r2,r3,r2
210950dc:	b8800215 	stw	r2,8(r23)
210950e0:	103fce26 	beq	r2,zero,2109501c <__flash_rwdata_start+0xffff2dd4>
210950e4:	8100030b 	ldhu	r4,12(r16)
210950e8:	903fe61e 	bne	r18,zero,21095084 <__flash_rwdata_start+0xffff2e3c>
210950ec:	8f000017 	ldw	fp,0(r17)
210950f0:	8c800117 	ldw	r18,4(r17)
210950f4:	8c400204 	addi	r17,r17,8
210950f8:	003fe106 	br	21095080 <__flash_rwdata_start+0xffff2e38>
210950fc:	8cc00017 	ldw	r19,0(r17)
21095100:	8c800117 	ldw	r18,4(r17)
21095104:	8c400204 	addi	r17,r17,8
21095108:	003fb306 	br	21094fd8 <__flash_rwdata_start+0xffff2d90>
2109510c:	0005883a 	mov	r2,zero
21095110:	f800283a 	ret
21095114:	00a00034 	movhi	r2,32768
21095118:	10bfffc4 	addi	r2,r2,-1
2109511c:	9009883a 	mov	r4,r18
21095120:	1480012e 	bgeu	r2,r18,21095128 <__sfvwrite_r+0x1c0>
21095124:	1009883a 	mov	r4,r2
21095128:	980b883a 	mov	r5,r19
2109512c:	108d4c80 	call	2108d4c8 <__divsi3>
21095130:	81400717 	ldw	r5,28(r16)
21095134:	80c00917 	ldw	r3,36(r16)
21095138:	988f383a 	mul	r7,r19,r2
2109513c:	a009883a 	mov	r4,r20
21095140:	e00d883a 	mov	r6,fp
21095144:	183ee83a 	callr	r3
21095148:	00bfe016 	blt	zero,r2,210950cc <__flash_rwdata_start+0xffff2e84>
2109514c:	8080030b 	ldhu	r2,12(r16)
21095150:	10801014 	ori	r2,r2,64
21095154:	8080030d 	sth	r2,12(r16)
21095158:	00bfffc4 	movi	r2,-1
2109515c:	003fb006 	br	21095020 <__flash_rwdata_start+0xffff2dd8>
21095160:	0027883a 	mov	r19,zero
21095164:	0011883a 	mov	r8,zero
21095168:	0039883a 	mov	fp,zero
2109516c:	0025883a 	mov	r18,zero
21095170:	90001f26 	beq	r18,zero,210951f0 <__sfvwrite_r+0x288>
21095174:	40006026 	beq	r8,zero,210952f8 <__sfvwrite_r+0x390>
21095178:	982b883a 	mov	r21,r19
2109517c:	94c0012e 	bgeu	r18,r19,21095184 <__sfvwrite_r+0x21c>
21095180:	902b883a 	mov	r21,r18
21095184:	81000017 	ldw	r4,0(r16)
21095188:	80800417 	ldw	r2,16(r16)
2109518c:	a82d883a 	mov	r22,r21
21095190:	81800217 	ldw	r6,8(r16)
21095194:	81c00517 	ldw	r7,20(r16)
21095198:	1100022e 	bgeu	r2,r4,210951a4 <__sfvwrite_r+0x23c>
2109519c:	31c7883a 	add	r3,r6,r7
210951a0:	1d401816 	blt	r3,r21,21095204 <__sfvwrite_r+0x29c>
210951a4:	a9c04416 	blt	r21,r7,210952b8 <__sfvwrite_r+0x350>
210951a8:	80800917 	ldw	r2,36(r16)
210951ac:	81400717 	ldw	r5,28(r16)
210951b0:	a009883a 	mov	r4,r20
210951b4:	da000115 	stw	r8,4(sp)
210951b8:	e00d883a 	mov	r6,fp
210951bc:	103ee83a 	callr	r2
210951c0:	102d883a 	mov	r22,r2
210951c4:	da000117 	ldw	r8,4(sp)
210951c8:	00bfe00e 	bge	zero,r2,2109514c <__flash_rwdata_start+0xffff2f04>
210951cc:	9da7c83a 	sub	r19,r19,r22
210951d0:	98001f26 	beq	r19,zero,21095250 <__sfvwrite_r+0x2e8>
210951d4:	b8800217 	ldw	r2,8(r23)
210951d8:	e5b9883a 	add	fp,fp,r22
210951dc:	95a5c83a 	sub	r18,r18,r22
210951e0:	15adc83a 	sub	r22,r2,r22
210951e4:	bd800215 	stw	r22,8(r23)
210951e8:	b03f8c26 	beq	r22,zero,2109501c <__flash_rwdata_start+0xffff2dd4>
210951ec:	903fe11e 	bne	r18,zero,21095174 <__flash_rwdata_start+0xffff2f2c>
210951f0:	8f000017 	ldw	fp,0(r17)
210951f4:	8c800117 	ldw	r18,4(r17)
210951f8:	0011883a 	mov	r8,zero
210951fc:	8c400204 	addi	r17,r17,8
21095200:	003fdb06 	br	21095170 <__flash_rwdata_start+0xffff2f28>
21095204:	180d883a 	mov	r6,r3
21095208:	e00b883a 	mov	r5,fp
2109520c:	da000115 	stw	r8,4(sp)
21095210:	d8c00015 	stw	r3,0(sp)
21095214:	10959300 	call	21095930 <memmove>
21095218:	d8c00017 	ldw	r3,0(sp)
2109521c:	80800017 	ldw	r2,0(r16)
21095220:	a009883a 	mov	r4,r20
21095224:	800b883a 	mov	r5,r16
21095228:	10c5883a 	add	r2,r2,r3
2109522c:	80800015 	stw	r2,0(r16)
21095230:	d8c00015 	stw	r3,0(sp)
21095234:	10947280 	call	21094728 <_fflush_r>
21095238:	d8c00017 	ldw	r3,0(sp)
2109523c:	da000117 	ldw	r8,4(sp)
21095240:	103fc21e 	bne	r2,zero,2109514c <__flash_rwdata_start+0xffff2f04>
21095244:	182d883a 	mov	r22,r3
21095248:	9da7c83a 	sub	r19,r19,r22
2109524c:	983fe11e 	bne	r19,zero,210951d4 <__flash_rwdata_start+0xffff2f8c>
21095250:	a009883a 	mov	r4,r20
21095254:	800b883a 	mov	r5,r16
21095258:	10947280 	call	21094728 <_fflush_r>
2109525c:	103fbb1e 	bne	r2,zero,2109514c <__flash_rwdata_start+0xffff2f04>
21095260:	0011883a 	mov	r8,zero
21095264:	003fdb06 	br	210951d4 <__flash_rwdata_start+0xffff2f8c>
21095268:	81000017 	ldw	r4,0(r16)
2109526c:	80800417 	ldw	r2,16(r16)
21095270:	11000236 	bltu	r2,r4,2109527c <__sfvwrite_r+0x314>
21095274:	84c00517 	ldw	r19,20(r16)
21095278:	94ffa62e 	bgeu	r18,r19,21095114 <__flash_rwdata_start+0xffff2ecc>
2109527c:	9027883a 	mov	r19,r18
21095280:	b480012e 	bgeu	r22,r18,21095288 <__sfvwrite_r+0x320>
21095284:	b027883a 	mov	r19,r22
21095288:	e00b883a 	mov	r5,fp
2109528c:	980d883a 	mov	r6,r19
21095290:	10959300 	call	21095930 <memmove>
21095294:	80800217 	ldw	r2,8(r16)
21095298:	80c00017 	ldw	r3,0(r16)
2109529c:	14c5c83a 	sub	r2,r2,r19
210952a0:	1cc7883a 	add	r3,r3,r19
210952a4:	80800215 	stw	r2,8(r16)
210952a8:	80c00015 	stw	r3,0(r16)
210952ac:	10004326 	beq	r2,zero,210953bc <__sfvwrite_r+0x454>
210952b0:	9805883a 	mov	r2,r19
210952b4:	003f8506 	br	210950cc <__flash_rwdata_start+0xffff2e84>
210952b8:	a80d883a 	mov	r6,r21
210952bc:	e00b883a 	mov	r5,fp
210952c0:	da000115 	stw	r8,4(sp)
210952c4:	10959300 	call	21095930 <memmove>
210952c8:	80800217 	ldw	r2,8(r16)
210952cc:	80c00017 	ldw	r3,0(r16)
210952d0:	da000117 	ldw	r8,4(sp)
210952d4:	1545c83a 	sub	r2,r2,r21
210952d8:	1d6b883a 	add	r21,r3,r21
210952dc:	80800215 	stw	r2,8(r16)
210952e0:	85400015 	stw	r21,0(r16)
210952e4:	003fb906 	br	210951cc <__flash_rwdata_start+0xffff2f84>
210952e8:	81000017 	ldw	r4,0(r16)
210952ec:	902d883a 	mov	r22,r18
210952f0:	9027883a 	mov	r19,r18
210952f4:	003f6b06 	br	210950a4 <__flash_rwdata_start+0xffff2e5c>
210952f8:	e009883a 	mov	r4,fp
210952fc:	01400284 	movi	r5,10
21095300:	900d883a 	mov	r6,r18
21095304:	10958480 	call	21095848 <memchr>
21095308:	10003e26 	beq	r2,zero,21095404 <__sfvwrite_r+0x49c>
2109530c:	10800044 	addi	r2,r2,1
21095310:	1727c83a 	sub	r19,r2,fp
21095314:	02000044 	movi	r8,1
21095318:	003f9706 	br	21095178 <__flash_rwdata_start+0xffff2f30>
2109531c:	80800517 	ldw	r2,20(r16)
21095320:	81400417 	ldw	r5,16(r16)
21095324:	80c00017 	ldw	r3,0(r16)
21095328:	10a7883a 	add	r19,r2,r2
2109532c:	9885883a 	add	r2,r19,r2
21095330:	1026d7fa 	srli	r19,r2,31
21095334:	196bc83a 	sub	r21,r3,r5
21095338:	a9800044 	addi	r6,r21,1
2109533c:	9885883a 	add	r2,r19,r2
21095340:	1027d07a 	srai	r19,r2,1
21095344:	3485883a 	add	r2,r6,r18
21095348:	980d883a 	mov	r6,r19
2109534c:	9880022e 	bgeu	r19,r2,21095358 <__sfvwrite_r+0x3f0>
21095350:	1027883a 	mov	r19,r2
21095354:	100d883a 	mov	r6,r2
21095358:	2101000c 	andi	r4,r4,1024
2109535c:	20001c26 	beq	r4,zero,210953d0 <__sfvwrite_r+0x468>
21095360:	a009883a 	mov	r4,r20
21095364:	300b883a 	mov	r5,r6
21095368:	108d9100 	call	2108d910 <_malloc_r>
2109536c:	102d883a 	mov	r22,r2
21095370:	10002926 	beq	r2,zero,21095418 <__sfvwrite_r+0x4b0>
21095374:	81400417 	ldw	r5,16(r16)
21095378:	1009883a 	mov	r4,r2
2109537c:	a80d883a 	mov	r6,r21
21095380:	108e1340 	call	2108e134 <memcpy>
21095384:	8080030b 	ldhu	r2,12(r16)
21095388:	00fedfc4 	movi	r3,-1153
2109538c:	10c4703a 	and	r2,r2,r3
21095390:	10802014 	ori	r2,r2,128
21095394:	8080030d 	sth	r2,12(r16)
21095398:	b549883a 	add	r4,r22,r21
2109539c:	9d4bc83a 	sub	r5,r19,r21
210953a0:	85800415 	stw	r22,16(r16)
210953a4:	84c00515 	stw	r19,20(r16)
210953a8:	81000015 	stw	r4,0(r16)
210953ac:	902d883a 	mov	r22,r18
210953b0:	81400215 	stw	r5,8(r16)
210953b4:	9027883a 	mov	r19,r18
210953b8:	003f3a06 	br	210950a4 <__flash_rwdata_start+0xffff2e5c>
210953bc:	a009883a 	mov	r4,r20
210953c0:	800b883a 	mov	r5,r16
210953c4:	10947280 	call	21094728 <_fflush_r>
210953c8:	103fb926 	beq	r2,zero,210952b0 <__flash_rwdata_start+0xffff3068>
210953cc:	003f5f06 	br	2109514c <__flash_rwdata_start+0xffff2f04>
210953d0:	a009883a 	mov	r4,r20
210953d4:	1096b980 	call	21096b98 <_realloc_r>
210953d8:	102d883a 	mov	r22,r2
210953dc:	103fee1e 	bne	r2,zero,21095398 <__flash_rwdata_start+0xffff3150>
210953e0:	81400417 	ldw	r5,16(r16)
210953e4:	a009883a 	mov	r4,r20
210953e8:	1094c780 	call	21094c78 <_free_r>
210953ec:	8080030b 	ldhu	r2,12(r16)
210953f0:	00ffdfc4 	movi	r3,-129
210953f4:	1884703a 	and	r2,r3,r2
210953f8:	00c00304 	movi	r3,12
210953fc:	a0c00015 	stw	r3,0(r20)
21095400:	003f5306 	br	21095150 <__flash_rwdata_start+0xffff2f08>
21095404:	94c00044 	addi	r19,r18,1
21095408:	02000044 	movi	r8,1
2109540c:	003f5a06 	br	21095178 <__flash_rwdata_start+0xffff2f30>
21095410:	00bfffc4 	movi	r2,-1
21095414:	003f0206 	br	21095020 <__flash_rwdata_start+0xffff2dd8>
21095418:	00800304 	movi	r2,12
2109541c:	a0800015 	stw	r2,0(r20)
21095420:	8080030b 	ldhu	r2,12(r16)
21095424:	003f4a06 	br	21095150 <__flash_rwdata_start+0xffff2f08>

21095428 <_fwalk>:
21095428:	defff704 	addi	sp,sp,-36
2109542c:	dd000415 	stw	r20,16(sp)
21095430:	dfc00815 	stw	ra,32(sp)
21095434:	ddc00715 	stw	r23,28(sp)
21095438:	dd800615 	stw	r22,24(sp)
2109543c:	dd400515 	stw	r21,20(sp)
21095440:	dcc00315 	stw	r19,12(sp)
21095444:	dc800215 	stw	r18,8(sp)
21095448:	dc400115 	stw	r17,4(sp)
2109544c:	dc000015 	stw	r16,0(sp)
21095450:	2500b804 	addi	r20,r4,736
21095454:	a0002326 	beq	r20,zero,210954e4 <_fwalk+0xbc>
21095458:	282b883a 	mov	r21,r5
2109545c:	002f883a 	mov	r23,zero
21095460:	05800044 	movi	r22,1
21095464:	04ffffc4 	movi	r19,-1
21095468:	a4400117 	ldw	r17,4(r20)
2109546c:	a4800217 	ldw	r18,8(r20)
21095470:	8c7fffc4 	addi	r17,r17,-1
21095474:	88000d16 	blt	r17,zero,210954ac <_fwalk+0x84>
21095478:	94000304 	addi	r16,r18,12
2109547c:	94800384 	addi	r18,r18,14
21095480:	80c0000b 	ldhu	r3,0(r16)
21095484:	8c7fffc4 	addi	r17,r17,-1
21095488:	813ffd04 	addi	r4,r16,-12
2109548c:	b0c0042e 	bgeu	r22,r3,210954a0 <_fwalk+0x78>
21095490:	90c0000f 	ldh	r3,0(r18)
21095494:	1cc00226 	beq	r3,r19,210954a0 <_fwalk+0x78>
21095498:	a83ee83a 	callr	r21
2109549c:	b8aeb03a 	or	r23,r23,r2
210954a0:	84001a04 	addi	r16,r16,104
210954a4:	94801a04 	addi	r18,r18,104
210954a8:	8cfff51e 	bne	r17,r19,21095480 <__flash_rwdata_start+0xffff3238>
210954ac:	a5000017 	ldw	r20,0(r20)
210954b0:	a03fed1e 	bne	r20,zero,21095468 <__flash_rwdata_start+0xffff3220>
210954b4:	b805883a 	mov	r2,r23
210954b8:	dfc00817 	ldw	ra,32(sp)
210954bc:	ddc00717 	ldw	r23,28(sp)
210954c0:	dd800617 	ldw	r22,24(sp)
210954c4:	dd400517 	ldw	r21,20(sp)
210954c8:	dd000417 	ldw	r20,16(sp)
210954cc:	dcc00317 	ldw	r19,12(sp)
210954d0:	dc800217 	ldw	r18,8(sp)
210954d4:	dc400117 	ldw	r17,4(sp)
210954d8:	dc000017 	ldw	r16,0(sp)
210954dc:	dec00904 	addi	sp,sp,36
210954e0:	f800283a 	ret
210954e4:	002f883a 	mov	r23,zero
210954e8:	003ff206 	br	210954b4 <__flash_rwdata_start+0xffff326c>

210954ec <_fwalk_reent>:
210954ec:	defff704 	addi	sp,sp,-36
210954f0:	dd400515 	stw	r21,20(sp)
210954f4:	dfc00815 	stw	ra,32(sp)
210954f8:	ddc00715 	stw	r23,28(sp)
210954fc:	dd800615 	stw	r22,24(sp)
21095500:	dd000415 	stw	r20,16(sp)
21095504:	dcc00315 	stw	r19,12(sp)
21095508:	dc800215 	stw	r18,8(sp)
2109550c:	dc400115 	stw	r17,4(sp)
21095510:	dc000015 	stw	r16,0(sp)
21095514:	2540b804 	addi	r21,r4,736
21095518:	a8002326 	beq	r21,zero,210955a8 <_fwalk_reent+0xbc>
2109551c:	2829883a 	mov	r20,r5
21095520:	202d883a 	mov	r22,r4
21095524:	002f883a 	mov	r23,zero
21095528:	04c00044 	movi	r19,1
2109552c:	04bfffc4 	movi	r18,-1
21095530:	ac400117 	ldw	r17,4(r21)
21095534:	ac000217 	ldw	r16,8(r21)
21095538:	8c7fffc4 	addi	r17,r17,-1
2109553c:	88000c16 	blt	r17,zero,21095570 <_fwalk_reent+0x84>
21095540:	84000304 	addi	r16,r16,12
21095544:	80c0000b 	ldhu	r3,0(r16)
21095548:	8c7fffc4 	addi	r17,r17,-1
2109554c:	817ffd04 	addi	r5,r16,-12
21095550:	98c0052e 	bgeu	r19,r3,21095568 <_fwalk_reent+0x7c>
21095554:	80c0008f 	ldh	r3,2(r16)
21095558:	b009883a 	mov	r4,r22
2109555c:	1c800226 	beq	r3,r18,21095568 <_fwalk_reent+0x7c>
21095560:	a03ee83a 	callr	r20
21095564:	b8aeb03a 	or	r23,r23,r2
21095568:	84001a04 	addi	r16,r16,104
2109556c:	8cbff51e 	bne	r17,r18,21095544 <__flash_rwdata_start+0xffff32fc>
21095570:	ad400017 	ldw	r21,0(r21)
21095574:	a83fee1e 	bne	r21,zero,21095530 <__flash_rwdata_start+0xffff32e8>
21095578:	b805883a 	mov	r2,r23
2109557c:	dfc00817 	ldw	ra,32(sp)
21095580:	ddc00717 	ldw	r23,28(sp)
21095584:	dd800617 	ldw	r22,24(sp)
21095588:	dd400517 	ldw	r21,20(sp)
2109558c:	dd000417 	ldw	r20,16(sp)
21095590:	dcc00317 	ldw	r19,12(sp)
21095594:	dc800217 	ldw	r18,8(sp)
21095598:	dc400117 	ldw	r17,4(sp)
2109559c:	dc000017 	ldw	r16,0(sp)
210955a0:	dec00904 	addi	sp,sp,36
210955a4:	f800283a 	ret
210955a8:	002f883a 	mov	r23,zero
210955ac:	003ff206 	br	21095578 <__flash_rwdata_start+0xffff3330>

210955b0 <_setlocale_r>:
210955b0:	30001b26 	beq	r6,zero,21095620 <_setlocale_r+0x70>
210955b4:	01400034 	movhi	r5,0
210955b8:	defffe04 	addi	sp,sp,-8
210955bc:	294eee04 	addi	r5,r5,15288
210955c0:	3009883a 	mov	r4,r6
210955c4:	dc000015 	stw	r16,0(sp)
210955c8:	dfc00115 	stw	ra,4(sp)
210955cc:	3021883a 	mov	r16,r6
210955d0:	108e5ec0 	call	2108e5ec <strcmp>
210955d4:	1000061e 	bne	r2,zero,210955f0 <_setlocale_r+0x40>
210955d8:	00800034 	movhi	r2,0
210955dc:	10803c04 	addi	r2,r2,240
210955e0:	dfc00117 	ldw	ra,4(sp)
210955e4:	dc000017 	ldw	r16,0(sp)
210955e8:	dec00204 	addi	sp,sp,8
210955ec:	f800283a 	ret
210955f0:	01400034 	movhi	r5,0
210955f4:	29403c04 	addi	r5,r5,240
210955f8:	8009883a 	mov	r4,r16
210955fc:	108e5ec0 	call	2108e5ec <strcmp>
21095600:	103ff526 	beq	r2,zero,210955d8 <__flash_rwdata_start+0xffff3390>
21095604:	01400034 	movhi	r5,0
21095608:	29405e04 	addi	r5,r5,376
2109560c:	8009883a 	mov	r4,r16
21095610:	108e5ec0 	call	2108e5ec <strcmp>
21095614:	103ff026 	beq	r2,zero,210955d8 <__flash_rwdata_start+0xffff3390>
21095618:	0005883a 	mov	r2,zero
2109561c:	003ff006 	br	210955e0 <__flash_rwdata_start+0xffff3398>
21095620:	00800034 	movhi	r2,0
21095624:	10803c04 	addi	r2,r2,240
21095628:	f800283a 	ret

2109562c <__locale_charset>:
2109562c:	00800034 	movhi	r2,0
21095630:	10925f04 	addi	r2,r2,18812
21095634:	f800283a 	ret

21095638 <__locale_mb_cur_max>:
21095638:	00800034 	movhi	r2,0
2109563c:	10976e04 	addi	r2,r2,23992
21095640:	10800017 	ldw	r2,0(r2)
21095644:	f800283a 	ret

21095648 <__locale_msgcharset>:
21095648:	00800034 	movhi	r2,0
2109564c:	10925704 	addi	r2,r2,18780
21095650:	f800283a 	ret

21095654 <__locale_cjk_lang>:
21095654:	0005883a 	mov	r2,zero
21095658:	f800283a 	ret

2109565c <_localeconv_r>:
2109565c:	00800034 	movhi	r2,0
21095660:	10926704 	addi	r2,r2,18844
21095664:	f800283a 	ret

21095668 <setlocale>:
21095668:	00c00034 	movhi	r3,0
2109566c:	18d76b04 	addi	r3,r3,23980
21095670:	2005883a 	mov	r2,r4
21095674:	19000017 	ldw	r4,0(r3)
21095678:	280d883a 	mov	r6,r5
2109567c:	100b883a 	mov	r5,r2
21095680:	10955b01 	jmpi	210955b0 <_setlocale_r>

21095684 <localeconv>:
21095684:	00800034 	movhi	r2,0
21095688:	10926704 	addi	r2,r2,18844
2109568c:	f800283a 	ret

21095690 <__smakebuf_r>:
21095690:	2880030b 	ldhu	r2,12(r5)
21095694:	10c0008c 	andi	r3,r2,2
21095698:	1800401e 	bne	r3,zero,2109579c <__smakebuf_r+0x10c>
2109569c:	deffec04 	addi	sp,sp,-80
210956a0:	dc000f15 	stw	r16,60(sp)
210956a4:	2821883a 	mov	r16,r5
210956a8:	2940038f 	ldh	r5,14(r5)
210956ac:	dc401015 	stw	r17,64(sp)
210956b0:	dfc01315 	stw	ra,76(sp)
210956b4:	dcc01215 	stw	r19,72(sp)
210956b8:	dc801115 	stw	r18,68(sp)
210956bc:	2023883a 	mov	r17,r4
210956c0:	28001b16 	blt	r5,zero,21095730 <__smakebuf_r+0xa0>
210956c4:	d80d883a 	mov	r6,sp
210956c8:	109a0880 	call	2109a088 <_fstat_r>
210956cc:	10001716 	blt	r2,zero,2109572c <__smakebuf_r+0x9c>
210956d0:	d8800117 	ldw	r2,4(sp)
210956d4:	00e00014 	movui	r3,32768
210956d8:	10bc000c 	andi	r2,r2,61440
210956dc:	10c03726 	beq	r2,r3,210957bc <__smakebuf_r+0x12c>
210956e0:	80c0030b 	ldhu	r3,12(r16)
210956e4:	18c20014 	ori	r3,r3,2048
210956e8:	80c0030d 	sth	r3,12(r16)
210956ec:	00c80004 	movi	r3,8192
210956f0:	10c03c1e 	bne	r2,r3,210957e4 <__smakebuf_r+0x154>
210956f4:	8140038f 	ldh	r5,14(r16)
210956f8:	8809883a 	mov	r4,r17
210956fc:	109a0e00 	call	2109a0e0 <_isatty_r>
21095700:	10004e26 	beq	r2,zero,2109583c <__smakebuf_r+0x1ac>
21095704:	8080030b 	ldhu	r2,12(r16)
21095708:	04c00044 	movi	r19,1
2109570c:	80c010c4 	addi	r3,r16,67
21095710:	14c4b03a 	or	r2,r2,r19
21095714:	8080030d 	sth	r2,12(r16)
21095718:	80c00015 	stw	r3,0(r16)
2109571c:	80c00415 	stw	r3,16(r16)
21095720:	84c00515 	stw	r19,20(r16)
21095724:	04810004 	movi	r18,1024
21095728:	00000706 	br	21095748 <__smakebuf_r+0xb8>
2109572c:	8080030b 	ldhu	r2,12(r16)
21095730:	10c0200c 	andi	r3,r2,128
21095734:	18001f1e 	bne	r3,zero,210957b4 <__smakebuf_r+0x124>
21095738:	04810004 	movi	r18,1024
2109573c:	10820014 	ori	r2,r2,2048
21095740:	8080030d 	sth	r2,12(r16)
21095744:	0027883a 	mov	r19,zero
21095748:	8809883a 	mov	r4,r17
2109574c:	900b883a 	mov	r5,r18
21095750:	108d9100 	call	2108d910 <_malloc_r>
21095754:	10002e26 	beq	r2,zero,21095810 <__smakebuf_r+0x180>
21095758:	80c0030b 	ldhu	r3,12(r16)
2109575c:	01084274 	movhi	r4,8457
21095760:	2111f104 	addi	r4,r4,18372
21095764:	89000f15 	stw	r4,60(r17)
21095768:	18c02014 	ori	r3,r3,128
2109576c:	80c0030d 	sth	r3,12(r16)
21095770:	80800015 	stw	r2,0(r16)
21095774:	80800415 	stw	r2,16(r16)
21095778:	84800515 	stw	r18,20(r16)
2109577c:	98001c1e 	bne	r19,zero,210957f0 <__smakebuf_r+0x160>
21095780:	dfc01317 	ldw	ra,76(sp)
21095784:	dcc01217 	ldw	r19,72(sp)
21095788:	dc801117 	ldw	r18,68(sp)
2109578c:	dc401017 	ldw	r17,64(sp)
21095790:	dc000f17 	ldw	r16,60(sp)
21095794:	dec01404 	addi	sp,sp,80
21095798:	f800283a 	ret
2109579c:	288010c4 	addi	r2,r5,67
210957a0:	28800015 	stw	r2,0(r5)
210957a4:	28800415 	stw	r2,16(r5)
210957a8:	00800044 	movi	r2,1
210957ac:	28800515 	stw	r2,20(r5)
210957b0:	f800283a 	ret
210957b4:	04801004 	movi	r18,64
210957b8:	003fe006 	br	2109573c <__flash_rwdata_start+0xffff34f4>
210957bc:	81000a17 	ldw	r4,40(r16)
210957c0:	00c84274 	movhi	r3,8457
210957c4:	18dc9304 	addi	r3,r3,29260
210957c8:	20ffc51e 	bne	r4,r3,210956e0 <__flash_rwdata_start+0xffff3498>
210957cc:	80c0030b 	ldhu	r3,12(r16)
210957d0:	01010004 	movi	r4,1024
210957d4:	81001315 	stw	r4,76(r16)
210957d8:	1906b03a 	or	r3,r3,r4
210957dc:	80c0030d 	sth	r3,12(r16)
210957e0:	003fc206 	br	210956ec <__flash_rwdata_start+0xffff34a4>
210957e4:	0027883a 	mov	r19,zero
210957e8:	04810004 	movi	r18,1024
210957ec:	003fd606 	br	21095748 <__flash_rwdata_start+0xffff3500>
210957f0:	8140038f 	ldh	r5,14(r16)
210957f4:	8809883a 	mov	r4,r17
210957f8:	109a0e00 	call	2109a0e0 <_isatty_r>
210957fc:	103fe026 	beq	r2,zero,21095780 <__flash_rwdata_start+0xffff3538>
21095800:	8080030b 	ldhu	r2,12(r16)
21095804:	10800054 	ori	r2,r2,1
21095808:	8080030d 	sth	r2,12(r16)
2109580c:	003fdc06 	br	21095780 <__flash_rwdata_start+0xffff3538>
21095810:	8080030b 	ldhu	r2,12(r16)
21095814:	10c0800c 	andi	r3,r2,512
21095818:	183fd91e 	bne	r3,zero,21095780 <__flash_rwdata_start+0xffff3538>
2109581c:	10800094 	ori	r2,r2,2
21095820:	80c010c4 	addi	r3,r16,67
21095824:	8080030d 	sth	r2,12(r16)
21095828:	00800044 	movi	r2,1
2109582c:	80c00015 	stw	r3,0(r16)
21095830:	80c00415 	stw	r3,16(r16)
21095834:	80800515 	stw	r2,20(r16)
21095838:	003fd106 	br	21095780 <__flash_rwdata_start+0xffff3538>
2109583c:	04c00044 	movi	r19,1
21095840:	04810004 	movi	r18,1024
21095844:	003fc006 	br	21095748 <__flash_rwdata_start+0xffff3500>

21095848 <memchr>:
21095848:	208000cc 	andi	r2,r4,3
2109584c:	280f883a 	mov	r7,r5
21095850:	10003526 	beq	r2,zero,21095928 <memchr+0xe0>
21095854:	30bfffc4 	addi	r2,r6,-1
21095858:	30001b26 	beq	r6,zero,210958c8 <memchr+0x80>
2109585c:	21800003 	ldbu	r6,0(r4)
21095860:	28c03fcc 	andi	r3,r5,255
21095864:	30c01a26 	beq	r6,r3,210958d0 <memchr+0x88>
21095868:	180d883a 	mov	r6,r3
2109586c:	00000406 	br	21095880 <memchr+0x38>
21095870:	10001526 	beq	r2,zero,210958c8 <memchr+0x80>
21095874:	20c00003 	ldbu	r3,0(r4)
21095878:	10bfffc4 	addi	r2,r2,-1
2109587c:	19801426 	beq	r3,r6,210958d0 <memchr+0x88>
21095880:	21000044 	addi	r4,r4,1
21095884:	20c000cc 	andi	r3,r4,3
21095888:	183ff91e 	bne	r3,zero,21095870 <__flash_rwdata_start+0xffff3628>
2109588c:	024000c4 	movi	r9,3
21095890:	48801136 	bltu	r9,r2,210958d8 <memchr+0x90>
21095894:	10000c26 	beq	r2,zero,210958c8 <memchr+0x80>
21095898:	20c00003 	ldbu	r3,0(r4)
2109589c:	29403fcc 	andi	r5,r5,255
210958a0:	19400b26 	beq	r3,r5,210958d0 <memchr+0x88>
210958a4:	20c00044 	addi	r3,r4,1
210958a8:	2085883a 	add	r2,r4,r2
210958ac:	39803fcc 	andi	r6,r7,255
210958b0:	00000306 	br	210958c0 <memchr+0x78>
210958b4:	18c00044 	addi	r3,r3,1
210958b8:	197fffc3 	ldbu	r5,-1(r3)
210958bc:	29800426 	beq	r5,r6,210958d0 <memchr+0x88>
210958c0:	1809883a 	mov	r4,r3
210958c4:	18bffb1e 	bne	r3,r2,210958b4 <__flash_rwdata_start+0xffff366c>
210958c8:	0005883a 	mov	r2,zero
210958cc:	f800283a 	ret
210958d0:	2005883a 	mov	r2,r4
210958d4:	f800283a 	ret
210958d8:	28c03fcc 	andi	r3,r5,255
210958dc:	1810923a 	slli	r8,r3,8
210958e0:	02ffbff4 	movhi	r11,65279
210958e4:	02a02074 	movhi	r10,32897
210958e8:	40c6b03a 	or	r3,r8,r3
210958ec:	1810943a 	slli	r8,r3,16
210958f0:	5affbfc4 	addi	r11,r11,-257
210958f4:	52a02004 	addi	r10,r10,-32640
210958f8:	40d0b03a 	or	r8,r8,r3
210958fc:	20c00017 	ldw	r3,0(r4)
21095900:	40c6f03a 	xor	r3,r8,r3
21095904:	1acd883a 	add	r6,r3,r11
21095908:	00c6303a 	nor	r3,zero,r3
2109590c:	30c6703a 	and	r3,r6,r3
21095910:	1a86703a 	and	r3,r3,r10
21095914:	183fdf1e 	bne	r3,zero,21095894 <__flash_rwdata_start+0xffff364c>
21095918:	10bfff04 	addi	r2,r2,-4
2109591c:	21000104 	addi	r4,r4,4
21095920:	48bff636 	bltu	r9,r2,210958fc <__flash_rwdata_start+0xffff36b4>
21095924:	003fdb06 	br	21095894 <__flash_rwdata_start+0xffff364c>
21095928:	3005883a 	mov	r2,r6
2109592c:	003fd706 	br	2109588c <__flash_rwdata_start+0xffff3644>

21095930 <memmove>:
21095930:	2005883a 	mov	r2,r4
21095934:	29000b2e 	bgeu	r5,r4,21095964 <memmove+0x34>
21095938:	298f883a 	add	r7,r5,r6
2109593c:	21c0092e 	bgeu	r4,r7,21095964 <memmove+0x34>
21095940:	2187883a 	add	r3,r4,r6
21095944:	198bc83a 	sub	r5,r3,r6
21095948:	30004b26 	beq	r6,zero,21095a78 <memmove+0x148>
2109594c:	39ffffc4 	addi	r7,r7,-1
21095950:	39000003 	ldbu	r4,0(r7)
21095954:	18ffffc4 	addi	r3,r3,-1
21095958:	19000005 	stb	r4,0(r3)
2109595c:	197ffb1e 	bne	r3,r5,2109594c <__flash_rwdata_start+0xffff3704>
21095960:	f800283a 	ret
21095964:	00c003c4 	movi	r3,15
21095968:	1980412e 	bgeu	r3,r6,21095a70 <memmove+0x140>
2109596c:	1146b03a 	or	r3,r2,r5
21095970:	18c000cc 	andi	r3,r3,3
21095974:	1800411e 	bne	r3,zero,21095a7c <memmove+0x14c>
21095978:	33fffc04 	addi	r15,r6,-16
2109597c:	781ed13a 	srli	r15,r15,4
21095980:	28c00104 	addi	r3,r5,4
21095984:	13400104 	addi	r13,r2,4
21095988:	781c913a 	slli	r14,r15,4
2109598c:	2b000204 	addi	r12,r5,8
21095990:	12c00204 	addi	r11,r2,8
21095994:	73800504 	addi	r14,r14,20
21095998:	2a800304 	addi	r10,r5,12
2109599c:	12400304 	addi	r9,r2,12
210959a0:	2b9d883a 	add	r14,r5,r14
210959a4:	2811883a 	mov	r8,r5
210959a8:	100f883a 	mov	r7,r2
210959ac:	41000017 	ldw	r4,0(r8)
210959b0:	39c00404 	addi	r7,r7,16
210959b4:	18c00404 	addi	r3,r3,16
210959b8:	393ffc15 	stw	r4,-16(r7)
210959bc:	193ffc17 	ldw	r4,-16(r3)
210959c0:	6b400404 	addi	r13,r13,16
210959c4:	5ac00404 	addi	r11,r11,16
210959c8:	693ffc15 	stw	r4,-16(r13)
210959cc:	61000017 	ldw	r4,0(r12)
210959d0:	4a400404 	addi	r9,r9,16
210959d4:	42000404 	addi	r8,r8,16
210959d8:	593ffc15 	stw	r4,-16(r11)
210959dc:	51000017 	ldw	r4,0(r10)
210959e0:	63000404 	addi	r12,r12,16
210959e4:	52800404 	addi	r10,r10,16
210959e8:	493ffc15 	stw	r4,-16(r9)
210959ec:	1bbfef1e 	bne	r3,r14,210959ac <__flash_rwdata_start+0xffff3764>
210959f0:	79000044 	addi	r4,r15,1
210959f4:	2008913a 	slli	r4,r4,4
210959f8:	328003cc 	andi	r10,r6,15
210959fc:	02c000c4 	movi	r11,3
21095a00:	1107883a 	add	r3,r2,r4
21095a04:	290b883a 	add	r5,r5,r4
21095a08:	5a801e2e 	bgeu	r11,r10,21095a84 <memmove+0x154>
21095a0c:	1813883a 	mov	r9,r3
21095a10:	2811883a 	mov	r8,r5
21095a14:	500f883a 	mov	r7,r10
21095a18:	41000017 	ldw	r4,0(r8)
21095a1c:	4a400104 	addi	r9,r9,4
21095a20:	39ffff04 	addi	r7,r7,-4
21095a24:	493fff15 	stw	r4,-4(r9)
21095a28:	42000104 	addi	r8,r8,4
21095a2c:	59fffa36 	bltu	r11,r7,21095a18 <__flash_rwdata_start+0xffff37d0>
21095a30:	513fff04 	addi	r4,r10,-4
21095a34:	2008d0ba 	srli	r4,r4,2
21095a38:	318000cc 	andi	r6,r6,3
21095a3c:	21000044 	addi	r4,r4,1
21095a40:	2109883a 	add	r4,r4,r4
21095a44:	2109883a 	add	r4,r4,r4
21095a48:	1907883a 	add	r3,r3,r4
21095a4c:	290b883a 	add	r5,r5,r4
21095a50:	30000926 	beq	r6,zero,21095a78 <memmove+0x148>
21095a54:	198d883a 	add	r6,r3,r6
21095a58:	29c00003 	ldbu	r7,0(r5)
21095a5c:	18c00044 	addi	r3,r3,1
21095a60:	29400044 	addi	r5,r5,1
21095a64:	19ffffc5 	stb	r7,-1(r3)
21095a68:	19bffb1e 	bne	r3,r6,21095a58 <__flash_rwdata_start+0xffff3810>
21095a6c:	f800283a 	ret
21095a70:	1007883a 	mov	r3,r2
21095a74:	003ff606 	br	21095a50 <__flash_rwdata_start+0xffff3808>
21095a78:	f800283a 	ret
21095a7c:	1007883a 	mov	r3,r2
21095a80:	003ff406 	br	21095a54 <__flash_rwdata_start+0xffff380c>
21095a84:	500d883a 	mov	r6,r10
21095a88:	003ff106 	br	21095a50 <__flash_rwdata_start+0xffff3808>

21095a8c <_Balloc>:
21095a8c:	20801317 	ldw	r2,76(r4)
21095a90:	defffc04 	addi	sp,sp,-16
21095a94:	dc400115 	stw	r17,4(sp)
21095a98:	dc000015 	stw	r16,0(sp)
21095a9c:	dfc00315 	stw	ra,12(sp)
21095aa0:	dc800215 	stw	r18,8(sp)
21095aa4:	2023883a 	mov	r17,r4
21095aa8:	2821883a 	mov	r16,r5
21095aac:	10000f26 	beq	r2,zero,21095aec <_Balloc+0x60>
21095ab0:	8407883a 	add	r3,r16,r16
21095ab4:	18c7883a 	add	r3,r3,r3
21095ab8:	10c7883a 	add	r3,r2,r3
21095abc:	18800017 	ldw	r2,0(r3)
21095ac0:	10001126 	beq	r2,zero,21095b08 <_Balloc+0x7c>
21095ac4:	11000017 	ldw	r4,0(r2)
21095ac8:	19000015 	stw	r4,0(r3)
21095acc:	10000415 	stw	zero,16(r2)
21095ad0:	10000315 	stw	zero,12(r2)
21095ad4:	dfc00317 	ldw	ra,12(sp)
21095ad8:	dc800217 	ldw	r18,8(sp)
21095adc:	dc400117 	ldw	r17,4(sp)
21095ae0:	dc000017 	ldw	r16,0(sp)
21095ae4:	dec00404 	addi	sp,sp,16
21095ae8:	f800283a 	ret
21095aec:	01400104 	movi	r5,4
21095af0:	01800844 	movi	r6,33
21095af4:	1099ce00 	call	21099ce0 <_calloc_r>
21095af8:	88801315 	stw	r2,76(r17)
21095afc:	103fec1e 	bne	r2,zero,21095ab0 <__flash_rwdata_start+0xffff3868>
21095b00:	0005883a 	mov	r2,zero
21095b04:	003ff306 	br	21095ad4 <__flash_rwdata_start+0xffff388c>
21095b08:	01400044 	movi	r5,1
21095b0c:	2c24983a 	sll	r18,r5,r16
21095b10:	8809883a 	mov	r4,r17
21095b14:	91800144 	addi	r6,r18,5
21095b18:	318d883a 	add	r6,r6,r6
21095b1c:	318d883a 	add	r6,r6,r6
21095b20:	1099ce00 	call	21099ce0 <_calloc_r>
21095b24:	103ff626 	beq	r2,zero,21095b00 <__flash_rwdata_start+0xffff38b8>
21095b28:	14000115 	stw	r16,4(r2)
21095b2c:	14800215 	stw	r18,8(r2)
21095b30:	003fe606 	br	21095acc <__flash_rwdata_start+0xffff3884>

21095b34 <_Bfree>:
21095b34:	28000826 	beq	r5,zero,21095b58 <_Bfree+0x24>
21095b38:	28c00117 	ldw	r3,4(r5)
21095b3c:	20801317 	ldw	r2,76(r4)
21095b40:	18c7883a 	add	r3,r3,r3
21095b44:	18c7883a 	add	r3,r3,r3
21095b48:	10c5883a 	add	r2,r2,r3
21095b4c:	10c00017 	ldw	r3,0(r2)
21095b50:	28c00015 	stw	r3,0(r5)
21095b54:	11400015 	stw	r5,0(r2)
21095b58:	f800283a 	ret

21095b5c <__multadd>:
21095b5c:	defffa04 	addi	sp,sp,-24
21095b60:	dc000115 	stw	r16,4(sp)
21095b64:	2c000417 	ldw	r16,16(r5)
21095b68:	dc800315 	stw	r18,12(sp)
21095b6c:	dc400215 	stw	r17,8(sp)
21095b70:	dfc00515 	stw	ra,20(sp)
21095b74:	dcc00415 	stw	r19,16(sp)
21095b78:	2823883a 	mov	r17,r5
21095b7c:	2025883a 	mov	r18,r4
21095b80:	2a400504 	addi	r9,r5,20
21095b84:	0015883a 	mov	r10,zero
21095b88:	4a000017 	ldw	r8,0(r9)
21095b8c:	4a400104 	addi	r9,r9,4
21095b90:	52800044 	addi	r10,r10,1
21095b94:	40ffffcc 	andi	r3,r8,65535
21095b98:	1987383a 	mul	r3,r3,r6
21095b9c:	4010d43a 	srli	r8,r8,16
21095ba0:	19cf883a 	add	r7,r3,r7
21095ba4:	4191383a 	mul	r8,r8,r6
21095ba8:	3816d43a 	srli	r11,r7,16
21095bac:	38ffffcc 	andi	r3,r7,65535
21095bb0:	5a0f883a 	add	r7,r11,r8
21095bb4:	3810943a 	slli	r8,r7,16
21095bb8:	380ed43a 	srli	r7,r7,16
21095bbc:	40c7883a 	add	r3,r8,r3
21095bc0:	48ffff15 	stw	r3,-4(r9)
21095bc4:	543ff016 	blt	r10,r16,21095b88 <__flash_rwdata_start+0xffff3940>
21095bc8:	38000926 	beq	r7,zero,21095bf0 <__multadd+0x94>
21095bcc:	88800217 	ldw	r2,8(r17)
21095bd0:	80800f0e 	bge	r16,r2,21095c10 <__multadd+0xb4>
21095bd4:	80800144 	addi	r2,r16,5
21095bd8:	1085883a 	add	r2,r2,r2
21095bdc:	1085883a 	add	r2,r2,r2
21095be0:	8885883a 	add	r2,r17,r2
21095be4:	11c00015 	stw	r7,0(r2)
21095be8:	84000044 	addi	r16,r16,1
21095bec:	8c000415 	stw	r16,16(r17)
21095bf0:	8805883a 	mov	r2,r17
21095bf4:	dfc00517 	ldw	ra,20(sp)
21095bf8:	dcc00417 	ldw	r19,16(sp)
21095bfc:	dc800317 	ldw	r18,12(sp)
21095c00:	dc400217 	ldw	r17,8(sp)
21095c04:	dc000117 	ldw	r16,4(sp)
21095c08:	dec00604 	addi	sp,sp,24
21095c0c:	f800283a 	ret
21095c10:	89400117 	ldw	r5,4(r17)
21095c14:	9009883a 	mov	r4,r18
21095c18:	d9c00015 	stw	r7,0(sp)
21095c1c:	29400044 	addi	r5,r5,1
21095c20:	1095a8c0 	call	21095a8c <_Balloc>
21095c24:	89800417 	ldw	r6,16(r17)
21095c28:	11000304 	addi	r4,r2,12
21095c2c:	89400304 	addi	r5,r17,12
21095c30:	31800084 	addi	r6,r6,2
21095c34:	318d883a 	add	r6,r6,r6
21095c38:	318d883a 	add	r6,r6,r6
21095c3c:	1027883a 	mov	r19,r2
21095c40:	108e1340 	call	2108e134 <memcpy>
21095c44:	d9c00017 	ldw	r7,0(sp)
21095c48:	88000a26 	beq	r17,zero,21095c74 <__multadd+0x118>
21095c4c:	89000117 	ldw	r4,4(r17)
21095c50:	90c01317 	ldw	r3,76(r18)
21095c54:	2109883a 	add	r4,r4,r4
21095c58:	2109883a 	add	r4,r4,r4
21095c5c:	1907883a 	add	r3,r3,r4
21095c60:	18800017 	ldw	r2,0(r3)
21095c64:	88800015 	stw	r2,0(r17)
21095c68:	1c400015 	stw	r17,0(r3)
21095c6c:	9823883a 	mov	r17,r19
21095c70:	003fd806 	br	21095bd4 <__flash_rwdata_start+0xffff398c>
21095c74:	9823883a 	mov	r17,r19
21095c78:	003fd606 	br	21095bd4 <__flash_rwdata_start+0xffff398c>

21095c7c <__s2b>:
21095c7c:	defff904 	addi	sp,sp,-28
21095c80:	dc400115 	stw	r17,4(sp)
21095c84:	dc000015 	stw	r16,0(sp)
21095c88:	2023883a 	mov	r17,r4
21095c8c:	2821883a 	mov	r16,r5
21095c90:	39000204 	addi	r4,r7,8
21095c94:	01400244 	movi	r5,9
21095c98:	dcc00315 	stw	r19,12(sp)
21095c9c:	dc800215 	stw	r18,8(sp)
21095ca0:	dfc00615 	stw	ra,24(sp)
21095ca4:	dd400515 	stw	r21,20(sp)
21095ca8:	dd000415 	stw	r20,16(sp)
21095cac:	3825883a 	mov	r18,r7
21095cb0:	3027883a 	mov	r19,r6
21095cb4:	108d4c80 	call	2108d4c8 <__divsi3>
21095cb8:	00c00044 	movi	r3,1
21095cbc:	000b883a 	mov	r5,zero
21095cc0:	1880030e 	bge	r3,r2,21095cd0 <__s2b+0x54>
21095cc4:	18c7883a 	add	r3,r3,r3
21095cc8:	29400044 	addi	r5,r5,1
21095ccc:	18bffd16 	blt	r3,r2,21095cc4 <__flash_rwdata_start+0xffff3a7c>
21095cd0:	8809883a 	mov	r4,r17
21095cd4:	1095a8c0 	call	21095a8c <_Balloc>
21095cd8:	d8c00717 	ldw	r3,28(sp)
21095cdc:	10c00515 	stw	r3,20(r2)
21095ce0:	00c00044 	movi	r3,1
21095ce4:	10c00415 	stw	r3,16(r2)
21095ce8:	00c00244 	movi	r3,9
21095cec:	1cc0210e 	bge	r3,r19,21095d74 <__s2b+0xf8>
21095cf0:	80eb883a 	add	r21,r16,r3
21095cf4:	a829883a 	mov	r20,r21
21095cf8:	84e1883a 	add	r16,r16,r19
21095cfc:	a1c00007 	ldb	r7,0(r20)
21095d00:	8809883a 	mov	r4,r17
21095d04:	a5000044 	addi	r20,r20,1
21095d08:	100b883a 	mov	r5,r2
21095d0c:	01800284 	movi	r6,10
21095d10:	39fff404 	addi	r7,r7,-48
21095d14:	1095b5c0 	call	21095b5c <__multadd>
21095d18:	a43ff81e 	bne	r20,r16,21095cfc <__flash_rwdata_start+0xffff3ab4>
21095d1c:	ace1883a 	add	r16,r21,r19
21095d20:	843ffe04 	addi	r16,r16,-8
21095d24:	9c800a0e 	bge	r19,r18,21095d50 <__s2b+0xd4>
21095d28:	94e5c83a 	sub	r18,r18,r19
21095d2c:	84a5883a 	add	r18,r16,r18
21095d30:	81c00007 	ldb	r7,0(r16)
21095d34:	8809883a 	mov	r4,r17
21095d38:	84000044 	addi	r16,r16,1
21095d3c:	100b883a 	mov	r5,r2
21095d40:	01800284 	movi	r6,10
21095d44:	39fff404 	addi	r7,r7,-48
21095d48:	1095b5c0 	call	21095b5c <__multadd>
21095d4c:	84bff81e 	bne	r16,r18,21095d30 <__flash_rwdata_start+0xffff3ae8>
21095d50:	dfc00617 	ldw	ra,24(sp)
21095d54:	dd400517 	ldw	r21,20(sp)
21095d58:	dd000417 	ldw	r20,16(sp)
21095d5c:	dcc00317 	ldw	r19,12(sp)
21095d60:	dc800217 	ldw	r18,8(sp)
21095d64:	dc400117 	ldw	r17,4(sp)
21095d68:	dc000017 	ldw	r16,0(sp)
21095d6c:	dec00704 	addi	sp,sp,28
21095d70:	f800283a 	ret
21095d74:	84000284 	addi	r16,r16,10
21095d78:	1827883a 	mov	r19,r3
21095d7c:	003fe906 	br	21095d24 <__flash_rwdata_start+0xffff3adc>

21095d80 <__hi0bits>:
21095d80:	20bfffec 	andhi	r2,r4,65535
21095d84:	1000141e 	bne	r2,zero,21095dd8 <__hi0bits+0x58>
21095d88:	2008943a 	slli	r4,r4,16
21095d8c:	00800404 	movi	r2,16
21095d90:	20ffc02c 	andhi	r3,r4,65280
21095d94:	1800021e 	bne	r3,zero,21095da0 <__hi0bits+0x20>
21095d98:	2008923a 	slli	r4,r4,8
21095d9c:	10800204 	addi	r2,r2,8
21095da0:	20fc002c 	andhi	r3,r4,61440
21095da4:	1800021e 	bne	r3,zero,21095db0 <__hi0bits+0x30>
21095da8:	2008913a 	slli	r4,r4,4
21095dac:	10800104 	addi	r2,r2,4
21095db0:	20f0002c 	andhi	r3,r4,49152
21095db4:	1800031e 	bne	r3,zero,21095dc4 <__hi0bits+0x44>
21095db8:	2109883a 	add	r4,r4,r4
21095dbc:	10800084 	addi	r2,r2,2
21095dc0:	2109883a 	add	r4,r4,r4
21095dc4:	20000316 	blt	r4,zero,21095dd4 <__hi0bits+0x54>
21095dc8:	2110002c 	andhi	r4,r4,16384
21095dcc:	2000041e 	bne	r4,zero,21095de0 <__hi0bits+0x60>
21095dd0:	00800804 	movi	r2,32
21095dd4:	f800283a 	ret
21095dd8:	0005883a 	mov	r2,zero
21095ddc:	003fec06 	br	21095d90 <__flash_rwdata_start+0xffff3b48>
21095de0:	10800044 	addi	r2,r2,1
21095de4:	f800283a 	ret

21095de8 <__lo0bits>:
21095de8:	20c00017 	ldw	r3,0(r4)
21095dec:	188001cc 	andi	r2,r3,7
21095df0:	10000826 	beq	r2,zero,21095e14 <__lo0bits+0x2c>
21095df4:	1880004c 	andi	r2,r3,1
21095df8:	1000211e 	bne	r2,zero,21095e80 <__lo0bits+0x98>
21095dfc:	1880008c 	andi	r2,r3,2
21095e00:	1000211e 	bne	r2,zero,21095e88 <__lo0bits+0xa0>
21095e04:	1806d0ba 	srli	r3,r3,2
21095e08:	00800084 	movi	r2,2
21095e0c:	20c00015 	stw	r3,0(r4)
21095e10:	f800283a 	ret
21095e14:	18bfffcc 	andi	r2,r3,65535
21095e18:	10001326 	beq	r2,zero,21095e68 <__lo0bits+0x80>
21095e1c:	0005883a 	mov	r2,zero
21095e20:	19403fcc 	andi	r5,r3,255
21095e24:	2800021e 	bne	r5,zero,21095e30 <__lo0bits+0x48>
21095e28:	1806d23a 	srli	r3,r3,8
21095e2c:	10800204 	addi	r2,r2,8
21095e30:	194003cc 	andi	r5,r3,15
21095e34:	2800021e 	bne	r5,zero,21095e40 <__lo0bits+0x58>
21095e38:	1806d13a 	srli	r3,r3,4
21095e3c:	10800104 	addi	r2,r2,4
21095e40:	194000cc 	andi	r5,r3,3
21095e44:	2800021e 	bne	r5,zero,21095e50 <__lo0bits+0x68>
21095e48:	1806d0ba 	srli	r3,r3,2
21095e4c:	10800084 	addi	r2,r2,2
21095e50:	1940004c 	andi	r5,r3,1
21095e54:	2800081e 	bne	r5,zero,21095e78 <__lo0bits+0x90>
21095e58:	1806d07a 	srli	r3,r3,1
21095e5c:	1800051e 	bne	r3,zero,21095e74 <__lo0bits+0x8c>
21095e60:	00800804 	movi	r2,32
21095e64:	f800283a 	ret
21095e68:	1806d43a 	srli	r3,r3,16
21095e6c:	00800404 	movi	r2,16
21095e70:	003feb06 	br	21095e20 <__flash_rwdata_start+0xffff3bd8>
21095e74:	10800044 	addi	r2,r2,1
21095e78:	20c00015 	stw	r3,0(r4)
21095e7c:	f800283a 	ret
21095e80:	0005883a 	mov	r2,zero
21095e84:	f800283a 	ret
21095e88:	1806d07a 	srli	r3,r3,1
21095e8c:	00800044 	movi	r2,1
21095e90:	20c00015 	stw	r3,0(r4)
21095e94:	f800283a 	ret

21095e98 <__i2b>:
21095e98:	defffd04 	addi	sp,sp,-12
21095e9c:	dc000015 	stw	r16,0(sp)
21095ea0:	04000044 	movi	r16,1
21095ea4:	dc400115 	stw	r17,4(sp)
21095ea8:	2823883a 	mov	r17,r5
21095eac:	800b883a 	mov	r5,r16
21095eb0:	dfc00215 	stw	ra,8(sp)
21095eb4:	1095a8c0 	call	21095a8c <_Balloc>
21095eb8:	14400515 	stw	r17,20(r2)
21095ebc:	14000415 	stw	r16,16(r2)
21095ec0:	dfc00217 	ldw	ra,8(sp)
21095ec4:	dc400117 	ldw	r17,4(sp)
21095ec8:	dc000017 	ldw	r16,0(sp)
21095ecc:	dec00304 	addi	sp,sp,12
21095ed0:	f800283a 	ret

21095ed4 <__multiply>:
21095ed4:	defffa04 	addi	sp,sp,-24
21095ed8:	dcc00315 	stw	r19,12(sp)
21095edc:	dc800215 	stw	r18,8(sp)
21095ee0:	2cc00417 	ldw	r19,16(r5)
21095ee4:	34800417 	ldw	r18,16(r6)
21095ee8:	dd000415 	stw	r20,16(sp)
21095eec:	dc400115 	stw	r17,4(sp)
21095ef0:	dfc00515 	stw	ra,20(sp)
21095ef4:	dc000015 	stw	r16,0(sp)
21095ef8:	2829883a 	mov	r20,r5
21095efc:	3023883a 	mov	r17,r6
21095f00:	9c807016 	blt	r19,r18,210960c4 <__multiply+0x1f0>
21095f04:	9005883a 	mov	r2,r18
21095f08:	9825883a 	mov	r18,r19
21095f0c:	1027883a 	mov	r19,r2
21095f10:	a0800217 	ldw	r2,8(r20)
21095f14:	94e1883a 	add	r16,r18,r19
21095f18:	a1400117 	ldw	r5,4(r20)
21095f1c:	1400010e 	bge	r2,r16,21095f24 <__multiply+0x50>
21095f20:	29400044 	addi	r5,r5,1
21095f24:	1095a8c0 	call	21095a8c <_Balloc>
21095f28:	8417883a 	add	r11,r16,r16
21095f2c:	13000504 	addi	r12,r2,20
21095f30:	5ad7883a 	add	r11,r11,r11
21095f34:	62d7883a 	add	r11,r12,r11
21095f38:	6007883a 	mov	r3,r12
21095f3c:	62c0032e 	bgeu	r12,r11,21095f4c <__multiply+0x78>
21095f40:	18000015 	stw	zero,0(r3)
21095f44:	18c00104 	addi	r3,r3,4
21095f48:	1afffd36 	bltu	r3,r11,21095f40 <__flash_rwdata_start+0xffff3cf8>
21095f4c:	9ce7883a 	add	r19,r19,r19
21095f50:	94a5883a 	add	r18,r18,r18
21095f54:	89800504 	addi	r6,r17,20
21095f58:	9ce7883a 	add	r19,r19,r19
21095f5c:	a3800504 	addi	r14,r20,20
21095f60:	94a5883a 	add	r18,r18,r18
21095f64:	34db883a 	add	r13,r6,r19
21095f68:	7495883a 	add	r10,r14,r18
21095f6c:	3340422e 	bgeu	r6,r13,21096078 <__multiply+0x1a4>
21095f70:	34400017 	ldw	r17,0(r6)
21095f74:	8cbfffcc 	andi	r18,r17,65535
21095f78:	90001b26 	beq	r18,zero,21095fe8 <__multiply+0x114>
21095f7c:	6013883a 	mov	r9,r12
21095f80:	7023883a 	mov	r17,r14
21095f84:	0011883a 	mov	r8,zero
21095f88:	88c00017 	ldw	r3,0(r17)
21095f8c:	4bc00017 	ldw	r15,0(r9)
21095f90:	8c400104 	addi	r17,r17,4
21095f94:	19ffffcc 	andi	r7,r3,65535
21095f98:	3c8f383a 	mul	r7,r7,r18
21095f9c:	1808d43a 	srli	r4,r3,16
21095fa0:	797fffcc 	andi	r5,r15,65535
21095fa4:	29cb883a 	add	r5,r5,r7
21095fa8:	2a0b883a 	add	r5,r5,r8
21095fac:	2489383a 	mul	r4,r4,r18
21095fb0:	7806d43a 	srli	r3,r15,16
21095fb4:	2810d43a 	srli	r8,r5,16
21095fb8:	297fffcc 	andi	r5,r5,65535
21095fbc:	1907883a 	add	r3,r3,r4
21095fc0:	1a07883a 	add	r3,r3,r8
21095fc4:	1808943a 	slli	r4,r3,16
21095fc8:	480f883a 	mov	r7,r9
21095fcc:	1810d43a 	srli	r8,r3,16
21095fd0:	214ab03a 	or	r5,r4,r5
21095fd4:	49400015 	stw	r5,0(r9)
21095fd8:	4a400104 	addi	r9,r9,4
21095fdc:	8abfea36 	bltu	r17,r10,21095f88 <__flash_rwdata_start+0xffff3d40>
21095fe0:	3a000115 	stw	r8,4(r7)
21095fe4:	34400017 	ldw	r17,0(r6)
21095fe8:	8822d43a 	srli	r17,r17,16
21095fec:	88001f26 	beq	r17,zero,2109606c <__multiply+0x198>
21095ff0:	60c00017 	ldw	r3,0(r12)
21095ff4:	7013883a 	mov	r9,r14
21095ff8:	601f883a 	mov	r15,r12
21095ffc:	1811883a 	mov	r8,r3
21096000:	6027883a 	mov	r19,r12
21096004:	000f883a 	mov	r7,zero
21096008:	00000106 	br	21096010 <__multiply+0x13c>
2109600c:	9027883a 	mov	r19,r18
21096010:	4940000b 	ldhu	r5,0(r9)
21096014:	4010d43a 	srli	r8,r8,16
21096018:	193fffcc 	andi	r4,r3,65535
2109601c:	2c4b383a 	mul	r5,r5,r17
21096020:	7bc00104 	addi	r15,r15,4
21096024:	4a400104 	addi	r9,r9,4
21096028:	2a0b883a 	add	r5,r5,r8
2109602c:	29cb883a 	add	r5,r5,r7
21096030:	2806943a 	slli	r3,r5,16
21096034:	9c800104 	addi	r18,r19,4
21096038:	280ad43a 	srli	r5,r5,16
2109603c:	1908b03a 	or	r4,r3,r4
21096040:	793fff15 	stw	r4,-4(r15)
21096044:	48ffff17 	ldw	r3,-4(r9)
21096048:	92000017 	ldw	r8,0(r18)
2109604c:	1806d43a 	srli	r3,r3,16
21096050:	413fffcc 	andi	r4,r8,65535
21096054:	1c47383a 	mul	r3,r3,r17
21096058:	1907883a 	add	r3,r3,r4
2109605c:	1947883a 	add	r3,r3,r5
21096060:	180ed43a 	srli	r7,r3,16
21096064:	4abfe936 	bltu	r9,r10,2109600c <__flash_rwdata_start+0xffff3dc4>
21096068:	98c00115 	stw	r3,4(r19)
2109606c:	31800104 	addi	r6,r6,4
21096070:	63000104 	addi	r12,r12,4
21096074:	337fbe36 	bltu	r6,r13,21095f70 <__flash_rwdata_start+0xffff3d28>
21096078:	0400090e 	bge	zero,r16,210960a0 <__multiply+0x1cc>
2109607c:	58ffff17 	ldw	r3,-4(r11)
21096080:	5affff04 	addi	r11,r11,-4
21096084:	18000326 	beq	r3,zero,21096094 <__multiply+0x1c0>
21096088:	00000506 	br	210960a0 <__multiply+0x1cc>
2109608c:	58c00017 	ldw	r3,0(r11)
21096090:	1800031e 	bne	r3,zero,210960a0 <__multiply+0x1cc>
21096094:	843fffc4 	addi	r16,r16,-1
21096098:	5affff04 	addi	r11,r11,-4
2109609c:	803ffb1e 	bne	r16,zero,2109608c <__flash_rwdata_start+0xffff3e44>
210960a0:	14000415 	stw	r16,16(r2)
210960a4:	dfc00517 	ldw	ra,20(sp)
210960a8:	dd000417 	ldw	r20,16(sp)
210960ac:	dcc00317 	ldw	r19,12(sp)
210960b0:	dc800217 	ldw	r18,8(sp)
210960b4:	dc400117 	ldw	r17,4(sp)
210960b8:	dc000017 	ldw	r16,0(sp)
210960bc:	dec00604 	addi	sp,sp,24
210960c0:	f800283a 	ret
210960c4:	3029883a 	mov	r20,r6
210960c8:	2823883a 	mov	r17,r5
210960cc:	003f9006 	br	21095f10 <__flash_rwdata_start+0xffff3cc8>

210960d0 <__pow5mult>:
210960d0:	defffa04 	addi	sp,sp,-24
210960d4:	dcc00315 	stw	r19,12(sp)
210960d8:	dc800215 	stw	r18,8(sp)
210960dc:	dc000015 	stw	r16,0(sp)
210960e0:	dfc00515 	stw	ra,20(sp)
210960e4:	dd000415 	stw	r20,16(sp)
210960e8:	dc400115 	stw	r17,4(sp)
210960ec:	308000cc 	andi	r2,r6,3
210960f0:	3021883a 	mov	r16,r6
210960f4:	2027883a 	mov	r19,r4
210960f8:	2825883a 	mov	r18,r5
210960fc:	10002e1e 	bne	r2,zero,210961b8 <__pow5mult+0xe8>
21096100:	8021d0ba 	srai	r16,r16,2
21096104:	80001a26 	beq	r16,zero,21096170 <__pow5mult+0xa0>
21096108:	9c401217 	ldw	r17,72(r19)
2109610c:	8800061e 	bne	r17,zero,21096128 <__pow5mult+0x58>
21096110:	00003406 	br	210961e4 <__pow5mult+0x114>
21096114:	8021d07a 	srai	r16,r16,1
21096118:	80001526 	beq	r16,zero,21096170 <__pow5mult+0xa0>
2109611c:	88800017 	ldw	r2,0(r17)
21096120:	10001c26 	beq	r2,zero,21096194 <__pow5mult+0xc4>
21096124:	1023883a 	mov	r17,r2
21096128:	80c0004c 	andi	r3,r16,1
2109612c:	183ff926 	beq	r3,zero,21096114 <__flash_rwdata_start+0xffff3ecc>
21096130:	900b883a 	mov	r5,r18
21096134:	880d883a 	mov	r6,r17
21096138:	9809883a 	mov	r4,r19
2109613c:	1095ed40 	call	21095ed4 <__multiply>
21096140:	90001b26 	beq	r18,zero,210961b0 <__pow5mult+0xe0>
21096144:	91c00117 	ldw	r7,4(r18)
21096148:	98c01317 	ldw	r3,76(r19)
2109614c:	8021d07a 	srai	r16,r16,1
21096150:	39cf883a 	add	r7,r7,r7
21096154:	39cf883a 	add	r7,r7,r7
21096158:	19c7883a 	add	r3,r3,r7
2109615c:	19000017 	ldw	r4,0(r3)
21096160:	91000015 	stw	r4,0(r18)
21096164:	1c800015 	stw	r18,0(r3)
21096168:	1025883a 	mov	r18,r2
2109616c:	803feb1e 	bne	r16,zero,2109611c <__flash_rwdata_start+0xffff3ed4>
21096170:	9005883a 	mov	r2,r18
21096174:	dfc00517 	ldw	ra,20(sp)
21096178:	dd000417 	ldw	r20,16(sp)
2109617c:	dcc00317 	ldw	r19,12(sp)
21096180:	dc800217 	ldw	r18,8(sp)
21096184:	dc400117 	ldw	r17,4(sp)
21096188:	dc000017 	ldw	r16,0(sp)
2109618c:	dec00604 	addi	sp,sp,24
21096190:	f800283a 	ret
21096194:	9809883a 	mov	r4,r19
21096198:	880b883a 	mov	r5,r17
2109619c:	880d883a 	mov	r6,r17
210961a0:	1095ed40 	call	21095ed4 <__multiply>
210961a4:	88800015 	stw	r2,0(r17)
210961a8:	10000015 	stw	zero,0(r2)
210961ac:	003fdd06 	br	21096124 <__flash_rwdata_start+0xffff3edc>
210961b0:	1025883a 	mov	r18,r2
210961b4:	003fd706 	br	21096114 <__flash_rwdata_start+0xffff3ecc>
210961b8:	10bfffc4 	addi	r2,r2,-1
210961bc:	1085883a 	add	r2,r2,r2
210961c0:	00c00034 	movhi	r3,0
210961c4:	18cef104 	addi	r3,r3,15300
210961c8:	1085883a 	add	r2,r2,r2
210961cc:	1885883a 	add	r2,r3,r2
210961d0:	11800017 	ldw	r6,0(r2)
210961d4:	000f883a 	mov	r7,zero
210961d8:	1095b5c0 	call	21095b5c <__multadd>
210961dc:	1025883a 	mov	r18,r2
210961e0:	003fc706 	br	21096100 <__flash_rwdata_start+0xffff3eb8>
210961e4:	05000044 	movi	r20,1
210961e8:	9809883a 	mov	r4,r19
210961ec:	a00b883a 	mov	r5,r20
210961f0:	1095a8c0 	call	21095a8c <_Balloc>
210961f4:	1023883a 	mov	r17,r2
210961f8:	00809c44 	movi	r2,625
210961fc:	88800515 	stw	r2,20(r17)
21096200:	8d000415 	stw	r20,16(r17)
21096204:	9c401215 	stw	r17,72(r19)
21096208:	88000015 	stw	zero,0(r17)
2109620c:	003fc606 	br	21096128 <__flash_rwdata_start+0xffff3ee0>

21096210 <__lshift>:
21096210:	defff904 	addi	sp,sp,-28
21096214:	dd000415 	stw	r20,16(sp)
21096218:	dcc00315 	stw	r19,12(sp)
2109621c:	3029d17a 	srai	r20,r6,5
21096220:	2cc00417 	ldw	r19,16(r5)
21096224:	28800217 	ldw	r2,8(r5)
21096228:	dd400515 	stw	r21,20(sp)
2109622c:	a4e7883a 	add	r19,r20,r19
21096230:	dc800215 	stw	r18,8(sp)
21096234:	dc400115 	stw	r17,4(sp)
21096238:	dc000015 	stw	r16,0(sp)
2109623c:	dfc00615 	stw	ra,24(sp)
21096240:	9c000044 	addi	r16,r19,1
21096244:	2823883a 	mov	r17,r5
21096248:	302b883a 	mov	r21,r6
2109624c:	2025883a 	mov	r18,r4
21096250:	29400117 	ldw	r5,4(r5)
21096254:	1400030e 	bge	r2,r16,21096264 <__lshift+0x54>
21096258:	1085883a 	add	r2,r2,r2
2109625c:	29400044 	addi	r5,r5,1
21096260:	143ffd16 	blt	r2,r16,21096258 <__flash_rwdata_start+0xffff4010>
21096264:	9009883a 	mov	r4,r18
21096268:	1095a8c0 	call	21095a8c <_Balloc>
2109626c:	11c00504 	addi	r7,r2,20
21096270:	0500090e 	bge	zero,r20,21096298 <__lshift+0x88>
21096274:	3811883a 	mov	r8,r7
21096278:	0007883a 	mov	r3,zero
2109627c:	40000015 	stw	zero,0(r8)
21096280:	18c00044 	addi	r3,r3,1
21096284:	42000104 	addi	r8,r8,4
21096288:	1d3ffc1e 	bne	r3,r20,2109627c <__flash_rwdata_start+0xffff4034>
2109628c:	18c7883a 	add	r3,r3,r3
21096290:	18c7883a 	add	r3,r3,r3
21096294:	38cf883a 	add	r7,r7,r3
21096298:	89000417 	ldw	r4,16(r17)
2109629c:	88c00504 	addi	r3,r17,20
210962a0:	a98007cc 	andi	r6,r21,31
210962a4:	2109883a 	add	r4,r4,r4
210962a8:	2109883a 	add	r4,r4,r4
210962ac:	1909883a 	add	r4,r3,r4
210962b0:	30002326 	beq	r6,zero,21096340 <__lshift+0x130>
210962b4:	01400804 	movi	r5,32
210962b8:	298bc83a 	sub	r5,r5,r6
210962bc:	0013883a 	mov	r9,zero
210962c0:	1a000017 	ldw	r8,0(r3)
210962c4:	3815883a 	mov	r10,r7
210962c8:	39c00104 	addi	r7,r7,4
210962cc:	4190983a 	sll	r8,r8,r6
210962d0:	18c00104 	addi	r3,r3,4
210962d4:	4a10b03a 	or	r8,r9,r8
210962d8:	3a3fff15 	stw	r8,-4(r7)
210962dc:	1a3fff17 	ldw	r8,-4(r3)
210962e0:	4152d83a 	srl	r9,r8,r5
210962e4:	193ff636 	bltu	r3,r4,210962c0 <__flash_rwdata_start+0xffff4078>
210962e8:	52400115 	stw	r9,4(r10)
210962ec:	48001a1e 	bne	r9,zero,21096358 <__lshift+0x148>
210962f0:	843fffc4 	addi	r16,r16,-1
210962f4:	14000415 	stw	r16,16(r2)
210962f8:	88000826 	beq	r17,zero,2109631c <__lshift+0x10c>
210962fc:	89000117 	ldw	r4,4(r17)
21096300:	90c01317 	ldw	r3,76(r18)
21096304:	2109883a 	add	r4,r4,r4
21096308:	2109883a 	add	r4,r4,r4
2109630c:	1907883a 	add	r3,r3,r4
21096310:	19000017 	ldw	r4,0(r3)
21096314:	89000015 	stw	r4,0(r17)
21096318:	1c400015 	stw	r17,0(r3)
2109631c:	dfc00617 	ldw	ra,24(sp)
21096320:	dd400517 	ldw	r21,20(sp)
21096324:	dd000417 	ldw	r20,16(sp)
21096328:	dcc00317 	ldw	r19,12(sp)
2109632c:	dc800217 	ldw	r18,8(sp)
21096330:	dc400117 	ldw	r17,4(sp)
21096334:	dc000017 	ldw	r16,0(sp)
21096338:	dec00704 	addi	sp,sp,28
2109633c:	f800283a 	ret
21096340:	19400017 	ldw	r5,0(r3)
21096344:	39c00104 	addi	r7,r7,4
21096348:	18c00104 	addi	r3,r3,4
2109634c:	397fff15 	stw	r5,-4(r7)
21096350:	193ffb36 	bltu	r3,r4,21096340 <__flash_rwdata_start+0xffff40f8>
21096354:	003fe606 	br	210962f0 <__flash_rwdata_start+0xffff40a8>
21096358:	9c000084 	addi	r16,r19,2
2109635c:	003fe406 	br	210962f0 <__flash_rwdata_start+0xffff40a8>

21096360 <__mcmp>:
21096360:	20800417 	ldw	r2,16(r4)
21096364:	28c00417 	ldw	r3,16(r5)
21096368:	10c5c83a 	sub	r2,r2,r3
2109636c:	1000111e 	bne	r2,zero,210963b4 <__mcmp+0x54>
21096370:	18c7883a 	add	r3,r3,r3
21096374:	18c7883a 	add	r3,r3,r3
21096378:	21000504 	addi	r4,r4,20
2109637c:	29400504 	addi	r5,r5,20
21096380:	20c5883a 	add	r2,r4,r3
21096384:	28cb883a 	add	r5,r5,r3
21096388:	00000106 	br	21096390 <__mcmp+0x30>
2109638c:	20800a2e 	bgeu	r4,r2,210963b8 <__mcmp+0x58>
21096390:	10bfff04 	addi	r2,r2,-4
21096394:	297fff04 	addi	r5,r5,-4
21096398:	11800017 	ldw	r6,0(r2)
2109639c:	28c00017 	ldw	r3,0(r5)
210963a0:	30fffa26 	beq	r6,r3,2109638c <__flash_rwdata_start+0xffff4144>
210963a4:	30c00236 	bltu	r6,r3,210963b0 <__mcmp+0x50>
210963a8:	00800044 	movi	r2,1
210963ac:	f800283a 	ret
210963b0:	00bfffc4 	movi	r2,-1
210963b4:	f800283a 	ret
210963b8:	0005883a 	mov	r2,zero
210963bc:	f800283a 	ret

210963c0 <__mdiff>:
210963c0:	defffb04 	addi	sp,sp,-20
210963c4:	dc000015 	stw	r16,0(sp)
210963c8:	2821883a 	mov	r16,r5
210963cc:	dcc00315 	stw	r19,12(sp)
210963d0:	300b883a 	mov	r5,r6
210963d4:	2027883a 	mov	r19,r4
210963d8:	8009883a 	mov	r4,r16
210963dc:	dc800215 	stw	r18,8(sp)
210963e0:	dfc00415 	stw	ra,16(sp)
210963e4:	dc400115 	stw	r17,4(sp)
210963e8:	3025883a 	mov	r18,r6
210963ec:	10963600 	call	21096360 <__mcmp>
210963f0:	10005226 	beq	r2,zero,2109653c <__mdiff+0x17c>
210963f4:	10004c16 	blt	r2,zero,21096528 <__mdiff+0x168>
210963f8:	0023883a 	mov	r17,zero
210963fc:	81400117 	ldw	r5,4(r16)
21096400:	9809883a 	mov	r4,r19
21096404:	1095a8c0 	call	21095a8c <_Balloc>
21096408:	83400417 	ldw	r13,16(r16)
2109640c:	93800417 	ldw	r14,16(r18)
21096410:	81000504 	addi	r4,r16,20
21096414:	6b59883a 	add	r12,r13,r13
21096418:	739d883a 	add	r14,r14,r14
2109641c:	6319883a 	add	r12,r12,r12
21096420:	91800504 	addi	r6,r18,20
21096424:	739d883a 	add	r14,r14,r14
21096428:	14400315 	stw	r17,12(r2)
2109642c:	2319883a 	add	r12,r4,r12
21096430:	339d883a 	add	r14,r6,r14
21096434:	12400504 	addi	r9,r2,20
21096438:	0007883a 	mov	r3,zero
2109643c:	22000017 	ldw	r8,0(r4)
21096440:	32800017 	ldw	r10,0(r6)
21096444:	4ac00104 	addi	r11,r9,4
21096448:	41ffffcc 	andi	r7,r8,65535
2109644c:	38c7883a 	add	r3,r7,r3
21096450:	51ffffcc 	andi	r7,r10,65535
21096454:	19cfc83a 	sub	r7,r3,r7
21096458:	4010d43a 	srli	r8,r8,16
2109645c:	5014d43a 	srli	r10,r10,16
21096460:	3807d43a 	srai	r3,r7,16
21096464:	39ffffcc 	andi	r7,r7,65535
21096468:	4291c83a 	sub	r8,r8,r10
2109646c:	40c7883a 	add	r3,r8,r3
21096470:	1810943a 	slli	r8,r3,16
21096474:	31800104 	addi	r6,r6,4
21096478:	21000104 	addi	r4,r4,4
2109647c:	41ceb03a 	or	r7,r8,r7
21096480:	49c00015 	stw	r7,0(r9)
21096484:	1807d43a 	srai	r3,r3,16
21096488:	580b883a 	mov	r5,r11
2109648c:	5813883a 	mov	r9,r11
21096490:	33bfea36 	bltu	r6,r14,2109643c <__flash_rwdata_start+0xffff41f4>
21096494:	2011883a 	mov	r8,r4
21096498:	2300152e 	bgeu	r4,r12,210964f0 <__mdiff+0x130>
2109649c:	21400017 	ldw	r5,0(r4)
210964a0:	4a400104 	addi	r9,r9,4
210964a4:	21000104 	addi	r4,r4,4
210964a8:	29ffffcc 	andi	r7,r5,65535
210964ac:	38c7883a 	add	r3,r7,r3
210964b0:	280ad43a 	srli	r5,r5,16
210964b4:	180dd43a 	srai	r6,r3,16
210964b8:	19ffffcc 	andi	r7,r3,65535
210964bc:	3147883a 	add	r3,r6,r5
210964c0:	180a943a 	slli	r5,r3,16
210964c4:	1807d43a 	srai	r3,r3,16
210964c8:	29ceb03a 	or	r7,r5,r7
210964cc:	49ffff15 	stw	r7,-4(r9)
210964d0:	233ff236 	bltu	r4,r12,2109649c <__flash_rwdata_start+0xffff4254>
210964d4:	0206303a 	nor	r3,zero,r8
210964d8:	1b07883a 	add	r3,r3,r12
210964dc:	1806d0ba 	srli	r3,r3,2
210964e0:	18c00044 	addi	r3,r3,1
210964e4:	18c7883a 	add	r3,r3,r3
210964e8:	18c7883a 	add	r3,r3,r3
210964ec:	58cb883a 	add	r5,r11,r3
210964f0:	28ffff04 	addi	r3,r5,-4
210964f4:	3800041e 	bne	r7,zero,21096508 <__mdiff+0x148>
210964f8:	18ffff04 	addi	r3,r3,-4
210964fc:	19000017 	ldw	r4,0(r3)
21096500:	6b7fffc4 	addi	r13,r13,-1
21096504:	203ffc26 	beq	r4,zero,210964f8 <__flash_rwdata_start+0xffff42b0>
21096508:	13400415 	stw	r13,16(r2)
2109650c:	dfc00417 	ldw	ra,16(sp)
21096510:	dcc00317 	ldw	r19,12(sp)
21096514:	dc800217 	ldw	r18,8(sp)
21096518:	dc400117 	ldw	r17,4(sp)
2109651c:	dc000017 	ldw	r16,0(sp)
21096520:	dec00504 	addi	sp,sp,20
21096524:	f800283a 	ret
21096528:	8005883a 	mov	r2,r16
2109652c:	04400044 	movi	r17,1
21096530:	9021883a 	mov	r16,r18
21096534:	1025883a 	mov	r18,r2
21096538:	003fb006 	br	210963fc <__flash_rwdata_start+0xffff41b4>
2109653c:	9809883a 	mov	r4,r19
21096540:	000b883a 	mov	r5,zero
21096544:	1095a8c0 	call	21095a8c <_Balloc>
21096548:	00c00044 	movi	r3,1
2109654c:	10c00415 	stw	r3,16(r2)
21096550:	10000515 	stw	zero,20(r2)
21096554:	003fed06 	br	2109650c <__flash_rwdata_start+0xffff42c4>

21096558 <__ulp>:
21096558:	295ffc2c 	andhi	r5,r5,32752
2109655c:	00bf3034 	movhi	r2,64704
21096560:	2887883a 	add	r3,r5,r2
21096564:	00c0020e 	bge	zero,r3,21096570 <__ulp+0x18>
21096568:	0005883a 	mov	r2,zero
2109656c:	f800283a 	ret
21096570:	00c7c83a 	sub	r3,zero,r3
21096574:	180bd53a 	srai	r5,r3,20
21096578:	008004c4 	movi	r2,19
2109657c:	11400a0e 	bge	r2,r5,210965a8 <__ulp+0x50>
21096580:	00800c84 	movi	r2,50
21096584:	0007883a 	mov	r3,zero
21096588:	11400516 	blt	r2,r5,210965a0 <__ulp+0x48>
2109658c:	00800cc4 	movi	r2,51
21096590:	114bc83a 	sub	r5,r2,r5
21096594:	00800044 	movi	r2,1
21096598:	1144983a 	sll	r2,r2,r5
2109659c:	f800283a 	ret
210965a0:	00800044 	movi	r2,1
210965a4:	f800283a 	ret
210965a8:	00800234 	movhi	r2,8
210965ac:	1147d83a 	sra	r3,r2,r5
210965b0:	0005883a 	mov	r2,zero
210965b4:	f800283a 	ret

210965b8 <__b2d>:
210965b8:	defffa04 	addi	sp,sp,-24
210965bc:	dc000015 	stw	r16,0(sp)
210965c0:	24000417 	ldw	r16,16(r4)
210965c4:	dc400115 	stw	r17,4(sp)
210965c8:	24400504 	addi	r17,r4,20
210965cc:	8421883a 	add	r16,r16,r16
210965d0:	8421883a 	add	r16,r16,r16
210965d4:	8c21883a 	add	r16,r17,r16
210965d8:	dc800215 	stw	r18,8(sp)
210965dc:	84bfff17 	ldw	r18,-4(r16)
210965e0:	dd000415 	stw	r20,16(sp)
210965e4:	dcc00315 	stw	r19,12(sp)
210965e8:	9009883a 	mov	r4,r18
210965ec:	2829883a 	mov	r20,r5
210965f0:	dfc00515 	stw	ra,20(sp)
210965f4:	1095d800 	call	21095d80 <__hi0bits>
210965f8:	00c00804 	movi	r3,32
210965fc:	1887c83a 	sub	r3,r3,r2
21096600:	a0c00015 	stw	r3,0(r20)
21096604:	00c00284 	movi	r3,10
21096608:	84ffff04 	addi	r19,r16,-4
2109660c:	18801216 	blt	r3,r2,21096658 <__b2d+0xa0>
21096610:	014002c4 	movi	r5,11
21096614:	2889c83a 	sub	r4,r5,r2
21096618:	9106d83a 	srl	r3,r18,r4
2109661c:	18cffc34 	orhi	r3,r3,16368
21096620:	8cc0282e 	bgeu	r17,r19,210966c4 <__b2d+0x10c>
21096624:	817ffe17 	ldw	r5,-8(r16)
21096628:	290ad83a 	srl	r5,r5,r4
2109662c:	10800544 	addi	r2,r2,21
21096630:	9084983a 	sll	r2,r18,r2
21096634:	2884b03a 	or	r2,r5,r2
21096638:	dfc00517 	ldw	ra,20(sp)
2109663c:	dd000417 	ldw	r20,16(sp)
21096640:	dcc00317 	ldw	r19,12(sp)
21096644:	dc800217 	ldw	r18,8(sp)
21096648:	dc400117 	ldw	r17,4(sp)
2109664c:	dc000017 	ldw	r16,0(sp)
21096650:	dec00604 	addi	sp,sp,24
21096654:	f800283a 	ret
21096658:	113ffd44 	addi	r4,r2,-11
2109665c:	8cc00f2e 	bgeu	r17,r19,2109669c <__b2d+0xe4>
21096660:	81bffe04 	addi	r6,r16,-8
21096664:	817ffe17 	ldw	r5,-8(r16)
21096668:	20001326 	beq	r4,zero,210966b8 <__b2d+0x100>
2109666c:	00c00ac4 	movi	r3,43
21096670:	1885c83a 	sub	r2,r3,r2
21096674:	2886d83a 	srl	r3,r5,r2
21096678:	9124983a 	sll	r18,r18,r4
2109667c:	90e4b03a 	or	r18,r18,r3
21096680:	90cffc34 	orhi	r3,r18,16368
21096684:	8980112e 	bgeu	r17,r6,210966cc <__b2d+0x114>
21096688:	81bffd17 	ldw	r6,-12(r16)
2109668c:	308cd83a 	srl	r6,r6,r2
21096690:	2904983a 	sll	r2,r5,r4
21096694:	1184b03a 	or	r2,r2,r6
21096698:	003fe706 	br	21096638 <__flash_rwdata_start+0xffff43f0>
2109669c:	20000526 	beq	r4,zero,210966b4 <__b2d+0xfc>
210966a0:	9124983a 	sll	r18,r18,r4
210966a4:	000d883a 	mov	r6,zero
210966a8:	000b883a 	mov	r5,zero
210966ac:	90cffc34 	orhi	r3,r18,16368
210966b0:	003ff706 	br	21096690 <__flash_rwdata_start+0xffff4448>
210966b4:	000b883a 	mov	r5,zero
210966b8:	90cffc34 	orhi	r3,r18,16368
210966bc:	2805883a 	mov	r2,r5
210966c0:	003fdd06 	br	21096638 <__flash_rwdata_start+0xffff43f0>
210966c4:	000b883a 	mov	r5,zero
210966c8:	003fd806 	br	2109662c <__flash_rwdata_start+0xffff43e4>
210966cc:	000d883a 	mov	r6,zero
210966d0:	003fef06 	br	21096690 <__flash_rwdata_start+0xffff4448>

210966d4 <__d2b>:
210966d4:	defff704 	addi	sp,sp,-36
210966d8:	dc000215 	stw	r16,8(sp)
210966dc:	3021883a 	mov	r16,r6
210966e0:	dc400315 	stw	r17,12(sp)
210966e4:	8022907a 	slli	r17,r16,1
210966e8:	dd400715 	stw	r21,28(sp)
210966ec:	282b883a 	mov	r21,r5
210966f0:	01400044 	movi	r5,1
210966f4:	dd000615 	stw	r20,24(sp)
210966f8:	dcc00515 	stw	r19,20(sp)
210966fc:	dc800415 	stw	r18,16(sp)
21096700:	dfc00815 	stw	ra,32(sp)
21096704:	3829883a 	mov	r20,r7
21096708:	dc800917 	ldw	r18,36(sp)
2109670c:	8822d57a 	srli	r17,r17,21
21096710:	1095a8c0 	call	21095a8c <_Balloc>
21096714:	1027883a 	mov	r19,r2
21096718:	00800434 	movhi	r2,16
2109671c:	10bfffc4 	addi	r2,r2,-1
21096720:	808c703a 	and	r6,r16,r2
21096724:	88000126 	beq	r17,zero,2109672c <__d2b+0x58>
21096728:	31800434 	orhi	r6,r6,16
2109672c:	d9800015 	stw	r6,0(sp)
21096730:	a8001f26 	beq	r21,zero,210967b0 <__d2b+0xdc>
21096734:	d9000104 	addi	r4,sp,4
21096738:	dd400115 	stw	r21,4(sp)
2109673c:	1095de80 	call	21095de8 <__lo0bits>
21096740:	d8c00017 	ldw	r3,0(sp)
21096744:	1000291e 	bne	r2,zero,210967ec <__d2b+0x118>
21096748:	d9000117 	ldw	r4,4(sp)
2109674c:	99000515 	stw	r4,20(r19)
21096750:	1820c03a 	cmpne	r16,r3,zero
21096754:	84000044 	addi	r16,r16,1
21096758:	98c00615 	stw	r3,24(r19)
2109675c:	9c000415 	stw	r16,16(r19)
21096760:	88001b1e 	bne	r17,zero,210967d0 <__d2b+0xfc>
21096764:	800690ba 	slli	r3,r16,2
21096768:	10bef384 	addi	r2,r2,-1074
2109676c:	a0800015 	stw	r2,0(r20)
21096770:	98c5883a 	add	r2,r19,r3
21096774:	11000417 	ldw	r4,16(r2)
21096778:	8020917a 	slli	r16,r16,5
2109677c:	1095d800 	call	21095d80 <__hi0bits>
21096780:	8085c83a 	sub	r2,r16,r2
21096784:	90800015 	stw	r2,0(r18)
21096788:	9805883a 	mov	r2,r19
2109678c:	dfc00817 	ldw	ra,32(sp)
21096790:	dd400717 	ldw	r21,28(sp)
21096794:	dd000617 	ldw	r20,24(sp)
21096798:	dcc00517 	ldw	r19,20(sp)
2109679c:	dc800417 	ldw	r18,16(sp)
210967a0:	dc400317 	ldw	r17,12(sp)
210967a4:	dc000217 	ldw	r16,8(sp)
210967a8:	dec00904 	addi	sp,sp,36
210967ac:	f800283a 	ret
210967b0:	d809883a 	mov	r4,sp
210967b4:	1095de80 	call	21095de8 <__lo0bits>
210967b8:	d8c00017 	ldw	r3,0(sp)
210967bc:	04000044 	movi	r16,1
210967c0:	9c000415 	stw	r16,16(r19)
210967c4:	98c00515 	stw	r3,20(r19)
210967c8:	10800804 	addi	r2,r2,32
210967cc:	883fe526 	beq	r17,zero,21096764 <__flash_rwdata_start+0xffff451c>
210967d0:	8c7ef344 	addi	r17,r17,-1075
210967d4:	88a3883a 	add	r17,r17,r2
210967d8:	00c00d44 	movi	r3,53
210967dc:	a4400015 	stw	r17,0(r20)
210967e0:	1885c83a 	sub	r2,r3,r2
210967e4:	90800015 	stw	r2,0(r18)
210967e8:	003fe706 	br	21096788 <__flash_rwdata_start+0xffff4540>
210967ec:	01000804 	movi	r4,32
210967f0:	2089c83a 	sub	r4,r4,r2
210967f4:	1908983a 	sll	r4,r3,r4
210967f8:	d9400117 	ldw	r5,4(sp)
210967fc:	1886d83a 	srl	r3,r3,r2
21096800:	2148b03a 	or	r4,r4,r5
21096804:	99000515 	stw	r4,20(r19)
21096808:	d8c00015 	stw	r3,0(sp)
2109680c:	003fd006 	br	21096750 <__flash_rwdata_start+0xffff4508>

21096810 <__ratio>:
21096810:	defff904 	addi	sp,sp,-28
21096814:	dc400315 	stw	r17,12(sp)
21096818:	2823883a 	mov	r17,r5
2109681c:	d9400104 	addi	r5,sp,4
21096820:	dfc00615 	stw	ra,24(sp)
21096824:	dcc00515 	stw	r19,20(sp)
21096828:	dc800415 	stw	r18,16(sp)
2109682c:	2027883a 	mov	r19,r4
21096830:	dc000215 	stw	r16,8(sp)
21096834:	10965b80 	call	210965b8 <__b2d>
21096838:	8809883a 	mov	r4,r17
2109683c:	d80b883a 	mov	r5,sp
21096840:	1025883a 	mov	r18,r2
21096844:	1821883a 	mov	r16,r3
21096848:	10965b80 	call	210965b8 <__b2d>
2109684c:	8a400417 	ldw	r9,16(r17)
21096850:	9a000417 	ldw	r8,16(r19)
21096854:	100d883a 	mov	r6,r2
21096858:	d8800017 	ldw	r2,0(sp)
2109685c:	4251c83a 	sub	r8,r8,r9
21096860:	4012917a 	slli	r9,r8,5
21096864:	da000117 	ldw	r8,4(sp)
21096868:	4091c83a 	sub	r8,r8,r2
2109686c:	4251883a 	add	r8,r8,r9
21096870:	02000d0e 	bge	zero,r8,210968a8 <__ratio+0x98>
21096874:	4010953a 	slli	r8,r8,20
21096878:	4421883a 	add	r16,r8,r16
2109687c:	9009883a 	mov	r4,r18
21096880:	800b883a 	mov	r5,r16
21096884:	180f883a 	mov	r7,r3
21096888:	108b5b40 	call	2108b5b4 <__divdf3>
2109688c:	dfc00617 	ldw	ra,24(sp)
21096890:	dcc00517 	ldw	r19,20(sp)
21096894:	dc800417 	ldw	r18,16(sp)
21096898:	dc400317 	ldw	r17,12(sp)
2109689c:	dc000217 	ldw	r16,8(sp)
210968a0:	dec00704 	addi	sp,sp,28
210968a4:	f800283a 	ret
210968a8:	4010953a 	slli	r8,r8,20
210968ac:	1a07c83a 	sub	r3,r3,r8
210968b0:	003ff206 	br	2109687c <__flash_rwdata_start+0xffff4634>

210968b4 <_mprec_log10>:
210968b4:	defffe04 	addi	sp,sp,-8
210968b8:	dc000015 	stw	r16,0(sp)
210968bc:	dfc00115 	stw	ra,4(sp)
210968c0:	008005c4 	movi	r2,23
210968c4:	2021883a 	mov	r16,r4
210968c8:	11000d0e 	bge	r2,r4,21096900 <_mprec_log10+0x4c>
210968cc:	0005883a 	mov	r2,zero
210968d0:	00cffc34 	movhi	r3,16368
210968d4:	843fffc4 	addi	r16,r16,-1
210968d8:	1009883a 	mov	r4,r2
210968dc:	180b883a 	mov	r5,r3
210968e0:	000d883a 	mov	r6,zero
210968e4:	01d00934 	movhi	r7,16420
210968e8:	108bf600 	call	2108bf60 <__muldf3>
210968ec:	803ff91e 	bne	r16,zero,210968d4 <__flash_rwdata_start+0xffff468c>
210968f0:	dfc00117 	ldw	ra,4(sp)
210968f4:	dc000017 	ldw	r16,0(sp)
210968f8:	dec00204 	addi	sp,sp,8
210968fc:	f800283a 	ret
21096900:	202090fa 	slli	r16,r4,3
21096904:	00800034 	movhi	r2,0
21096908:	108f0804 	addi	r2,r2,15392
2109690c:	1421883a 	add	r16,r2,r16
21096910:	80800017 	ldw	r2,0(r16)
21096914:	80c00117 	ldw	r3,4(r16)
21096918:	dfc00117 	ldw	ra,4(sp)
2109691c:	dc000017 	ldw	r16,0(sp)
21096920:	dec00204 	addi	sp,sp,8
21096924:	f800283a 	ret

21096928 <__copybits>:
21096928:	297fffc4 	addi	r5,r5,-1
2109692c:	280fd17a 	srai	r7,r5,5
21096930:	30c00417 	ldw	r3,16(r6)
21096934:	30800504 	addi	r2,r6,20
21096938:	39c00044 	addi	r7,r7,1
2109693c:	18c7883a 	add	r3,r3,r3
21096940:	39cf883a 	add	r7,r7,r7
21096944:	18c7883a 	add	r3,r3,r3
21096948:	39cf883a 	add	r7,r7,r7
2109694c:	10c7883a 	add	r3,r2,r3
21096950:	21cf883a 	add	r7,r4,r7
21096954:	10c00d2e 	bgeu	r2,r3,2109698c <__copybits+0x64>
21096958:	200b883a 	mov	r5,r4
2109695c:	12000017 	ldw	r8,0(r2)
21096960:	29400104 	addi	r5,r5,4
21096964:	10800104 	addi	r2,r2,4
21096968:	2a3fff15 	stw	r8,-4(r5)
2109696c:	10fffb36 	bltu	r2,r3,2109695c <__flash_rwdata_start+0xffff4714>
21096970:	1985c83a 	sub	r2,r3,r6
21096974:	10bffac4 	addi	r2,r2,-21
21096978:	1004d0ba 	srli	r2,r2,2
2109697c:	10800044 	addi	r2,r2,1
21096980:	1085883a 	add	r2,r2,r2
21096984:	1085883a 	add	r2,r2,r2
21096988:	2089883a 	add	r4,r4,r2
2109698c:	21c0032e 	bgeu	r4,r7,2109699c <__copybits+0x74>
21096990:	20000015 	stw	zero,0(r4)
21096994:	21000104 	addi	r4,r4,4
21096998:	21fffd36 	bltu	r4,r7,21096990 <__flash_rwdata_start+0xffff4748>
2109699c:	f800283a 	ret

210969a0 <__any_on>:
210969a0:	20c00417 	ldw	r3,16(r4)
210969a4:	2805d17a 	srai	r2,r5,5
210969a8:	21000504 	addi	r4,r4,20
210969ac:	18800d0e 	bge	r3,r2,210969e4 <__any_on+0x44>
210969b0:	18c7883a 	add	r3,r3,r3
210969b4:	18c7883a 	add	r3,r3,r3
210969b8:	20c7883a 	add	r3,r4,r3
210969bc:	20c0192e 	bgeu	r4,r3,21096a24 <__any_on+0x84>
210969c0:	18bfff17 	ldw	r2,-4(r3)
210969c4:	18ffff04 	addi	r3,r3,-4
210969c8:	1000041e 	bne	r2,zero,210969dc <__any_on+0x3c>
210969cc:	20c0142e 	bgeu	r4,r3,21096a20 <__any_on+0x80>
210969d0:	18ffff04 	addi	r3,r3,-4
210969d4:	19400017 	ldw	r5,0(r3)
210969d8:	283ffc26 	beq	r5,zero,210969cc <__flash_rwdata_start+0xffff4784>
210969dc:	00800044 	movi	r2,1
210969e0:	f800283a 	ret
210969e4:	10c00a0e 	bge	r2,r3,21096a10 <__any_on+0x70>
210969e8:	1085883a 	add	r2,r2,r2
210969ec:	1085883a 	add	r2,r2,r2
210969f0:	294007cc 	andi	r5,r5,31
210969f4:	2087883a 	add	r3,r4,r2
210969f8:	283ff026 	beq	r5,zero,210969bc <__flash_rwdata_start+0xffff4774>
210969fc:	19800017 	ldw	r6,0(r3)
21096a00:	3144d83a 	srl	r2,r6,r5
21096a04:	114a983a 	sll	r5,r2,r5
21096a08:	29bff41e 	bne	r5,r6,210969dc <__flash_rwdata_start+0xffff4794>
21096a0c:	003feb06 	br	210969bc <__flash_rwdata_start+0xffff4774>
21096a10:	1085883a 	add	r2,r2,r2
21096a14:	1085883a 	add	r2,r2,r2
21096a18:	2087883a 	add	r3,r4,r2
21096a1c:	003fe706 	br	210969bc <__flash_rwdata_start+0xffff4774>
21096a20:	f800283a 	ret
21096a24:	0005883a 	mov	r2,zero
21096a28:	f800283a 	ret

21096a2c <_putc_r>:
21096a2c:	defffc04 	addi	sp,sp,-16
21096a30:	dc000215 	stw	r16,8(sp)
21096a34:	dfc00315 	stw	ra,12(sp)
21096a38:	2021883a 	mov	r16,r4
21096a3c:	20000226 	beq	r4,zero,21096a48 <_putc_r+0x1c>
21096a40:	20800e17 	ldw	r2,56(r4)
21096a44:	10001b26 	beq	r2,zero,21096ab4 <_putc_r+0x88>
21096a48:	30800217 	ldw	r2,8(r6)
21096a4c:	10bfffc4 	addi	r2,r2,-1
21096a50:	30800215 	stw	r2,8(r6)
21096a54:	10000a16 	blt	r2,zero,21096a80 <_putc_r+0x54>
21096a58:	30800017 	ldw	r2,0(r6)
21096a5c:	11400005 	stb	r5,0(r2)
21096a60:	30800017 	ldw	r2,0(r6)
21096a64:	10c00044 	addi	r3,r2,1
21096a68:	30c00015 	stw	r3,0(r6)
21096a6c:	10800003 	ldbu	r2,0(r2)
21096a70:	dfc00317 	ldw	ra,12(sp)
21096a74:	dc000217 	ldw	r16,8(sp)
21096a78:	dec00404 	addi	sp,sp,16
21096a7c:	f800283a 	ret
21096a80:	30c00617 	ldw	r3,24(r6)
21096a84:	10c00616 	blt	r2,r3,21096aa0 <_putc_r+0x74>
21096a88:	30800017 	ldw	r2,0(r6)
21096a8c:	00c00284 	movi	r3,10
21096a90:	11400005 	stb	r5,0(r2)
21096a94:	30800017 	ldw	r2,0(r6)
21096a98:	11400003 	ldbu	r5,0(r2)
21096a9c:	28fff11e 	bne	r5,r3,21096a64 <__flash_rwdata_start+0xffff481c>
21096aa0:	8009883a 	mov	r4,r16
21096aa4:	dfc00317 	ldw	ra,12(sp)
21096aa8:	dc000217 	ldw	r16,8(sp)
21096aac:	dec00404 	addi	sp,sp,16
21096ab0:	1099adc1 	jmpi	21099adc <__swbuf_r>
21096ab4:	d9400015 	stw	r5,0(sp)
21096ab8:	d9800115 	stw	r6,4(sp)
21096abc:	1094b040 	call	21094b04 <__sinit>
21096ac0:	d9800117 	ldw	r6,4(sp)
21096ac4:	d9400017 	ldw	r5,0(sp)
21096ac8:	003fdf06 	br	21096a48 <__flash_rwdata_start+0xffff4800>

21096acc <putc>:
21096acc:	00800034 	movhi	r2,0
21096ad0:	defffc04 	addi	sp,sp,-16
21096ad4:	10976b04 	addi	r2,r2,23980
21096ad8:	dc400115 	stw	r17,4(sp)
21096adc:	14400017 	ldw	r17,0(r2)
21096ae0:	dc800215 	stw	r18,8(sp)
21096ae4:	dc000015 	stw	r16,0(sp)
21096ae8:	dfc00315 	stw	ra,12(sp)
21096aec:	2025883a 	mov	r18,r4
21096af0:	2821883a 	mov	r16,r5
21096af4:	88000226 	beq	r17,zero,21096b00 <putc+0x34>
21096af8:	88800e17 	ldw	r2,56(r17)
21096afc:	10001a26 	beq	r2,zero,21096b68 <putc+0x9c>
21096b00:	80800217 	ldw	r2,8(r16)
21096b04:	10bfffc4 	addi	r2,r2,-1
21096b08:	80800215 	stw	r2,8(r16)
21096b0c:	10000c16 	blt	r2,zero,21096b40 <putc+0x74>
21096b10:	80800017 	ldw	r2,0(r16)
21096b14:	14800005 	stb	r18,0(r2)
21096b18:	80800017 	ldw	r2,0(r16)
21096b1c:	10c00044 	addi	r3,r2,1
21096b20:	80c00015 	stw	r3,0(r16)
21096b24:	10800003 	ldbu	r2,0(r2)
21096b28:	dfc00317 	ldw	ra,12(sp)
21096b2c:	dc800217 	ldw	r18,8(sp)
21096b30:	dc400117 	ldw	r17,4(sp)
21096b34:	dc000017 	ldw	r16,0(sp)
21096b38:	dec00404 	addi	sp,sp,16
21096b3c:	f800283a 	ret
21096b40:	80c00617 	ldw	r3,24(r16)
21096b44:	10c00b16 	blt	r2,r3,21096b74 <putc+0xa8>
21096b48:	80800017 	ldw	r2,0(r16)
21096b4c:	00c00284 	movi	r3,10
21096b50:	14800005 	stb	r18,0(r2)
21096b54:	80800017 	ldw	r2,0(r16)
21096b58:	11400003 	ldbu	r5,0(r2)
21096b5c:	28ffef1e 	bne	r5,r3,21096b1c <__flash_rwdata_start+0xffff48d4>
21096b60:	8809883a 	mov	r4,r17
21096b64:	00000506 	br	21096b7c <putc+0xb0>
21096b68:	8809883a 	mov	r4,r17
21096b6c:	1094b040 	call	21094b04 <__sinit>
21096b70:	003fe306 	br	21096b00 <__flash_rwdata_start+0xffff48b8>
21096b74:	8809883a 	mov	r4,r17
21096b78:	900b883a 	mov	r5,r18
21096b7c:	800d883a 	mov	r6,r16
21096b80:	dfc00317 	ldw	ra,12(sp)
21096b84:	dc800217 	ldw	r18,8(sp)
21096b88:	dc400117 	ldw	r17,4(sp)
21096b8c:	dc000017 	ldw	r16,0(sp)
21096b90:	dec00404 	addi	sp,sp,16
21096b94:	1099adc1 	jmpi	21099adc <__swbuf_r>

21096b98 <_realloc_r>:
21096b98:	defff604 	addi	sp,sp,-40
21096b9c:	dd000415 	stw	r20,16(sp)
21096ba0:	dc400115 	stw	r17,4(sp)
21096ba4:	dfc00915 	stw	ra,36(sp)
21096ba8:	df000815 	stw	fp,32(sp)
21096bac:	ddc00715 	stw	r23,28(sp)
21096bb0:	dd800615 	stw	r22,24(sp)
21096bb4:	dd400515 	stw	r21,20(sp)
21096bb8:	dcc00315 	stw	r19,12(sp)
21096bbc:	dc800215 	stw	r18,8(sp)
21096bc0:	dc000015 	stw	r16,0(sp)
21096bc4:	2829883a 	mov	r20,r5
21096bc8:	3023883a 	mov	r17,r6
21096bcc:	2800ad26 	beq	r5,zero,21096e84 <_realloc_r+0x2ec>
21096bd0:	2025883a 	mov	r18,r4
21096bd4:	109b5540 	call	2109b554 <__malloc_lock>
21096bd8:	a0ffff17 	ldw	r3,-4(r20)
21096bdc:	043fff04 	movi	r16,-4
21096be0:	890002c4 	addi	r4,r17,11
21096be4:	01c00584 	movi	r7,22
21096be8:	a57ffe04 	addi	r21,r20,-8
21096bec:	1c20703a 	and	r16,r3,r16
21096bf0:	39001d2e 	bgeu	r7,r4,21096c68 <_realloc_r+0xd0>
21096bf4:	05bffe04 	movi	r22,-8
21096bf8:	25ac703a 	and	r22,r4,r22
21096bfc:	b00f883a 	mov	r7,r22
21096c00:	b0006516 	blt	r22,zero,21096d98 <_realloc_r+0x200>
21096c04:	b4406436 	bltu	r22,r17,21096d98 <_realloc_r+0x200>
21096c08:	81c01a0e 	bge	r16,r7,21096c74 <_realloc_r+0xdc>
21096c0c:	07000034 	movhi	fp,0
21096c10:	e7115504 	addi	fp,fp,17748
21096c14:	e1400217 	ldw	r5,8(fp)
21096c18:	ac11883a 	add	r8,r21,r16
21096c1c:	2a006226 	beq	r5,r8,21096da8 <_realloc_r+0x210>
21096c20:	41800117 	ldw	r6,4(r8)
21096c24:	027fff84 	movi	r9,-2
21096c28:	3252703a 	and	r9,r6,r9
21096c2c:	4253883a 	add	r9,r8,r9
21096c30:	49000117 	ldw	r4,4(r9)
21096c34:	2100004c 	andi	r4,r4,1
21096c38:	2000281e 	bne	r4,zero,21096cdc <_realloc_r+0x144>
21096c3c:	00bfff04 	movi	r2,-4
21096c40:	3084703a 	and	r2,r6,r2
21096c44:	1409883a 	add	r4,r2,r16
21096c48:	21c05e16 	blt	r4,r7,21096dc4 <_realloc_r+0x22c>
21096c4c:	40800317 	ldw	r2,12(r8)
21096c50:	41400217 	ldw	r5,8(r8)
21096c54:	a023883a 	mov	r17,r20
21096c58:	2021883a 	mov	r16,r4
21096c5c:	28800315 	stw	r2,12(r5)
21096c60:	11400215 	stw	r5,8(r2)
21096c64:	00000406 	br	21096c78 <_realloc_r+0xe0>
21096c68:	01c00404 	movi	r7,16
21096c6c:	382d883a 	mov	r22,r7
21096c70:	003fe406 	br	21096c04 <__flash_rwdata_start+0xffff49bc>
21096c74:	a023883a 	mov	r17,r20
21096c78:	858fc83a 	sub	r7,r16,r22
21096c7c:	008003c4 	movi	r2,15
21096c80:	18c0004c 	andi	r3,r3,1
21096c84:	11c07236 	bltu	r2,r7,21096e50 <_realloc_r+0x2b8>
21096c88:	1c06b03a 	or	r3,r3,r16
21096c8c:	a8c00115 	stw	r3,4(r21)
21096c90:	ac21883a 	add	r16,r21,r16
21096c94:	80800117 	ldw	r2,4(r16)
21096c98:	10800054 	ori	r2,r2,1
21096c9c:	80800115 	stw	r2,4(r16)
21096ca0:	9009883a 	mov	r4,r18
21096ca4:	109b5580 	call	2109b558 <__malloc_unlock>
21096ca8:	8805883a 	mov	r2,r17
21096cac:	dfc00917 	ldw	ra,36(sp)
21096cb0:	df000817 	ldw	fp,32(sp)
21096cb4:	ddc00717 	ldw	r23,28(sp)
21096cb8:	dd800617 	ldw	r22,24(sp)
21096cbc:	dd400517 	ldw	r21,20(sp)
21096cc0:	dd000417 	ldw	r20,16(sp)
21096cc4:	dcc00317 	ldw	r19,12(sp)
21096cc8:	dc800217 	ldw	r18,8(sp)
21096ccc:	dc400117 	ldw	r17,4(sp)
21096cd0:	dc000017 	ldw	r16,0(sp)
21096cd4:	dec00a04 	addi	sp,sp,40
21096cd8:	f800283a 	ret
21096cdc:	18c0004c 	andi	r3,r3,1
21096ce0:	1800081e 	bne	r3,zero,21096d04 <_realloc_r+0x16c>
21096ce4:	a4fffe17 	ldw	r19,-8(r20)
21096ce8:	00bfff04 	movi	r2,-4
21096cec:	ace7c83a 	sub	r19,r21,r19
21096cf0:	98c00117 	ldw	r3,4(r19)
21096cf4:	1886703a 	and	r3,r3,r2
21096cf8:	98000226 	beq	r19,zero,21096d04 <_realloc_r+0x16c>
21096cfc:	1c2f883a 	add	r23,r3,r16
21096d00:	b9c06d0e 	bge	r23,r7,21096eb8 <_realloc_r+0x320>
21096d04:	880b883a 	mov	r5,r17
21096d08:	9009883a 	mov	r4,r18
21096d0c:	108d9100 	call	2108d910 <_malloc_r>
21096d10:	1023883a 	mov	r17,r2
21096d14:	1000ef26 	beq	r2,zero,210970d4 <_realloc_r+0x53c>
21096d18:	a0ffff17 	ldw	r3,-4(r20)
21096d1c:	113ffe04 	addi	r4,r2,-8
21096d20:	00bfff84 	movi	r2,-2
21096d24:	1884703a 	and	r2,r3,r2
21096d28:	a885883a 	add	r2,r21,r2
21096d2c:	2080bf26 	beq	r4,r2,2109702c <_realloc_r+0x494>
21096d30:	81bfff04 	addi	r6,r16,-4
21096d34:	00800904 	movi	r2,36
21096d38:	11808936 	bltu	r2,r6,21096f60 <_realloc_r+0x3c8>
21096d3c:	00c004c4 	movi	r3,19
21096d40:	19806c2e 	bgeu	r3,r6,21096ef4 <_realloc_r+0x35c>
21096d44:	a0c00017 	ldw	r3,0(r20)
21096d48:	88c00015 	stw	r3,0(r17)
21096d4c:	a0c00117 	ldw	r3,4(r20)
21096d50:	88c00115 	stw	r3,4(r17)
21096d54:	00c006c4 	movi	r3,27
21096d58:	1980ac36 	bltu	r3,r6,2109700c <_realloc_r+0x474>
21096d5c:	88800204 	addi	r2,r17,8
21096d60:	a0c00204 	addi	r3,r20,8
21096d64:	19000017 	ldw	r4,0(r3)
21096d68:	11000015 	stw	r4,0(r2)
21096d6c:	19000117 	ldw	r4,4(r3)
21096d70:	11000115 	stw	r4,4(r2)
21096d74:	18c00217 	ldw	r3,8(r3)
21096d78:	10c00215 	stw	r3,8(r2)
21096d7c:	a00b883a 	mov	r5,r20
21096d80:	9009883a 	mov	r4,r18
21096d84:	1094c780 	call	21094c78 <_free_r>
21096d88:	9009883a 	mov	r4,r18
21096d8c:	109b5580 	call	2109b558 <__malloc_unlock>
21096d90:	8805883a 	mov	r2,r17
21096d94:	003fc506 	br	21096cac <__flash_rwdata_start+0xffff4a64>
21096d98:	00800304 	movi	r2,12
21096d9c:	90800015 	stw	r2,0(r18)
21096da0:	0005883a 	mov	r2,zero
21096da4:	003fc106 	br	21096cac <__flash_rwdata_start+0xffff4a64>
21096da8:	29800117 	ldw	r6,4(r5)
21096dac:	00bfff04 	movi	r2,-4
21096db0:	b1000404 	addi	r4,r22,16
21096db4:	3084703a 	and	r2,r6,r2
21096db8:	140d883a 	add	r6,r2,r16
21096dbc:	31005b0e 	bge	r6,r4,21096f2c <_realloc_r+0x394>
21096dc0:	2811883a 	mov	r8,r5
21096dc4:	18c0004c 	andi	r3,r3,1
21096dc8:	183fce1e 	bne	r3,zero,21096d04 <__flash_rwdata_start+0xffff4abc>
21096dcc:	a4fffe17 	ldw	r19,-8(r20)
21096dd0:	00ffff04 	movi	r3,-4
21096dd4:	ace7c83a 	sub	r19,r21,r19
21096dd8:	99000117 	ldw	r4,4(r19)
21096ddc:	20c6703a 	and	r3,r4,r3
21096de0:	403fc526 	beq	r8,zero,21096cf8 <__flash_rwdata_start+0xffff4ab0>
21096de4:	1c2f883a 	add	r23,r3,r16
21096de8:	b8af883a 	add	r23,r23,r2
21096dec:	41406026 	beq	r8,r5,21096f70 <_realloc_r+0x3d8>
21096df0:	b9ffc116 	blt	r23,r7,21096cf8 <__flash_rwdata_start+0xffff4ab0>
21096df4:	40c00217 	ldw	r3,8(r8)
21096df8:	40800317 	ldw	r2,12(r8)
21096dfc:	81bfff04 	addi	r6,r16,-4
21096e00:	01000904 	movi	r4,36
21096e04:	18800315 	stw	r2,12(r3)
21096e08:	10c00215 	stw	r3,8(r2)
21096e0c:	99400217 	ldw	r5,8(r19)
21096e10:	98c00317 	ldw	r3,12(r19)
21096e14:	9c400204 	addi	r17,r19,8
21096e18:	28c00315 	stw	r3,12(r5)
21096e1c:	19400215 	stw	r5,8(r3)
21096e20:	21802d36 	bltu	r4,r6,21096ed8 <_realloc_r+0x340>
21096e24:	008004c4 	movi	r2,19
21096e28:	1180352e 	bgeu	r2,r6,21096f00 <_realloc_r+0x368>
21096e2c:	a0800017 	ldw	r2,0(r20)
21096e30:	98800215 	stw	r2,8(r19)
21096e34:	a0800117 	ldw	r2,4(r20)
21096e38:	98800315 	stw	r2,12(r19)
21096e3c:	008006c4 	movi	r2,27
21096e40:	11808036 	bltu	r2,r6,21097044 <_realloc_r+0x4ac>
21096e44:	98c00404 	addi	r3,r19,16
21096e48:	a5000204 	addi	r20,r20,8
21096e4c:	00002d06 	br	21096f04 <_realloc_r+0x36c>
21096e50:	1d86b03a 	or	r3,r3,r22
21096e54:	ad8b883a 	add	r5,r21,r22
21096e58:	a8c00115 	stw	r3,4(r21)
21096e5c:	38800054 	ori	r2,r7,1
21096e60:	28800115 	stw	r2,4(r5)
21096e64:	29cf883a 	add	r7,r5,r7
21096e68:	38800117 	ldw	r2,4(r7)
21096e6c:	9009883a 	mov	r4,r18
21096e70:	29400204 	addi	r5,r5,8
21096e74:	10800054 	ori	r2,r2,1
21096e78:	38800115 	stw	r2,4(r7)
21096e7c:	1094c780 	call	21094c78 <_free_r>
21096e80:	003f8706 	br	21096ca0 <__flash_rwdata_start+0xffff4a58>
21096e84:	300b883a 	mov	r5,r6
21096e88:	dfc00917 	ldw	ra,36(sp)
21096e8c:	df000817 	ldw	fp,32(sp)
21096e90:	ddc00717 	ldw	r23,28(sp)
21096e94:	dd800617 	ldw	r22,24(sp)
21096e98:	dd400517 	ldw	r21,20(sp)
21096e9c:	dd000417 	ldw	r20,16(sp)
21096ea0:	dcc00317 	ldw	r19,12(sp)
21096ea4:	dc800217 	ldw	r18,8(sp)
21096ea8:	dc400117 	ldw	r17,4(sp)
21096eac:	dc000017 	ldw	r16,0(sp)
21096eb0:	dec00a04 	addi	sp,sp,40
21096eb4:	108d9101 	jmpi	2108d910 <_malloc_r>
21096eb8:	98800317 	ldw	r2,12(r19)
21096ebc:	98c00217 	ldw	r3,8(r19)
21096ec0:	81bfff04 	addi	r6,r16,-4
21096ec4:	01000904 	movi	r4,36
21096ec8:	18800315 	stw	r2,12(r3)
21096ecc:	10c00215 	stw	r3,8(r2)
21096ed0:	9c400204 	addi	r17,r19,8
21096ed4:	21bfd32e 	bgeu	r4,r6,21096e24 <__flash_rwdata_start+0xffff4bdc>
21096ed8:	8809883a 	mov	r4,r17
21096edc:	a00b883a 	mov	r5,r20
21096ee0:	10959300 	call	21095930 <memmove>
21096ee4:	98c00117 	ldw	r3,4(r19)
21096ee8:	b821883a 	mov	r16,r23
21096eec:	982b883a 	mov	r21,r19
21096ef0:	003f6106 	br	21096c78 <__flash_rwdata_start+0xffff4a30>
21096ef4:	8805883a 	mov	r2,r17
21096ef8:	a007883a 	mov	r3,r20
21096efc:	003f9906 	br	21096d64 <__flash_rwdata_start+0xffff4b1c>
21096f00:	8807883a 	mov	r3,r17
21096f04:	a0800017 	ldw	r2,0(r20)
21096f08:	b821883a 	mov	r16,r23
21096f0c:	982b883a 	mov	r21,r19
21096f10:	18800015 	stw	r2,0(r3)
21096f14:	a0800117 	ldw	r2,4(r20)
21096f18:	18800115 	stw	r2,4(r3)
21096f1c:	a0800217 	ldw	r2,8(r20)
21096f20:	18800215 	stw	r2,8(r3)
21096f24:	98c00117 	ldw	r3,4(r19)
21096f28:	003f5306 	br	21096c78 <__flash_rwdata_start+0xffff4a30>
21096f2c:	adab883a 	add	r21,r21,r22
21096f30:	3585c83a 	sub	r2,r6,r22
21096f34:	e5400215 	stw	r21,8(fp)
21096f38:	10800054 	ori	r2,r2,1
21096f3c:	a8800115 	stw	r2,4(r21)
21096f40:	a0bfff17 	ldw	r2,-4(r20)
21096f44:	9009883a 	mov	r4,r18
21096f48:	1080004c 	andi	r2,r2,1
21096f4c:	b0acb03a 	or	r22,r22,r2
21096f50:	a5bfff15 	stw	r22,-4(r20)
21096f54:	109b5580 	call	2109b558 <__malloc_unlock>
21096f58:	a005883a 	mov	r2,r20
21096f5c:	003f5306 	br	21096cac <__flash_rwdata_start+0xffff4a64>
21096f60:	8809883a 	mov	r4,r17
21096f64:	a00b883a 	mov	r5,r20
21096f68:	10959300 	call	21095930 <memmove>
21096f6c:	003f8306 	br	21096d7c <__flash_rwdata_start+0xffff4b34>
21096f70:	b0800404 	addi	r2,r22,16
21096f74:	b8bf6016 	blt	r23,r2,21096cf8 <__flash_rwdata_start+0xffff4ab0>
21096f78:	98800317 	ldw	r2,12(r19)
21096f7c:	98c00217 	ldw	r3,8(r19)
21096f80:	81bfff04 	addi	r6,r16,-4
21096f84:	01000904 	movi	r4,36
21096f88:	18800315 	stw	r2,12(r3)
21096f8c:	10c00215 	stw	r3,8(r2)
21096f90:	9c400204 	addi	r17,r19,8
21096f94:	21804336 	bltu	r4,r6,210970a4 <_realloc_r+0x50c>
21096f98:	008004c4 	movi	r2,19
21096f9c:	11803f2e 	bgeu	r2,r6,2109709c <_realloc_r+0x504>
21096fa0:	a0800017 	ldw	r2,0(r20)
21096fa4:	98800215 	stw	r2,8(r19)
21096fa8:	a0800117 	ldw	r2,4(r20)
21096fac:	98800315 	stw	r2,12(r19)
21096fb0:	008006c4 	movi	r2,27
21096fb4:	11803f36 	bltu	r2,r6,210970b4 <_realloc_r+0x51c>
21096fb8:	98800404 	addi	r2,r19,16
21096fbc:	a5000204 	addi	r20,r20,8
21096fc0:	a0c00017 	ldw	r3,0(r20)
21096fc4:	10c00015 	stw	r3,0(r2)
21096fc8:	a0c00117 	ldw	r3,4(r20)
21096fcc:	10c00115 	stw	r3,4(r2)
21096fd0:	a0c00217 	ldw	r3,8(r20)
21096fd4:	10c00215 	stw	r3,8(r2)
21096fd8:	9d87883a 	add	r3,r19,r22
21096fdc:	bd85c83a 	sub	r2,r23,r22
21096fe0:	e0c00215 	stw	r3,8(fp)
21096fe4:	10800054 	ori	r2,r2,1
21096fe8:	18800115 	stw	r2,4(r3)
21096fec:	98800117 	ldw	r2,4(r19)
21096ff0:	9009883a 	mov	r4,r18
21096ff4:	1080004c 	andi	r2,r2,1
21096ff8:	b0acb03a 	or	r22,r22,r2
21096ffc:	9d800115 	stw	r22,4(r19)
21097000:	109b5580 	call	2109b558 <__malloc_unlock>
21097004:	8805883a 	mov	r2,r17
21097008:	003f2806 	br	21096cac <__flash_rwdata_start+0xffff4a64>
2109700c:	a0c00217 	ldw	r3,8(r20)
21097010:	88c00215 	stw	r3,8(r17)
21097014:	a0c00317 	ldw	r3,12(r20)
21097018:	88c00315 	stw	r3,12(r17)
2109701c:	30801126 	beq	r6,r2,21097064 <_realloc_r+0x4cc>
21097020:	88800404 	addi	r2,r17,16
21097024:	a0c00404 	addi	r3,r20,16
21097028:	003f4e06 	br	21096d64 <__flash_rwdata_start+0xffff4b1c>
2109702c:	893fff17 	ldw	r4,-4(r17)
21097030:	00bfff04 	movi	r2,-4
21097034:	a023883a 	mov	r17,r20
21097038:	2084703a 	and	r2,r4,r2
2109703c:	80a1883a 	add	r16,r16,r2
21097040:	003f0d06 	br	21096c78 <__flash_rwdata_start+0xffff4a30>
21097044:	a0800217 	ldw	r2,8(r20)
21097048:	98800415 	stw	r2,16(r19)
2109704c:	a0800317 	ldw	r2,12(r20)
21097050:	98800515 	stw	r2,20(r19)
21097054:	31000a26 	beq	r6,r4,21097080 <_realloc_r+0x4e8>
21097058:	98c00604 	addi	r3,r19,24
2109705c:	a5000404 	addi	r20,r20,16
21097060:	003fa806 	br	21096f04 <__flash_rwdata_start+0xffff4cbc>
21097064:	a1000417 	ldw	r4,16(r20)
21097068:	88800604 	addi	r2,r17,24
2109706c:	a0c00604 	addi	r3,r20,24
21097070:	89000415 	stw	r4,16(r17)
21097074:	a1000517 	ldw	r4,20(r20)
21097078:	89000515 	stw	r4,20(r17)
2109707c:	003f3906 	br	21096d64 <__flash_rwdata_start+0xffff4b1c>
21097080:	a0800417 	ldw	r2,16(r20)
21097084:	a5000604 	addi	r20,r20,24
21097088:	98c00804 	addi	r3,r19,32
2109708c:	98800615 	stw	r2,24(r19)
21097090:	a0bfff17 	ldw	r2,-4(r20)
21097094:	98800715 	stw	r2,28(r19)
21097098:	003f9a06 	br	21096f04 <__flash_rwdata_start+0xffff4cbc>
2109709c:	8805883a 	mov	r2,r17
210970a0:	003fc706 	br	21096fc0 <__flash_rwdata_start+0xffff4d78>
210970a4:	8809883a 	mov	r4,r17
210970a8:	a00b883a 	mov	r5,r20
210970ac:	10959300 	call	21095930 <memmove>
210970b0:	003fc906 	br	21096fd8 <__flash_rwdata_start+0xffff4d90>
210970b4:	a0800217 	ldw	r2,8(r20)
210970b8:	98800415 	stw	r2,16(r19)
210970bc:	a0800317 	ldw	r2,12(r20)
210970c0:	98800515 	stw	r2,20(r19)
210970c4:	31000726 	beq	r6,r4,210970e4 <_realloc_r+0x54c>
210970c8:	98800604 	addi	r2,r19,24
210970cc:	a5000404 	addi	r20,r20,16
210970d0:	003fbb06 	br	21096fc0 <__flash_rwdata_start+0xffff4d78>
210970d4:	9009883a 	mov	r4,r18
210970d8:	109b5580 	call	2109b558 <__malloc_unlock>
210970dc:	0005883a 	mov	r2,zero
210970e0:	003ef206 	br	21096cac <__flash_rwdata_start+0xffff4a64>
210970e4:	a0c00417 	ldw	r3,16(r20)
210970e8:	a5000604 	addi	r20,r20,24
210970ec:	98800804 	addi	r2,r19,32
210970f0:	98c00615 	stw	r3,24(r19)
210970f4:	a0ffff17 	ldw	r3,-4(r20)
210970f8:	98c00715 	stw	r3,28(r19)
210970fc:	003fb006 	br	21096fc0 <__flash_rwdata_start+0xffff4d78>

21097100 <__fpclassifyd>:
21097100:	00a00034 	movhi	r2,32768
21097104:	10bfffc4 	addi	r2,r2,-1
21097108:	2884703a 	and	r2,r5,r2
2109710c:	10000726 	beq	r2,zero,2109712c <__fpclassifyd+0x2c>
21097110:	00fffc34 	movhi	r3,65520
21097114:	019ff834 	movhi	r6,32736
21097118:	28c7883a 	add	r3,r5,r3
2109711c:	31bfffc4 	addi	r6,r6,-1
21097120:	30c00536 	bltu	r6,r3,21097138 <__fpclassifyd+0x38>
21097124:	00800104 	movi	r2,4
21097128:	f800283a 	ret
2109712c:	2000021e 	bne	r4,zero,21097138 <__fpclassifyd+0x38>
21097130:	00800084 	movi	r2,2
21097134:	f800283a 	ret
21097138:	00dffc34 	movhi	r3,32752
2109713c:	019ff834 	movhi	r6,32736
21097140:	28cb883a 	add	r5,r5,r3
21097144:	31bfffc4 	addi	r6,r6,-1
21097148:	317ff62e 	bgeu	r6,r5,21097124 <__flash_rwdata_start+0xffff4edc>
2109714c:	01400434 	movhi	r5,16
21097150:	297fffc4 	addi	r5,r5,-1
21097154:	28800236 	bltu	r5,r2,21097160 <__fpclassifyd+0x60>
21097158:	008000c4 	movi	r2,3
2109715c:	f800283a 	ret
21097160:	10c00226 	beq	r2,r3,2109716c <__fpclassifyd+0x6c>
21097164:	0005883a 	mov	r2,zero
21097168:	f800283a 	ret
2109716c:	2005003a 	cmpeq	r2,r4,zero
21097170:	f800283a 	ret

21097174 <__sread>:
21097174:	defffe04 	addi	sp,sp,-8
21097178:	dc000015 	stw	r16,0(sp)
2109717c:	2821883a 	mov	r16,r5
21097180:	2940038f 	ldh	r5,14(r5)
21097184:	dfc00115 	stw	ra,4(sp)
21097188:	109a1900 	call	2109a190 <_read_r>
2109718c:	10000716 	blt	r2,zero,210971ac <__sread+0x38>
21097190:	80c01417 	ldw	r3,80(r16)
21097194:	1887883a 	add	r3,r3,r2
21097198:	80c01415 	stw	r3,80(r16)
2109719c:	dfc00117 	ldw	ra,4(sp)
210971a0:	dc000017 	ldw	r16,0(sp)
210971a4:	dec00204 	addi	sp,sp,8
210971a8:	f800283a 	ret
210971ac:	80c0030b 	ldhu	r3,12(r16)
210971b0:	18fbffcc 	andi	r3,r3,61439
210971b4:	80c0030d 	sth	r3,12(r16)
210971b8:	dfc00117 	ldw	ra,4(sp)
210971bc:	dc000017 	ldw	r16,0(sp)
210971c0:	dec00204 	addi	sp,sp,8
210971c4:	f800283a 	ret

210971c8 <__seofread>:
210971c8:	0005883a 	mov	r2,zero
210971cc:	f800283a 	ret

210971d0 <__swrite>:
210971d0:	2880030b 	ldhu	r2,12(r5)
210971d4:	defffb04 	addi	sp,sp,-20
210971d8:	dcc00315 	stw	r19,12(sp)
210971dc:	dc800215 	stw	r18,8(sp)
210971e0:	dc400115 	stw	r17,4(sp)
210971e4:	dc000015 	stw	r16,0(sp)
210971e8:	dfc00415 	stw	ra,16(sp)
210971ec:	10c0400c 	andi	r3,r2,256
210971f0:	2821883a 	mov	r16,r5
210971f4:	2027883a 	mov	r19,r4
210971f8:	3025883a 	mov	r18,r6
210971fc:	3823883a 	mov	r17,r7
21097200:	18000526 	beq	r3,zero,21097218 <__swrite+0x48>
21097204:	2940038f 	ldh	r5,14(r5)
21097208:	000d883a 	mov	r6,zero
2109720c:	01c00084 	movi	r7,2
21097210:	109a1340 	call	2109a134 <_lseek_r>
21097214:	8080030b 	ldhu	r2,12(r16)
21097218:	8140038f 	ldh	r5,14(r16)
2109721c:	10bbffcc 	andi	r2,r2,61439
21097220:	9809883a 	mov	r4,r19
21097224:	900d883a 	mov	r6,r18
21097228:	880f883a 	mov	r7,r17
2109722c:	8080030d 	sth	r2,12(r16)
21097230:	dfc00417 	ldw	ra,16(sp)
21097234:	dcc00317 	ldw	r19,12(sp)
21097238:	dc800217 	ldw	r18,8(sp)
2109723c:	dc400117 	ldw	r17,4(sp)
21097240:	dc000017 	ldw	r16,0(sp)
21097244:	dec00504 	addi	sp,sp,20
21097248:	1099c301 	jmpi	21099c30 <_write_r>

2109724c <__sseek>:
2109724c:	defffe04 	addi	sp,sp,-8
21097250:	dc000015 	stw	r16,0(sp)
21097254:	2821883a 	mov	r16,r5
21097258:	2940038f 	ldh	r5,14(r5)
2109725c:	dfc00115 	stw	ra,4(sp)
21097260:	109a1340 	call	2109a134 <_lseek_r>
21097264:	00ffffc4 	movi	r3,-1
21097268:	10c00826 	beq	r2,r3,2109728c <__sseek+0x40>
2109726c:	80c0030b 	ldhu	r3,12(r16)
21097270:	80801415 	stw	r2,80(r16)
21097274:	18c40014 	ori	r3,r3,4096
21097278:	80c0030d 	sth	r3,12(r16)
2109727c:	dfc00117 	ldw	ra,4(sp)
21097280:	dc000017 	ldw	r16,0(sp)
21097284:	dec00204 	addi	sp,sp,8
21097288:	f800283a 	ret
2109728c:	80c0030b 	ldhu	r3,12(r16)
21097290:	18fbffcc 	andi	r3,r3,61439
21097294:	80c0030d 	sth	r3,12(r16)
21097298:	dfc00117 	ldw	ra,4(sp)
2109729c:	dc000017 	ldw	r16,0(sp)
210972a0:	dec00204 	addi	sp,sp,8
210972a4:	f800283a 	ret

210972a8 <__sclose>:
210972a8:	2940038f 	ldh	r5,14(r5)
210972ac:	1099c8c1 	jmpi	21099c8c <_close_r>

210972b0 <strchr>:
210972b0:	2ac03fcc 	andi	r11,r5,255
210972b4:	2815883a 	mov	r10,r5
210972b8:	208000cc 	andi	r2,r4,3
210972bc:	58003726 	beq	r11,zero,2109739c <strchr+0xec>
210972c0:	10000b26 	beq	r2,zero,210972f0 <strchr+0x40>
210972c4:	20800003 	ldbu	r2,0(r4)
210972c8:	10003226 	beq	r2,zero,21097394 <strchr+0xe4>
210972cc:	28c03fcc 	andi	r3,r5,255
210972d0:	5880041e 	bne	r11,r2,210972e4 <strchr+0x34>
210972d4:	00004d06 	br	2109740c <strchr+0x15c>
210972d8:	20800003 	ldbu	r2,0(r4)
210972dc:	10002d26 	beq	r2,zero,21097394 <strchr+0xe4>
210972e0:	18804a26 	beq	r3,r2,2109740c <strchr+0x15c>
210972e4:	21000044 	addi	r4,r4,1
210972e8:	208000cc 	andi	r2,r4,3
210972ec:	103ffa1e 	bne	r2,zero,210972d8 <__flash_rwdata_start+0xffff5090>
210972f0:	29403fcc 	andi	r5,r5,255
210972f4:	280e923a 	slli	r7,r5,8
210972f8:	20800017 	ldw	r2,0(r4)
210972fc:	01bfbff4 	movhi	r6,65279
21097300:	394ab03a 	or	r5,r7,r5
21097304:	280e943a 	slli	r7,r5,16
21097308:	31bfbfc4 	addi	r6,r6,-257
2109730c:	0090303a 	nor	r8,zero,r2
21097310:	394eb03a 	or	r7,r7,r5
21097314:	1187883a 	add	r3,r2,r6
21097318:	11c4f03a 	xor	r2,r2,r7
2109731c:	008a303a 	nor	r5,zero,r2
21097320:	1185883a 	add	r2,r2,r6
21097324:	03202074 	movhi	r12,32897
21097328:	2884703a 	and	r2,r5,r2
2109732c:	40c6703a 	and	r3,r8,r3
21097330:	63202004 	addi	r12,r12,-32640
21097334:	10c4b03a 	or	r2,r2,r3
21097338:	1304703a 	and	r2,r2,r12
2109733c:	10000c1e 	bne	r2,zero,21097370 <strchr+0xc0>
21097340:	21000104 	addi	r4,r4,4
21097344:	20800017 	ldw	r2,0(r4)
21097348:	3886f03a 	xor	r3,r7,r2
2109734c:	00d2303a 	nor	r9,zero,r3
21097350:	198b883a 	add	r5,r3,r6
21097354:	0090303a 	nor	r8,zero,r2
21097358:	1187883a 	add	r3,r2,r6
2109735c:	494a703a 	and	r5,r9,r5
21097360:	40c4703a 	and	r2,r8,r3
21097364:	2884b03a 	or	r2,r5,r2
21097368:	1304703a 	and	r2,r2,r12
2109736c:	103ff426 	beq	r2,zero,21097340 <__flash_rwdata_start+0xffff50f8>
21097370:	20800003 	ldbu	r2,0(r4)
21097374:	10000726 	beq	r2,zero,21097394 <strchr+0xe4>
21097378:	58802426 	beq	r11,r2,2109740c <strchr+0x15c>
2109737c:	50c03fcc 	andi	r3,r10,255
21097380:	00000106 	br	21097388 <strchr+0xd8>
21097384:	18802126 	beq	r3,r2,2109740c <strchr+0x15c>
21097388:	21000044 	addi	r4,r4,1
2109738c:	20800003 	ldbu	r2,0(r4)
21097390:	103ffc1e 	bne	r2,zero,21097384 <__flash_rwdata_start+0xffff513c>
21097394:	0005883a 	mov	r2,zero
21097398:	f800283a 	ret
2109739c:	10000526 	beq	r2,zero,210973b4 <strchr+0x104>
210973a0:	20800003 	ldbu	r2,0(r4)
210973a4:	10001926 	beq	r2,zero,2109740c <strchr+0x15c>
210973a8:	21000044 	addi	r4,r4,1
210973ac:	208000cc 	andi	r2,r4,3
210973b0:	103ffb1e 	bne	r2,zero,210973a0 <__flash_rwdata_start+0xffff5158>
210973b4:	20800017 	ldw	r2,0(r4)
210973b8:	01bfbff4 	movhi	r6,65279
210973bc:	31bfbfc4 	addi	r6,r6,-257
210973c0:	0086303a 	nor	r3,zero,r2
210973c4:	01602074 	movhi	r5,32897
210973c8:	1185883a 	add	r2,r2,r6
210973cc:	29602004 	addi	r5,r5,-32640
210973d0:	10c4703a 	and	r2,r2,r3
210973d4:	1144703a 	and	r2,r2,r5
210973d8:	10000a1e 	bne	r2,zero,21097404 <strchr+0x154>
210973dc:	21000104 	addi	r4,r4,4
210973e0:	20800017 	ldw	r2,0(r4)
210973e4:	1187883a 	add	r3,r2,r6
210973e8:	0084303a 	nor	r2,zero,r2
210973ec:	1884703a 	and	r2,r3,r2
210973f0:	1144703a 	and	r2,r2,r5
210973f4:	103ff926 	beq	r2,zero,210973dc <__flash_rwdata_start+0xffff5194>
210973f8:	20800003 	ldbu	r2,0(r4)
210973fc:	10000326 	beq	r2,zero,2109740c <strchr+0x15c>
21097400:	21000044 	addi	r4,r4,1
21097404:	20800003 	ldbu	r2,0(r4)
21097408:	103ffd1e 	bne	r2,zero,21097400 <__flash_rwdata_start+0xffff51b8>
2109740c:	2005883a 	mov	r2,r4
21097410:	f800283a 	ret

21097414 <__ssprint_r>:
21097414:	30800217 	ldw	r2,8(r6)
21097418:	defff604 	addi	sp,sp,-40
2109741c:	ddc00715 	stw	r23,28(sp)
21097420:	dc800215 	stw	r18,8(sp)
21097424:	dfc00915 	stw	ra,36(sp)
21097428:	df000815 	stw	fp,32(sp)
2109742c:	dd800615 	stw	r22,24(sp)
21097430:	dd400515 	stw	r21,20(sp)
21097434:	dd000415 	stw	r20,16(sp)
21097438:	dcc00315 	stw	r19,12(sp)
2109743c:	dc400115 	stw	r17,4(sp)
21097440:	dc000015 	stw	r16,0(sp)
21097444:	3025883a 	mov	r18,r6
21097448:	35c00017 	ldw	r23,0(r6)
2109744c:	10005626 	beq	r2,zero,210975a8 <__ssprint_r+0x194>
21097450:	2027883a 	mov	r19,r4
21097454:	28800217 	ldw	r2,8(r5)
21097458:	29000017 	ldw	r4,0(r5)
2109745c:	2823883a 	mov	r17,r5
21097460:	0039883a 	mov	fp,zero
21097464:	0021883a 	mov	r16,zero
21097468:	80003926 	beq	r16,zero,21097550 <__ssprint_r+0x13c>
2109746c:	102b883a 	mov	r21,r2
21097470:	102d883a 	mov	r22,r2
21097474:	80803a36 	bltu	r16,r2,21097560 <__ssprint_r+0x14c>
21097478:	88c0030b 	ldhu	r3,12(r17)
2109747c:	1881200c 	andi	r2,r3,1152
21097480:	10002626 	beq	r2,zero,2109751c <__ssprint_r+0x108>
21097484:	88800517 	ldw	r2,20(r17)
21097488:	89400417 	ldw	r5,16(r17)
2109748c:	81c00044 	addi	r7,r16,1
21097490:	108d883a 	add	r6,r2,r2
21097494:	3085883a 	add	r2,r6,r2
21097498:	100cd7fa 	srli	r6,r2,31
2109749c:	216dc83a 	sub	r22,r4,r5
210974a0:	3d89883a 	add	r4,r7,r22
210974a4:	3085883a 	add	r2,r6,r2
210974a8:	102bd07a 	srai	r21,r2,1
210974ac:	a80d883a 	mov	r6,r21
210974b0:	a900022e 	bgeu	r21,r4,210974bc <__ssprint_r+0xa8>
210974b4:	202b883a 	mov	r21,r4
210974b8:	200d883a 	mov	r6,r4
210974bc:	18c1000c 	andi	r3,r3,1024
210974c0:	9809883a 	mov	r4,r19
210974c4:	18002926 	beq	r3,zero,2109756c <__ssprint_r+0x158>
210974c8:	300b883a 	mov	r5,r6
210974cc:	108d9100 	call	2108d910 <_malloc_r>
210974d0:	1029883a 	mov	r20,r2
210974d4:	10002b26 	beq	r2,zero,21097584 <__ssprint_r+0x170>
210974d8:	89400417 	ldw	r5,16(r17)
210974dc:	1009883a 	mov	r4,r2
210974e0:	b00d883a 	mov	r6,r22
210974e4:	108e1340 	call	2108e134 <memcpy>
210974e8:	8880030b 	ldhu	r2,12(r17)
210974ec:	00fedfc4 	movi	r3,-1153
210974f0:	10c4703a 	and	r2,r2,r3
210974f4:	10802014 	ori	r2,r2,128
210974f8:	8880030d 	sth	r2,12(r17)
210974fc:	a589883a 	add	r4,r20,r22
21097500:	adadc83a 	sub	r22,r21,r22
21097504:	8d400515 	stw	r21,20(r17)
21097508:	8d800215 	stw	r22,8(r17)
2109750c:	8d000415 	stw	r20,16(r17)
21097510:	89000015 	stw	r4,0(r17)
21097514:	802b883a 	mov	r21,r16
21097518:	802d883a 	mov	r22,r16
2109751c:	e00b883a 	mov	r5,fp
21097520:	b00d883a 	mov	r6,r22
21097524:	10959300 	call	21095930 <memmove>
21097528:	88800217 	ldw	r2,8(r17)
2109752c:	89000017 	ldw	r4,0(r17)
21097530:	90c00217 	ldw	r3,8(r18)
21097534:	1545c83a 	sub	r2,r2,r21
21097538:	2589883a 	add	r4,r4,r22
2109753c:	88800215 	stw	r2,8(r17)
21097540:	89000015 	stw	r4,0(r17)
21097544:	1c21c83a 	sub	r16,r3,r16
21097548:	94000215 	stw	r16,8(r18)
2109754c:	80001626 	beq	r16,zero,210975a8 <__ssprint_r+0x194>
21097550:	bf000017 	ldw	fp,0(r23)
21097554:	bc000117 	ldw	r16,4(r23)
21097558:	bdc00204 	addi	r23,r23,8
2109755c:	003fc206 	br	21097468 <__flash_rwdata_start+0xffff5220>
21097560:	802b883a 	mov	r21,r16
21097564:	802d883a 	mov	r22,r16
21097568:	003fec06 	br	2109751c <__flash_rwdata_start+0xffff52d4>
2109756c:	1096b980 	call	21096b98 <_realloc_r>
21097570:	1029883a 	mov	r20,r2
21097574:	103fe11e 	bne	r2,zero,210974fc <__flash_rwdata_start+0xffff52b4>
21097578:	89400417 	ldw	r5,16(r17)
2109757c:	9809883a 	mov	r4,r19
21097580:	1094c780 	call	21094c78 <_free_r>
21097584:	88c0030b 	ldhu	r3,12(r17)
21097588:	00800304 	movi	r2,12
2109758c:	98800015 	stw	r2,0(r19)
21097590:	18c01014 	ori	r3,r3,64
21097594:	88c0030d 	sth	r3,12(r17)
21097598:	00bfffc4 	movi	r2,-1
2109759c:	90000215 	stw	zero,8(r18)
210975a0:	90000115 	stw	zero,4(r18)
210975a4:	00000206 	br	210975b0 <__ssprint_r+0x19c>
210975a8:	90000115 	stw	zero,4(r18)
210975ac:	0005883a 	mov	r2,zero
210975b0:	dfc00917 	ldw	ra,36(sp)
210975b4:	df000817 	ldw	fp,32(sp)
210975b8:	ddc00717 	ldw	r23,28(sp)
210975bc:	dd800617 	ldw	r22,24(sp)
210975c0:	dd400517 	ldw	r21,20(sp)
210975c4:	dd000417 	ldw	r20,16(sp)
210975c8:	dcc00317 	ldw	r19,12(sp)
210975cc:	dc800217 	ldw	r18,8(sp)
210975d0:	dc400117 	ldw	r17,4(sp)
210975d4:	dc000017 	ldw	r16,0(sp)
210975d8:	dec00a04 	addi	sp,sp,40
210975dc:	f800283a 	ret

210975e0 <___svfiprintf_internal_r>:
210975e0:	2880030b 	ldhu	r2,12(r5)
210975e4:	deffc904 	addi	sp,sp,-220
210975e8:	dd403215 	stw	r21,200(sp)
210975ec:	dfc03615 	stw	ra,216(sp)
210975f0:	df003515 	stw	fp,212(sp)
210975f4:	ddc03415 	stw	r23,208(sp)
210975f8:	dd803315 	stw	r22,204(sp)
210975fc:	dd003115 	stw	r20,196(sp)
21097600:	dcc03015 	stw	r19,192(sp)
21097604:	dc802f15 	stw	r18,188(sp)
21097608:	dc402e15 	stw	r17,184(sp)
2109760c:	dc002d15 	stw	r16,180(sp)
21097610:	d9402715 	stw	r5,156(sp)
21097614:	d9002915 	stw	r4,164(sp)
21097618:	1080200c 	andi	r2,r2,128
2109761c:	d9c02315 	stw	r7,140(sp)
21097620:	302b883a 	mov	r21,r6
21097624:	10000226 	beq	r2,zero,21097630 <___svfiprintf_internal_r+0x50>
21097628:	28800417 	ldw	r2,16(r5)
2109762c:	1003ce26 	beq	r2,zero,21098568 <___svfiprintf_internal_r+0xf88>
21097630:	dac01a04 	addi	r11,sp,104
21097634:	da8019c4 	addi	r10,sp,103
21097638:	dc802917 	ldw	r18,164(sp)
2109763c:	dd002717 	ldw	r20,156(sp)
21097640:	04c00034 	movhi	r19,0
21097644:	dac01e15 	stw	r11,120(sp)
21097648:	5a97c83a 	sub	r11,r11,r10
2109764c:	9ccf3a04 	addi	r19,r19,15592
21097650:	da801f15 	stw	r10,124(sp)
21097654:	dec01a15 	stw	sp,104(sp)
21097658:	d8001c15 	stw	zero,112(sp)
2109765c:	d8001b15 	stw	zero,108(sp)
21097660:	d811883a 	mov	r8,sp
21097664:	d8002a15 	stw	zero,168(sp)
21097668:	d8002415 	stw	zero,144(sp)
2109766c:	dac02b15 	stw	r11,172(sp)
21097670:	a8800007 	ldb	r2,0(r21)
21097674:	10026a26 	beq	r2,zero,21098020 <___svfiprintf_internal_r+0xa40>
21097678:	01000944 	movi	r4,37
2109767c:	11026826 	beq	r2,r4,21098020 <___svfiprintf_internal_r+0xa40>
21097680:	a805883a 	mov	r2,r21
21097684:	00000106 	br	2109768c <___svfiprintf_internal_r+0xac>
21097688:	19000326 	beq	r3,r4,21097698 <___svfiprintf_internal_r+0xb8>
2109768c:	10800044 	addi	r2,r2,1
21097690:	10c00007 	ldb	r3,0(r2)
21097694:	183ffc1e 	bne	r3,zero,21097688 <__flash_rwdata_start+0xffff5440>
21097698:	1561c83a 	sub	r16,r2,r21
2109769c:	102d883a 	mov	r22,r2
210976a0:	80000e26 	beq	r16,zero,210976dc <___svfiprintf_internal_r+0xfc>
210976a4:	d8c01c17 	ldw	r3,112(sp)
210976a8:	d8801b17 	ldw	r2,108(sp)
210976ac:	45400015 	stw	r21,0(r8)
210976b0:	1c07883a 	add	r3,r3,r16
210976b4:	10800044 	addi	r2,r2,1
210976b8:	d8c01c15 	stw	r3,112(sp)
210976bc:	44000115 	stw	r16,4(r8)
210976c0:	d8801b15 	stw	r2,108(sp)
210976c4:	00c001c4 	movi	r3,7
210976c8:	1882d816 	blt	r3,r2,2109822c <___svfiprintf_internal_r+0xc4c>
210976cc:	42000204 	addi	r8,r8,8
210976d0:	da802417 	ldw	r10,144(sp)
210976d4:	5415883a 	add	r10,r10,r16
210976d8:	da802415 	stw	r10,144(sp)
210976dc:	b0800007 	ldb	r2,0(r22)
210976e0:	10027526 	beq	r2,zero,210980b8 <___svfiprintf_internal_r+0xad8>
210976e4:	b1000047 	ldb	r4,1(r22)
210976e8:	b5400044 	addi	r21,r22,1
210976ec:	d8001d85 	stb	zero,118(sp)
210976f0:	000d883a 	mov	r6,zero
210976f4:	043fffc4 	movi	r16,-1
210976f8:	d8002115 	stw	zero,132(sp)
210976fc:	0023883a 	mov	r17,zero
21097700:	00c01604 	movi	r3,88
21097704:	01400244 	movi	r5,9
21097708:	02400a84 	movi	r9,42
2109770c:	01c01b04 	movi	r7,108
21097710:	ad400044 	addi	r21,r21,1
21097714:	20bff804 	addi	r2,r4,-32
21097718:	18819736 	bltu	r3,r2,21097d78 <___svfiprintf_internal_r+0x798>
2109771c:	100490ba 	slli	r2,r2,2
21097720:	02c84274 	movhi	r11,8457
21097724:	5addcd04 	addi	r11,r11,30516
21097728:	12c5883a 	add	r2,r2,r11
2109772c:	10800017 	ldw	r2,0(r2)
21097730:	1000683a 	jmp	r2
21097734:	21097c70 	cmpltui	r4,r4,9713
21097738:	21097d78 	rdprs	r4,r4,9717
2109773c:	21097d78 	rdprs	r4,r4,9717
21097740:	21097c64 	muli	r4,r4,9713
21097744:	21097d78 	rdprs	r4,r4,9717
21097748:	21097d78 	rdprs	r4,r4,9717
2109774c:	21097d78 	rdprs	r4,r4,9717
21097750:	21097d78 	rdprs	r4,r4,9717
21097754:	21097d78 	rdprs	r4,r4,9717
21097758:	21097d78 	rdprs	r4,r4,9717
2109775c:	21097990 	cmplti	r4,r4,9702
21097760:	21097dac 	andhi	r4,r4,9718
21097764:	21097d78 	rdprs	r4,r4,9717
21097768:	210979b8 	rdprs	r4,r4,9702
2109776c:	21097db8 	rdprs	r4,r4,9718
21097770:	21097d78 	rdprs	r4,r4,9717
21097774:	21097da0 	cmpeqi	r4,r4,9718
21097778:	21097d40 	call	221097d4 <__flash_rwdata_start+0x106758c>
2109777c:	21097d40 	call	221097d4 <__flash_rwdata_start+0x106758c>
21097780:	21097d40 	call	221097d4 <__flash_rwdata_start+0x106758c>
21097784:	21097d40 	call	221097d4 <__flash_rwdata_start+0x106758c>
21097788:	21097d40 	call	221097d4 <__flash_rwdata_start+0x106758c>
2109778c:	21097d40 	call	221097d4 <__flash_rwdata_start+0x106758c>
21097790:	21097d40 	call	221097d4 <__flash_rwdata_start+0x106758c>
21097794:	21097d40 	call	221097d4 <__flash_rwdata_start+0x106758c>
21097798:	21097d40 	call	221097d4 <__flash_rwdata_start+0x106758c>
2109779c:	21097d78 	rdprs	r4,r4,9717
210977a0:	21097d78 	rdprs	r4,r4,9717
210977a4:	21097d78 	rdprs	r4,r4,9717
210977a8:	21097d78 	rdprs	r4,r4,9717
210977ac:	21097d78 	rdprs	r4,r4,9717
210977b0:	21097d78 	rdprs	r4,r4,9717
210977b4:	21097d78 	rdprs	r4,r4,9717
210977b8:	21097d78 	rdprs	r4,r4,9717
210977bc:	21097d78 	rdprs	r4,r4,9717
210977c0:	21097d78 	rdprs	r4,r4,9717
210977c4:	21097cd8 	cmpnei	r4,r4,9715
210977c8:	21097d78 	rdprs	r4,r4,9717
210977cc:	21097d78 	rdprs	r4,r4,9717
210977d0:	21097d78 	rdprs	r4,r4,9717
210977d4:	21097d78 	rdprs	r4,r4,9717
210977d8:	21097d78 	rdprs	r4,r4,9717
210977dc:	21097d78 	rdprs	r4,r4,9717
210977e0:	21097d78 	rdprs	r4,r4,9717
210977e4:	21097d78 	rdprs	r4,r4,9717
210977e8:	21097d78 	rdprs	r4,r4,9717
210977ec:	21097d78 	rdprs	r4,r4,9717
210977f0:	21097964 	muli	r4,r4,9701
210977f4:	21097d78 	rdprs	r4,r4,9717
210977f8:	21097d78 	rdprs	r4,r4,9717
210977fc:	21097d78 	rdprs	r4,r4,9717
21097800:	21097d78 	rdprs	r4,r4,9717
21097804:	21097d78 	rdprs	r4,r4,9717
21097808:	21097898 	cmpnei	r4,r4,9698
2109780c:	21097d78 	rdprs	r4,r4,9717
21097810:	21097d78 	rdprs	r4,r4,9717
21097814:	21097bc4 	addi	r4,r4,9711
21097818:	21097d78 	rdprs	r4,r4,9717
2109781c:	21097d78 	rdprs	r4,r4,9717
21097820:	21097d78 	rdprs	r4,r4,9717
21097824:	21097d78 	rdprs	r4,r4,9717
21097828:	21097d78 	rdprs	r4,r4,9717
2109782c:	21097d78 	rdprs	r4,r4,9717
21097830:	21097d78 	rdprs	r4,r4,9717
21097834:	21097d78 	rdprs	r4,r4,9717
21097838:	21097d78 	rdprs	r4,r4,9717
2109783c:	21097d78 	rdprs	r4,r4,9717
21097840:	21097ab0 	cmpltui	r4,r4,9706
21097844:	21097a70 	cmpltui	r4,r4,9705
21097848:	21097d78 	rdprs	r4,r4,9717
2109784c:	21097d78 	rdprs	r4,r4,9717
21097850:	21097d78 	rdprs	r4,r4,9717
21097854:	21097c20 	cmpeqi	r4,r4,9712
21097858:	21097a70 	cmpltui	r4,r4,9705
2109785c:	21097d78 	rdprs	r4,r4,9717
21097860:	21097d78 	rdprs	r4,r4,9717
21097864:	21097c0c 	andi	r4,r4,9712
21097868:	21097d78 	rdprs	r4,r4,9717
2109786c:	21097c2c 	andhi	r4,r4,9712
21097870:	21097968 	cmpgeui	r4,r4,9701
21097874:	21097a2c 	andhi	r4,r4,9704
21097878:	21097a20 	cmpeqi	r4,r4,9704
2109787c:	21097d78 	rdprs	r4,r4,9717
21097880:	210979c4 	addi	r4,r4,9703
21097884:	21097d78 	rdprs	r4,r4,9717
21097888:	2109789c 	xori	r4,r4,9698
2109788c:	21097d78 	rdprs	r4,r4,9717
21097890:	21097d78 	rdprs	r4,r4,9717
21097894:	21097c8c 	andi	r4,r4,9714
21097898:	8c400414 	ori	r17,r17,16
2109789c:	8880080c 	andi	r2,r17,32
210978a0:	10029626 	beq	r2,zero,210982fc <___svfiprintf_internal_r+0xd1c>
210978a4:	da802317 	ldw	r10,140(sp)
210978a8:	dac02317 	ldw	r11,140(sp)
210978ac:	00800044 	movi	r2,1
210978b0:	52400017 	ldw	r9,0(r10)
210978b4:	52800117 	ldw	r10,4(r10)
210978b8:	5ac00204 	addi	r11,r11,8
210978bc:	dac02315 	stw	r11,140(sp)
210978c0:	4a86b03a 	or	r3,r9,r10
210978c4:	d8001d85 	stb	zero,118(sp)
210978c8:	8039883a 	mov	fp,r16
210978cc:	0017883a 	mov	r11,zero
210978d0:	80000216 	blt	r16,zero,210978dc <___svfiprintf_internal_r+0x2fc>
210978d4:	013fdfc4 	movi	r4,-129
210978d8:	8922703a 	and	r17,r17,r4
210978dc:	1801d21e 	bne	r3,zero,21098028 <___svfiprintf_internal_r+0xa48>
210978e0:	80024626 	beq	r16,zero,210981fc <___svfiprintf_internal_r+0xc1c>
210978e4:	10803fcc 	andi	r2,r2,255
210978e8:	00c00044 	movi	r3,1
210978ec:	10c2b426 	beq	r2,r3,210983c0 <___svfiprintf_internal_r+0xde0>
210978f0:	00c00084 	movi	r3,2
210978f4:	10c25d26 	beq	r2,r3,2109826c <___svfiprintf_internal_r+0xc8c>
210978f8:	d8c01a04 	addi	r3,sp,104
210978fc:	4808d0fa 	srli	r4,r9,3
21097900:	500a977a 	slli	r5,r10,29
21097904:	5014d0fa 	srli	r10,r10,3
21097908:	4a4001cc 	andi	r9,r9,7
2109790c:	48800c04 	addi	r2,r9,48
21097910:	18ffffc4 	addi	r3,r3,-1
21097914:	2912b03a 	or	r9,r5,r4
21097918:	18800005 	stb	r2,0(r3)
2109791c:	4a88b03a 	or	r4,r9,r10
21097920:	203ff61e 	bne	r4,zero,210978fc <__flash_rwdata_start+0xffff56b4>
21097924:	8900004c 	andi	r4,r17,1
21097928:	d8c02615 	stw	r3,152(sp)
2109792c:	2002961e 	bne	r4,zero,21098388 <___svfiprintf_internal_r+0xda8>
21097930:	da801e17 	ldw	r10,120(sp)
21097934:	50f9c83a 	sub	fp,r10,r3
21097938:	df002015 	stw	fp,128(sp)
2109793c:	e400010e 	bge	fp,r16,21097944 <___svfiprintf_internal_r+0x364>
21097940:	dc002015 	stw	r16,128(sp)
21097944:	5ac03fcc 	andi	r11,r11,255
21097948:	5ac0201c 	xori	r11,r11,128
2109794c:	5affe004 	addi	r11,r11,-128
21097950:	58006326 	beq	r11,zero,21097ae0 <___svfiprintf_internal_r+0x500>
21097954:	d8c02017 	ldw	r3,128(sp)
21097958:	18c00044 	addi	r3,r3,1
2109795c:	d8c02015 	stw	r3,128(sp)
21097960:	00005f06 	br	21097ae0 <___svfiprintf_internal_r+0x500>
21097964:	8c400414 	ori	r17,r17,16
21097968:	8880080c 	andi	r2,r17,32
2109796c:	10027926 	beq	r2,zero,21098354 <___svfiprintf_internal_r+0xd74>
21097970:	dac02317 	ldw	r11,140(sp)
21097974:	0005883a 	mov	r2,zero
21097978:	5a400017 	ldw	r9,0(r11)
2109797c:	5a800117 	ldw	r10,4(r11)
21097980:	5ac00204 	addi	r11,r11,8
21097984:	dac02315 	stw	r11,140(sp)
21097988:	4a86b03a 	or	r3,r9,r10
2109798c:	003fcd06 	br	210978c4 <__flash_rwdata_start+0xffff567c>
21097990:	da802317 	ldw	r10,140(sp)
21097994:	dac02317 	ldw	r11,140(sp)
21097998:	52800017 	ldw	r10,0(r10)
2109799c:	58800104 	addi	r2,r11,4
210979a0:	da802115 	stw	r10,132(sp)
210979a4:	50028c0e 	bge	r10,zero,210983d8 <___svfiprintf_internal_r+0xdf8>
210979a8:	da802117 	ldw	r10,132(sp)
210979ac:	d8802315 	stw	r2,140(sp)
210979b0:	0295c83a 	sub	r10,zero,r10
210979b4:	da802115 	stw	r10,132(sp)
210979b8:	8c400114 	ori	r17,r17,4
210979bc:	a9000007 	ldb	r4,0(r21)
210979c0:	003f5306 	br	21097710 <__flash_rwdata_start+0xffff54c8>
210979c4:	da802317 	ldw	r10,140(sp)
210979c8:	dac02317 	ldw	r11,140(sp)
210979cc:	d8001d85 	stb	zero,118(sp)
210979d0:	52800017 	ldw	r10,0(r10)
210979d4:	5dc00104 	addi	r23,r11,4
210979d8:	da802615 	stw	r10,152(sp)
210979dc:	5002d626 	beq	r10,zero,21098538 <___svfiprintf_internal_r+0xf58>
210979e0:	d9002617 	ldw	r4,152(sp)
210979e4:	8002cc16 	blt	r16,zero,21098518 <___svfiprintf_internal_r+0xf38>
210979e8:	000b883a 	mov	r5,zero
210979ec:	800d883a 	mov	r6,r16
210979f0:	da002c15 	stw	r8,176(sp)
210979f4:	10958480 	call	21095848 <memchr>
210979f8:	da002c17 	ldw	r8,176(sp)
210979fc:	1002f026 	beq	r2,zero,210985c0 <___svfiprintf_internal_r+0xfe0>
21097a00:	d8c02617 	ldw	r3,152(sp)
21097a04:	10f9c83a 	sub	fp,r2,r3
21097a08:	8700010e 	bge	r16,fp,21097a10 <___svfiprintf_internal_r+0x430>
21097a0c:	8039883a 	mov	fp,r16
21097a10:	dac01d83 	ldbu	r11,118(sp)
21097a14:	ddc02315 	stw	r23,140(sp)
21097a18:	0021883a 	mov	r16,zero
21097a1c:	003fc606 	br	21097938 <__flash_rwdata_start+0xffff56f0>
21097a20:	8c400814 	ori	r17,r17,32
21097a24:	a9000007 	ldb	r4,0(r21)
21097a28:	003f3906 	br	21097710 <__flash_rwdata_start+0xffff54c8>
21097a2c:	da802317 	ldw	r10,140(sp)
21097a30:	00800c04 	movi	r2,48
21097a34:	dac02317 	ldw	r11,140(sp)
21097a38:	52400017 	ldw	r9,0(r10)
21097a3c:	d8801d05 	stb	r2,116(sp)
21097a40:	00801e04 	movi	r2,120
21097a44:	d8801d45 	stb	r2,117(sp)
21097a48:	00800034 	movhi	r2,0
21097a4c:	108ed204 	addi	r2,r2,15176
21097a50:	5ac00104 	addi	r11,r11,4
21097a54:	d8802a15 	stw	r2,168(sp)
21097a58:	0015883a 	mov	r10,zero
21097a5c:	8c400094 	ori	r17,r17,2
21097a60:	dac02315 	stw	r11,140(sp)
21097a64:	00800084 	movi	r2,2
21097a68:	4807883a 	mov	r3,r9
21097a6c:	003f9506 	br	210978c4 <__flash_rwdata_start+0xffff567c>
21097a70:	d9801d85 	stb	r6,118(sp)
21097a74:	8880080c 	andi	r2,r17,32
21097a78:	d8c02317 	ldw	r3,140(sp)
21097a7c:	10009b26 	beq	r2,zero,21097cec <___svfiprintf_internal_r+0x70c>
21097a80:	dac02317 	ldw	r11,140(sp)
21097a84:	18800117 	ldw	r2,4(r3)
21097a88:	1a400017 	ldw	r9,0(r3)
21097a8c:	5ac00204 	addi	r11,r11,8
21097a90:	dac02315 	stw	r11,140(sp)
21097a94:	1015883a 	mov	r10,r2
21097a98:	10009f16 	blt	r2,zero,21097d18 <___svfiprintf_internal_r+0x738>
21097a9c:	dac01d83 	ldbu	r11,118(sp)
21097aa0:	8039883a 	mov	fp,r16
21097aa4:	00800044 	movi	r2,1
21097aa8:	4a86b03a 	or	r3,r9,r10
21097aac:	003f8806 	br	210978d0 <__flash_rwdata_start+0xffff5688>
21097ab0:	dac02317 	ldw	r11,140(sp)
21097ab4:	00c00044 	movi	r3,1
21097ab8:	da801004 	addi	r10,sp,64
21097abc:	58800017 	ldw	r2,0(r11)
21097ac0:	5ac00104 	addi	r11,r11,4
21097ac4:	d8c02015 	stw	r3,128(sp)
21097ac8:	d8001d85 	stb	zero,118(sp)
21097acc:	d8801005 	stb	r2,64(sp)
21097ad0:	dac02315 	stw	r11,140(sp)
21097ad4:	1839883a 	mov	fp,r3
21097ad8:	da802615 	stw	r10,152(sp)
21097adc:	0021883a 	mov	r16,zero
21097ae0:	8a80008c 	andi	r10,r17,2
21097ae4:	da802215 	stw	r10,136(sp)
21097ae8:	50000326 	beq	r10,zero,21097af8 <___svfiprintf_internal_r+0x518>
21097aec:	dac02017 	ldw	r11,128(sp)
21097af0:	5ac00084 	addi	r11,r11,2
21097af4:	dac02015 	stw	r11,128(sp)
21097af8:	88c0210c 	andi	r3,r17,132
21097afc:	d8c02515 	stw	r3,148(sp)
21097b00:	1800bd1e 	bne	r3,zero,21097df8 <___svfiprintf_internal_r+0x818>
21097b04:	da802117 	ldw	r10,132(sp)
21097b08:	dac02017 	ldw	r11,128(sp)
21097b0c:	52edc83a 	sub	r22,r10,r11
21097b10:	0580b90e 	bge	zero,r22,21097df8 <___svfiprintf_internal_r+0x818>
21097b14:	02400404 	movi	r9,16
21097b18:	d8c01c17 	ldw	r3,112(sp)
21097b1c:	d8801b17 	ldw	r2,108(sp)
21097b20:	4d829b0e 	bge	r9,r22,21098590 <___svfiprintf_internal_r+0xfb0>
21097b24:	01400034 	movhi	r5,0
21097b28:	294f3e04 	addi	r5,r5,15608
21097b2c:	d9402815 	stw	r5,160(sp)
21097b30:	05c001c4 	movi	r23,7
21097b34:	00000306 	br	21097b44 <___svfiprintf_internal_r+0x564>
21097b38:	b5bffc04 	addi	r22,r22,-16
21097b3c:	42000204 	addi	r8,r8,8
21097b40:	4d80150e 	bge	r9,r22,21097b98 <___svfiprintf_internal_r+0x5b8>
21097b44:	02800034 	movhi	r10,0
21097b48:	18c00404 	addi	r3,r3,16
21097b4c:	10800044 	addi	r2,r2,1
21097b50:	528f3e04 	addi	r10,r10,15608
21097b54:	42800015 	stw	r10,0(r8)
21097b58:	42400115 	stw	r9,4(r8)
21097b5c:	d8c01c15 	stw	r3,112(sp)
21097b60:	d8801b15 	stw	r2,108(sp)
21097b64:	b8bff40e 	bge	r23,r2,21097b38 <__flash_rwdata_start+0xffff58f0>
21097b68:	9009883a 	mov	r4,r18
21097b6c:	a00b883a 	mov	r5,r20
21097b70:	d9801a04 	addi	r6,sp,104
21097b74:	da402c15 	stw	r9,176(sp)
21097b78:	10974140 	call	21097414 <__ssprint_r>
21097b7c:	da402c17 	ldw	r9,176(sp)
21097b80:	1001531e 	bne	r2,zero,210980d0 <___svfiprintf_internal_r+0xaf0>
21097b84:	b5bffc04 	addi	r22,r22,-16
21097b88:	d8c01c17 	ldw	r3,112(sp)
21097b8c:	d8801b17 	ldw	r2,108(sp)
21097b90:	d811883a 	mov	r8,sp
21097b94:	4dbfeb16 	blt	r9,r22,21097b44 <__flash_rwdata_start+0xffff58fc>
21097b98:	dac02817 	ldw	r11,160(sp)
21097b9c:	b0c7883a 	add	r3,r22,r3
21097ba0:	10800044 	addi	r2,r2,1
21097ba4:	42c00015 	stw	r11,0(r8)
21097ba8:	45800115 	stw	r22,4(r8)
21097bac:	d8c01c15 	stw	r3,112(sp)
21097bb0:	d8801b15 	stw	r2,108(sp)
21097bb4:	010001c4 	movi	r4,7
21097bb8:	2081dd16 	blt	r4,r2,21098330 <___svfiprintf_internal_r+0xd50>
21097bbc:	42000204 	addi	r8,r8,8
21097bc0:	00008f06 	br	21097e00 <___svfiprintf_internal_r+0x820>
21097bc4:	00800034 	movhi	r2,0
21097bc8:	108ecd04 	addi	r2,r2,15156
21097bcc:	d8802a15 	stw	r2,168(sp)
21097bd0:	d9801d85 	stb	r6,118(sp)
21097bd4:	8880080c 	andi	r2,r17,32
21097bd8:	10003226 	beq	r2,zero,21097ca4 <___svfiprintf_internal_r+0x6c4>
21097bdc:	da802317 	ldw	r10,140(sp)
21097be0:	dac02317 	ldw	r11,140(sp)
21097be4:	52400017 	ldw	r9,0(r10)
21097be8:	52800117 	ldw	r10,4(r10)
21097bec:	5ac00204 	addi	r11,r11,8
21097bf0:	dac02315 	stw	r11,140(sp)
21097bf4:	8880004c 	andi	r2,r17,1
21097bf8:	10003426 	beq	r2,zero,21097ccc <___svfiprintf_internal_r+0x6ec>
21097bfc:	4a86b03a 	or	r3,r9,r10
21097c00:	1802231e 	bne	r3,zero,21098490 <___svfiprintf_internal_r+0xeb0>
21097c04:	00800084 	movi	r2,2
21097c08:	003f2e06 	br	210978c4 <__flash_rwdata_start+0xffff567c>
21097c0c:	a9000007 	ldb	r4,0(r21)
21097c10:	a805883a 	mov	r2,r21
21097c14:	21c22426 	beq	r4,r7,210984a8 <___svfiprintf_internal_r+0xec8>
21097c18:	8c400414 	ori	r17,r17,16
21097c1c:	003ebc06 	br	21097710 <__flash_rwdata_start+0xffff54c8>
21097c20:	8c401014 	ori	r17,r17,64
21097c24:	a9000007 	ldb	r4,0(r21)
21097c28:	003eb906 	br	21097710 <__flash_rwdata_start+0xffff54c8>
21097c2c:	d9801d85 	stb	r6,118(sp)
21097c30:	8880080c 	andi	r2,r17,32
21097c34:	10020d1e 	bne	r2,zero,2109846c <___svfiprintf_internal_r+0xe8c>
21097c38:	8880040c 	andi	r2,r17,16
21097c3c:	10021e1e 	bne	r2,zero,210984b8 <___svfiprintf_internal_r+0xed8>
21097c40:	8c40100c 	andi	r17,r17,64
21097c44:	88021c26 	beq	r17,zero,210984b8 <___svfiprintf_internal_r+0xed8>
21097c48:	dac02317 	ldw	r11,140(sp)
21097c4c:	da802417 	ldw	r10,144(sp)
21097c50:	58800017 	ldw	r2,0(r11)
21097c54:	5ac00104 	addi	r11,r11,4
21097c58:	dac02315 	stw	r11,140(sp)
21097c5c:	1280000d 	sth	r10,0(r2)
21097c60:	003e8306 	br	21097670 <__flash_rwdata_start+0xffff5428>
21097c64:	8c400054 	ori	r17,r17,1
21097c68:	a9000007 	ldb	r4,0(r21)
21097c6c:	003ea806 	br	21097710 <__flash_rwdata_start+0xffff54c8>
21097c70:	30803fcc 	andi	r2,r6,255
21097c74:	1080201c 	xori	r2,r2,128
21097c78:	10bfe004 	addi	r2,r2,-128
21097c7c:	1001f91e 	bne	r2,zero,21098464 <___svfiprintf_internal_r+0xe84>
21097c80:	01800804 	movi	r6,32
21097c84:	a9000007 	ldb	r4,0(r21)
21097c88:	003ea106 	br	21097710 <__flash_rwdata_start+0xffff54c8>
21097c8c:	00800034 	movhi	r2,0
21097c90:	108ed204 	addi	r2,r2,15176
21097c94:	d8802a15 	stw	r2,168(sp)
21097c98:	d9801d85 	stb	r6,118(sp)
21097c9c:	8880080c 	andi	r2,r17,32
21097ca0:	103fce1e 	bne	r2,zero,21097bdc <__flash_rwdata_start+0xffff5994>
21097ca4:	8880040c 	andi	r2,r17,16
21097ca8:	1001e526 	beq	r2,zero,21098440 <___svfiprintf_internal_r+0xe60>
21097cac:	da802317 	ldw	r10,140(sp)
21097cb0:	dac02317 	ldw	r11,140(sp)
21097cb4:	52400017 	ldw	r9,0(r10)
21097cb8:	8880004c 	andi	r2,r17,1
21097cbc:	5ac00104 	addi	r11,r11,4
21097cc0:	dac02315 	stw	r11,140(sp)
21097cc4:	0015883a 	mov	r10,zero
21097cc8:	103fcc1e 	bne	r2,zero,21097bfc <__flash_rwdata_start+0xffff59b4>
21097ccc:	00800084 	movi	r2,2
21097cd0:	4a86b03a 	or	r3,r9,r10
21097cd4:	003efb06 	br	210978c4 <__flash_rwdata_start+0xffff567c>
21097cd8:	8c400414 	ori	r17,r17,16
21097cdc:	d9801d85 	stb	r6,118(sp)
21097ce0:	8880080c 	andi	r2,r17,32
21097ce4:	d8c02317 	ldw	r3,140(sp)
21097ce8:	103f651e 	bne	r2,zero,21097a80 <__flash_rwdata_start+0xffff5838>
21097cec:	8880040c 	andi	r2,r17,16
21097cf0:	1001c61e 	bne	r2,zero,2109840c <___svfiprintf_internal_r+0xe2c>
21097cf4:	8880100c 	andi	r2,r17,64
21097cf8:	1001c426 	beq	r2,zero,2109840c <___svfiprintf_internal_r+0xe2c>
21097cfc:	1a40000f 	ldh	r9,0(r3)
21097d00:	dac02317 	ldw	r11,140(sp)
21097d04:	4815d7fa 	srai	r10,r9,31
21097d08:	5ac00104 	addi	r11,r11,4
21097d0c:	dac02315 	stw	r11,140(sp)
21097d10:	5005883a 	mov	r2,r10
21097d14:	103f610e 	bge	r2,zero,21097a9c <__flash_rwdata_start+0xffff5854>
21097d18:	0253c83a 	sub	r9,zero,r9
21097d1c:	4804c03a 	cmpne	r2,r9,zero
21097d20:	0295c83a 	sub	r10,zero,r10
21097d24:	5095c83a 	sub	r10,r10,r2
21097d28:	02c00b44 	movi	r11,45
21097d2c:	dac01d85 	stb	r11,118(sp)
21097d30:	8039883a 	mov	fp,r16
21097d34:	00800044 	movi	r2,1
21097d38:	4a86b03a 	or	r3,r9,r10
21097d3c:	003ee406 	br	210978d0 <__flash_rwdata_start+0xffff5688>
21097d40:	a815883a 	mov	r10,r21
21097d44:	d8002115 	stw	zero,132(sp)
21097d48:	20bff404 	addi	r2,r4,-48
21097d4c:	51000007 	ldb	r4,0(r10)
21097d50:	da802117 	ldw	r10,132(sp)
21097d54:	ad400044 	addi	r21,r21,1
21097d58:	52c002a4 	muli	r11,r10,10
21097d5c:	a815883a 	mov	r10,r21
21097d60:	5885883a 	add	r2,r11,r2
21097d64:	d8802115 	stw	r2,132(sp)
21097d68:	20bff404 	addi	r2,r4,-48
21097d6c:	28bff72e 	bgeu	r5,r2,21097d4c <__flash_rwdata_start+0xffff5b04>
21097d70:	20bff804 	addi	r2,r4,-32
21097d74:	18be692e 	bgeu	r3,r2,2109771c <__flash_rwdata_start+0xffff54d4>
21097d78:	d9801d85 	stb	r6,118(sp)
21097d7c:	2000ce26 	beq	r4,zero,210980b8 <___svfiprintf_internal_r+0xad8>
21097d80:	02800044 	movi	r10,1
21097d84:	dac01004 	addi	r11,sp,64
21097d88:	da802015 	stw	r10,128(sp)
21097d8c:	d9001005 	stb	r4,64(sp)
21097d90:	d8001d85 	stb	zero,118(sp)
21097d94:	5039883a 	mov	fp,r10
21097d98:	dac02615 	stw	r11,152(sp)
21097d9c:	003f4f06 	br	21097adc <__flash_rwdata_start+0xffff5894>
21097da0:	8c402014 	ori	r17,r17,128
21097da4:	a9000007 	ldb	r4,0(r21)
21097da8:	003e5906 	br	21097710 <__flash_rwdata_start+0xffff54c8>
21097dac:	01800ac4 	movi	r6,43
21097db0:	a9000007 	ldb	r4,0(r21)
21097db4:	003e5606 	br	21097710 <__flash_rwdata_start+0xffff54c8>
21097db8:	a9000007 	ldb	r4,0(r21)
21097dbc:	aa800044 	addi	r10,r21,1
21097dc0:	22420626 	beq	r4,r9,210985dc <___svfiprintf_internal_r+0xffc>
21097dc4:	20bff404 	addi	r2,r4,-48
21097dc8:	502b883a 	mov	r21,r10
21097dcc:	0021883a 	mov	r16,zero
21097dd0:	28be5036 	bltu	r5,r2,21097714 <__flash_rwdata_start+0xffff54cc>
21097dd4:	a9000007 	ldb	r4,0(r21)
21097dd8:	840002a4 	muli	r16,r16,10
21097ddc:	ad400044 	addi	r21,r21,1
21097de0:	1421883a 	add	r16,r2,r16
21097de4:	20bff404 	addi	r2,r4,-48
21097de8:	28bffa2e 	bgeu	r5,r2,21097dd4 <__flash_rwdata_start+0xffff5b8c>
21097dec:	803e490e 	bge	r16,zero,21097714 <__flash_rwdata_start+0xffff54cc>
21097df0:	043fffc4 	movi	r16,-1
21097df4:	003e4706 	br	21097714 <__flash_rwdata_start+0xffff54cc>
21097df8:	d8c01c17 	ldw	r3,112(sp)
21097dfc:	d8801b17 	ldw	r2,108(sp)
21097e00:	d9001d87 	ldb	r4,118(sp)
21097e04:	20000b26 	beq	r4,zero,21097e34 <___svfiprintf_internal_r+0x854>
21097e08:	d9001d84 	addi	r4,sp,118
21097e0c:	18c00044 	addi	r3,r3,1
21097e10:	10800044 	addi	r2,r2,1
21097e14:	41000015 	stw	r4,0(r8)
21097e18:	01000044 	movi	r4,1
21097e1c:	41000115 	stw	r4,4(r8)
21097e20:	d8c01c15 	stw	r3,112(sp)
21097e24:	d8801b15 	stw	r2,108(sp)
21097e28:	010001c4 	movi	r4,7
21097e2c:	20811e16 	blt	r4,r2,210982a8 <___svfiprintf_internal_r+0xcc8>
21097e30:	42000204 	addi	r8,r8,8
21097e34:	da802217 	ldw	r10,136(sp)
21097e38:	50000b26 	beq	r10,zero,21097e68 <___svfiprintf_internal_r+0x888>
21097e3c:	d9001d04 	addi	r4,sp,116
21097e40:	18c00084 	addi	r3,r3,2
21097e44:	10800044 	addi	r2,r2,1
21097e48:	41000015 	stw	r4,0(r8)
21097e4c:	01000084 	movi	r4,2
21097e50:	41000115 	stw	r4,4(r8)
21097e54:	d8c01c15 	stw	r3,112(sp)
21097e58:	d8801b15 	stw	r2,108(sp)
21097e5c:	010001c4 	movi	r4,7
21097e60:	20811a16 	blt	r4,r2,210982cc <___svfiprintf_internal_r+0xcec>
21097e64:	42000204 	addi	r8,r8,8
21097e68:	dac02517 	ldw	r11,148(sp)
21097e6c:	01002004 	movi	r4,128
21097e70:	5900a826 	beq	r11,r4,21098114 <___svfiprintf_internal_r+0xb34>
21097e74:	8721c83a 	sub	r16,r16,fp
21097e78:	0400260e 	bge	zero,r16,21097f14 <___svfiprintf_internal_r+0x934>
21097e7c:	01c00404 	movi	r7,16
21097e80:	3c019d0e 	bge	r7,r16,210984f8 <___svfiprintf_internal_r+0xf18>
21097e84:	01000034 	movhi	r4,0
21097e88:	210f3a04 	addi	r4,r4,15592
21097e8c:	d9002215 	stw	r4,136(sp)
21097e90:	382f883a 	mov	r23,r7
21097e94:	058001c4 	movi	r22,7
21097e98:	00000306 	br	21097ea8 <___svfiprintf_internal_r+0x8c8>
21097e9c:	843ffc04 	addi	r16,r16,-16
21097ea0:	42000204 	addi	r8,r8,8
21097ea4:	bc00110e 	bge	r23,r16,21097eec <___svfiprintf_internal_r+0x90c>
21097ea8:	18c00404 	addi	r3,r3,16
21097eac:	10800044 	addi	r2,r2,1
21097eb0:	44c00015 	stw	r19,0(r8)
21097eb4:	45c00115 	stw	r23,4(r8)
21097eb8:	d8c01c15 	stw	r3,112(sp)
21097ebc:	d8801b15 	stw	r2,108(sp)
21097ec0:	b0bff60e 	bge	r22,r2,21097e9c <__flash_rwdata_start+0xffff5c54>
21097ec4:	9009883a 	mov	r4,r18
21097ec8:	a00b883a 	mov	r5,r20
21097ecc:	d9801a04 	addi	r6,sp,104
21097ed0:	10974140 	call	21097414 <__ssprint_r>
21097ed4:	10007e1e 	bne	r2,zero,210980d0 <___svfiprintf_internal_r+0xaf0>
21097ed8:	843ffc04 	addi	r16,r16,-16
21097edc:	d8c01c17 	ldw	r3,112(sp)
21097ee0:	d8801b17 	ldw	r2,108(sp)
21097ee4:	d811883a 	mov	r8,sp
21097ee8:	bc3fef16 	blt	r23,r16,21097ea8 <__flash_rwdata_start+0xffff5c60>
21097eec:	da802217 	ldw	r10,136(sp)
21097ef0:	1c07883a 	add	r3,r3,r16
21097ef4:	10800044 	addi	r2,r2,1
21097ef8:	42800015 	stw	r10,0(r8)
21097efc:	44000115 	stw	r16,4(r8)
21097f00:	d8c01c15 	stw	r3,112(sp)
21097f04:	d8801b15 	stw	r2,108(sp)
21097f08:	010001c4 	movi	r4,7
21097f0c:	2080ce16 	blt	r4,r2,21098248 <___svfiprintf_internal_r+0xc68>
21097f10:	42000204 	addi	r8,r8,8
21097f14:	dac02617 	ldw	r11,152(sp)
21097f18:	1f07883a 	add	r3,r3,fp
21097f1c:	10800044 	addi	r2,r2,1
21097f20:	42c00015 	stw	r11,0(r8)
21097f24:	47000115 	stw	fp,4(r8)
21097f28:	d8c01c15 	stw	r3,112(sp)
21097f2c:	d8801b15 	stw	r2,108(sp)
21097f30:	010001c4 	movi	r4,7
21097f34:	2080a316 	blt	r4,r2,210981c4 <___svfiprintf_internal_r+0xbe4>
21097f38:	42000204 	addi	r8,r8,8
21097f3c:	8c40010c 	andi	r17,r17,4
21097f40:	88002b26 	beq	r17,zero,21097ff0 <___svfiprintf_internal_r+0xa10>
21097f44:	da802117 	ldw	r10,132(sp)
21097f48:	dac02017 	ldw	r11,128(sp)
21097f4c:	52e1c83a 	sub	r16,r10,r11
21097f50:	0400270e 	bge	zero,r16,21097ff0 <___svfiprintf_internal_r+0xa10>
21097f54:	04400404 	movi	r17,16
21097f58:	d8801b17 	ldw	r2,108(sp)
21097f5c:	8c01900e 	bge	r17,r16,210985a0 <___svfiprintf_internal_r+0xfc0>
21097f60:	01400034 	movhi	r5,0
21097f64:	294f3e04 	addi	r5,r5,15608
21097f68:	d9402815 	stw	r5,160(sp)
21097f6c:	070001c4 	movi	fp,7
21097f70:	00000306 	br	21097f80 <___svfiprintf_internal_r+0x9a0>
21097f74:	843ffc04 	addi	r16,r16,-16
21097f78:	42000204 	addi	r8,r8,8
21097f7c:	8c00130e 	bge	r17,r16,21097fcc <___svfiprintf_internal_r+0x9ec>
21097f80:	02800034 	movhi	r10,0
21097f84:	18c00404 	addi	r3,r3,16
21097f88:	10800044 	addi	r2,r2,1
21097f8c:	528f3e04 	addi	r10,r10,15608
21097f90:	42800015 	stw	r10,0(r8)
21097f94:	44400115 	stw	r17,4(r8)
21097f98:	d8c01c15 	stw	r3,112(sp)
21097f9c:	d8801b15 	stw	r2,108(sp)
21097fa0:	e0bff40e 	bge	fp,r2,21097f74 <__flash_rwdata_start+0xffff5d2c>
21097fa4:	9009883a 	mov	r4,r18
21097fa8:	a00b883a 	mov	r5,r20
21097fac:	d9801a04 	addi	r6,sp,104
21097fb0:	10974140 	call	21097414 <__ssprint_r>
21097fb4:	1000461e 	bne	r2,zero,210980d0 <___svfiprintf_internal_r+0xaf0>
21097fb8:	843ffc04 	addi	r16,r16,-16
21097fbc:	d8c01c17 	ldw	r3,112(sp)
21097fc0:	d8801b17 	ldw	r2,108(sp)
21097fc4:	d811883a 	mov	r8,sp
21097fc8:	8c3fed16 	blt	r17,r16,21097f80 <__flash_rwdata_start+0xffff5d38>
21097fcc:	dac02817 	ldw	r11,160(sp)
21097fd0:	1c07883a 	add	r3,r3,r16
21097fd4:	10800044 	addi	r2,r2,1
21097fd8:	42c00015 	stw	r11,0(r8)
21097fdc:	44000115 	stw	r16,4(r8)
21097fe0:	d8c01c15 	stw	r3,112(sp)
21097fe4:	d8801b15 	stw	r2,108(sp)
21097fe8:	010001c4 	movi	r4,7
21097fec:	2080fd16 	blt	r4,r2,210983e4 <___svfiprintf_internal_r+0xe04>
21097ff0:	dd802017 	ldw	r22,128(sp)
21097ff4:	da802117 	ldw	r10,132(sp)
21097ff8:	b280010e 	bge	r22,r10,21098000 <___svfiprintf_internal_r+0xa20>
21097ffc:	502d883a 	mov	r22,r10
21098000:	dac02417 	ldw	r11,144(sp)
21098004:	5d97883a 	add	r11,r11,r22
21098008:	dac02415 	stw	r11,144(sp)
2109800c:	1800751e 	bne	r3,zero,210981e4 <___svfiprintf_internal_r+0xc04>
21098010:	a8800007 	ldb	r2,0(r21)
21098014:	d8001b15 	stw	zero,108(sp)
21098018:	d811883a 	mov	r8,sp
2109801c:	103d961e 	bne	r2,zero,21097678 <__flash_rwdata_start+0xffff5430>
21098020:	a82d883a 	mov	r22,r21
21098024:	003dad06 	br	210976dc <__flash_rwdata_start+0xffff5494>
21098028:	10803fcc 	andi	r2,r2,255
2109802c:	00c00044 	movi	r3,1
21098030:	10fe2f1e 	bne	r2,r3,210978f0 <__flash_rwdata_start+0xffff56a8>
21098034:	5000e026 	beq	r10,zero,210983b8 <___svfiprintf_internal_r+0xdd8>
21098038:	dc002015 	stw	r16,128(sp)
2109803c:	dc402215 	stw	r17,136(sp)
21098040:	dd801a04 	addi	r22,sp,104
21098044:	402f883a 	mov	r23,r8
21098048:	5839883a 	mov	fp,r11
2109804c:	4821883a 	mov	r16,r9
21098050:	5023883a 	mov	r17,r10
21098054:	8009883a 	mov	r4,r16
21098058:	880b883a 	mov	r5,r17
2109805c:	01800284 	movi	r6,10
21098060:	000f883a 	mov	r7,zero
21098064:	109a9940 	call	2109a994 <__umoddi3>
21098068:	10800c04 	addi	r2,r2,48
2109806c:	b5bfffc4 	addi	r22,r22,-1
21098070:	8009883a 	mov	r4,r16
21098074:	880b883a 	mov	r5,r17
21098078:	01800284 	movi	r6,10
2109807c:	000f883a 	mov	r7,zero
21098080:	b0800005 	stb	r2,0(r22)
21098084:	109a3d40 	call	2109a3d4 <__udivdi3>
21098088:	1021883a 	mov	r16,r2
2109808c:	10c4b03a 	or	r2,r2,r3
21098090:	1823883a 	mov	r17,r3
21098094:	103fef1e 	bne	r2,zero,21098054 <__flash_rwdata_start+0xffff5e0c>
21098098:	da801e17 	ldw	r10,120(sp)
2109809c:	e017883a 	mov	r11,fp
210980a0:	dc002017 	ldw	r16,128(sp)
210980a4:	dc402217 	ldw	r17,136(sp)
210980a8:	b811883a 	mov	r8,r23
210980ac:	dd802615 	stw	r22,152(sp)
210980b0:	55b9c83a 	sub	fp,r10,r22
210980b4:	003e2006 	br	21097938 <__flash_rwdata_start+0xffff56f0>
210980b8:	d8801c17 	ldw	r2,112(sp)
210980bc:	10000426 	beq	r2,zero,210980d0 <___svfiprintf_internal_r+0xaf0>
210980c0:	d9002917 	ldw	r4,164(sp)
210980c4:	d9402717 	ldw	r5,156(sp)
210980c8:	d9801a04 	addi	r6,sp,104
210980cc:	10974140 	call	21097414 <__ssprint_r>
210980d0:	da802717 	ldw	r10,156(sp)
210980d4:	5080030b 	ldhu	r2,12(r10)
210980d8:	1080100c 	andi	r2,r2,64
210980dc:	1000511e 	bne	r2,zero,21098224 <___svfiprintf_internal_r+0xc44>
210980e0:	d8802417 	ldw	r2,144(sp)
210980e4:	dfc03617 	ldw	ra,216(sp)
210980e8:	df003517 	ldw	fp,212(sp)
210980ec:	ddc03417 	ldw	r23,208(sp)
210980f0:	dd803317 	ldw	r22,204(sp)
210980f4:	dd403217 	ldw	r21,200(sp)
210980f8:	dd003117 	ldw	r20,196(sp)
210980fc:	dcc03017 	ldw	r19,192(sp)
21098100:	dc802f17 	ldw	r18,188(sp)
21098104:	dc402e17 	ldw	r17,184(sp)
21098108:	dc002d17 	ldw	r16,180(sp)
2109810c:	dec03704 	addi	sp,sp,220
21098110:	f800283a 	ret
21098114:	da802117 	ldw	r10,132(sp)
21098118:	dac02017 	ldw	r11,128(sp)
2109811c:	52edc83a 	sub	r22,r10,r11
21098120:	05bf540e 	bge	zero,r22,21097e74 <__flash_rwdata_start+0xffff5c2c>
21098124:	02400404 	movi	r9,16
21098128:	4d81210e 	bge	r9,r22,210985b0 <___svfiprintf_internal_r+0xfd0>
2109812c:	01400034 	movhi	r5,0
21098130:	294f3a04 	addi	r5,r5,15592
21098134:	d9402215 	stw	r5,136(sp)
21098138:	05c001c4 	movi	r23,7
2109813c:	00000306 	br	2109814c <___svfiprintf_internal_r+0xb6c>
21098140:	b5bffc04 	addi	r22,r22,-16
21098144:	42000204 	addi	r8,r8,8
21098148:	4d80130e 	bge	r9,r22,21098198 <___svfiprintf_internal_r+0xbb8>
2109814c:	18c00404 	addi	r3,r3,16
21098150:	10800044 	addi	r2,r2,1
21098154:	44c00015 	stw	r19,0(r8)
21098158:	42400115 	stw	r9,4(r8)
2109815c:	d8c01c15 	stw	r3,112(sp)
21098160:	d8801b15 	stw	r2,108(sp)
21098164:	b8bff60e 	bge	r23,r2,21098140 <__flash_rwdata_start+0xffff5ef8>
21098168:	9009883a 	mov	r4,r18
2109816c:	a00b883a 	mov	r5,r20
21098170:	d9801a04 	addi	r6,sp,104
21098174:	da402c15 	stw	r9,176(sp)
21098178:	10974140 	call	21097414 <__ssprint_r>
2109817c:	da402c17 	ldw	r9,176(sp)
21098180:	103fd31e 	bne	r2,zero,210980d0 <__flash_rwdata_start+0xffff5e88>
21098184:	b5bffc04 	addi	r22,r22,-16
21098188:	d8c01c17 	ldw	r3,112(sp)
2109818c:	d8801b17 	ldw	r2,108(sp)
21098190:	d811883a 	mov	r8,sp
21098194:	4dbfed16 	blt	r9,r22,2109814c <__flash_rwdata_start+0xffff5f04>
21098198:	da802217 	ldw	r10,136(sp)
2109819c:	1d87883a 	add	r3,r3,r22
210981a0:	10800044 	addi	r2,r2,1
210981a4:	42800015 	stw	r10,0(r8)
210981a8:	45800115 	stw	r22,4(r8)
210981ac:	d8c01c15 	stw	r3,112(sp)
210981b0:	d8801b15 	stw	r2,108(sp)
210981b4:	010001c4 	movi	r4,7
210981b8:	2080c616 	blt	r4,r2,210984d4 <___svfiprintf_internal_r+0xef4>
210981bc:	42000204 	addi	r8,r8,8
210981c0:	003f2c06 	br	21097e74 <__flash_rwdata_start+0xffff5c2c>
210981c4:	9009883a 	mov	r4,r18
210981c8:	a00b883a 	mov	r5,r20
210981cc:	d9801a04 	addi	r6,sp,104
210981d0:	10974140 	call	21097414 <__ssprint_r>
210981d4:	103fbe1e 	bne	r2,zero,210980d0 <__flash_rwdata_start+0xffff5e88>
210981d8:	d8c01c17 	ldw	r3,112(sp)
210981dc:	d811883a 	mov	r8,sp
210981e0:	003f5606 	br	21097f3c <__flash_rwdata_start+0xffff5cf4>
210981e4:	9009883a 	mov	r4,r18
210981e8:	a00b883a 	mov	r5,r20
210981ec:	d9801a04 	addi	r6,sp,104
210981f0:	10974140 	call	21097414 <__ssprint_r>
210981f4:	103f8626 	beq	r2,zero,21098010 <__flash_rwdata_start+0xffff5dc8>
210981f8:	003fb506 	br	210980d0 <__flash_rwdata_start+0xffff5e88>
210981fc:	10803fcc 	andi	r2,r2,255
21098200:	10003b1e 	bne	r2,zero,210982f0 <___svfiprintf_internal_r+0xd10>
21098204:	8880004c 	andi	r2,r17,1
21098208:	10007d26 	beq	r2,zero,21098400 <___svfiprintf_internal_r+0xe20>
2109820c:	00800c04 	movi	r2,48
21098210:	d8c019c4 	addi	r3,sp,103
21098214:	d88019c5 	stb	r2,103(sp)
21098218:	df002b17 	ldw	fp,172(sp)
2109821c:	d8c02615 	stw	r3,152(sp)
21098220:	003dc506 	br	21097938 <__flash_rwdata_start+0xffff56f0>
21098224:	00bfffc4 	movi	r2,-1
21098228:	003fae06 	br	210980e4 <__flash_rwdata_start+0xffff5e9c>
2109822c:	9009883a 	mov	r4,r18
21098230:	a00b883a 	mov	r5,r20
21098234:	d9801a04 	addi	r6,sp,104
21098238:	10974140 	call	21097414 <__ssprint_r>
2109823c:	103fa41e 	bne	r2,zero,210980d0 <__flash_rwdata_start+0xffff5e88>
21098240:	d811883a 	mov	r8,sp
21098244:	003d2206 	br	210976d0 <__flash_rwdata_start+0xffff5488>
21098248:	9009883a 	mov	r4,r18
2109824c:	a00b883a 	mov	r5,r20
21098250:	d9801a04 	addi	r6,sp,104
21098254:	10974140 	call	21097414 <__ssprint_r>
21098258:	103f9d1e 	bne	r2,zero,210980d0 <__flash_rwdata_start+0xffff5e88>
2109825c:	d8c01c17 	ldw	r3,112(sp)
21098260:	d8801b17 	ldw	r2,108(sp)
21098264:	d811883a 	mov	r8,sp
21098268:	003f2a06 	br	21097f14 <__flash_rwdata_start+0xffff5ccc>
2109826c:	d9402a17 	ldw	r5,168(sp)
21098270:	d8c01a04 	addi	r3,sp,104
21098274:	488003cc 	andi	r2,r9,15
21098278:	5008973a 	slli	r4,r10,28
2109827c:	2885883a 	add	r2,r5,r2
21098280:	4812d13a 	srli	r9,r9,4
21098284:	10800003 	ldbu	r2,0(r2)
21098288:	5014d13a 	srli	r10,r10,4
2109828c:	18ffffc4 	addi	r3,r3,-1
21098290:	2252b03a 	or	r9,r4,r9
21098294:	18800005 	stb	r2,0(r3)
21098298:	4a84b03a 	or	r2,r9,r10
2109829c:	103ff51e 	bne	r2,zero,21098274 <__flash_rwdata_start+0xffff602c>
210982a0:	d8c02615 	stw	r3,152(sp)
210982a4:	003da206 	br	21097930 <__flash_rwdata_start+0xffff56e8>
210982a8:	9009883a 	mov	r4,r18
210982ac:	a00b883a 	mov	r5,r20
210982b0:	d9801a04 	addi	r6,sp,104
210982b4:	10974140 	call	21097414 <__ssprint_r>
210982b8:	103f851e 	bne	r2,zero,210980d0 <__flash_rwdata_start+0xffff5e88>
210982bc:	d8c01c17 	ldw	r3,112(sp)
210982c0:	d8801b17 	ldw	r2,108(sp)
210982c4:	d811883a 	mov	r8,sp
210982c8:	003eda06 	br	21097e34 <__flash_rwdata_start+0xffff5bec>
210982cc:	9009883a 	mov	r4,r18
210982d0:	a00b883a 	mov	r5,r20
210982d4:	d9801a04 	addi	r6,sp,104
210982d8:	10974140 	call	21097414 <__ssprint_r>
210982dc:	103f7c1e 	bne	r2,zero,210980d0 <__flash_rwdata_start+0xffff5e88>
210982e0:	d8c01c17 	ldw	r3,112(sp)
210982e4:	d8801b17 	ldw	r2,108(sp)
210982e8:	d811883a 	mov	r8,sp
210982ec:	003ede06 	br	21097e68 <__flash_rwdata_start+0xffff5c20>
210982f0:	da801a04 	addi	r10,sp,104
210982f4:	da802615 	stw	r10,152(sp)
210982f8:	003d8f06 	br	21097938 <__flash_rwdata_start+0xffff56f0>
210982fc:	8880040c 	andi	r2,r17,16
21098300:	10004c1e 	bne	r2,zero,21098434 <___svfiprintf_internal_r+0xe54>
21098304:	8880100c 	andi	r2,r17,64
21098308:	da802317 	ldw	r10,140(sp)
2109830c:	10004a26 	beq	r2,zero,21098438 <___svfiprintf_internal_r+0xe58>
21098310:	5240000b 	ldhu	r9,0(r10)
21098314:	dac02317 	ldw	r11,140(sp)
21098318:	0015883a 	mov	r10,zero
2109831c:	00800044 	movi	r2,1
21098320:	5ac00104 	addi	r11,r11,4
21098324:	dac02315 	stw	r11,140(sp)
21098328:	4807883a 	mov	r3,r9
2109832c:	003d6506 	br	210978c4 <__flash_rwdata_start+0xffff567c>
21098330:	9009883a 	mov	r4,r18
21098334:	a00b883a 	mov	r5,r20
21098338:	d9801a04 	addi	r6,sp,104
2109833c:	10974140 	call	21097414 <__ssprint_r>
21098340:	103f631e 	bne	r2,zero,210980d0 <__flash_rwdata_start+0xffff5e88>
21098344:	d8c01c17 	ldw	r3,112(sp)
21098348:	d8801b17 	ldw	r2,108(sp)
2109834c:	d811883a 	mov	r8,sp
21098350:	003eab06 	br	21097e00 <__flash_rwdata_start+0xffff5bb8>
21098354:	8880040c 	andi	r2,r17,16
21098358:	1000331e 	bne	r2,zero,21098428 <___svfiprintf_internal_r+0xe48>
2109835c:	8880100c 	andi	r2,r17,64
21098360:	da802317 	ldw	r10,140(sp)
21098364:	10003126 	beq	r2,zero,2109842c <___svfiprintf_internal_r+0xe4c>
21098368:	5240000b 	ldhu	r9,0(r10)
2109836c:	dac02317 	ldw	r11,140(sp)
21098370:	0015883a 	mov	r10,zero
21098374:	0005883a 	mov	r2,zero
21098378:	5ac00104 	addi	r11,r11,4
2109837c:	dac02315 	stw	r11,140(sp)
21098380:	4807883a 	mov	r3,r9
21098384:	003d4f06 	br	210978c4 <__flash_rwdata_start+0xffff567c>
21098388:	10803fcc 	andi	r2,r2,255
2109838c:	1080201c 	xori	r2,r2,128
21098390:	10bfe004 	addi	r2,r2,-128
21098394:	01000c04 	movi	r4,48
21098398:	11005b26 	beq	r2,r4,21098508 <___svfiprintf_internal_r+0xf28>
2109839c:	da802617 	ldw	r10,152(sp)
210983a0:	d8801e17 	ldw	r2,120(sp)
210983a4:	193fffc5 	stb	r4,-1(r3)
210983a8:	52bfffc4 	addi	r10,r10,-1
210983ac:	da802615 	stw	r10,152(sp)
210983b0:	12b9c83a 	sub	fp,r2,r10
210983b4:	003d6006 	br	21097938 <__flash_rwdata_start+0xffff56f0>
210983b8:	00800244 	movi	r2,9
210983bc:	127f1e36 	bltu	r2,r9,21098038 <__flash_rwdata_start+0xffff5df0>
210983c0:	4a400c04 	addi	r9,r9,48
210983c4:	d8c019c4 	addi	r3,sp,103
210983c8:	da4019c5 	stb	r9,103(sp)
210983cc:	df002b17 	ldw	fp,172(sp)
210983d0:	d8c02615 	stw	r3,152(sp)
210983d4:	003d5806 	br	21097938 <__flash_rwdata_start+0xffff56f0>
210983d8:	d8802315 	stw	r2,140(sp)
210983dc:	a9000007 	ldb	r4,0(r21)
210983e0:	003ccb06 	br	21097710 <__flash_rwdata_start+0xffff54c8>
210983e4:	9009883a 	mov	r4,r18
210983e8:	a00b883a 	mov	r5,r20
210983ec:	d9801a04 	addi	r6,sp,104
210983f0:	10974140 	call	21097414 <__ssprint_r>
210983f4:	103f361e 	bne	r2,zero,210980d0 <__flash_rwdata_start+0xffff5e88>
210983f8:	d8c01c17 	ldw	r3,112(sp)
210983fc:	003efc06 	br	21097ff0 <__flash_rwdata_start+0xffff5da8>
21098400:	d8c01a04 	addi	r3,sp,104
21098404:	d8c02615 	stw	r3,152(sp)
21098408:	003d4b06 	br	21097938 <__flash_rwdata_start+0xffff56f0>
2109840c:	da802317 	ldw	r10,140(sp)
21098410:	1a400017 	ldw	r9,0(r3)
21098414:	52800104 	addi	r10,r10,4
21098418:	da802315 	stw	r10,140(sp)
2109841c:	4815d7fa 	srai	r10,r9,31
21098420:	5005883a 	mov	r2,r10
21098424:	003d9c06 	br	21097a98 <__flash_rwdata_start+0xffff5850>
21098428:	da802317 	ldw	r10,140(sp)
2109842c:	52400017 	ldw	r9,0(r10)
21098430:	003fce06 	br	2109836c <__flash_rwdata_start+0xffff6124>
21098434:	da802317 	ldw	r10,140(sp)
21098438:	52400017 	ldw	r9,0(r10)
2109843c:	003fb506 	br	21098314 <__flash_rwdata_start+0xffff60cc>
21098440:	8880100c 	andi	r2,r17,64
21098444:	da802317 	ldw	r10,140(sp)
21098448:	103e1926 	beq	r2,zero,21097cb0 <__flash_rwdata_start+0xffff5a68>
2109844c:	dac02317 	ldw	r11,140(sp)
21098450:	5240000b 	ldhu	r9,0(r10)
21098454:	0015883a 	mov	r10,zero
21098458:	5ac00104 	addi	r11,r11,4
2109845c:	dac02315 	stw	r11,140(sp)
21098460:	003de406 	br	21097bf4 <__flash_rwdata_start+0xffff59ac>
21098464:	a9000007 	ldb	r4,0(r21)
21098468:	003ca906 	br	21097710 <__flash_rwdata_start+0xffff54c8>
2109846c:	dac02317 	ldw	r11,140(sp)
21098470:	da802417 	ldw	r10,144(sp)
21098474:	58800017 	ldw	r2,0(r11)
21098478:	5007d7fa 	srai	r3,r10,31
2109847c:	5ac00104 	addi	r11,r11,4
21098480:	dac02315 	stw	r11,140(sp)
21098484:	12800015 	stw	r10,0(r2)
21098488:	10c00115 	stw	r3,4(r2)
2109848c:	003c7806 	br	21097670 <__flash_rwdata_start+0xffff5428>
21098490:	00800c04 	movi	r2,48
21098494:	d8801d05 	stb	r2,116(sp)
21098498:	d9001d45 	stb	r4,117(sp)
2109849c:	8c400094 	ori	r17,r17,2
210984a0:	00800084 	movi	r2,2
210984a4:	003d0706 	br	210978c4 <__flash_rwdata_start+0xffff567c>
210984a8:	ad400044 	addi	r21,r21,1
210984ac:	8c400814 	ori	r17,r17,32
210984b0:	11000047 	ldb	r4,1(r2)
210984b4:	003c9606 	br	21097710 <__flash_rwdata_start+0xffff54c8>
210984b8:	dac02317 	ldw	r11,140(sp)
210984bc:	da802417 	ldw	r10,144(sp)
210984c0:	58800017 	ldw	r2,0(r11)
210984c4:	5ac00104 	addi	r11,r11,4
210984c8:	dac02315 	stw	r11,140(sp)
210984cc:	12800015 	stw	r10,0(r2)
210984d0:	003c6706 	br	21097670 <__flash_rwdata_start+0xffff5428>
210984d4:	9009883a 	mov	r4,r18
210984d8:	a00b883a 	mov	r5,r20
210984dc:	d9801a04 	addi	r6,sp,104
210984e0:	10974140 	call	21097414 <__ssprint_r>
210984e4:	103efa1e 	bne	r2,zero,210980d0 <__flash_rwdata_start+0xffff5e88>
210984e8:	d8c01c17 	ldw	r3,112(sp)
210984ec:	d8801b17 	ldw	r2,108(sp)
210984f0:	d811883a 	mov	r8,sp
210984f4:	003e5f06 	br	21097e74 <__flash_rwdata_start+0xffff5c2c>
210984f8:	02c00034 	movhi	r11,0
210984fc:	5acf3a04 	addi	r11,r11,15592
21098500:	dac02215 	stw	r11,136(sp)
21098504:	003e7906 	br	21097eec <__flash_rwdata_start+0xffff5ca4>
21098508:	da801e17 	ldw	r10,120(sp)
2109850c:	d8c02617 	ldw	r3,152(sp)
21098510:	50f9c83a 	sub	fp,r10,r3
21098514:	003d0806 	br	21097938 <__flash_rwdata_start+0xffff56f0>
21098518:	da002c15 	stw	r8,176(sp)
2109851c:	108e7200 	call	2108e720 <strlen>
21098520:	1039883a 	mov	fp,r2
21098524:	dac01d83 	ldbu	r11,118(sp)
21098528:	ddc02315 	stw	r23,140(sp)
2109852c:	0021883a 	mov	r16,zero
21098530:	da002c17 	ldw	r8,176(sp)
21098534:	003d0006 	br	21097938 <__flash_rwdata_start+0xffff56f0>
21098538:	00800184 	movi	r2,6
2109853c:	1400012e 	bgeu	r2,r16,21098544 <___svfiprintf_internal_r+0xf64>
21098540:	1021883a 	mov	r16,r2
21098544:	8039883a 	mov	fp,r16
21098548:	802d883a 	mov	r22,r16
2109854c:	80002116 	blt	r16,zero,210985d4 <___svfiprintf_internal_r+0xff4>
21098550:	00800034 	movhi	r2,0
21098554:	108ed704 	addi	r2,r2,15196
21098558:	dd802015 	stw	r22,128(sp)
2109855c:	ddc02315 	stw	r23,140(sp)
21098560:	d8802615 	stw	r2,152(sp)
21098564:	003d5d06 	br	21097adc <__flash_rwdata_start+0xffff5894>
21098568:	04001004 	movi	r16,64
2109856c:	800b883a 	mov	r5,r16
21098570:	108d9100 	call	2108d910 <_malloc_r>
21098574:	da802717 	ldw	r10,156(sp)
21098578:	50800015 	stw	r2,0(r10)
2109857c:	50800415 	stw	r2,16(r10)
21098580:	10002026 	beq	r2,zero,21098604 <___svfiprintf_internal_r+0x1024>
21098584:	da802717 	ldw	r10,156(sp)
21098588:	54000515 	stw	r16,20(r10)
2109858c:	003c2806 	br	21097630 <__flash_rwdata_start+0xffff53e8>
21098590:	01000034 	movhi	r4,0
21098594:	210f3e04 	addi	r4,r4,15608
21098598:	d9002815 	stw	r4,160(sp)
2109859c:	003d7e06 	br	21097b98 <__flash_rwdata_start+0xffff5950>
210985a0:	01000034 	movhi	r4,0
210985a4:	210f3e04 	addi	r4,r4,15608
210985a8:	d9002815 	stw	r4,160(sp)
210985ac:	003e8706 	br	21097fcc <__flash_rwdata_start+0xffff5d84>
210985b0:	01000034 	movhi	r4,0
210985b4:	210f3a04 	addi	r4,r4,15592
210985b8:	d9002215 	stw	r4,136(sp)
210985bc:	003ef606 	br	21098198 <__flash_rwdata_start+0xffff5f50>
210985c0:	8039883a 	mov	fp,r16
210985c4:	dac01d83 	ldbu	r11,118(sp)
210985c8:	ddc02315 	stw	r23,140(sp)
210985cc:	0021883a 	mov	r16,zero
210985d0:	003cd906 	br	21097938 <__flash_rwdata_start+0xffff56f0>
210985d4:	002d883a 	mov	r22,zero
210985d8:	003fdd06 	br	21098550 <__flash_rwdata_start+0xffff6308>
210985dc:	dac02317 	ldw	r11,140(sp)
210985e0:	a805883a 	mov	r2,r21
210985e4:	502b883a 	mov	r21,r10
210985e8:	5c000017 	ldw	r16,0(r11)
210985ec:	59000104 	addi	r4,r11,4
210985f0:	d9002315 	stw	r4,140(sp)
210985f4:	803fae0e 	bge	r16,zero,210984b0 <__flash_rwdata_start+0xffff6268>
210985f8:	043fffc4 	movi	r16,-1
210985fc:	11000047 	ldb	r4,1(r2)
21098600:	003c4306 	br	21097710 <__flash_rwdata_start+0xffff54c8>
21098604:	dac02917 	ldw	r11,164(sp)
21098608:	00800304 	movi	r2,12
2109860c:	58800015 	stw	r2,0(r11)
21098610:	00bfffc4 	movi	r2,-1
21098614:	003eb306 	br	210980e4 <__flash_rwdata_start+0xffff5e9c>

21098618 <__sprint_r.part.0>:
21098618:	28801917 	ldw	r2,100(r5)
2109861c:	defff604 	addi	sp,sp,-40
21098620:	dd400515 	stw	r21,20(sp)
21098624:	dcc00315 	stw	r19,12(sp)
21098628:	dfc00915 	stw	ra,36(sp)
2109862c:	df000815 	stw	fp,32(sp)
21098630:	ddc00715 	stw	r23,28(sp)
21098634:	dd800615 	stw	r22,24(sp)
21098638:	dd000415 	stw	r20,16(sp)
2109863c:	dc800215 	stw	r18,8(sp)
21098640:	dc400115 	stw	r17,4(sp)
21098644:	dc000015 	stw	r16,0(sp)
21098648:	1088000c 	andi	r2,r2,8192
2109864c:	2827883a 	mov	r19,r5
21098650:	302b883a 	mov	r21,r6
21098654:	10002d26 	beq	r2,zero,2109870c <__sprint_r.part.0+0xf4>
21098658:	30800217 	ldw	r2,8(r6)
2109865c:	35800017 	ldw	r22,0(r6)
21098660:	10002826 	beq	r2,zero,21098704 <__sprint_r.part.0+0xec>
21098664:	2029883a 	mov	r20,r4
21098668:	b5c00104 	addi	r23,r22,4
2109866c:	04bfffc4 	movi	r18,-1
21098670:	bc400017 	ldw	r17,0(r23)
21098674:	b4000017 	ldw	r16,0(r22)
21098678:	0039883a 	mov	fp,zero
2109867c:	8822d0ba 	srli	r17,r17,2
21098680:	04400316 	blt	zero,r17,21098690 <__sprint_r.part.0+0x78>
21098684:	00001806 	br	210986e8 <__sprint_r.part.0+0xd0>
21098688:	84000104 	addi	r16,r16,4
2109868c:	8f001526 	beq	r17,fp,210986e4 <__sprint_r.part.0+0xcc>
21098690:	81400017 	ldw	r5,0(r16)
21098694:	a009883a 	mov	r4,r20
21098698:	980d883a 	mov	r6,r19
2109869c:	1099ea80 	call	21099ea8 <_fputwc_r>
210986a0:	e7000044 	addi	fp,fp,1
210986a4:	14bff81e 	bne	r2,r18,21098688 <__flash_rwdata_start+0xffff6440>
210986a8:	9005883a 	mov	r2,r18
210986ac:	a8000215 	stw	zero,8(r21)
210986b0:	a8000115 	stw	zero,4(r21)
210986b4:	dfc00917 	ldw	ra,36(sp)
210986b8:	df000817 	ldw	fp,32(sp)
210986bc:	ddc00717 	ldw	r23,28(sp)
210986c0:	dd800617 	ldw	r22,24(sp)
210986c4:	dd400517 	ldw	r21,20(sp)
210986c8:	dd000417 	ldw	r20,16(sp)
210986cc:	dcc00317 	ldw	r19,12(sp)
210986d0:	dc800217 	ldw	r18,8(sp)
210986d4:	dc400117 	ldw	r17,4(sp)
210986d8:	dc000017 	ldw	r16,0(sp)
210986dc:	dec00a04 	addi	sp,sp,40
210986e0:	f800283a 	ret
210986e4:	a8800217 	ldw	r2,8(r21)
210986e8:	8c63883a 	add	r17,r17,r17
210986ec:	8c63883a 	add	r17,r17,r17
210986f0:	1445c83a 	sub	r2,r2,r17
210986f4:	a8800215 	stw	r2,8(r21)
210986f8:	b5800204 	addi	r22,r22,8
210986fc:	bdc00204 	addi	r23,r23,8
21098700:	103fdb1e 	bne	r2,zero,21098670 <__flash_rwdata_start+0xffff6428>
21098704:	0005883a 	mov	r2,zero
21098708:	003fe806 	br	210986ac <__flash_rwdata_start+0xffff6464>
2109870c:	1094f680 	call	21094f68 <__sfvwrite_r>
21098710:	003fe606 	br	210986ac <__flash_rwdata_start+0xffff6464>

21098714 <__sprint_r>:
21098714:	30c00217 	ldw	r3,8(r6)
21098718:	18000126 	beq	r3,zero,21098720 <__sprint_r+0xc>
2109871c:	10986181 	jmpi	21098618 <__sprint_r.part.0>
21098720:	30000115 	stw	zero,4(r6)
21098724:	0005883a 	mov	r2,zero
21098728:	f800283a 	ret

2109872c <___vfiprintf_internal_r>:
2109872c:	deffca04 	addi	sp,sp,-216
21098730:	dd803215 	stw	r22,200(sp)
21098734:	dd403115 	stw	r21,196(sp)
21098738:	dfc03515 	stw	ra,212(sp)
2109873c:	df003415 	stw	fp,208(sp)
21098740:	ddc03315 	stw	r23,204(sp)
21098744:	dd003015 	stw	r20,192(sp)
21098748:	dcc02f15 	stw	r19,188(sp)
2109874c:	dc802e15 	stw	r18,184(sp)
21098750:	dc402d15 	stw	r17,180(sp)
21098754:	dc002c15 	stw	r16,176(sp)
21098758:	d9002015 	stw	r4,128(sp)
2109875c:	d9c02215 	stw	r7,136(sp)
21098760:	282b883a 	mov	r21,r5
21098764:	302d883a 	mov	r22,r6
21098768:	20000226 	beq	r4,zero,21098774 <___vfiprintf_internal_r+0x48>
2109876c:	20800e17 	ldw	r2,56(r4)
21098770:	1001b126 	beq	r2,zero,21098e38 <___vfiprintf_internal_r+0x70c>
21098774:	a880030b 	ldhu	r2,12(r21)
21098778:	10c8000c 	andi	r3,r2,8192
2109877c:	1800061e 	bne	r3,zero,21098798 <___vfiprintf_internal_r+0x6c>
21098780:	a9001917 	ldw	r4,100(r21)
21098784:	00f7ffc4 	movi	r3,-8193
21098788:	10880014 	ori	r2,r2,8192
2109878c:	20c6703a 	and	r3,r4,r3
21098790:	a880030d 	sth	r2,12(r21)
21098794:	a8c01915 	stw	r3,100(r21)
21098798:	10c0020c 	andi	r3,r2,8
2109879c:	18018926 	beq	r3,zero,21098dc4 <___vfiprintf_internal_r+0x698>
210987a0:	a8c00417 	ldw	r3,16(r21)
210987a4:	18018726 	beq	r3,zero,21098dc4 <___vfiprintf_internal_r+0x698>
210987a8:	1080068c 	andi	r2,r2,26
210987ac:	00c00284 	movi	r3,10
210987b0:	10c18c26 	beq	r2,r3,21098de4 <___vfiprintf_internal_r+0x6b8>
210987b4:	d8801a04 	addi	r2,sp,104
210987b8:	d8c019c4 	addi	r3,sp,103
210987bc:	07000034 	movhi	fp,0
210987c0:	05c00034 	movhi	r23,0
210987c4:	10c9c83a 	sub	r4,r2,r3
210987c8:	e70f4604 	addi	fp,fp,15640
210987cc:	bdcf4204 	addi	r23,r23,15624
210987d0:	d8801e15 	stw	r2,120(sp)
210987d4:	d8c01f15 	stw	r3,124(sp)
210987d8:	dec01a15 	stw	sp,104(sp)
210987dc:	d8001c15 	stw	zero,112(sp)
210987e0:	d8001b15 	stw	zero,108(sp)
210987e4:	d8002615 	stw	zero,152(sp)
210987e8:	d8002315 	stw	zero,140(sp)
210987ec:	d9002715 	stw	r4,156(sp)
210987f0:	d811883a 	mov	r8,sp
210987f4:	dd402115 	stw	r21,132(sp)
210987f8:	b021883a 	mov	r16,r22
210987fc:	80800007 	ldb	r2,0(r16)
21098800:	10037226 	beq	r2,zero,210995cc <___vfiprintf_internal_r+0xea0>
21098804:	01000944 	movi	r4,37
21098808:	11037026 	beq	r2,r4,210995cc <___vfiprintf_internal_r+0xea0>
2109880c:	8005883a 	mov	r2,r16
21098810:	00000106 	br	21098818 <___vfiprintf_internal_r+0xec>
21098814:	19000326 	beq	r3,r4,21098824 <___vfiprintf_internal_r+0xf8>
21098818:	10800044 	addi	r2,r2,1
2109881c:	10c00007 	ldb	r3,0(r2)
21098820:	183ffc1e 	bne	r3,zero,21098814 <__flash_rwdata_start+0xffff65cc>
21098824:	1425c83a 	sub	r18,r2,r16
21098828:	1023883a 	mov	r17,r2
2109882c:	90001026 	beq	r18,zero,21098870 <___vfiprintf_internal_r+0x144>
21098830:	d8c01c17 	ldw	r3,112(sp)
21098834:	d8801b17 	ldw	r2,108(sp)
21098838:	44000015 	stw	r16,0(r8)
2109883c:	90c7883a 	add	r3,r18,r3
21098840:	10800044 	addi	r2,r2,1
21098844:	44800115 	stw	r18,4(r8)
21098848:	d8c01c15 	stw	r3,112(sp)
2109884c:	d8801b15 	stw	r2,108(sp)
21098850:	010001c4 	movi	r4,7
21098854:	2080750e 	bge	r4,r2,21098a2c <___vfiprintf_internal_r+0x300>
21098858:	18036f1e 	bne	r3,zero,21099618 <___vfiprintf_internal_r+0xeec>
2109885c:	d8802317 	ldw	r2,140(sp)
21098860:	d8001b15 	stw	zero,108(sp)
21098864:	d811883a 	mov	r8,sp
21098868:	1485883a 	add	r2,r2,r18
2109886c:	d8802315 	stw	r2,140(sp)
21098870:	88800007 	ldb	r2,0(r17)
21098874:	10041026 	beq	r2,zero,210998b8 <___vfiprintf_internal_r+0x118c>
21098878:	88c00047 	ldb	r3,1(r17)
2109887c:	88800044 	addi	r2,r17,1
21098880:	d8001d85 	stb	zero,118(sp)
21098884:	000f883a 	mov	r7,zero
21098888:	027fffc4 	movi	r9,-1
2109888c:	0025883a 	mov	r18,zero
21098890:	002b883a 	mov	r21,zero
21098894:	01401604 	movi	r5,88
21098898:	01800244 	movi	r6,9
2109889c:	03400a84 	movi	r13,42
210988a0:	03001b04 	movi	r12,108
210988a4:	14000044 	addi	r16,r2,1
210988a8:	18bff804 	addi	r2,r3,-32
210988ac:	28825536 	bltu	r5,r2,21099204 <___vfiprintf_internal_r+0xad8>
210988b0:	100490ba 	slli	r2,r2,2
210988b4:	010842b4 	movhi	r4,8458
210988b8:	21223204 	addi	r4,r4,-30520
210988bc:	1105883a 	add	r2,r2,r4
210988c0:	10800017 	ldw	r2,0(r2)
210988c4:	1000683a 	jmp	r2
210988c8:	21098fc8 	cmpgei	r4,r4,9791
210988cc:	21099204 	addi	r4,r4,9800
210988d0:	21099204 	addi	r4,r4,9800
210988d4:	21098fe8 	cmpgeui	r4,r4,9791
210988d8:	21099204 	addi	r4,r4,9800
210988dc:	21099204 	addi	r4,r4,9800
210988e0:	21099204 	addi	r4,r4,9800
210988e4:	21099204 	addi	r4,r4,9800
210988e8:	21099204 	addi	r4,r4,9800
210988ec:	21099204 	addi	r4,r4,9800
210988f0:	21098ff8 	rdprs	r4,r4,9791
210988f4:	21099018 	cmpnei	r4,r4,9792
210988f8:	21099204 	addi	r4,r4,9800
210988fc:	21098e40 	call	221098e4 <__flash_rwdata_start+0x106769c>
21098900:	21098f2c 	andhi	r4,r4,9788
21098904:	21099204 	addi	r4,r4,9800
21098908:	21098eac 	andhi	r4,r4,9786
2109890c:	21098ebc 	xorhi	r4,r4,9786
21098910:	21098ebc 	xorhi	r4,r4,9786
21098914:	21098ebc 	xorhi	r4,r4,9786
21098918:	21098ebc 	xorhi	r4,r4,9786
2109891c:	21098ebc 	xorhi	r4,r4,9786
21098920:	21098ebc 	xorhi	r4,r4,9786
21098924:	21098ebc 	xorhi	r4,r4,9786
21098928:	21098ebc 	xorhi	r4,r4,9786
2109892c:	21098ebc 	xorhi	r4,r4,9786
21098930:	21099204 	addi	r4,r4,9800
21098934:	21099204 	addi	r4,r4,9800
21098938:	21099204 	addi	r4,r4,9800
2109893c:	21099204 	addi	r4,r4,9800
21098940:	21099204 	addi	r4,r4,9800
21098944:	21099204 	addi	r4,r4,9800
21098948:	21099204 	addi	r4,r4,9800
2109894c:	21099204 	addi	r4,r4,9800
21098950:	21099204 	addi	r4,r4,9800
21098954:	21099204 	addi	r4,r4,9800
21098958:	21098ee8 	cmpgeui	r4,r4,9787
2109895c:	21099204 	addi	r4,r4,9800
21098960:	21099204 	addi	r4,r4,9800
21098964:	21099204 	addi	r4,r4,9800
21098968:	21099204 	addi	r4,r4,9800
2109896c:	21099204 	addi	r4,r4,9800
21098970:	21099204 	addi	r4,r4,9800
21098974:	21099204 	addi	r4,r4,9800
21098978:	21099204 	addi	r4,r4,9800
2109897c:	21099204 	addi	r4,r4,9800
21098980:	21099204 	addi	r4,r4,9800
21098984:	21098a74 	orhi	r4,r4,9769
21098988:	21099204 	addi	r4,r4,9800
2109898c:	21099204 	addi	r4,r4,9800
21098990:	21099204 	addi	r4,r4,9800
21098994:	21099204 	addi	r4,r4,9800
21098998:	21099204 	addi	r4,r4,9800
2109899c:	21098a40 	call	221098a4 <__flash_rwdata_start+0x106765c>
210989a0:	21099204 	addi	r4,r4,9800
210989a4:	21099204 	addi	r4,r4,9800
210989a8:	21099088 	cmpgei	r4,r4,9794
210989ac:	21099204 	addi	r4,r4,9800
210989b0:	21099204 	addi	r4,r4,9800
210989b4:	21099204 	addi	r4,r4,9800
210989b8:	21099204 	addi	r4,r4,9800
210989bc:	21099204 	addi	r4,r4,9800
210989c0:	21099204 	addi	r4,r4,9800
210989c4:	21099204 	addi	r4,r4,9800
210989c8:	21099204 	addi	r4,r4,9800
210989cc:	21099204 	addi	r4,r4,9800
210989d0:	21099204 	addi	r4,r4,9800
210989d4:	21099028 	cmpgeui	r4,r4,9792
210989d8:	21099054 	ori	r4,r4,9793
210989dc:	21099204 	addi	r4,r4,9800
210989e0:	21099204 	addi	r4,r4,9800
210989e4:	21099204 	addi	r4,r4,9800
210989e8:	21099130 	cmpltui	r4,r4,9796
210989ec:	21099054 	ori	r4,r4,9793
210989f0:	21099204 	addi	r4,r4,9800
210989f4:	21099204 	addi	r4,r4,9800
210989f8:	21099140 	call	22109914 <__flash_rwdata_start+0x10676cc>
210989fc:	21099204 	addi	r4,r4,9800
21098a00:	21098f6c 	andhi	r4,r4,9789
21098a04:	21098a78 	rdprs	r4,r4,9769
21098a08:	21099154 	ori	r4,r4,9797
21098a0c:	21099194 	ori	r4,r4,9798
21098a10:	21099204 	addi	r4,r4,9800
21098a14:	210990dc 	xori	r4,r4,9795
21098a18:	21099204 	addi	r4,r4,9800
21098a1c:	21098a44 	addi	r4,r4,9769
21098a20:	21099204 	addi	r4,r4,9800
21098a24:	21099204 	addi	r4,r4,9800
21098a28:	210991a4 	muli	r4,r4,9798
21098a2c:	42000204 	addi	r8,r8,8
21098a30:	d8802317 	ldw	r2,140(sp)
21098a34:	1485883a 	add	r2,r2,r18
21098a38:	d8802315 	stw	r2,140(sp)
21098a3c:	003f8c06 	br	21098870 <__flash_rwdata_start+0xffff6628>
21098a40:	ad400414 	ori	r21,r21,16
21098a44:	a880080c 	andi	r2,r21,32
21098a48:	1001e61e 	bne	r2,zero,210991e4 <___vfiprintf_internal_r+0xab8>
21098a4c:	a880040c 	andi	r2,r21,16
21098a50:	10034726 	beq	r2,zero,21099770 <___vfiprintf_internal_r+0x1044>
21098a54:	d8802217 	ldw	r2,136(sp)
21098a58:	001b883a 	mov	r13,zero
21098a5c:	15800017 	ldw	r22,0(r2)
21098a60:	10800104 	addi	r2,r2,4
21098a64:	d8802215 	stw	r2,136(sp)
21098a68:	b009883a 	mov	r4,r22
21098a6c:	00800044 	movi	r2,1
21098a70:	00000c06 	br	21098aa4 <___vfiprintf_internal_r+0x378>
21098a74:	ad400414 	ori	r21,r21,16
21098a78:	a880080c 	andi	r2,r21,32
21098a7c:	1001491e 	bne	r2,zero,21098fa4 <___vfiprintf_internal_r+0x878>
21098a80:	a880040c 	andi	r2,r21,16
21098a84:	10032d26 	beq	r2,zero,2109973c <___vfiprintf_internal_r+0x1010>
21098a88:	d9002217 	ldw	r4,136(sp)
21098a8c:	001b883a 	mov	r13,zero
21098a90:	0005883a 	mov	r2,zero
21098a94:	25800017 	ldw	r22,0(r4)
21098a98:	21000104 	addi	r4,r4,4
21098a9c:	d9002215 	stw	r4,136(sp)
21098aa0:	b009883a 	mov	r4,r22
21098aa4:	d8001d85 	stb	zero,118(sp)
21098aa8:	4827883a 	mov	r19,r9
21098aac:	001d883a 	mov	r14,zero
21098ab0:	48000216 	blt	r9,zero,21098abc <___vfiprintf_internal_r+0x390>
21098ab4:	00ffdfc4 	movi	r3,-129
21098ab8:	a8ea703a 	and	r21,r21,r3
21098abc:	2002071e 	bne	r4,zero,210992dc <___vfiprintf_internal_r+0xbb0>
21098ac0:	4802ad26 	beq	r9,zero,21099578 <___vfiprintf_internal_r+0xe4c>
21098ac4:	10803fcc 	andi	r2,r2,255
21098ac8:	00c00044 	movi	r3,1
21098acc:	10c22b26 	beq	r2,r3,2109937c <___vfiprintf_internal_r+0xc50>
21098ad0:	00c00084 	movi	r3,2
21098ad4:	dd001a04 	addi	r20,sp,104
21098ad8:	10c0dd1e 	bne	r2,r3,21098e50 <___vfiprintf_internal_r+0x724>
21098adc:	d9002617 	ldw	r4,152(sp)
21098ae0:	b08003cc 	andi	r2,r22,15
21098ae4:	6806973a 	slli	r3,r13,28
21098ae8:	2085883a 	add	r2,r4,r2
21098aec:	b02cd13a 	srli	r22,r22,4
21098af0:	10800003 	ldbu	r2,0(r2)
21098af4:	681ad13a 	srli	r13,r13,4
21098af8:	a53fffc4 	addi	r20,r20,-1
21098afc:	1dacb03a 	or	r22,r3,r22
21098b00:	a0800005 	stb	r2,0(r20)
21098b04:	b344b03a 	or	r2,r22,r13
21098b08:	103ff51e 	bne	r2,zero,21098ae0 <__flash_rwdata_start+0xffff6898>
21098b0c:	d9001e17 	ldw	r4,120(sp)
21098b10:	2527c83a 	sub	r19,r4,r20
21098b14:	9823883a 	mov	r17,r19
21098b18:	9a40010e 	bge	r19,r9,21098b20 <___vfiprintf_internal_r+0x3f4>
21098b1c:	4823883a 	mov	r17,r9
21098b20:	73803fcc 	andi	r14,r14,255
21098b24:	7380201c 	xori	r14,r14,128
21098b28:	73bfe004 	addi	r14,r14,-128
21098b2c:	70000126 	beq	r14,zero,21098b34 <___vfiprintf_internal_r+0x408>
21098b30:	8c400044 	addi	r17,r17,1
21098b34:	ab40008c 	andi	r13,r21,2
21098b38:	68000126 	beq	r13,zero,21098b40 <___vfiprintf_internal_r+0x414>
21098b3c:	8c400084 	addi	r17,r17,2
21098b40:	ad80210c 	andi	r22,r21,132
21098b44:	b001c51e 	bne	r22,zero,2109925c <___vfiprintf_internal_r+0xb30>
21098b48:	9447c83a 	sub	r3,r18,r17
21098b4c:	00c1c30e 	bge	zero,r3,2109925c <___vfiprintf_internal_r+0xb30>
21098b50:	01c00404 	movi	r7,16
21098b54:	d8801c17 	ldw	r2,112(sp)
21098b58:	38c37b0e 	bge	r7,r3,21099948 <___vfiprintf_internal_r+0x121c>
21098b5c:	01000034 	movhi	r4,0
21098b60:	210f4604 	addi	r4,r4,15640
21098b64:	dc002915 	stw	r16,164(sp)
21098b68:	d9801b17 	ldw	r6,108(sp)
21098b6c:	d9002415 	stw	r4,144(sp)
21098b70:	03c001c4 	movi	r15,7
21098b74:	da402515 	stw	r9,148(sp)
21098b78:	db402815 	stw	r13,160(sp)
21098b7c:	1821883a 	mov	r16,r3
21098b80:	00000506 	br	21098b98 <___vfiprintf_internal_r+0x46c>
21098b84:	31400084 	addi	r5,r6,2
21098b88:	42000204 	addi	r8,r8,8
21098b8c:	200d883a 	mov	r6,r4
21098b90:	843ffc04 	addi	r16,r16,-16
21098b94:	3c000d0e 	bge	r7,r16,21098bcc <___vfiprintf_internal_r+0x4a0>
21098b98:	10800404 	addi	r2,r2,16
21098b9c:	31000044 	addi	r4,r6,1
21098ba0:	47000015 	stw	fp,0(r8)
21098ba4:	41c00115 	stw	r7,4(r8)
21098ba8:	d8801c15 	stw	r2,112(sp)
21098bac:	d9001b15 	stw	r4,108(sp)
21098bb0:	793ff40e 	bge	r15,r4,21098b84 <__flash_rwdata_start+0xffff693c>
21098bb4:	10019b1e 	bne	r2,zero,21099224 <___vfiprintf_internal_r+0xaf8>
21098bb8:	843ffc04 	addi	r16,r16,-16
21098bbc:	000d883a 	mov	r6,zero
21098bc0:	01400044 	movi	r5,1
21098bc4:	d811883a 	mov	r8,sp
21098bc8:	3c3ff316 	blt	r7,r16,21098b98 <__flash_rwdata_start+0xffff6950>
21098bcc:	8007883a 	mov	r3,r16
21098bd0:	da402517 	ldw	r9,148(sp)
21098bd4:	db402817 	ldw	r13,160(sp)
21098bd8:	dc002917 	ldw	r16,164(sp)
21098bdc:	d9002417 	ldw	r4,144(sp)
21098be0:	1885883a 	add	r2,r3,r2
21098be4:	40c00115 	stw	r3,4(r8)
21098be8:	41000015 	stw	r4,0(r8)
21098bec:	d8801c15 	stw	r2,112(sp)
21098bf0:	d9401b15 	stw	r5,108(sp)
21098bf4:	00c001c4 	movi	r3,7
21098bf8:	19426a16 	blt	r3,r5,210995a4 <___vfiprintf_internal_r+0xe78>
21098bfc:	d8c01d87 	ldb	r3,118(sp)
21098c00:	42000204 	addi	r8,r8,8
21098c04:	29000044 	addi	r4,r5,1
21098c08:	1801991e 	bne	r3,zero,21099270 <___vfiprintf_internal_r+0xb44>
21098c0c:	68000c26 	beq	r13,zero,21098c40 <___vfiprintf_internal_r+0x514>
21098c10:	d8c01d04 	addi	r3,sp,116
21098c14:	10800084 	addi	r2,r2,2
21098c18:	40c00015 	stw	r3,0(r8)
21098c1c:	00c00084 	movi	r3,2
21098c20:	40c00115 	stw	r3,4(r8)
21098c24:	d8801c15 	stw	r2,112(sp)
21098c28:	d9001b15 	stw	r4,108(sp)
21098c2c:	00c001c4 	movi	r3,7
21098c30:	19024c16 	blt	r3,r4,21099564 <___vfiprintf_internal_r+0xe38>
21098c34:	200b883a 	mov	r5,r4
21098c38:	42000204 	addi	r8,r8,8
21098c3c:	21000044 	addi	r4,r4,1
21098c40:	00c02004 	movi	r3,128
21098c44:	b0c20126 	beq	r22,r3,2109944c <___vfiprintf_internal_r+0xd20>
21098c48:	4cedc83a 	sub	r22,r9,r19
21098c4c:	0580230e 	bge	zero,r22,21098cdc <___vfiprintf_internal_r+0x5b0>
21098c50:	01c00404 	movi	r7,16
21098c54:	3d83140e 	bge	r7,r22,210998a8 <___vfiprintf_internal_r+0x117c>
21098c58:	01000034 	movhi	r4,0
21098c5c:	210f4204 	addi	r4,r4,15624
21098c60:	d9002415 	stw	r4,144(sp)
21098c64:	034001c4 	movi	r13,7
21098c68:	00000506 	br	21098c80 <___vfiprintf_internal_r+0x554>
21098c6c:	29000084 	addi	r4,r5,2
21098c70:	42000204 	addi	r8,r8,8
21098c74:	180b883a 	mov	r5,r3
21098c78:	b5bffc04 	addi	r22,r22,-16
21098c7c:	3d800d0e 	bge	r7,r22,21098cb4 <___vfiprintf_internal_r+0x588>
21098c80:	10800404 	addi	r2,r2,16
21098c84:	28c00044 	addi	r3,r5,1
21098c88:	45c00015 	stw	r23,0(r8)
21098c8c:	41c00115 	stw	r7,4(r8)
21098c90:	d8801c15 	stw	r2,112(sp)
21098c94:	d8c01b15 	stw	r3,108(sp)
21098c98:	68fff40e 	bge	r13,r3,21098c6c <__flash_rwdata_start+0xffff6a24>
21098c9c:	1001811e 	bne	r2,zero,210992a4 <___vfiprintf_internal_r+0xb78>
21098ca0:	b5bffc04 	addi	r22,r22,-16
21098ca4:	01000044 	movi	r4,1
21098ca8:	000b883a 	mov	r5,zero
21098cac:	d811883a 	mov	r8,sp
21098cb0:	3dbff316 	blt	r7,r22,21098c80 <__flash_rwdata_start+0xffff6a38>
21098cb4:	d8c02417 	ldw	r3,144(sp)
21098cb8:	1585883a 	add	r2,r2,r22
21098cbc:	45800115 	stw	r22,4(r8)
21098cc0:	40c00015 	stw	r3,0(r8)
21098cc4:	d8801c15 	stw	r2,112(sp)
21098cc8:	d9001b15 	stw	r4,108(sp)
21098ccc:	00c001c4 	movi	r3,7
21098cd0:	1901d016 	blt	r3,r4,21099414 <___vfiprintf_internal_r+0xce8>
21098cd4:	42000204 	addi	r8,r8,8
21098cd8:	21000044 	addi	r4,r4,1
21098cdc:	14c5883a 	add	r2,r2,r19
21098ce0:	45000015 	stw	r20,0(r8)
21098ce4:	44c00115 	stw	r19,4(r8)
21098ce8:	d8801c15 	stw	r2,112(sp)
21098cec:	d9001b15 	stw	r4,108(sp)
21098cf0:	00c001c4 	movi	r3,7
21098cf4:	1901cf0e 	bge	r3,r4,21099434 <___vfiprintf_internal_r+0xd08>
21098cf8:	1002361e 	bne	r2,zero,210995d4 <___vfiprintf_internal_r+0xea8>
21098cfc:	d8001b15 	stw	zero,108(sp)
21098d00:	aac0010c 	andi	r11,r21,4
21098d04:	58002826 	beq	r11,zero,21098da8 <___vfiprintf_internal_r+0x67c>
21098d08:	9467c83a 	sub	r19,r18,r17
21098d0c:	d811883a 	mov	r8,sp
21098d10:	04c3340e 	bge	zero,r19,210999e4 <___vfiprintf_internal_r+0x12b8>
21098d14:	01c00404 	movi	r7,16
21098d18:	3cc31b0e 	bge	r7,r19,21099988 <___vfiprintf_internal_r+0x125c>
21098d1c:	00c00034 	movhi	r3,0
21098d20:	18cf4604 	addi	r3,r3,15640
21098d24:	d9001b17 	ldw	r4,108(sp)
21098d28:	d8c02415 	stw	r3,144(sp)
21098d2c:	382b883a 	mov	r21,r7
21098d30:	050001c4 	movi	r20,7
21098d34:	dd802017 	ldw	r22,128(sp)
21098d38:	00000506 	br	21098d50 <___vfiprintf_internal_r+0x624>
21098d3c:	21400084 	addi	r5,r4,2
21098d40:	42000204 	addi	r8,r8,8
21098d44:	1809883a 	mov	r4,r3
21098d48:	9cfffc04 	addi	r19,r19,-16
21098d4c:	acc00d0e 	bge	r21,r19,21098d84 <___vfiprintf_internal_r+0x658>
21098d50:	10800404 	addi	r2,r2,16
21098d54:	20c00044 	addi	r3,r4,1
21098d58:	47000015 	stw	fp,0(r8)
21098d5c:	45400115 	stw	r21,4(r8)
21098d60:	d8801c15 	stw	r2,112(sp)
21098d64:	d8c01b15 	stw	r3,108(sp)
21098d68:	a0fff40e 	bge	r20,r3,21098d3c <__flash_rwdata_start+0xffff6af4>
21098d6c:	10019f1e 	bne	r2,zero,210993ec <___vfiprintf_internal_r+0xcc0>
21098d70:	9cfffc04 	addi	r19,r19,-16
21098d74:	01400044 	movi	r5,1
21098d78:	0009883a 	mov	r4,zero
21098d7c:	d811883a 	mov	r8,sp
21098d80:	acfff316 	blt	r21,r19,21098d50 <__flash_rwdata_start+0xffff6b08>
21098d84:	d8c02417 	ldw	r3,144(sp)
21098d88:	14c5883a 	add	r2,r2,r19
21098d8c:	44c00115 	stw	r19,4(r8)
21098d90:	40c00015 	stw	r3,0(r8)
21098d94:	d8801c15 	stw	r2,112(sp)
21098d98:	d9401b15 	stw	r5,108(sp)
21098d9c:	00c001c4 	movi	r3,7
21098da0:	1941810e 	bge	r3,r5,210993a8 <___vfiprintf_internal_r+0xc7c>
21098da4:	10017a1e 	bne	r2,zero,21099390 <___vfiprintf_internal_r+0xc64>
21098da8:	8c82a416 	blt	r17,r18,2109983c <___vfiprintf_internal_r+0x1110>
21098dac:	d9002317 	ldw	r4,140(sp)
21098db0:	2449883a 	add	r4,r4,r17
21098db4:	d9002315 	stw	r4,140(sp)
21098db8:	d8001b15 	stw	zero,108(sp)
21098dbc:	d811883a 	mov	r8,sp
21098dc0:	003e8e06 	br	210987fc <__flash_rwdata_start+0xffff65b4>
21098dc4:	d9002017 	ldw	r4,128(sp)
21098dc8:	a80b883a 	mov	r5,r21
21098dcc:	10929100 	call	21092910 <__swsetup_r>
21098dd0:	10000c1e 	bne	r2,zero,21098e04 <___vfiprintf_internal_r+0x6d8>
21098dd4:	a880030b 	ldhu	r2,12(r21)
21098dd8:	00c00284 	movi	r3,10
21098ddc:	1080068c 	andi	r2,r2,26
21098de0:	10fe741e 	bne	r2,r3,210987b4 <__flash_rwdata_start+0xffff656c>
21098de4:	a880038f 	ldh	r2,14(r21)
21098de8:	103e7216 	blt	r2,zero,210987b4 <__flash_rwdata_start+0xffff656c>
21098dec:	d9002017 	ldw	r4,128(sp)
21098df0:	d9c02217 	ldw	r7,136(sp)
21098df4:	a80b883a 	mov	r5,r21
21098df8:	b00d883a 	mov	r6,r22
21098dfc:	1099a200 	call	21099a20 <__sbprintf>
21098e00:	00000106 	br	21098e08 <___vfiprintf_internal_r+0x6dc>
21098e04:	00bfffc4 	movi	r2,-1
21098e08:	dfc03517 	ldw	ra,212(sp)
21098e0c:	df003417 	ldw	fp,208(sp)
21098e10:	ddc03317 	ldw	r23,204(sp)
21098e14:	dd803217 	ldw	r22,200(sp)
21098e18:	dd403117 	ldw	r21,196(sp)
21098e1c:	dd003017 	ldw	r20,192(sp)
21098e20:	dcc02f17 	ldw	r19,188(sp)
21098e24:	dc802e17 	ldw	r18,184(sp)
21098e28:	dc402d17 	ldw	r17,180(sp)
21098e2c:	dc002c17 	ldw	r16,176(sp)
21098e30:	dec03604 	addi	sp,sp,216
21098e34:	f800283a 	ret
21098e38:	1094b040 	call	21094b04 <__sinit>
21098e3c:	003e4d06 	br	21098774 <__flash_rwdata_start+0xffff652c>
21098e40:	8005883a 	mov	r2,r16
21098e44:	ad400114 	ori	r21,r21,4
21098e48:	80c00007 	ldb	r3,0(r16)
21098e4c:	003e9506 	br	210988a4 <__flash_rwdata_start+0xffff665c>
21098e50:	b006d0fa 	srli	r3,r22,3
21098e54:	6808977a 	slli	r4,r13,29
21098e58:	681ad0fa 	srli	r13,r13,3
21098e5c:	b58001cc 	andi	r22,r22,7
21098e60:	b0800c04 	addi	r2,r22,48
21098e64:	a53fffc4 	addi	r20,r20,-1
21098e68:	20ecb03a 	or	r22,r4,r3
21098e6c:	a0800005 	stb	r2,0(r20)
21098e70:	b346b03a 	or	r3,r22,r13
21098e74:	183ff61e 	bne	r3,zero,21098e50 <__flash_rwdata_start+0xffff6c08>
21098e78:	a8c0004c 	andi	r3,r21,1
21098e7c:	a009883a 	mov	r4,r20
21098e80:	18013b26 	beq	r3,zero,21099370 <___vfiprintf_internal_r+0xc44>
21098e84:	10803fcc 	andi	r2,r2,255
21098e88:	1080201c 	xori	r2,r2,128
21098e8c:	10bfe004 	addi	r2,r2,-128
21098e90:	00c00c04 	movi	r3,48
21098e94:	10ff1d26 	beq	r2,r3,21098b0c <__flash_rwdata_start+0xffff68c4>
21098e98:	d8801e17 	ldw	r2,120(sp)
21098e9c:	a53fffc4 	addi	r20,r20,-1
21098ea0:	20ffffc5 	stb	r3,-1(r4)
21098ea4:	1527c83a 	sub	r19,r2,r20
21098ea8:	003f1a06 	br	21098b14 <__flash_rwdata_start+0xffff68cc>
21098eac:	ad402014 	ori	r21,r21,128
21098eb0:	8005883a 	mov	r2,r16
21098eb4:	80c00007 	ldb	r3,0(r16)
21098eb8:	003e7a06 	br	210988a4 <__flash_rwdata_start+0xffff665c>
21098ebc:	8005883a 	mov	r2,r16
21098ec0:	0025883a 	mov	r18,zero
21098ec4:	193ff404 	addi	r4,r3,-48
21098ec8:	10c00007 	ldb	r3,0(r2)
21098ecc:	948002a4 	muli	r18,r18,10
21098ed0:	84000044 	addi	r16,r16,1
21098ed4:	8005883a 	mov	r2,r16
21098ed8:	9125883a 	add	r18,r18,r4
21098edc:	193ff404 	addi	r4,r3,-48
21098ee0:	313ff92e 	bgeu	r6,r4,21098ec8 <__flash_rwdata_start+0xffff6c80>
21098ee4:	003e7006 	br	210988a8 <__flash_rwdata_start+0xffff6660>
21098ee8:	ad400414 	ori	r21,r21,16
21098eec:	d9c01d85 	stb	r7,118(sp)
21098ef0:	a880080c 	andi	r2,r21,32
21098ef4:	d8c02217 	ldw	r3,136(sp)
21098ef8:	10005a26 	beq	r2,zero,21099064 <___vfiprintf_internal_r+0x938>
21098efc:	d9002217 	ldw	r4,136(sp)
21098f00:	18800117 	ldw	r2,4(r3)
21098f04:	1d800017 	ldw	r22,0(r3)
21098f08:	21000204 	addi	r4,r4,8
21098f0c:	d9002215 	stw	r4,136(sp)
21098f10:	101b883a 	mov	r13,r2
21098f14:	1001f416 	blt	r2,zero,210996e8 <___vfiprintf_internal_r+0xfbc>
21098f18:	db801d83 	ldbu	r14,118(sp)
21098f1c:	4827883a 	mov	r19,r9
21098f20:	00800044 	movi	r2,1
21098f24:	b348b03a 	or	r4,r22,r13
21098f28:	003ee106 	br	21098ab0 <__flash_rwdata_start+0xffff6868>
21098f2c:	80c00007 	ldb	r3,0(r16)
21098f30:	80800044 	addi	r2,r16,1
21098f34:	1b42a326 	beq	r3,r13,210999c4 <___vfiprintf_internal_r+0x1298>
21098f38:	193ff404 	addi	r4,r3,-48
21098f3c:	1021883a 	mov	r16,r2
21098f40:	0013883a 	mov	r9,zero
21098f44:	313e5836 	bltu	r6,r4,210988a8 <__flash_rwdata_start+0xffff6660>
21098f48:	80c00007 	ldb	r3,0(r16)
21098f4c:	4a4002a4 	muli	r9,r9,10
21098f50:	84000044 	addi	r16,r16,1
21098f54:	2253883a 	add	r9,r4,r9
21098f58:	193ff404 	addi	r4,r3,-48
21098f5c:	313ffa2e 	bgeu	r6,r4,21098f48 <__flash_rwdata_start+0xffff6d00>
21098f60:	483e510e 	bge	r9,zero,210988a8 <__flash_rwdata_start+0xffff6660>
21098f64:	027fffc4 	movi	r9,-1
21098f68:	003e4f06 	br	210988a8 <__flash_rwdata_start+0xffff6660>
21098f6c:	d9c01d85 	stb	r7,118(sp)
21098f70:	a880080c 	andi	r2,r21,32
21098f74:	10020826 	beq	r2,zero,21099798 <___vfiprintf_internal_r+0x106c>
21098f78:	d8c02217 	ldw	r3,136(sp)
21098f7c:	d9002317 	ldw	r4,140(sp)
21098f80:	18800017 	ldw	r2,0(r3)
21098f84:	2007d7fa 	srai	r3,r4,31
21098f88:	d9002217 	ldw	r4,136(sp)
21098f8c:	10c00115 	stw	r3,4(r2)
21098f90:	21000104 	addi	r4,r4,4
21098f94:	d9002215 	stw	r4,136(sp)
21098f98:	d9002317 	ldw	r4,140(sp)
21098f9c:	11000015 	stw	r4,0(r2)
21098fa0:	003e1606 	br	210987fc <__flash_rwdata_start+0xffff65b4>
21098fa4:	d8802217 	ldw	r2,136(sp)
21098fa8:	d8c02217 	ldw	r3,136(sp)
21098fac:	15800017 	ldw	r22,0(r2)
21098fb0:	13400117 	ldw	r13,4(r2)
21098fb4:	18c00204 	addi	r3,r3,8
21098fb8:	0005883a 	mov	r2,zero
21098fbc:	d8c02215 	stw	r3,136(sp)
21098fc0:	b348b03a 	or	r4,r22,r13
21098fc4:	003eb706 	br	21098aa4 <__flash_rwdata_start+0xffff685c>
21098fc8:	38803fcc 	andi	r2,r7,255
21098fcc:	1080201c 	xori	r2,r2,128
21098fd0:	10bfe004 	addi	r2,r2,-128
21098fd4:	1001e31e 	bne	r2,zero,21099764 <___vfiprintf_internal_r+0x1038>
21098fd8:	8005883a 	mov	r2,r16
21098fdc:	01c00804 	movi	r7,32
21098fe0:	80c00007 	ldb	r3,0(r16)
21098fe4:	003e2f06 	br	210988a4 <__flash_rwdata_start+0xffff665c>
21098fe8:	ad400054 	ori	r21,r21,1
21098fec:	8005883a 	mov	r2,r16
21098ff0:	80c00007 	ldb	r3,0(r16)
21098ff4:	003e2b06 	br	210988a4 <__flash_rwdata_start+0xffff665c>
21098ff8:	d8c02217 	ldw	r3,136(sp)
21098ffc:	1c800017 	ldw	r18,0(r3)
21099000:	18c00104 	addi	r3,r3,4
21099004:	90023816 	blt	r18,zero,210998e8 <___vfiprintf_internal_r+0x11bc>
21099008:	d8c02215 	stw	r3,136(sp)
2109900c:	8005883a 	mov	r2,r16
21099010:	80c00007 	ldb	r3,0(r16)
21099014:	003e2306 	br	210988a4 <__flash_rwdata_start+0xffff665c>
21099018:	8005883a 	mov	r2,r16
2109901c:	01c00ac4 	movi	r7,43
21099020:	80c00007 	ldb	r3,0(r16)
21099024:	003e1f06 	br	210988a4 <__flash_rwdata_start+0xffff665c>
21099028:	d8c02217 	ldw	r3,136(sp)
2109902c:	04400044 	movi	r17,1
21099030:	d8001d85 	stb	zero,118(sp)
21099034:	18800017 	ldw	r2,0(r3)
21099038:	18c00104 	addi	r3,r3,4
2109903c:	d8c02215 	stw	r3,136(sp)
21099040:	d8801005 	stb	r2,64(sp)
21099044:	8827883a 	mov	r19,r17
21099048:	dd001004 	addi	r20,sp,64
2109904c:	0013883a 	mov	r9,zero
21099050:	003eb806 	br	21098b34 <__flash_rwdata_start+0xffff68ec>
21099054:	d9c01d85 	stb	r7,118(sp)
21099058:	a880080c 	andi	r2,r21,32
2109905c:	d8c02217 	ldw	r3,136(sp)
21099060:	103fa61e 	bne	r2,zero,21098efc <__flash_rwdata_start+0xffff6cb4>
21099064:	a880040c 	andi	r2,r21,16
21099068:	1001dd26 	beq	r2,zero,210997e0 <___vfiprintf_internal_r+0x10b4>
2109906c:	1d800017 	ldw	r22,0(r3)
21099070:	d8802217 	ldw	r2,136(sp)
21099074:	b01bd7fa 	srai	r13,r22,31
21099078:	10800104 	addi	r2,r2,4
2109907c:	d8802215 	stw	r2,136(sp)
21099080:	6805883a 	mov	r2,r13
21099084:	003fa306 	br	21098f14 <__flash_rwdata_start+0xffff6ccc>
21099088:	00800034 	movhi	r2,0
2109908c:	108ecd04 	addi	r2,r2,15156
21099090:	d8802615 	stw	r2,152(sp)
21099094:	d9c01d85 	stb	r7,118(sp)
21099098:	a880080c 	andi	r2,r21,32
2109909c:	10004726 	beq	r2,zero,210991bc <___vfiprintf_internal_r+0xa90>
210990a0:	d9002217 	ldw	r4,136(sp)
210990a4:	25800017 	ldw	r22,0(r4)
210990a8:	23400117 	ldw	r13,4(r4)
210990ac:	21000204 	addi	r4,r4,8
210990b0:	d9002215 	stw	r4,136(sp)
210990b4:	a880004c 	andi	r2,r21,1
210990b8:	10014e26 	beq	r2,zero,210995f4 <___vfiprintf_internal_r+0xec8>
210990bc:	b348b03a 	or	r4,r22,r13
210990c0:	20019c26 	beq	r4,zero,21099734 <___vfiprintf_internal_r+0x1008>
210990c4:	00800c04 	movi	r2,48
210990c8:	d8801d05 	stb	r2,116(sp)
210990cc:	d8c01d45 	stb	r3,117(sp)
210990d0:	ad400094 	ori	r21,r21,2
210990d4:	00800084 	movi	r2,2
210990d8:	003e7206 	br	21098aa4 <__flash_rwdata_start+0xffff685c>
210990dc:	d8c02217 	ldw	r3,136(sp)
210990e0:	d8001d85 	stb	zero,118(sp)
210990e4:	1d000017 	ldw	r20,0(r3)
210990e8:	1d800104 	addi	r22,r3,4
210990ec:	a0021c26 	beq	r20,zero,21099960 <___vfiprintf_internal_r+0x1234>
210990f0:	a009883a 	mov	r4,r20
210990f4:	48020016 	blt	r9,zero,210998f8 <___vfiprintf_internal_r+0x11cc>
210990f8:	480d883a 	mov	r6,r9
210990fc:	000b883a 	mov	r5,zero
21099100:	da002a15 	stw	r8,168(sp)
21099104:	da402b15 	stw	r9,172(sp)
21099108:	10958480 	call	21095848 <memchr>
2109910c:	da002a17 	ldw	r8,168(sp)
21099110:	da402b17 	ldw	r9,172(sp)
21099114:	10022226 	beq	r2,zero,210999a0 <___vfiprintf_internal_r+0x1274>
21099118:	1527c83a 	sub	r19,r2,r20
2109911c:	4cc1c916 	blt	r9,r19,21099844 <___vfiprintf_internal_r+0x1118>
21099120:	db801d83 	ldbu	r14,118(sp)
21099124:	dd802215 	stw	r22,136(sp)
21099128:	0013883a 	mov	r9,zero
2109912c:	003e7906 	br	21098b14 <__flash_rwdata_start+0xffff68cc>
21099130:	ad401014 	ori	r21,r21,64
21099134:	8005883a 	mov	r2,r16
21099138:	80c00007 	ldb	r3,0(r16)
2109913c:	003dd906 	br	210988a4 <__flash_rwdata_start+0xffff665c>
21099140:	80c00007 	ldb	r3,0(r16)
21099144:	8005883a 	mov	r2,r16
21099148:	1b01e326 	beq	r3,r12,210998d8 <___vfiprintf_internal_r+0x11ac>
2109914c:	ad400414 	ori	r21,r21,16
21099150:	003dd406 	br	210988a4 <__flash_rwdata_start+0xffff665c>
21099154:	d9002217 	ldw	r4,136(sp)
21099158:	00800c04 	movi	r2,48
2109915c:	d8801d05 	stb	r2,116(sp)
21099160:	25800017 	ldw	r22,0(r4)
21099164:	00801e04 	movi	r2,120
21099168:	d8801d45 	stb	r2,117(sp)
2109916c:	00800034 	movhi	r2,0
21099170:	21000104 	addi	r4,r4,4
21099174:	108ed204 	addi	r2,r2,15176
21099178:	d9002215 	stw	r4,136(sp)
2109917c:	d8802615 	stw	r2,152(sp)
21099180:	001b883a 	mov	r13,zero
21099184:	ad400094 	ori	r21,r21,2
21099188:	00800084 	movi	r2,2
2109918c:	b009883a 	mov	r4,r22
21099190:	003e4406 	br	21098aa4 <__flash_rwdata_start+0xffff685c>
21099194:	ad400814 	ori	r21,r21,32
21099198:	8005883a 	mov	r2,r16
2109919c:	80c00007 	ldb	r3,0(r16)
210991a0:	003dc006 	br	210988a4 <__flash_rwdata_start+0xffff665c>
210991a4:	00800034 	movhi	r2,0
210991a8:	108ed204 	addi	r2,r2,15176
210991ac:	d8802615 	stw	r2,152(sp)
210991b0:	d9c01d85 	stb	r7,118(sp)
210991b4:	a880080c 	andi	r2,r21,32
210991b8:	103fb91e 	bne	r2,zero,210990a0 <__flash_rwdata_start+0xffff6e58>
210991bc:	a880040c 	andi	r2,r21,16
210991c0:	10010f1e 	bne	r2,zero,21099600 <___vfiprintf_internal_r+0xed4>
210991c4:	a880100c 	andi	r2,r21,64
210991c8:	10010d26 	beq	r2,zero,21099600 <___vfiprintf_internal_r+0xed4>
210991cc:	d9002217 	ldw	r4,136(sp)
210991d0:	001b883a 	mov	r13,zero
210991d4:	2580000b 	ldhu	r22,0(r4)
210991d8:	21000104 	addi	r4,r4,4
210991dc:	d9002215 	stw	r4,136(sp)
210991e0:	003fb406 	br	210990b4 <__flash_rwdata_start+0xffff6e6c>
210991e4:	d9002217 	ldw	r4,136(sp)
210991e8:	00800044 	movi	r2,1
210991ec:	25800017 	ldw	r22,0(r4)
210991f0:	23400117 	ldw	r13,4(r4)
210991f4:	21000204 	addi	r4,r4,8
210991f8:	d9002215 	stw	r4,136(sp)
210991fc:	b348b03a 	or	r4,r22,r13
21099200:	003e2806 	br	21098aa4 <__flash_rwdata_start+0xffff685c>
21099204:	d9c01d85 	stb	r7,118(sp)
21099208:	1801ab26 	beq	r3,zero,210998b8 <___vfiprintf_internal_r+0x118c>
2109920c:	04400044 	movi	r17,1
21099210:	d8c01005 	stb	r3,64(sp)
21099214:	d8001d85 	stb	zero,118(sp)
21099218:	8827883a 	mov	r19,r17
2109921c:	dd001004 	addi	r20,sp,64
21099220:	003f8a06 	br	2109904c <__flash_rwdata_start+0xffff6e04>
21099224:	d9002017 	ldw	r4,128(sp)
21099228:	d9402117 	ldw	r5,132(sp)
2109922c:	d9801a04 	addi	r6,sp,104
21099230:	d9c02b15 	stw	r7,172(sp)
21099234:	dbc02a15 	stw	r15,168(sp)
21099238:	10986180 	call	21098618 <__sprint_r.part.0>
2109923c:	d9c02b17 	ldw	r7,172(sp)
21099240:	dbc02a17 	ldw	r15,168(sp)
21099244:	1000631e 	bne	r2,zero,210993d4 <___vfiprintf_internal_r+0xca8>
21099248:	d9801b17 	ldw	r6,108(sp)
2109924c:	d8801c17 	ldw	r2,112(sp)
21099250:	d811883a 	mov	r8,sp
21099254:	31400044 	addi	r5,r6,1
21099258:	003e4d06 	br	21098b90 <__flash_rwdata_start+0xffff6948>
2109925c:	d9401b17 	ldw	r5,108(sp)
21099260:	d8801c17 	ldw	r2,112(sp)
21099264:	29000044 	addi	r4,r5,1
21099268:	d8c01d87 	ldb	r3,118(sp)
2109926c:	183e6726 	beq	r3,zero,21098c0c <__flash_rwdata_start+0xffff69c4>
21099270:	00c00044 	movi	r3,1
21099274:	d9401d84 	addi	r5,sp,118
21099278:	10c5883a 	add	r2,r2,r3
2109927c:	41400015 	stw	r5,0(r8)
21099280:	40c00115 	stw	r3,4(r8)
21099284:	d8801c15 	stw	r2,112(sp)
21099288:	d9001b15 	stw	r4,108(sp)
2109928c:	014001c4 	movi	r5,7
21099290:	2900ab16 	blt	r5,r4,21099540 <___vfiprintf_internal_r+0xe14>
21099294:	200b883a 	mov	r5,r4
21099298:	42000204 	addi	r8,r8,8
2109929c:	21000044 	addi	r4,r4,1
210992a0:	003e5a06 	br	21098c0c <__flash_rwdata_start+0xffff69c4>
210992a4:	d9002017 	ldw	r4,128(sp)
210992a8:	d9402117 	ldw	r5,132(sp)
210992ac:	d9801a04 	addi	r6,sp,104
210992b0:	d9c02b15 	stw	r7,172(sp)
210992b4:	db402a15 	stw	r13,168(sp)
210992b8:	10986180 	call	21098618 <__sprint_r.part.0>
210992bc:	d9c02b17 	ldw	r7,172(sp)
210992c0:	db402a17 	ldw	r13,168(sp)
210992c4:	1000431e 	bne	r2,zero,210993d4 <___vfiprintf_internal_r+0xca8>
210992c8:	d9401b17 	ldw	r5,108(sp)
210992cc:	d8801c17 	ldw	r2,112(sp)
210992d0:	d811883a 	mov	r8,sp
210992d4:	29000044 	addi	r4,r5,1
210992d8:	003e6706 	br	21098c78 <__flash_rwdata_start+0xffff6a30>
210992dc:	10803fcc 	andi	r2,r2,255
210992e0:	00c00044 	movi	r3,1
210992e4:	10fdfa1e 	bne	r2,r3,21098ad0 <__flash_rwdata_start+0xffff6888>
210992e8:	6800021e 	bne	r13,zero,210992f4 <___vfiprintf_internal_r+0xbc8>
210992ec:	00800244 	movi	r2,9
210992f0:	1580222e 	bgeu	r2,r22,2109937c <___vfiprintf_internal_r+0xc50>
210992f4:	dc802415 	stw	r18,144(sp)
210992f8:	dc002515 	stw	r16,148(sp)
210992fc:	dc401a04 	addi	r17,sp,104
21099300:	b021883a 	mov	r16,r22
21099304:	4827883a 	mov	r19,r9
21099308:	4029883a 	mov	r20,r8
2109930c:	702d883a 	mov	r22,r14
21099310:	6825883a 	mov	r18,r13
21099314:	8009883a 	mov	r4,r16
21099318:	900b883a 	mov	r5,r18
2109931c:	01800284 	movi	r6,10
21099320:	000f883a 	mov	r7,zero
21099324:	109a9940 	call	2109a994 <__umoddi3>
21099328:	10800c04 	addi	r2,r2,48
2109932c:	8c7fffc4 	addi	r17,r17,-1
21099330:	8009883a 	mov	r4,r16
21099334:	900b883a 	mov	r5,r18
21099338:	01800284 	movi	r6,10
2109933c:	000f883a 	mov	r7,zero
21099340:	88800005 	stb	r2,0(r17)
21099344:	109a3d40 	call	2109a3d4 <__udivdi3>
21099348:	1021883a 	mov	r16,r2
2109934c:	10c4b03a 	or	r2,r2,r3
21099350:	1825883a 	mov	r18,r3
21099354:	103fef1e 	bne	r2,zero,21099314 <__flash_rwdata_start+0xffff70cc>
21099358:	dc802417 	ldw	r18,144(sp)
2109935c:	dc002517 	ldw	r16,148(sp)
21099360:	a011883a 	mov	r8,r20
21099364:	9813883a 	mov	r9,r19
21099368:	b01d883a 	mov	r14,r22
2109936c:	8829883a 	mov	r20,r17
21099370:	d8c01e17 	ldw	r3,120(sp)
21099374:	1d27c83a 	sub	r19,r3,r20
21099378:	003de606 	br	21098b14 <__flash_rwdata_start+0xffff68cc>
2109937c:	b5800c04 	addi	r22,r22,48
21099380:	dd8019c5 	stb	r22,103(sp)
21099384:	dcc02717 	ldw	r19,156(sp)
21099388:	dd0019c4 	addi	r20,sp,103
2109938c:	003de106 	br	21098b14 <__flash_rwdata_start+0xffff68cc>
21099390:	d9002017 	ldw	r4,128(sp)
21099394:	d9402117 	ldw	r5,132(sp)
21099398:	d9801a04 	addi	r6,sp,104
2109939c:	10986180 	call	21098618 <__sprint_r.part.0>
210993a0:	10000c1e 	bne	r2,zero,210993d4 <___vfiprintf_internal_r+0xca8>
210993a4:	d8801c17 	ldw	r2,112(sp)
210993a8:	8c80010e 	bge	r17,r18,210993b0 <___vfiprintf_internal_r+0xc84>
210993ac:	9023883a 	mov	r17,r18
210993b0:	d8c02317 	ldw	r3,140(sp)
210993b4:	1c47883a 	add	r3,r3,r17
210993b8:	d8c02315 	stw	r3,140(sp)
210993bc:	103e7e26 	beq	r2,zero,21098db8 <__flash_rwdata_start+0xffff6b70>
210993c0:	d9002017 	ldw	r4,128(sp)
210993c4:	d9402117 	ldw	r5,132(sp)
210993c8:	d9801a04 	addi	r6,sp,104
210993cc:	10986180 	call	21098618 <__sprint_r.part.0>
210993d0:	103e7926 	beq	r2,zero,21098db8 <__flash_rwdata_start+0xffff6b70>
210993d4:	dd402117 	ldw	r21,132(sp)
210993d8:	a880030b 	ldhu	r2,12(r21)
210993dc:	1080100c 	andi	r2,r2,64
210993e0:	103e881e 	bne	r2,zero,21098e04 <__flash_rwdata_start+0xffff6bbc>
210993e4:	d8802317 	ldw	r2,140(sp)
210993e8:	003e8706 	br	21098e08 <__flash_rwdata_start+0xffff6bc0>
210993ec:	d9402117 	ldw	r5,132(sp)
210993f0:	b009883a 	mov	r4,r22
210993f4:	d9801a04 	addi	r6,sp,104
210993f8:	10986180 	call	21098618 <__sprint_r.part.0>
210993fc:	103ff51e 	bne	r2,zero,210993d4 <__flash_rwdata_start+0xffff718c>
21099400:	d9001b17 	ldw	r4,108(sp)
21099404:	d8801c17 	ldw	r2,112(sp)
21099408:	d811883a 	mov	r8,sp
2109940c:	21400044 	addi	r5,r4,1
21099410:	003e4d06 	br	21098d48 <__flash_rwdata_start+0xffff6b00>
21099414:	1000aa1e 	bne	r2,zero,210996c0 <___vfiprintf_internal_r+0xf94>
21099418:	00c00044 	movi	r3,1
2109941c:	9805883a 	mov	r2,r19
21099420:	dd000015 	stw	r20,0(sp)
21099424:	dcc00115 	stw	r19,4(sp)
21099428:	dcc01c15 	stw	r19,112(sp)
2109942c:	d8c01b15 	stw	r3,108(sp)
21099430:	d811883a 	mov	r8,sp
21099434:	42000204 	addi	r8,r8,8
21099438:	aac0010c 	andi	r11,r21,4
2109943c:	583fda26 	beq	r11,zero,210993a8 <__flash_rwdata_start+0xffff7160>
21099440:	9467c83a 	sub	r19,r18,r17
21099444:	04fe3316 	blt	zero,r19,21098d14 <__flash_rwdata_start+0xffff6acc>
21099448:	003fd706 	br	210993a8 <__flash_rwdata_start+0xffff7160>
2109944c:	946dc83a 	sub	r22,r18,r17
21099450:	05bdfd0e 	bge	zero,r22,21098c48 <__flash_rwdata_start+0xffff6a00>
21099454:	00c00034 	movhi	r3,0
21099458:	18cf4204 	addi	r3,r3,15624
2109945c:	01c00404 	movi	r7,16
21099460:	d8c02415 	stw	r3,144(sp)
21099464:	3d81530e 	bge	r7,r22,210999b4 <___vfiprintf_internal_r+0x1288>
21099468:	8007883a 	mov	r3,r16
2109946c:	034001c4 	movi	r13,7
21099470:	b021883a 	mov	r16,r22
21099474:	da402515 	stw	r9,148(sp)
21099478:	182d883a 	mov	r22,r3
2109947c:	00000506 	br	21099494 <___vfiprintf_internal_r+0xd68>
21099480:	29800084 	addi	r6,r5,2
21099484:	42000204 	addi	r8,r8,8
21099488:	180b883a 	mov	r5,r3
2109948c:	843ffc04 	addi	r16,r16,-16
21099490:	3c000d0e 	bge	r7,r16,210994c8 <___vfiprintf_internal_r+0xd9c>
21099494:	10800404 	addi	r2,r2,16
21099498:	28c00044 	addi	r3,r5,1
2109949c:	45c00015 	stw	r23,0(r8)
210994a0:	41c00115 	stw	r7,4(r8)
210994a4:	d8801c15 	stw	r2,112(sp)
210994a8:	d8c01b15 	stw	r3,108(sp)
210994ac:	68fff40e 	bge	r13,r3,21099480 <__flash_rwdata_start+0xffff7238>
210994b0:	1000151e 	bne	r2,zero,21099508 <___vfiprintf_internal_r+0xddc>
210994b4:	843ffc04 	addi	r16,r16,-16
210994b8:	01800044 	movi	r6,1
210994bc:	000b883a 	mov	r5,zero
210994c0:	d811883a 	mov	r8,sp
210994c4:	3c3ff316 	blt	r7,r16,21099494 <__flash_rwdata_start+0xffff724c>
210994c8:	da402517 	ldw	r9,148(sp)
210994cc:	b007883a 	mov	r3,r22
210994d0:	802d883a 	mov	r22,r16
210994d4:	1821883a 	mov	r16,r3
210994d8:	d8c02417 	ldw	r3,144(sp)
210994dc:	1585883a 	add	r2,r2,r22
210994e0:	45800115 	stw	r22,4(r8)
210994e4:	40c00015 	stw	r3,0(r8)
210994e8:	d8801c15 	stw	r2,112(sp)
210994ec:	d9801b15 	stw	r6,108(sp)
210994f0:	00c001c4 	movi	r3,7
210994f4:	19806d16 	blt	r3,r6,210996ac <___vfiprintf_internal_r+0xf80>
210994f8:	42000204 	addi	r8,r8,8
210994fc:	31000044 	addi	r4,r6,1
21099500:	300b883a 	mov	r5,r6
21099504:	003dd006 	br	21098c48 <__flash_rwdata_start+0xffff6a00>
21099508:	d9002017 	ldw	r4,128(sp)
2109950c:	d9402117 	ldw	r5,132(sp)
21099510:	d9801a04 	addi	r6,sp,104
21099514:	d9c02b15 	stw	r7,172(sp)
21099518:	db402a15 	stw	r13,168(sp)
2109951c:	10986180 	call	21098618 <__sprint_r.part.0>
21099520:	d9c02b17 	ldw	r7,172(sp)
21099524:	db402a17 	ldw	r13,168(sp)
21099528:	103faa1e 	bne	r2,zero,210993d4 <__flash_rwdata_start+0xffff718c>
2109952c:	d9401b17 	ldw	r5,108(sp)
21099530:	d8801c17 	ldw	r2,112(sp)
21099534:	d811883a 	mov	r8,sp
21099538:	29800044 	addi	r6,r5,1
2109953c:	003fd306 	br	2109948c <__flash_rwdata_start+0xffff7244>
21099540:	1000401e 	bne	r2,zero,21099644 <___vfiprintf_internal_r+0xf18>
21099544:	68003b26 	beq	r13,zero,21099634 <___vfiprintf_internal_r+0xf08>
21099548:	d9001d04 	addi	r4,sp,116
2109954c:	00800084 	movi	r2,2
21099550:	d9000015 	stw	r4,0(sp)
21099554:	d8800115 	stw	r2,4(sp)
21099558:	1809883a 	mov	r4,r3
2109955c:	d811883a 	mov	r8,sp
21099560:	003db406 	br	21098c34 <__flash_rwdata_start+0xffff69ec>
21099564:	1000451e 	bne	r2,zero,2109967c <___vfiprintf_internal_r+0xf50>
21099568:	01000044 	movi	r4,1
2109956c:	000b883a 	mov	r5,zero
21099570:	d811883a 	mov	r8,sp
21099574:	003db206 	br	21098c40 <__flash_rwdata_start+0xffff69f8>
21099578:	10803fcc 	andi	r2,r2,255
2109957c:	1000071e 	bne	r2,zero,2109959c <___vfiprintf_internal_r+0xe70>
21099580:	a880004c 	andi	r2,r21,1
21099584:	10000526 	beq	r2,zero,2109959c <___vfiprintf_internal_r+0xe70>
21099588:	00800c04 	movi	r2,48
2109958c:	d88019c5 	stb	r2,103(sp)
21099590:	dcc02717 	ldw	r19,156(sp)
21099594:	dd0019c4 	addi	r20,sp,103
21099598:	003d5e06 	br	21098b14 <__flash_rwdata_start+0xffff68cc>
2109959c:	dd001a04 	addi	r20,sp,104
210995a0:	003d5c06 	br	21098b14 <__flash_rwdata_start+0xffff68cc>
210995a4:	1000971e 	bne	r2,zero,21099804 <___vfiprintf_internal_r+0x10d8>
210995a8:	d8c01d87 	ldb	r3,118(sp)
210995ac:	18005826 	beq	r3,zero,21099710 <___vfiprintf_internal_r+0xfe4>
210995b0:	00800044 	movi	r2,1
210995b4:	d8c01d84 	addi	r3,sp,118
210995b8:	1009883a 	mov	r4,r2
210995bc:	d8c00015 	stw	r3,0(sp)
210995c0:	d8800115 	stw	r2,4(sp)
210995c4:	d811883a 	mov	r8,sp
210995c8:	003f3206 	br	21099294 <__flash_rwdata_start+0xffff704c>
210995cc:	8023883a 	mov	r17,r16
210995d0:	003ca706 	br	21098870 <__flash_rwdata_start+0xffff6628>
210995d4:	d9002017 	ldw	r4,128(sp)
210995d8:	d9402117 	ldw	r5,132(sp)
210995dc:	d9801a04 	addi	r6,sp,104
210995e0:	10986180 	call	21098618 <__sprint_r.part.0>
210995e4:	103f7b1e 	bne	r2,zero,210993d4 <__flash_rwdata_start+0xffff718c>
210995e8:	d8801c17 	ldw	r2,112(sp)
210995ec:	d811883a 	mov	r8,sp
210995f0:	003f9106 	br	21099438 <__flash_rwdata_start+0xffff71f0>
210995f4:	00800084 	movi	r2,2
210995f8:	b348b03a 	or	r4,r22,r13
210995fc:	003d2906 	br	21098aa4 <__flash_rwdata_start+0xffff685c>
21099600:	d8802217 	ldw	r2,136(sp)
21099604:	001b883a 	mov	r13,zero
21099608:	15800017 	ldw	r22,0(r2)
2109960c:	10800104 	addi	r2,r2,4
21099610:	d8802215 	stw	r2,136(sp)
21099614:	003ea706 	br	210990b4 <__flash_rwdata_start+0xffff6e6c>
21099618:	d9002017 	ldw	r4,128(sp)
2109961c:	d9402117 	ldw	r5,132(sp)
21099620:	d9801a04 	addi	r6,sp,104
21099624:	10986180 	call	21098618 <__sprint_r.part.0>
21099628:	103f6a1e 	bne	r2,zero,210993d4 <__flash_rwdata_start+0xffff718c>
2109962c:	d811883a 	mov	r8,sp
21099630:	003cff06 	br	21098a30 <__flash_rwdata_start+0xffff67e8>
21099634:	000b883a 	mov	r5,zero
21099638:	1809883a 	mov	r4,r3
2109963c:	d811883a 	mov	r8,sp
21099640:	003d7f06 	br	21098c40 <__flash_rwdata_start+0xffff69f8>
21099644:	d9002017 	ldw	r4,128(sp)
21099648:	d9402117 	ldw	r5,132(sp)
2109964c:	d9801a04 	addi	r6,sp,104
21099650:	da402b15 	stw	r9,172(sp)
21099654:	db402a15 	stw	r13,168(sp)
21099658:	10986180 	call	21098618 <__sprint_r.part.0>
2109965c:	da402b17 	ldw	r9,172(sp)
21099660:	db402a17 	ldw	r13,168(sp)
21099664:	103f5b1e 	bne	r2,zero,210993d4 <__flash_rwdata_start+0xffff718c>
21099668:	d9401b17 	ldw	r5,108(sp)
2109966c:	d8801c17 	ldw	r2,112(sp)
21099670:	d811883a 	mov	r8,sp
21099674:	29000044 	addi	r4,r5,1
21099678:	003d6406 	br	21098c0c <__flash_rwdata_start+0xffff69c4>
2109967c:	d9002017 	ldw	r4,128(sp)
21099680:	d9402117 	ldw	r5,132(sp)
21099684:	d9801a04 	addi	r6,sp,104
21099688:	da402b15 	stw	r9,172(sp)
2109968c:	10986180 	call	21098618 <__sprint_r.part.0>
21099690:	da402b17 	ldw	r9,172(sp)
21099694:	103f4f1e 	bne	r2,zero,210993d4 <__flash_rwdata_start+0xffff718c>
21099698:	d9401b17 	ldw	r5,108(sp)
2109969c:	d8801c17 	ldw	r2,112(sp)
210996a0:	d811883a 	mov	r8,sp
210996a4:	29000044 	addi	r4,r5,1
210996a8:	003d6506 	br	21098c40 <__flash_rwdata_start+0xffff69f8>
210996ac:	10009a1e 	bne	r2,zero,21099918 <___vfiprintf_internal_r+0x11ec>
210996b0:	01000044 	movi	r4,1
210996b4:	000b883a 	mov	r5,zero
210996b8:	d811883a 	mov	r8,sp
210996bc:	003d6206 	br	21098c48 <__flash_rwdata_start+0xffff6a00>
210996c0:	d9002017 	ldw	r4,128(sp)
210996c4:	d9402117 	ldw	r5,132(sp)
210996c8:	d9801a04 	addi	r6,sp,104
210996cc:	10986180 	call	21098618 <__sprint_r.part.0>
210996d0:	103f401e 	bne	r2,zero,210993d4 <__flash_rwdata_start+0xffff718c>
210996d4:	d9001b17 	ldw	r4,108(sp)
210996d8:	d8801c17 	ldw	r2,112(sp)
210996dc:	d811883a 	mov	r8,sp
210996e0:	21000044 	addi	r4,r4,1
210996e4:	003d7d06 	br	21098cdc <__flash_rwdata_start+0xffff6a94>
210996e8:	05adc83a 	sub	r22,zero,r22
210996ec:	b004c03a 	cmpne	r2,r22,zero
210996f0:	035bc83a 	sub	r13,zero,r13
210996f4:	689bc83a 	sub	r13,r13,r2
210996f8:	03800b44 	movi	r14,45
210996fc:	db801d85 	stb	r14,118(sp)
21099700:	4827883a 	mov	r19,r9
21099704:	00800044 	movi	r2,1
21099708:	b348b03a 	or	r4,r22,r13
2109970c:	003ce806 	br	21098ab0 <__flash_rwdata_start+0xffff6868>
21099710:	000b883a 	mov	r5,zero
21099714:	01000044 	movi	r4,1
21099718:	d811883a 	mov	r8,sp
2109971c:	683d4826 	beq	r13,zero,21098c40 <__flash_rwdata_start+0xffff69f8>
21099720:	00800084 	movi	r2,2
21099724:	d8c01d04 	addi	r3,sp,116
21099728:	d8c00015 	stw	r3,0(sp)
2109972c:	d8800115 	stw	r2,4(sp)
21099730:	003d4006 	br	21098c34 <__flash_rwdata_start+0xffff69ec>
21099734:	00800084 	movi	r2,2
21099738:	003cda06 	br	21098aa4 <__flash_rwdata_start+0xffff685c>
2109973c:	a880100c 	andi	r2,r21,64
21099740:	10004226 	beq	r2,zero,2109984c <___vfiprintf_internal_r+0x1120>
21099744:	d8802217 	ldw	r2,136(sp)
21099748:	001b883a 	mov	r13,zero
2109974c:	1580000b 	ldhu	r22,0(r2)
21099750:	10800104 	addi	r2,r2,4
21099754:	d8802215 	stw	r2,136(sp)
21099758:	b009883a 	mov	r4,r22
2109975c:	0005883a 	mov	r2,zero
21099760:	003cd006 	br	21098aa4 <__flash_rwdata_start+0xffff685c>
21099764:	80c00007 	ldb	r3,0(r16)
21099768:	8005883a 	mov	r2,r16
2109976c:	003c4d06 	br	210988a4 <__flash_rwdata_start+0xffff665c>
21099770:	a880100c 	andi	r2,r21,64
21099774:	10004426 	beq	r2,zero,21099888 <___vfiprintf_internal_r+0x115c>
21099778:	d8c02217 	ldw	r3,136(sp)
2109977c:	001b883a 	mov	r13,zero
21099780:	00800044 	movi	r2,1
21099784:	1d80000b 	ldhu	r22,0(r3)
21099788:	18c00104 	addi	r3,r3,4
2109978c:	d8c02215 	stw	r3,136(sp)
21099790:	b009883a 	mov	r4,r22
21099794:	003cc306 	br	21098aa4 <__flash_rwdata_start+0xffff685c>
21099798:	a880040c 	andi	r2,r21,16
2109979c:	1000091e 	bne	r2,zero,210997c4 <___vfiprintf_internal_r+0x1098>
210997a0:	aac0100c 	andi	r11,r21,64
210997a4:	58000726 	beq	r11,zero,210997c4 <___vfiprintf_internal_r+0x1098>
210997a8:	d8c02217 	ldw	r3,136(sp)
210997ac:	d9002317 	ldw	r4,140(sp)
210997b0:	18800017 	ldw	r2,0(r3)
210997b4:	18c00104 	addi	r3,r3,4
210997b8:	d8c02215 	stw	r3,136(sp)
210997bc:	1100000d 	sth	r4,0(r2)
210997c0:	003c0e06 	br	210987fc <__flash_rwdata_start+0xffff65b4>
210997c4:	d8c02217 	ldw	r3,136(sp)
210997c8:	d9002317 	ldw	r4,140(sp)
210997cc:	18800017 	ldw	r2,0(r3)
210997d0:	18c00104 	addi	r3,r3,4
210997d4:	d8c02215 	stw	r3,136(sp)
210997d8:	11000015 	stw	r4,0(r2)
210997dc:	003c0706 	br	210987fc <__flash_rwdata_start+0xffff65b4>
210997e0:	a880100c 	andi	r2,r21,64
210997e4:	10002126 	beq	r2,zero,2109986c <___vfiprintf_internal_r+0x1140>
210997e8:	1d80000f 	ldh	r22,0(r3)
210997ec:	d8c02217 	ldw	r3,136(sp)
210997f0:	b01bd7fa 	srai	r13,r22,31
210997f4:	18c00104 	addi	r3,r3,4
210997f8:	d8c02215 	stw	r3,136(sp)
210997fc:	6805883a 	mov	r2,r13
21099800:	003dc406 	br	21098f14 <__flash_rwdata_start+0xffff6ccc>
21099804:	d9002017 	ldw	r4,128(sp)
21099808:	d9402117 	ldw	r5,132(sp)
2109980c:	d9801a04 	addi	r6,sp,104
21099810:	da402b15 	stw	r9,172(sp)
21099814:	db402a15 	stw	r13,168(sp)
21099818:	10986180 	call	21098618 <__sprint_r.part.0>
2109981c:	da402b17 	ldw	r9,172(sp)
21099820:	db402a17 	ldw	r13,168(sp)
21099824:	103eeb1e 	bne	r2,zero,210993d4 <__flash_rwdata_start+0xffff718c>
21099828:	d9401b17 	ldw	r5,108(sp)
2109982c:	d8801c17 	ldw	r2,112(sp)
21099830:	d811883a 	mov	r8,sp
21099834:	29000044 	addi	r4,r5,1
21099838:	003e8b06 	br	21099268 <__flash_rwdata_start+0xffff7020>
2109983c:	9023883a 	mov	r17,r18
21099840:	003d5a06 	br	21098dac <__flash_rwdata_start+0xffff6b64>
21099844:	4827883a 	mov	r19,r9
21099848:	003e3506 	br	21099120 <__flash_rwdata_start+0xffff6ed8>
2109984c:	d8c02217 	ldw	r3,136(sp)
21099850:	001b883a 	mov	r13,zero
21099854:	0005883a 	mov	r2,zero
21099858:	1d800017 	ldw	r22,0(r3)
2109985c:	18c00104 	addi	r3,r3,4
21099860:	d8c02215 	stw	r3,136(sp)
21099864:	b009883a 	mov	r4,r22
21099868:	003c8e06 	br	21098aa4 <__flash_rwdata_start+0xffff685c>
2109986c:	1d800017 	ldw	r22,0(r3)
21099870:	d9002217 	ldw	r4,136(sp)
21099874:	b01bd7fa 	srai	r13,r22,31
21099878:	21000104 	addi	r4,r4,4
2109987c:	d9002215 	stw	r4,136(sp)
21099880:	6805883a 	mov	r2,r13
21099884:	003da306 	br	21098f14 <__flash_rwdata_start+0xffff6ccc>
21099888:	d9002217 	ldw	r4,136(sp)
2109988c:	001b883a 	mov	r13,zero
21099890:	00800044 	movi	r2,1
21099894:	25800017 	ldw	r22,0(r4)
21099898:	21000104 	addi	r4,r4,4
2109989c:	d9002215 	stw	r4,136(sp)
210998a0:	b009883a 	mov	r4,r22
210998a4:	003c7f06 	br	21098aa4 <__flash_rwdata_start+0xffff685c>
210998a8:	00c00034 	movhi	r3,0
210998ac:	18cf4204 	addi	r3,r3,15624
210998b0:	d8c02415 	stw	r3,144(sp)
210998b4:	003cff06 	br	21098cb4 <__flash_rwdata_start+0xffff6a6c>
210998b8:	d8801c17 	ldw	r2,112(sp)
210998bc:	dd402117 	ldw	r21,132(sp)
210998c0:	103ec526 	beq	r2,zero,210993d8 <__flash_rwdata_start+0xffff7190>
210998c4:	d9002017 	ldw	r4,128(sp)
210998c8:	a80b883a 	mov	r5,r21
210998cc:	d9801a04 	addi	r6,sp,104
210998d0:	10986180 	call	21098618 <__sprint_r.part.0>
210998d4:	003ec006 	br	210993d8 <__flash_rwdata_start+0xffff7190>
210998d8:	80800044 	addi	r2,r16,1
210998dc:	ad400814 	ori	r21,r21,32
210998e0:	80c00047 	ldb	r3,1(r16)
210998e4:	003bef06 	br	210988a4 <__flash_rwdata_start+0xffff665c>
210998e8:	04a5c83a 	sub	r18,zero,r18
210998ec:	8005883a 	mov	r2,r16
210998f0:	d8c02215 	stw	r3,136(sp)
210998f4:	003d5306 	br	21098e44 <__flash_rwdata_start+0xffff6bfc>
210998f8:	da002a15 	stw	r8,168(sp)
210998fc:	108e7200 	call	2108e720 <strlen>
21099900:	1027883a 	mov	r19,r2
21099904:	db801d83 	ldbu	r14,118(sp)
21099908:	dd802215 	stw	r22,136(sp)
2109990c:	0013883a 	mov	r9,zero
21099910:	da002a17 	ldw	r8,168(sp)
21099914:	003c7f06 	br	21098b14 <__flash_rwdata_start+0xffff68cc>
21099918:	d9002017 	ldw	r4,128(sp)
2109991c:	d9402117 	ldw	r5,132(sp)
21099920:	d9801a04 	addi	r6,sp,104
21099924:	da402b15 	stw	r9,172(sp)
21099928:	10986180 	call	21098618 <__sprint_r.part.0>
2109992c:	da402b17 	ldw	r9,172(sp)
21099930:	103ea81e 	bne	r2,zero,210993d4 <__flash_rwdata_start+0xffff718c>
21099934:	d9401b17 	ldw	r5,108(sp)
21099938:	d8801c17 	ldw	r2,112(sp)
2109993c:	d811883a 	mov	r8,sp
21099940:	29000044 	addi	r4,r5,1
21099944:	003cc006 	br	21098c48 <__flash_rwdata_start+0xffff6a00>
21099948:	d9401b17 	ldw	r5,108(sp)
2109994c:	01000034 	movhi	r4,0
21099950:	210f4604 	addi	r4,r4,15640
21099954:	d9002415 	stw	r4,144(sp)
21099958:	29400044 	addi	r5,r5,1
2109995c:	003c9f06 	br	21098bdc <__flash_rwdata_start+0xffff6994>
21099960:	00800184 	movi	r2,6
21099964:	1240012e 	bgeu	r2,r9,2109996c <___vfiprintf_internal_r+0x1240>
21099968:	1013883a 	mov	r9,r2
2109996c:	4827883a 	mov	r19,r9
21099970:	4823883a 	mov	r17,r9
21099974:	48001116 	blt	r9,zero,210999bc <___vfiprintf_internal_r+0x1290>
21099978:	05000034 	movhi	r20,0
2109997c:	dd802215 	stw	r22,136(sp)
21099980:	a50ed704 	addi	r20,r20,15196
21099984:	003db106 	br	2109904c <__flash_rwdata_start+0xffff6e04>
21099988:	d9401b17 	ldw	r5,108(sp)
2109998c:	01000034 	movhi	r4,0
21099990:	210f4604 	addi	r4,r4,15640
21099994:	d9002415 	stw	r4,144(sp)
21099998:	29400044 	addi	r5,r5,1
2109999c:	003cf906 	br	21098d84 <__flash_rwdata_start+0xffff6b3c>
210999a0:	4827883a 	mov	r19,r9
210999a4:	db801d83 	ldbu	r14,118(sp)
210999a8:	dd802215 	stw	r22,136(sp)
210999ac:	0013883a 	mov	r9,zero
210999b0:	003c5806 	br	21098b14 <__flash_rwdata_start+0xffff68cc>
210999b4:	200d883a 	mov	r6,r4
210999b8:	003ec706 	br	210994d8 <__flash_rwdata_start+0xffff7290>
210999bc:	0023883a 	mov	r17,zero
210999c0:	003fed06 	br	21099978 <__flash_rwdata_start+0xffff7730>
210999c4:	d9002217 	ldw	r4,136(sp)
210999c8:	22400017 	ldw	r9,0(r4)
210999cc:	20c00104 	addi	r3,r4,4
210999d0:	d8c02215 	stw	r3,136(sp)
210999d4:	483fc20e 	bge	r9,zero,210998e0 <__flash_rwdata_start+0xffff7698>
210999d8:	027fffc4 	movi	r9,-1
210999dc:	80c00047 	ldb	r3,1(r16)
210999e0:	003bb006 	br	210988a4 <__flash_rwdata_start+0xffff665c>
210999e4:	8c80010e 	bge	r17,r18,210999ec <___vfiprintf_internal_r+0x12c0>
210999e8:	9023883a 	mov	r17,r18
210999ec:	d8802317 	ldw	r2,140(sp)
210999f0:	1445883a 	add	r2,r2,r17
210999f4:	d8802315 	stw	r2,140(sp)
210999f8:	003cef06 	br	21098db8 <__flash_rwdata_start+0xffff6b70>

210999fc <__vfiprintf_internal>:
210999fc:	2007883a 	mov	r3,r4
21099a00:	01000034 	movhi	r4,0
21099a04:	21176b04 	addi	r4,r4,23980
21099a08:	21000017 	ldw	r4,0(r4)
21099a0c:	2805883a 	mov	r2,r5
21099a10:	300f883a 	mov	r7,r6
21099a14:	180b883a 	mov	r5,r3
21099a18:	100d883a 	mov	r6,r2
21099a1c:	109872c1 	jmpi	2109872c <___vfiprintf_internal_r>

21099a20 <__sbprintf>:
21099a20:	2880030b 	ldhu	r2,12(r5)
21099a24:	2ac01917 	ldw	r11,100(r5)
21099a28:	2a80038b 	ldhu	r10,14(r5)
21099a2c:	2a400717 	ldw	r9,28(r5)
21099a30:	2a000917 	ldw	r8,36(r5)
21099a34:	defee204 	addi	sp,sp,-1144
21099a38:	00c10004 	movi	r3,1024
21099a3c:	dc011a15 	stw	r16,1128(sp)
21099a40:	10bfff4c 	andi	r2,r2,65533
21099a44:	2821883a 	mov	r16,r5
21099a48:	d8cb883a 	add	r5,sp,r3
21099a4c:	dc811c15 	stw	r18,1136(sp)
21099a50:	dc411b15 	stw	r17,1132(sp)
21099a54:	dfc11d15 	stw	ra,1140(sp)
21099a58:	2025883a 	mov	r18,r4
21099a5c:	d881030d 	sth	r2,1036(sp)
21099a60:	dac11915 	stw	r11,1124(sp)
21099a64:	da81038d 	sth	r10,1038(sp)
21099a68:	da410715 	stw	r9,1052(sp)
21099a6c:	da010915 	stw	r8,1060(sp)
21099a70:	dec10015 	stw	sp,1024(sp)
21099a74:	dec10415 	stw	sp,1040(sp)
21099a78:	d8c10215 	stw	r3,1032(sp)
21099a7c:	d8c10515 	stw	r3,1044(sp)
21099a80:	d8010615 	stw	zero,1048(sp)
21099a84:	109872c0 	call	2109872c <___vfiprintf_internal_r>
21099a88:	1023883a 	mov	r17,r2
21099a8c:	10000416 	blt	r2,zero,21099aa0 <__sbprintf+0x80>
21099a90:	9009883a 	mov	r4,r18
21099a94:	d9410004 	addi	r5,sp,1024
21099a98:	10947280 	call	21094728 <_fflush_r>
21099a9c:	10000d1e 	bne	r2,zero,21099ad4 <__sbprintf+0xb4>
21099aa0:	d8c1030b 	ldhu	r3,1036(sp)
21099aa4:	18c0100c 	andi	r3,r3,64
21099aa8:	18000326 	beq	r3,zero,21099ab8 <__sbprintf+0x98>
21099aac:	8080030b 	ldhu	r2,12(r16)
21099ab0:	10801014 	ori	r2,r2,64
21099ab4:	8080030d 	sth	r2,12(r16)
21099ab8:	8805883a 	mov	r2,r17
21099abc:	dfc11d17 	ldw	ra,1140(sp)
21099ac0:	dc811c17 	ldw	r18,1136(sp)
21099ac4:	dc411b17 	ldw	r17,1132(sp)
21099ac8:	dc011a17 	ldw	r16,1128(sp)
21099acc:	dec11e04 	addi	sp,sp,1144
21099ad0:	f800283a 	ret
21099ad4:	047fffc4 	movi	r17,-1
21099ad8:	003ff106 	br	21099aa0 <__flash_rwdata_start+0xffff7858>

21099adc <__swbuf_r>:
21099adc:	defffc04 	addi	sp,sp,-16
21099ae0:	dc800215 	stw	r18,8(sp)
21099ae4:	dc400115 	stw	r17,4(sp)
21099ae8:	dc000015 	stw	r16,0(sp)
21099aec:	dfc00315 	stw	ra,12(sp)
21099af0:	2025883a 	mov	r18,r4
21099af4:	2823883a 	mov	r17,r5
21099af8:	3021883a 	mov	r16,r6
21099afc:	20000226 	beq	r4,zero,21099b08 <__swbuf_r+0x2c>
21099b00:	20800e17 	ldw	r2,56(r4)
21099b04:	10004126 	beq	r2,zero,21099c0c <__swbuf_r+0x130>
21099b08:	80c00617 	ldw	r3,24(r16)
21099b0c:	8180030b 	ldhu	r6,12(r16)
21099b10:	80c00215 	stw	r3,8(r16)
21099b14:	30c0020c 	andi	r3,r6,8
21099b18:	18003526 	beq	r3,zero,21099bf0 <__swbuf_r+0x114>
21099b1c:	80c00417 	ldw	r3,16(r16)
21099b20:	18003326 	beq	r3,zero,21099bf0 <__swbuf_r+0x114>
21099b24:	3088000c 	andi	r2,r6,8192
21099b28:	8c403fcc 	andi	r17,r17,255
21099b2c:	10001726 	beq	r2,zero,21099b8c <__swbuf_r+0xb0>
21099b30:	80800017 	ldw	r2,0(r16)
21099b34:	81000517 	ldw	r4,20(r16)
21099b38:	10c7c83a 	sub	r3,r2,r3
21099b3c:	19001d0e 	bge	r3,r4,21099bb4 <__swbuf_r+0xd8>
21099b40:	18c00044 	addi	r3,r3,1
21099b44:	81400217 	ldw	r5,8(r16)
21099b48:	11000044 	addi	r4,r2,1
21099b4c:	81000015 	stw	r4,0(r16)
21099b50:	297fffc4 	addi	r5,r5,-1
21099b54:	81400215 	stw	r5,8(r16)
21099b58:	14400005 	stb	r17,0(r2)
21099b5c:	80800517 	ldw	r2,20(r16)
21099b60:	10c01d26 	beq	r2,r3,21099bd8 <__swbuf_r+0xfc>
21099b64:	8080030b 	ldhu	r2,12(r16)
21099b68:	1080004c 	andi	r2,r2,1
21099b6c:	1000181e 	bne	r2,zero,21099bd0 <__swbuf_r+0xf4>
21099b70:	8805883a 	mov	r2,r17
21099b74:	dfc00317 	ldw	ra,12(sp)
21099b78:	dc800217 	ldw	r18,8(sp)
21099b7c:	dc400117 	ldw	r17,4(sp)
21099b80:	dc000017 	ldw	r16,0(sp)
21099b84:	dec00404 	addi	sp,sp,16
21099b88:	f800283a 	ret
21099b8c:	81001917 	ldw	r4,100(r16)
21099b90:	00b7ffc4 	movi	r2,-8193
21099b94:	31880014 	ori	r6,r6,8192
21099b98:	2084703a 	and	r2,r4,r2
21099b9c:	80801915 	stw	r2,100(r16)
21099ba0:	80800017 	ldw	r2,0(r16)
21099ba4:	81000517 	ldw	r4,20(r16)
21099ba8:	8180030d 	sth	r6,12(r16)
21099bac:	10c7c83a 	sub	r3,r2,r3
21099bb0:	193fe316 	blt	r3,r4,21099b40 <__flash_rwdata_start+0xffff78f8>
21099bb4:	9009883a 	mov	r4,r18
21099bb8:	800b883a 	mov	r5,r16
21099bbc:	10947280 	call	21094728 <_fflush_r>
21099bc0:	1000091e 	bne	r2,zero,21099be8 <__swbuf_r+0x10c>
21099bc4:	80800017 	ldw	r2,0(r16)
21099bc8:	00c00044 	movi	r3,1
21099bcc:	003fdd06 	br	21099b44 <__flash_rwdata_start+0xffff78fc>
21099bd0:	00800284 	movi	r2,10
21099bd4:	88bfe61e 	bne	r17,r2,21099b70 <__flash_rwdata_start+0xffff7928>
21099bd8:	9009883a 	mov	r4,r18
21099bdc:	800b883a 	mov	r5,r16
21099be0:	10947280 	call	21094728 <_fflush_r>
21099be4:	103fe226 	beq	r2,zero,21099b70 <__flash_rwdata_start+0xffff7928>
21099be8:	00bfffc4 	movi	r2,-1
21099bec:	003fe106 	br	21099b74 <__flash_rwdata_start+0xffff792c>
21099bf0:	9009883a 	mov	r4,r18
21099bf4:	800b883a 	mov	r5,r16
21099bf8:	10929100 	call	21092910 <__swsetup_r>
21099bfc:	103ffa1e 	bne	r2,zero,21099be8 <__flash_rwdata_start+0xffff79a0>
21099c00:	8180030b 	ldhu	r6,12(r16)
21099c04:	80c00417 	ldw	r3,16(r16)
21099c08:	003fc606 	br	21099b24 <__flash_rwdata_start+0xffff78dc>
21099c0c:	1094b040 	call	21094b04 <__sinit>
21099c10:	003fbd06 	br	21099b08 <__flash_rwdata_start+0xffff78c0>

21099c14 <__swbuf>:
21099c14:	00c00034 	movhi	r3,0
21099c18:	18d76b04 	addi	r3,r3,23980
21099c1c:	2005883a 	mov	r2,r4
21099c20:	19000017 	ldw	r4,0(r3)
21099c24:	280d883a 	mov	r6,r5
21099c28:	100b883a 	mov	r5,r2
21099c2c:	1099adc1 	jmpi	21099adc <__swbuf_r>

21099c30 <_write_r>:
21099c30:	defffd04 	addi	sp,sp,-12
21099c34:	dc000015 	stw	r16,0(sp)
21099c38:	04000034 	movhi	r16,0
21099c3c:	dc400115 	stw	r17,4(sp)
21099c40:	84178504 	addi	r16,r16,24084
21099c44:	2023883a 	mov	r17,r4
21099c48:	2809883a 	mov	r4,r5
21099c4c:	300b883a 	mov	r5,r6
21099c50:	380d883a 	mov	r6,r7
21099c54:	dfc00215 	stw	ra,8(sp)
21099c58:	80000015 	stw	zero,0(r16)
21099c5c:	109b8540 	call	2109b854 <write>
21099c60:	00ffffc4 	movi	r3,-1
21099c64:	10c00526 	beq	r2,r3,21099c7c <_write_r+0x4c>
21099c68:	dfc00217 	ldw	ra,8(sp)
21099c6c:	dc400117 	ldw	r17,4(sp)
21099c70:	dc000017 	ldw	r16,0(sp)
21099c74:	dec00304 	addi	sp,sp,12
21099c78:	f800283a 	ret
21099c7c:	80c00017 	ldw	r3,0(r16)
21099c80:	183ff926 	beq	r3,zero,21099c68 <__flash_rwdata_start+0xffff7a20>
21099c84:	88c00015 	stw	r3,0(r17)
21099c88:	003ff706 	br	21099c68 <__flash_rwdata_start+0xffff7a20>

21099c8c <_close_r>:
21099c8c:	defffd04 	addi	sp,sp,-12
21099c90:	dc000015 	stw	r16,0(sp)
21099c94:	04000034 	movhi	r16,0
21099c98:	dc400115 	stw	r17,4(sp)
21099c9c:	84178504 	addi	r16,r16,24084
21099ca0:	2023883a 	mov	r17,r4
21099ca4:	2809883a 	mov	r4,r5
21099ca8:	dfc00215 	stw	ra,8(sp)
21099cac:	80000015 	stw	zero,0(r16)
21099cb0:	109b0880 	call	2109b088 <close>
21099cb4:	00ffffc4 	movi	r3,-1
21099cb8:	10c00526 	beq	r2,r3,21099cd0 <_close_r+0x44>
21099cbc:	dfc00217 	ldw	ra,8(sp)
21099cc0:	dc400117 	ldw	r17,4(sp)
21099cc4:	dc000017 	ldw	r16,0(sp)
21099cc8:	dec00304 	addi	sp,sp,12
21099ccc:	f800283a 	ret
21099cd0:	80c00017 	ldw	r3,0(r16)
21099cd4:	183ff926 	beq	r3,zero,21099cbc <__flash_rwdata_start+0xffff7a74>
21099cd8:	88c00015 	stw	r3,0(r17)
21099cdc:	003ff706 	br	21099cbc <__flash_rwdata_start+0xffff7a74>

21099ce0 <_calloc_r>:
21099ce0:	298b383a 	mul	r5,r5,r6
21099ce4:	defffe04 	addi	sp,sp,-8
21099ce8:	dc000015 	stw	r16,0(sp)
21099cec:	dfc00115 	stw	ra,4(sp)
21099cf0:	108d9100 	call	2108d910 <_malloc_r>
21099cf4:	1021883a 	mov	r16,r2
21099cf8:	10002826 	beq	r2,zero,21099d9c <_calloc_r+0xbc>
21099cfc:	11bfff17 	ldw	r6,-4(r2)
21099d00:	00bfff04 	movi	r2,-4
21099d04:	00c00904 	movi	r3,36
21099d08:	308c703a 	and	r6,r6,r2
21099d0c:	308d883a 	add	r6,r6,r2
21099d10:	19801436 	bltu	r3,r6,21099d64 <_calloc_r+0x84>
21099d14:	008004c4 	movi	r2,19
21099d18:	11800936 	bltu	r2,r6,21099d40 <_calloc_r+0x60>
21099d1c:	8005883a 	mov	r2,r16
21099d20:	10000015 	stw	zero,0(r2)
21099d24:	10000115 	stw	zero,4(r2)
21099d28:	10000215 	stw	zero,8(r2)
21099d2c:	8005883a 	mov	r2,r16
21099d30:	dfc00117 	ldw	ra,4(sp)
21099d34:	dc000017 	ldw	r16,0(sp)
21099d38:	dec00204 	addi	sp,sp,8
21099d3c:	f800283a 	ret
21099d40:	80000015 	stw	zero,0(r16)
21099d44:	80000115 	stw	zero,4(r16)
21099d48:	008006c4 	movi	r2,27
21099d4c:	11800d2e 	bgeu	r2,r6,21099d84 <_calloc_r+0xa4>
21099d50:	80000215 	stw	zero,8(r16)
21099d54:	80000315 	stw	zero,12(r16)
21099d58:	30c00c26 	beq	r6,r3,21099d8c <_calloc_r+0xac>
21099d5c:	80800404 	addi	r2,r16,16
21099d60:	003fef06 	br	21099d20 <__flash_rwdata_start+0xffff7ad8>
21099d64:	8009883a 	mov	r4,r16
21099d68:	000b883a 	mov	r5,zero
21099d6c:	108e26c0 	call	2108e26c <memset>
21099d70:	8005883a 	mov	r2,r16
21099d74:	dfc00117 	ldw	ra,4(sp)
21099d78:	dc000017 	ldw	r16,0(sp)
21099d7c:	dec00204 	addi	sp,sp,8
21099d80:	f800283a 	ret
21099d84:	80800204 	addi	r2,r16,8
21099d88:	003fe506 	br	21099d20 <__flash_rwdata_start+0xffff7ad8>
21099d8c:	80000415 	stw	zero,16(r16)
21099d90:	80800604 	addi	r2,r16,24
21099d94:	80000515 	stw	zero,20(r16)
21099d98:	003fe106 	br	21099d20 <__flash_rwdata_start+0xffff7ad8>
21099d9c:	0005883a 	mov	r2,zero
21099da0:	003fe306 	br	21099d30 <__flash_rwdata_start+0xffff7ae8>

21099da4 <_fclose_r>:
21099da4:	28003926 	beq	r5,zero,21099e8c <_fclose_r+0xe8>
21099da8:	defffc04 	addi	sp,sp,-16
21099dac:	dc400115 	stw	r17,4(sp)
21099db0:	dc000015 	stw	r16,0(sp)
21099db4:	dfc00315 	stw	ra,12(sp)
21099db8:	dc800215 	stw	r18,8(sp)
21099dbc:	2023883a 	mov	r17,r4
21099dc0:	2821883a 	mov	r16,r5
21099dc4:	20000226 	beq	r4,zero,21099dd0 <_fclose_r+0x2c>
21099dc8:	20800e17 	ldw	r2,56(r4)
21099dcc:	10002726 	beq	r2,zero,21099e6c <_fclose_r+0xc8>
21099dd0:	8080030f 	ldh	r2,12(r16)
21099dd4:	1000071e 	bne	r2,zero,21099df4 <_fclose_r+0x50>
21099dd8:	0005883a 	mov	r2,zero
21099ddc:	dfc00317 	ldw	ra,12(sp)
21099de0:	dc800217 	ldw	r18,8(sp)
21099de4:	dc400117 	ldw	r17,4(sp)
21099de8:	dc000017 	ldw	r16,0(sp)
21099dec:	dec00404 	addi	sp,sp,16
21099df0:	f800283a 	ret
21099df4:	8809883a 	mov	r4,r17
21099df8:	800b883a 	mov	r5,r16
21099dfc:	10945200 	call	21094520 <__sflush_r>
21099e00:	1025883a 	mov	r18,r2
21099e04:	80800b17 	ldw	r2,44(r16)
21099e08:	10000426 	beq	r2,zero,21099e1c <_fclose_r+0x78>
21099e0c:	81400717 	ldw	r5,28(r16)
21099e10:	8809883a 	mov	r4,r17
21099e14:	103ee83a 	callr	r2
21099e18:	10001616 	blt	r2,zero,21099e74 <_fclose_r+0xd0>
21099e1c:	8080030b 	ldhu	r2,12(r16)
21099e20:	1080200c 	andi	r2,r2,128
21099e24:	1000151e 	bne	r2,zero,21099e7c <_fclose_r+0xd8>
21099e28:	81400c17 	ldw	r5,48(r16)
21099e2c:	28000526 	beq	r5,zero,21099e44 <_fclose_r+0xa0>
21099e30:	80801004 	addi	r2,r16,64
21099e34:	28800226 	beq	r5,r2,21099e40 <_fclose_r+0x9c>
21099e38:	8809883a 	mov	r4,r17
21099e3c:	1094c780 	call	21094c78 <_free_r>
21099e40:	80000c15 	stw	zero,48(r16)
21099e44:	81401117 	ldw	r5,68(r16)
21099e48:	28000326 	beq	r5,zero,21099e58 <_fclose_r+0xb4>
21099e4c:	8809883a 	mov	r4,r17
21099e50:	1094c780 	call	21094c78 <_free_r>
21099e54:	80001115 	stw	zero,68(r16)
21099e58:	1094b140 	call	21094b14 <__sfp_lock_acquire>
21099e5c:	8000030d 	sth	zero,12(r16)
21099e60:	1094b180 	call	21094b18 <__sfp_lock_release>
21099e64:	9005883a 	mov	r2,r18
21099e68:	003fdc06 	br	21099ddc <__flash_rwdata_start+0xffff7b94>
21099e6c:	1094b040 	call	21094b04 <__sinit>
21099e70:	003fd706 	br	21099dd0 <__flash_rwdata_start+0xffff7b88>
21099e74:	04bfffc4 	movi	r18,-1
21099e78:	003fe806 	br	21099e1c <__flash_rwdata_start+0xffff7bd4>
21099e7c:	81400417 	ldw	r5,16(r16)
21099e80:	8809883a 	mov	r4,r17
21099e84:	1094c780 	call	21094c78 <_free_r>
21099e88:	003fe706 	br	21099e28 <__flash_rwdata_start+0xffff7be0>
21099e8c:	0005883a 	mov	r2,zero
21099e90:	f800283a 	ret

21099e94 <fclose>:
21099e94:	00800034 	movhi	r2,0
21099e98:	10976b04 	addi	r2,r2,23980
21099e9c:	200b883a 	mov	r5,r4
21099ea0:	11000017 	ldw	r4,0(r2)
21099ea4:	1099da41 	jmpi	21099da4 <_fclose_r>

21099ea8 <_fputwc_r>:
21099ea8:	3080030b 	ldhu	r2,12(r6)
21099eac:	defff804 	addi	sp,sp,-32
21099eb0:	dcc00415 	stw	r19,16(sp)
21099eb4:	dc800315 	stw	r18,12(sp)
21099eb8:	dc000115 	stw	r16,4(sp)
21099ebc:	dfc00715 	stw	ra,28(sp)
21099ec0:	dd400615 	stw	r21,24(sp)
21099ec4:	dd000515 	stw	r20,20(sp)
21099ec8:	dc400215 	stw	r17,8(sp)
21099ecc:	10c8000c 	andi	r3,r2,8192
21099ed0:	3021883a 	mov	r16,r6
21099ed4:	2027883a 	mov	r19,r4
21099ed8:	2825883a 	mov	r18,r5
21099edc:	1800051e 	bne	r3,zero,21099ef4 <_fputwc_r+0x4c>
21099ee0:	30c01917 	ldw	r3,100(r6)
21099ee4:	10880014 	ori	r2,r2,8192
21099ee8:	3080030d 	sth	r2,12(r6)
21099eec:	18880014 	ori	r2,r3,8192
21099ef0:	30801915 	stw	r2,100(r6)
21099ef4:	10956380 	call	21095638 <__locale_mb_cur_max>
21099ef8:	00c00044 	movi	r3,1
21099efc:	10c03e26 	beq	r2,r3,21099ff8 <_fputwc_r+0x150>
21099f00:	9809883a 	mov	r4,r19
21099f04:	d80b883a 	mov	r5,sp
21099f08:	900d883a 	mov	r6,r18
21099f0c:	81c01704 	addi	r7,r16,92
21099f10:	109a1ec0 	call	2109a1ec <_wcrtomb_r>
21099f14:	1029883a 	mov	r20,r2
21099f18:	00bfffc4 	movi	r2,-1
21099f1c:	a0802026 	beq	r20,r2,21099fa0 <_fputwc_r+0xf8>
21099f20:	d9400003 	ldbu	r5,0(sp)
21099f24:	a0001c26 	beq	r20,zero,21099f98 <_fputwc_r+0xf0>
21099f28:	0023883a 	mov	r17,zero
21099f2c:	05400284 	movi	r21,10
21099f30:	00000906 	br	21099f58 <_fputwc_r+0xb0>
21099f34:	80800017 	ldw	r2,0(r16)
21099f38:	11400005 	stb	r5,0(r2)
21099f3c:	80c00017 	ldw	r3,0(r16)
21099f40:	18c00044 	addi	r3,r3,1
21099f44:	80c00015 	stw	r3,0(r16)
21099f48:	8c400044 	addi	r17,r17,1
21099f4c:	dc45883a 	add	r2,sp,r17
21099f50:	8d00112e 	bgeu	r17,r20,21099f98 <_fputwc_r+0xf0>
21099f54:	11400003 	ldbu	r5,0(r2)
21099f58:	80c00217 	ldw	r3,8(r16)
21099f5c:	18ffffc4 	addi	r3,r3,-1
21099f60:	80c00215 	stw	r3,8(r16)
21099f64:	183ff30e 	bge	r3,zero,21099f34 <__flash_rwdata_start+0xffff7cec>
21099f68:	80800617 	ldw	r2,24(r16)
21099f6c:	18801916 	blt	r3,r2,21099fd4 <_fputwc_r+0x12c>
21099f70:	80800017 	ldw	r2,0(r16)
21099f74:	11400005 	stb	r5,0(r2)
21099f78:	80800017 	ldw	r2,0(r16)
21099f7c:	10c00003 	ldbu	r3,0(r2)
21099f80:	10800044 	addi	r2,r2,1
21099f84:	1d402326 	beq	r3,r21,2109a014 <_fputwc_r+0x16c>
21099f88:	80800015 	stw	r2,0(r16)
21099f8c:	8c400044 	addi	r17,r17,1
21099f90:	dc45883a 	add	r2,sp,r17
21099f94:	8d3fef36 	bltu	r17,r20,21099f54 <__flash_rwdata_start+0xffff7d0c>
21099f98:	9005883a 	mov	r2,r18
21099f9c:	00000406 	br	21099fb0 <_fputwc_r+0x108>
21099fa0:	80c0030b 	ldhu	r3,12(r16)
21099fa4:	a005883a 	mov	r2,r20
21099fa8:	18c01014 	ori	r3,r3,64
21099fac:	80c0030d 	sth	r3,12(r16)
21099fb0:	dfc00717 	ldw	ra,28(sp)
21099fb4:	dd400617 	ldw	r21,24(sp)
21099fb8:	dd000517 	ldw	r20,20(sp)
21099fbc:	dcc00417 	ldw	r19,16(sp)
21099fc0:	dc800317 	ldw	r18,12(sp)
21099fc4:	dc400217 	ldw	r17,8(sp)
21099fc8:	dc000117 	ldw	r16,4(sp)
21099fcc:	dec00804 	addi	sp,sp,32
21099fd0:	f800283a 	ret
21099fd4:	9809883a 	mov	r4,r19
21099fd8:	29403fcc 	andi	r5,r5,255
21099fdc:	800d883a 	mov	r6,r16
21099fe0:	1099adc0 	call	21099adc <__swbuf_r>
21099fe4:	10bfffe0 	cmpeqi	r2,r2,-1
21099fe8:	10803fcc 	andi	r2,r2,255
21099fec:	103fd626 	beq	r2,zero,21099f48 <__flash_rwdata_start+0xffff7d00>
21099ff0:	00bfffc4 	movi	r2,-1
21099ff4:	003fee06 	br	21099fb0 <__flash_rwdata_start+0xffff7d68>
21099ff8:	90ffffc4 	addi	r3,r18,-1
21099ffc:	01003f84 	movi	r4,254
2109a000:	20ffbf36 	bltu	r4,r3,21099f00 <__flash_rwdata_start+0xffff7cb8>
2109a004:	900b883a 	mov	r5,r18
2109a008:	dc800005 	stb	r18,0(sp)
2109a00c:	1029883a 	mov	r20,r2
2109a010:	003fc506 	br	21099f28 <__flash_rwdata_start+0xffff7ce0>
2109a014:	9809883a 	mov	r4,r19
2109a018:	a80b883a 	mov	r5,r21
2109a01c:	800d883a 	mov	r6,r16
2109a020:	1099adc0 	call	21099adc <__swbuf_r>
2109a024:	10bfffe0 	cmpeqi	r2,r2,-1
2109a028:	003fef06 	br	21099fe8 <__flash_rwdata_start+0xffff7da0>

2109a02c <fputwc>:
2109a02c:	00800034 	movhi	r2,0
2109a030:	defffc04 	addi	sp,sp,-16
2109a034:	10976b04 	addi	r2,r2,23980
2109a038:	dc000115 	stw	r16,4(sp)
2109a03c:	14000017 	ldw	r16,0(r2)
2109a040:	dc400215 	stw	r17,8(sp)
2109a044:	dfc00315 	stw	ra,12(sp)
2109a048:	2023883a 	mov	r17,r4
2109a04c:	280d883a 	mov	r6,r5
2109a050:	80000626 	beq	r16,zero,2109a06c <fputwc+0x40>
2109a054:	80800e17 	ldw	r2,56(r16)
2109a058:	1000041e 	bne	r2,zero,2109a06c <fputwc+0x40>
2109a05c:	8009883a 	mov	r4,r16
2109a060:	d9400015 	stw	r5,0(sp)
2109a064:	1094b040 	call	21094b04 <__sinit>
2109a068:	d9800017 	ldw	r6,0(sp)
2109a06c:	8009883a 	mov	r4,r16
2109a070:	880b883a 	mov	r5,r17
2109a074:	dfc00317 	ldw	ra,12(sp)
2109a078:	dc400217 	ldw	r17,8(sp)
2109a07c:	dc000117 	ldw	r16,4(sp)
2109a080:	dec00404 	addi	sp,sp,16
2109a084:	1099ea81 	jmpi	21099ea8 <_fputwc_r>

2109a088 <_fstat_r>:
2109a088:	defffd04 	addi	sp,sp,-12
2109a08c:	dc000015 	stw	r16,0(sp)
2109a090:	04000034 	movhi	r16,0
2109a094:	dc400115 	stw	r17,4(sp)
2109a098:	84178504 	addi	r16,r16,24084
2109a09c:	2023883a 	mov	r17,r4
2109a0a0:	2809883a 	mov	r4,r5
2109a0a4:	300b883a 	mov	r5,r6
2109a0a8:	dfc00215 	stw	ra,8(sp)
2109a0ac:	80000015 	stw	zero,0(r16)
2109a0b0:	109b1d00 	call	2109b1d0 <fstat>
2109a0b4:	00ffffc4 	movi	r3,-1
2109a0b8:	10c00526 	beq	r2,r3,2109a0d0 <_fstat_r+0x48>
2109a0bc:	dfc00217 	ldw	ra,8(sp)
2109a0c0:	dc400117 	ldw	r17,4(sp)
2109a0c4:	dc000017 	ldw	r16,0(sp)
2109a0c8:	dec00304 	addi	sp,sp,12
2109a0cc:	f800283a 	ret
2109a0d0:	80c00017 	ldw	r3,0(r16)
2109a0d4:	183ff926 	beq	r3,zero,2109a0bc <__flash_rwdata_start+0xffff7e74>
2109a0d8:	88c00015 	stw	r3,0(r17)
2109a0dc:	003ff706 	br	2109a0bc <__flash_rwdata_start+0xffff7e74>

2109a0e0 <_isatty_r>:
2109a0e0:	defffd04 	addi	sp,sp,-12
2109a0e4:	dc000015 	stw	r16,0(sp)
2109a0e8:	04000034 	movhi	r16,0
2109a0ec:	dc400115 	stw	r17,4(sp)
2109a0f0:	84178504 	addi	r16,r16,24084
2109a0f4:	2023883a 	mov	r17,r4
2109a0f8:	2809883a 	mov	r4,r5
2109a0fc:	dfc00215 	stw	ra,8(sp)
2109a100:	80000015 	stw	zero,0(r16)
2109a104:	109b3100 	call	2109b310 <isatty>
2109a108:	00ffffc4 	movi	r3,-1
2109a10c:	10c00526 	beq	r2,r3,2109a124 <_isatty_r+0x44>
2109a110:	dfc00217 	ldw	ra,8(sp)
2109a114:	dc400117 	ldw	r17,4(sp)
2109a118:	dc000017 	ldw	r16,0(sp)
2109a11c:	dec00304 	addi	sp,sp,12
2109a120:	f800283a 	ret
2109a124:	80c00017 	ldw	r3,0(r16)
2109a128:	183ff926 	beq	r3,zero,2109a110 <__flash_rwdata_start+0xffff7ec8>
2109a12c:	88c00015 	stw	r3,0(r17)
2109a130:	003ff706 	br	2109a110 <__flash_rwdata_start+0xffff7ec8>

2109a134 <_lseek_r>:
2109a134:	defffd04 	addi	sp,sp,-12
2109a138:	dc000015 	stw	r16,0(sp)
2109a13c:	04000034 	movhi	r16,0
2109a140:	dc400115 	stw	r17,4(sp)
2109a144:	84178504 	addi	r16,r16,24084
2109a148:	2023883a 	mov	r17,r4
2109a14c:	2809883a 	mov	r4,r5
2109a150:	300b883a 	mov	r5,r6
2109a154:	380d883a 	mov	r6,r7
2109a158:	dfc00215 	stw	ra,8(sp)
2109a15c:	80000015 	stw	zero,0(r16)
2109a160:	109b46c0 	call	2109b46c <lseek>
2109a164:	00ffffc4 	movi	r3,-1
2109a168:	10c00526 	beq	r2,r3,2109a180 <_lseek_r+0x4c>
2109a16c:	dfc00217 	ldw	ra,8(sp)
2109a170:	dc400117 	ldw	r17,4(sp)
2109a174:	dc000017 	ldw	r16,0(sp)
2109a178:	dec00304 	addi	sp,sp,12
2109a17c:	f800283a 	ret
2109a180:	80c00017 	ldw	r3,0(r16)
2109a184:	183ff926 	beq	r3,zero,2109a16c <__flash_rwdata_start+0xffff7f24>
2109a188:	88c00015 	stw	r3,0(r17)
2109a18c:	003ff706 	br	2109a16c <__flash_rwdata_start+0xffff7f24>

2109a190 <_read_r>:
2109a190:	defffd04 	addi	sp,sp,-12
2109a194:	dc000015 	stw	r16,0(sp)
2109a198:	04000034 	movhi	r16,0
2109a19c:	dc400115 	stw	r17,4(sp)
2109a1a0:	84178504 	addi	r16,r16,24084
2109a1a4:	2023883a 	mov	r17,r4
2109a1a8:	2809883a 	mov	r4,r5
2109a1ac:	300b883a 	mov	r5,r6
2109a1b0:	380d883a 	mov	r6,r7
2109a1b4:	dfc00215 	stw	ra,8(sp)
2109a1b8:	80000015 	stw	zero,0(r16)
2109a1bc:	109b55c0 	call	2109b55c <read>
2109a1c0:	00ffffc4 	movi	r3,-1
2109a1c4:	10c00526 	beq	r2,r3,2109a1dc <_read_r+0x4c>
2109a1c8:	dfc00217 	ldw	ra,8(sp)
2109a1cc:	dc400117 	ldw	r17,4(sp)
2109a1d0:	dc000017 	ldw	r16,0(sp)
2109a1d4:	dec00304 	addi	sp,sp,12
2109a1d8:	f800283a 	ret
2109a1dc:	80c00017 	ldw	r3,0(r16)
2109a1e0:	183ff926 	beq	r3,zero,2109a1c8 <__flash_rwdata_start+0xffff7f80>
2109a1e4:	88c00015 	stw	r3,0(r17)
2109a1e8:	003ff706 	br	2109a1c8 <__flash_rwdata_start+0xffff7f80>

2109a1ec <_wcrtomb_r>:
2109a1ec:	defff604 	addi	sp,sp,-40
2109a1f0:	00800034 	movhi	r2,0
2109a1f4:	dc800815 	stw	r18,32(sp)
2109a1f8:	dc400715 	stw	r17,28(sp)
2109a1fc:	dc000615 	stw	r16,24(sp)
2109a200:	10976f04 	addi	r2,r2,23996
2109a204:	dfc00915 	stw	ra,36(sp)
2109a208:	2021883a 	mov	r16,r4
2109a20c:	3823883a 	mov	r17,r7
2109a210:	14800017 	ldw	r18,0(r2)
2109a214:	28001426 	beq	r5,zero,2109a268 <_wcrtomb_r+0x7c>
2109a218:	d9400415 	stw	r5,16(sp)
2109a21c:	d9800515 	stw	r6,20(sp)
2109a220:	109562c0 	call	2109562c <__locale_charset>
2109a224:	d9400417 	ldw	r5,16(sp)
2109a228:	d9800517 	ldw	r6,20(sp)
2109a22c:	8009883a 	mov	r4,r16
2109a230:	dc400015 	stw	r17,0(sp)
2109a234:	100f883a 	mov	r7,r2
2109a238:	903ee83a 	callr	r18
2109a23c:	00ffffc4 	movi	r3,-1
2109a240:	10c0031e 	bne	r2,r3,2109a250 <_wcrtomb_r+0x64>
2109a244:	88000015 	stw	zero,0(r17)
2109a248:	00c02284 	movi	r3,138
2109a24c:	80c00015 	stw	r3,0(r16)
2109a250:	dfc00917 	ldw	ra,36(sp)
2109a254:	dc800817 	ldw	r18,32(sp)
2109a258:	dc400717 	ldw	r17,28(sp)
2109a25c:	dc000617 	ldw	r16,24(sp)
2109a260:	dec00a04 	addi	sp,sp,40
2109a264:	f800283a 	ret
2109a268:	109562c0 	call	2109562c <__locale_charset>
2109a26c:	8009883a 	mov	r4,r16
2109a270:	dc400015 	stw	r17,0(sp)
2109a274:	d9400104 	addi	r5,sp,4
2109a278:	000d883a 	mov	r6,zero
2109a27c:	100f883a 	mov	r7,r2
2109a280:	903ee83a 	callr	r18
2109a284:	003fed06 	br	2109a23c <__flash_rwdata_start+0xffff7ff4>

2109a288 <wcrtomb>:
2109a288:	defff604 	addi	sp,sp,-40
2109a28c:	00800034 	movhi	r2,0
2109a290:	dc800615 	stw	r18,24(sp)
2109a294:	dc400515 	stw	r17,20(sp)
2109a298:	dc000415 	stw	r16,16(sp)
2109a29c:	10976b04 	addi	r2,r2,23980
2109a2a0:	dfc00915 	stw	ra,36(sp)
2109a2a4:	dd000815 	stw	r20,32(sp)
2109a2a8:	dcc00715 	stw	r19,28(sp)
2109a2ac:	2021883a 	mov	r16,r4
2109a2b0:	3025883a 	mov	r18,r6
2109a2b4:	14400017 	ldw	r17,0(r2)
2109a2b8:	20001826 	beq	r4,zero,2109a31c <wcrtomb+0x94>
2109a2bc:	00800034 	movhi	r2,0
2109a2c0:	10976f04 	addi	r2,r2,23996
2109a2c4:	15000017 	ldw	r20,0(r2)
2109a2c8:	2827883a 	mov	r19,r5
2109a2cc:	109562c0 	call	2109562c <__locale_charset>
2109a2d0:	8809883a 	mov	r4,r17
2109a2d4:	dc800015 	stw	r18,0(sp)
2109a2d8:	800b883a 	mov	r5,r16
2109a2dc:	980d883a 	mov	r6,r19
2109a2e0:	100f883a 	mov	r7,r2
2109a2e4:	a03ee83a 	callr	r20
2109a2e8:	00ffffc4 	movi	r3,-1
2109a2ec:	10c0031e 	bne	r2,r3,2109a2fc <wcrtomb+0x74>
2109a2f0:	90000015 	stw	zero,0(r18)
2109a2f4:	00c02284 	movi	r3,138
2109a2f8:	88c00015 	stw	r3,0(r17)
2109a2fc:	dfc00917 	ldw	ra,36(sp)
2109a300:	dd000817 	ldw	r20,32(sp)
2109a304:	dcc00717 	ldw	r19,28(sp)
2109a308:	dc800617 	ldw	r18,24(sp)
2109a30c:	dc400517 	ldw	r17,20(sp)
2109a310:	dc000417 	ldw	r16,16(sp)
2109a314:	dec00a04 	addi	sp,sp,40
2109a318:	f800283a 	ret
2109a31c:	00800034 	movhi	r2,0
2109a320:	10976f04 	addi	r2,r2,23996
2109a324:	14000017 	ldw	r16,0(r2)
2109a328:	109562c0 	call	2109562c <__locale_charset>
2109a32c:	8809883a 	mov	r4,r17
2109a330:	dc800015 	stw	r18,0(sp)
2109a334:	d9400104 	addi	r5,sp,4
2109a338:	000d883a 	mov	r6,zero
2109a33c:	100f883a 	mov	r7,r2
2109a340:	803ee83a 	callr	r16
2109a344:	003fe806 	br	2109a2e8 <__flash_rwdata_start+0xffff80a0>

2109a348 <__ascii_wctomb>:
2109a348:	28000526 	beq	r5,zero,2109a360 <__ascii_wctomb+0x18>
2109a34c:	00803fc4 	movi	r2,255
2109a350:	11800536 	bltu	r2,r6,2109a368 <__ascii_wctomb+0x20>
2109a354:	29800005 	stb	r6,0(r5)
2109a358:	00800044 	movi	r2,1
2109a35c:	f800283a 	ret
2109a360:	0005883a 	mov	r2,zero
2109a364:	f800283a 	ret
2109a368:	00802284 	movi	r2,138
2109a36c:	20800015 	stw	r2,0(r4)
2109a370:	00bfffc4 	movi	r2,-1
2109a374:	f800283a 	ret

2109a378 <_wctomb_r>:
2109a378:	00800034 	movhi	r2,0
2109a37c:	defff904 	addi	sp,sp,-28
2109a380:	10976f04 	addi	r2,r2,23996
2109a384:	dfc00615 	stw	ra,24(sp)
2109a388:	dc400515 	stw	r17,20(sp)
2109a38c:	dc000415 	stw	r16,16(sp)
2109a390:	3823883a 	mov	r17,r7
2109a394:	14000017 	ldw	r16,0(r2)
2109a398:	d9000115 	stw	r4,4(sp)
2109a39c:	d9400215 	stw	r5,8(sp)
2109a3a0:	d9800315 	stw	r6,12(sp)
2109a3a4:	109562c0 	call	2109562c <__locale_charset>
2109a3a8:	d9000117 	ldw	r4,4(sp)
2109a3ac:	d9400217 	ldw	r5,8(sp)
2109a3b0:	d9800317 	ldw	r6,12(sp)
2109a3b4:	dc400015 	stw	r17,0(sp)
2109a3b8:	100f883a 	mov	r7,r2
2109a3bc:	803ee83a 	callr	r16
2109a3c0:	dfc00617 	ldw	ra,24(sp)
2109a3c4:	dc400517 	ldw	r17,20(sp)
2109a3c8:	dc000417 	ldw	r16,16(sp)
2109a3cc:	dec00704 	addi	sp,sp,28
2109a3d0:	f800283a 	ret

2109a3d4 <__udivdi3>:
2109a3d4:	defff504 	addi	sp,sp,-44
2109a3d8:	dcc00415 	stw	r19,16(sp)
2109a3dc:	dc000115 	stw	r16,4(sp)
2109a3e0:	dfc00a15 	stw	ra,40(sp)
2109a3e4:	df000915 	stw	fp,36(sp)
2109a3e8:	ddc00815 	stw	r23,32(sp)
2109a3ec:	dd800715 	stw	r22,28(sp)
2109a3f0:	dd400615 	stw	r21,24(sp)
2109a3f4:	dd000515 	stw	r20,20(sp)
2109a3f8:	dc800315 	stw	r18,12(sp)
2109a3fc:	dc400215 	stw	r17,8(sp)
2109a400:	2027883a 	mov	r19,r4
2109a404:	2821883a 	mov	r16,r5
2109a408:	3800421e 	bne	r7,zero,2109a514 <__udivdi3+0x140>
2109a40c:	3025883a 	mov	r18,r6
2109a410:	2023883a 	mov	r17,r4
2109a414:	2980542e 	bgeu	r5,r6,2109a568 <__udivdi3+0x194>
2109a418:	00bfffd4 	movui	r2,65535
2109a41c:	282d883a 	mov	r22,r5
2109a420:	1180a836 	bltu	r2,r6,2109a6c4 <__udivdi3+0x2f0>
2109a424:	00803fc4 	movi	r2,255
2109a428:	1181422e 	bgeu	r2,r6,2109a934 <__udivdi3+0x560>
2109a42c:	00800204 	movi	r2,8
2109a430:	1007883a 	mov	r3,r2
2109a434:	3084d83a 	srl	r2,r6,r2
2109a438:	01000034 	movhi	r4,0
2109a43c:	210e8904 	addi	r4,r4,14884
2109a440:	2085883a 	add	r2,r4,r2
2109a444:	10800003 	ldbu	r2,0(r2)
2109a448:	10c7883a 	add	r3,r2,r3
2109a44c:	00800804 	movi	r2,32
2109a450:	10c5c83a 	sub	r2,r2,r3
2109a454:	10000526 	beq	r2,zero,2109a46c <__udivdi3+0x98>
2109a458:	80a0983a 	sll	r16,r16,r2
2109a45c:	98c6d83a 	srl	r3,r19,r3
2109a460:	30a4983a 	sll	r18,r6,r2
2109a464:	98a2983a 	sll	r17,r19,r2
2109a468:	80ecb03a 	or	r22,r16,r3
2109a46c:	902ad43a 	srli	r21,r18,16
2109a470:	b009883a 	mov	r4,r22
2109a474:	953fffcc 	andi	r20,r18,65535
2109a478:	a80b883a 	mov	r5,r21
2109a47c:	108d5800 	call	2108d580 <__umodsi3>
2109a480:	b009883a 	mov	r4,r22
2109a484:	a80b883a 	mov	r5,r21
2109a488:	1027883a 	mov	r19,r2
2109a48c:	108d5780 	call	2108d578 <__udivsi3>
2109a490:	1021883a 	mov	r16,r2
2109a494:	8806d43a 	srli	r3,r17,16
2109a498:	9804943a 	slli	r2,r19,16
2109a49c:	8527383a 	mul	r19,r16,r20
2109a4a0:	10c4b03a 	or	r2,r2,r3
2109a4a4:	14c0052e 	bgeu	r2,r19,2109a4bc <__udivdi3+0xe8>
2109a4a8:	1485883a 	add	r2,r2,r18
2109a4ac:	80ffffc4 	addi	r3,r16,-1
2109a4b0:	14800136 	bltu	r2,r18,2109a4b8 <__udivdi3+0xe4>
2109a4b4:	14c13436 	bltu	r2,r19,2109a988 <__udivdi3+0x5b4>
2109a4b8:	1821883a 	mov	r16,r3
2109a4bc:	14e7c83a 	sub	r19,r2,r19
2109a4c0:	9809883a 	mov	r4,r19
2109a4c4:	a80b883a 	mov	r5,r21
2109a4c8:	108d5800 	call	2108d580 <__umodsi3>
2109a4cc:	102d883a 	mov	r22,r2
2109a4d0:	9809883a 	mov	r4,r19
2109a4d4:	a80b883a 	mov	r5,r21
2109a4d8:	108d5780 	call	2108d578 <__udivsi3>
2109a4dc:	b02c943a 	slli	r22,r22,16
2109a4e0:	1529383a 	mul	r20,r2,r20
2109a4e4:	8c7fffcc 	andi	r17,r17,65535
2109a4e8:	b462b03a 	or	r17,r22,r17
2109a4ec:	8d00052e 	bgeu	r17,r20,2109a504 <__udivdi3+0x130>
2109a4f0:	8ca3883a 	add	r17,r17,r18
2109a4f4:	10ffffc4 	addi	r3,r2,-1
2109a4f8:	8c80f636 	bltu	r17,r18,2109a8d4 <__udivdi3+0x500>
2109a4fc:	8d00f52e 	bgeu	r17,r20,2109a8d4 <__udivdi3+0x500>
2109a500:	10bfff84 	addi	r2,r2,-2
2109a504:	8020943a 	slli	r16,r16,16
2109a508:	0007883a 	mov	r3,zero
2109a50c:	1404b03a 	or	r2,r2,r16
2109a510:	00005b06 	br	2109a680 <__udivdi3+0x2ac>
2109a514:	29c05836 	bltu	r5,r7,2109a678 <__udivdi3+0x2a4>
2109a518:	00bfffd4 	movui	r2,65535
2109a51c:	11c0642e 	bgeu	r2,r7,2109a6b0 <__udivdi3+0x2dc>
2109a520:	00804034 	movhi	r2,256
2109a524:	10bfffc4 	addi	r2,r2,-1
2109a528:	11c0f32e 	bgeu	r2,r7,2109a8f8 <__udivdi3+0x524>
2109a52c:	00c00604 	movi	r3,24
2109a530:	180b883a 	mov	r5,r3
2109a534:	38c6d83a 	srl	r3,r7,r3
2109a538:	00800034 	movhi	r2,0
2109a53c:	108e8904 	addi	r2,r2,14884
2109a540:	10c7883a 	add	r3,r2,r3
2109a544:	18c00003 	ldbu	r3,0(r3)
2109a548:	01000804 	movi	r4,32
2109a54c:	1947883a 	add	r3,r3,r5
2109a550:	20e5c83a 	sub	r18,r4,r3
2109a554:	9000661e 	bne	r18,zero,2109a6f0 <__udivdi3+0x31c>
2109a558:	3c00f936 	bltu	r7,r16,2109a940 <__udivdi3+0x56c>
2109a55c:	9985403a 	cmpgeu	r2,r19,r6
2109a560:	0007883a 	mov	r3,zero
2109a564:	00004606 	br	2109a680 <__udivdi3+0x2ac>
2109a568:	3000041e 	bne	r6,zero,2109a57c <__udivdi3+0x1a8>
2109a56c:	01000044 	movi	r4,1
2109a570:	000b883a 	mov	r5,zero
2109a574:	108d5780 	call	2108d578 <__udivsi3>
2109a578:	1025883a 	mov	r18,r2
2109a57c:	00bfffd4 	movui	r2,65535
2109a580:	1480562e 	bgeu	r2,r18,2109a6dc <__udivdi3+0x308>
2109a584:	00804034 	movhi	r2,256
2109a588:	10bfffc4 	addi	r2,r2,-1
2109a58c:	1480e32e 	bgeu	r2,r18,2109a91c <__udivdi3+0x548>
2109a590:	00800604 	movi	r2,24
2109a594:	1007883a 	mov	r3,r2
2109a598:	9084d83a 	srl	r2,r18,r2
2109a59c:	01000034 	movhi	r4,0
2109a5a0:	210e8904 	addi	r4,r4,14884
2109a5a4:	2085883a 	add	r2,r4,r2
2109a5a8:	10800003 	ldbu	r2,0(r2)
2109a5ac:	10c5883a 	add	r2,r2,r3
2109a5b0:	00c00804 	movi	r3,32
2109a5b4:	1887c83a 	sub	r3,r3,r2
2109a5b8:	1800911e 	bne	r3,zero,2109a800 <__udivdi3+0x42c>
2109a5bc:	9028d43a 	srli	r20,r18,16
2109a5c0:	84a1c83a 	sub	r16,r16,r18
2109a5c4:	957fffcc 	andi	r21,r18,65535
2109a5c8:	00c00044 	movi	r3,1
2109a5cc:	8009883a 	mov	r4,r16
2109a5d0:	a00b883a 	mov	r5,r20
2109a5d4:	d8c00015 	stw	r3,0(sp)
2109a5d8:	108d5800 	call	2108d580 <__umodsi3>
2109a5dc:	8009883a 	mov	r4,r16
2109a5e0:	a00b883a 	mov	r5,r20
2109a5e4:	1027883a 	mov	r19,r2
2109a5e8:	108d5780 	call	2108d578 <__udivsi3>
2109a5ec:	1021883a 	mov	r16,r2
2109a5f0:	880cd43a 	srli	r6,r17,16
2109a5f4:	9804943a 	slli	r2,r19,16
2109a5f8:	8567383a 	mul	r19,r16,r21
2109a5fc:	d8c00017 	ldw	r3,0(sp)
2109a600:	1188b03a 	or	r4,r2,r6
2109a604:	24c0052e 	bgeu	r4,r19,2109a61c <__udivdi3+0x248>
2109a608:	2489883a 	add	r4,r4,r18
2109a60c:	80bfffc4 	addi	r2,r16,-1
2109a610:	24800136 	bltu	r4,r18,2109a618 <__udivdi3+0x244>
2109a614:	24c0d936 	bltu	r4,r19,2109a97c <__udivdi3+0x5a8>
2109a618:	1021883a 	mov	r16,r2
2109a61c:	24e7c83a 	sub	r19,r4,r19
2109a620:	9809883a 	mov	r4,r19
2109a624:	a00b883a 	mov	r5,r20
2109a628:	d8c00015 	stw	r3,0(sp)
2109a62c:	108d5800 	call	2108d580 <__umodsi3>
2109a630:	102d883a 	mov	r22,r2
2109a634:	9809883a 	mov	r4,r19
2109a638:	a00b883a 	mov	r5,r20
2109a63c:	108d5780 	call	2108d578 <__udivsi3>
2109a640:	b02c943a 	slli	r22,r22,16
2109a644:	156b383a 	mul	r21,r2,r21
2109a648:	8c7fffcc 	andi	r17,r17,65535
2109a64c:	b462b03a 	or	r17,r22,r17
2109a650:	d8c00017 	ldw	r3,0(sp)
2109a654:	8d40052e 	bgeu	r17,r21,2109a66c <__udivdi3+0x298>
2109a658:	8ca3883a 	add	r17,r17,r18
2109a65c:	113fffc4 	addi	r4,r2,-1
2109a660:	8c809a36 	bltu	r17,r18,2109a8cc <__udivdi3+0x4f8>
2109a664:	8d40992e 	bgeu	r17,r21,2109a8cc <__udivdi3+0x4f8>
2109a668:	10bfff84 	addi	r2,r2,-2
2109a66c:	8020943a 	slli	r16,r16,16
2109a670:	1404b03a 	or	r2,r2,r16
2109a674:	00000206 	br	2109a680 <__udivdi3+0x2ac>
2109a678:	0007883a 	mov	r3,zero
2109a67c:	0005883a 	mov	r2,zero
2109a680:	dfc00a17 	ldw	ra,40(sp)
2109a684:	df000917 	ldw	fp,36(sp)
2109a688:	ddc00817 	ldw	r23,32(sp)
2109a68c:	dd800717 	ldw	r22,28(sp)
2109a690:	dd400617 	ldw	r21,24(sp)
2109a694:	dd000517 	ldw	r20,20(sp)
2109a698:	dcc00417 	ldw	r19,16(sp)
2109a69c:	dc800317 	ldw	r18,12(sp)
2109a6a0:	dc400217 	ldw	r17,8(sp)
2109a6a4:	dc000117 	ldw	r16,4(sp)
2109a6a8:	dec00b04 	addi	sp,sp,44
2109a6ac:	f800283a 	ret
2109a6b0:	00803fc4 	movi	r2,255
2109a6b4:	11c0932e 	bgeu	r2,r7,2109a904 <__udivdi3+0x530>
2109a6b8:	00c00204 	movi	r3,8
2109a6bc:	180b883a 	mov	r5,r3
2109a6c0:	003f9c06 	br	2109a534 <__flash_rwdata_start+0xffff82ec>
2109a6c4:	00804034 	movhi	r2,256
2109a6c8:	10bfffc4 	addi	r2,r2,-1
2109a6cc:	1180902e 	bgeu	r2,r6,2109a910 <__udivdi3+0x53c>
2109a6d0:	00800604 	movi	r2,24
2109a6d4:	1007883a 	mov	r3,r2
2109a6d8:	003f5606 	br	2109a434 <__flash_rwdata_start+0xffff81ec>
2109a6dc:	00803fc4 	movi	r2,255
2109a6e0:	1480912e 	bgeu	r2,r18,2109a928 <__udivdi3+0x554>
2109a6e4:	00800204 	movi	r2,8
2109a6e8:	1007883a 	mov	r3,r2
2109a6ec:	003faa06 	br	2109a598 <__flash_rwdata_start+0xffff8350>
2109a6f0:	30eed83a 	srl	r23,r6,r3
2109a6f4:	3c8e983a 	sll	r7,r7,r18
2109a6f8:	80f8d83a 	srl	fp,r16,r3
2109a6fc:	98c6d83a 	srl	r3,r19,r3
2109a700:	3deeb03a 	or	r23,r7,r23
2109a704:	b828d43a 	srli	r20,r23,16
2109a708:	84a0983a 	sll	r16,r16,r18
2109a70c:	e009883a 	mov	r4,fp
2109a710:	a00b883a 	mov	r5,r20
2109a714:	80e2b03a 	or	r17,r16,r3
2109a718:	34aa983a 	sll	r21,r6,r18
2109a71c:	108d5800 	call	2108d580 <__umodsi3>
2109a720:	e009883a 	mov	r4,fp
2109a724:	a00b883a 	mov	r5,r20
2109a728:	102d883a 	mov	r22,r2
2109a72c:	108d5780 	call	2108d578 <__udivsi3>
2109a730:	1021883a 	mov	r16,r2
2109a734:	bf3fffcc 	andi	fp,r23,65535
2109a738:	b004943a 	slli	r2,r22,16
2109a73c:	8808d43a 	srli	r4,r17,16
2109a740:	872d383a 	mul	r22,r16,fp
2109a744:	1104b03a 	or	r2,r2,r4
2109a748:	1580042e 	bgeu	r2,r22,2109a75c <__udivdi3+0x388>
2109a74c:	15c5883a 	add	r2,r2,r23
2109a750:	80ffffc4 	addi	r3,r16,-1
2109a754:	15c0812e 	bgeu	r2,r23,2109a95c <__udivdi3+0x588>
2109a758:	1821883a 	mov	r16,r3
2109a75c:	15adc83a 	sub	r22,r2,r22
2109a760:	b009883a 	mov	r4,r22
2109a764:	a00b883a 	mov	r5,r20
2109a768:	108d5800 	call	2108d580 <__umodsi3>
2109a76c:	a00b883a 	mov	r5,r20
2109a770:	b009883a 	mov	r4,r22
2109a774:	d8800015 	stw	r2,0(sp)
2109a778:	108d5780 	call	2108d578 <__udivsi3>
2109a77c:	d8c00017 	ldw	r3,0(sp)
2109a780:	170b383a 	mul	r5,r2,fp
2109a784:	8c7fffcc 	andi	r17,r17,65535
2109a788:	1806943a 	slli	r3,r3,16
2109a78c:	1c46b03a 	or	r3,r3,r17
2109a790:	1940042e 	bgeu	r3,r5,2109a7a4 <__udivdi3+0x3d0>
2109a794:	1dc7883a 	add	r3,r3,r23
2109a798:	113fffc4 	addi	r4,r2,-1
2109a79c:	1dc06b2e 	bgeu	r3,r23,2109a94c <__udivdi3+0x578>
2109a7a0:	2005883a 	mov	r2,r4
2109a7a4:	8020943a 	slli	r16,r16,16
2109a7a8:	a9ffffcc 	andi	r7,r21,65535
2109a7ac:	a82ad43a 	srli	r21,r21,16
2109a7b0:	1404b03a 	or	r2,r2,r16
2109a7b4:	113fffcc 	andi	r4,r2,65535
2109a7b8:	100cd43a 	srli	r6,r2,16
2109a7bc:	21d3383a 	mul	r9,r4,r7
2109a7c0:	2549383a 	mul	r4,r4,r21
2109a7c4:	31cf383a 	mul	r7,r6,r7
2109a7c8:	4810d43a 	srli	r8,r9,16
2109a7cc:	1947c83a 	sub	r3,r3,r5
2109a7d0:	3909883a 	add	r4,r7,r4
2109a7d4:	2209883a 	add	r4,r4,r8
2109a7d8:	354d383a 	mul	r6,r6,r21
2109a7dc:	21c0022e 	bgeu	r4,r7,2109a7e8 <__udivdi3+0x414>
2109a7e0:	01400074 	movhi	r5,1
2109a7e4:	314d883a 	add	r6,r6,r5
2109a7e8:	202ad43a 	srli	r21,r4,16
2109a7ec:	354d883a 	add	r6,r6,r21
2109a7f0:	19803f36 	bltu	r3,r6,2109a8f0 <__udivdi3+0x51c>
2109a7f4:	19803926 	beq	r3,r6,2109a8dc <__udivdi3+0x508>
2109a7f8:	0007883a 	mov	r3,zero
2109a7fc:	003fa006 	br	2109a680 <__flash_rwdata_start+0xffff8438>
2109a800:	90e4983a 	sll	r18,r18,r3
2109a804:	80aad83a 	srl	r21,r16,r2
2109a808:	80e0983a 	sll	r16,r16,r3
2109a80c:	9028d43a 	srli	r20,r18,16
2109a810:	9884d83a 	srl	r2,r19,r2
2109a814:	a809883a 	mov	r4,r21
2109a818:	a00b883a 	mov	r5,r20
2109a81c:	80acb03a 	or	r22,r16,r2
2109a820:	98e2983a 	sll	r17,r19,r3
2109a824:	108d5800 	call	2108d580 <__umodsi3>
2109a828:	a809883a 	mov	r4,r21
2109a82c:	a00b883a 	mov	r5,r20
2109a830:	1021883a 	mov	r16,r2
2109a834:	108d5780 	call	2108d578 <__udivsi3>
2109a838:	957fffcc 	andi	r21,r18,65535
2109a83c:	8020943a 	slli	r16,r16,16
2109a840:	b00ad43a 	srli	r5,r22,16
2109a844:	1567383a 	mul	r19,r2,r21
2109a848:	102f883a 	mov	r23,r2
2109a84c:	8148b03a 	or	r4,r16,r5
2109a850:	24c0062e 	bgeu	r4,r19,2109a86c <__udivdi3+0x498>
2109a854:	2489883a 	add	r4,r4,r18
2109a858:	10bfffc4 	addi	r2,r2,-1
2109a85c:	24804536 	bltu	r4,r18,2109a974 <__udivdi3+0x5a0>
2109a860:	24c0442e 	bgeu	r4,r19,2109a974 <__udivdi3+0x5a0>
2109a864:	bdffff84 	addi	r23,r23,-2
2109a868:	2489883a 	add	r4,r4,r18
2109a86c:	24e7c83a 	sub	r19,r4,r19
2109a870:	9809883a 	mov	r4,r19
2109a874:	a00b883a 	mov	r5,r20
2109a878:	108d5800 	call	2108d580 <__umodsi3>
2109a87c:	1021883a 	mov	r16,r2
2109a880:	9809883a 	mov	r4,r19
2109a884:	a00b883a 	mov	r5,r20
2109a888:	108d5780 	call	2108d578 <__udivsi3>
2109a88c:	8020943a 	slli	r16,r16,16
2109a890:	1007883a 	mov	r3,r2
2109a894:	1545383a 	mul	r2,r2,r21
2109a898:	b13fffcc 	andi	r4,r22,65535
2109a89c:	8108b03a 	or	r4,r16,r4
2109a8a0:	2080062e 	bgeu	r4,r2,2109a8bc <__udivdi3+0x4e8>
2109a8a4:	2489883a 	add	r4,r4,r18
2109a8a8:	197fffc4 	addi	r5,r3,-1
2109a8ac:	24802f36 	bltu	r4,r18,2109a96c <__udivdi3+0x598>
2109a8b0:	20802e2e 	bgeu	r4,r2,2109a96c <__udivdi3+0x598>
2109a8b4:	18ffff84 	addi	r3,r3,-2
2109a8b8:	2489883a 	add	r4,r4,r18
2109a8bc:	b82e943a 	slli	r23,r23,16
2109a8c0:	20a1c83a 	sub	r16,r4,r2
2109a8c4:	1dc6b03a 	or	r3,r3,r23
2109a8c8:	003f4006 	br	2109a5cc <__flash_rwdata_start+0xffff8384>
2109a8cc:	2005883a 	mov	r2,r4
2109a8d0:	003f6606 	br	2109a66c <__flash_rwdata_start+0xffff8424>
2109a8d4:	1805883a 	mov	r2,r3
2109a8d8:	003f0a06 	br	2109a504 <__flash_rwdata_start+0xffff82bc>
2109a8dc:	2006943a 	slli	r3,r4,16
2109a8e0:	9c88983a 	sll	r4,r19,r18
2109a8e4:	4a7fffcc 	andi	r9,r9,65535
2109a8e8:	1a47883a 	add	r3,r3,r9
2109a8ec:	20ffc22e 	bgeu	r4,r3,2109a7f8 <__flash_rwdata_start+0xffff85b0>
2109a8f0:	10bfffc4 	addi	r2,r2,-1
2109a8f4:	003fc006 	br	2109a7f8 <__flash_rwdata_start+0xffff85b0>
2109a8f8:	00c00404 	movi	r3,16
2109a8fc:	180b883a 	mov	r5,r3
2109a900:	003f0c06 	br	2109a534 <__flash_rwdata_start+0xffff82ec>
2109a904:	0007883a 	mov	r3,zero
2109a908:	000b883a 	mov	r5,zero
2109a90c:	003f0906 	br	2109a534 <__flash_rwdata_start+0xffff82ec>
2109a910:	00800404 	movi	r2,16
2109a914:	1007883a 	mov	r3,r2
2109a918:	003ec606 	br	2109a434 <__flash_rwdata_start+0xffff81ec>
2109a91c:	00800404 	movi	r2,16
2109a920:	1007883a 	mov	r3,r2
2109a924:	003f1c06 	br	2109a598 <__flash_rwdata_start+0xffff8350>
2109a928:	0005883a 	mov	r2,zero
2109a92c:	0007883a 	mov	r3,zero
2109a930:	003f1906 	br	2109a598 <__flash_rwdata_start+0xffff8350>
2109a934:	0005883a 	mov	r2,zero
2109a938:	0007883a 	mov	r3,zero
2109a93c:	003ebd06 	br	2109a434 <__flash_rwdata_start+0xffff81ec>
2109a940:	0007883a 	mov	r3,zero
2109a944:	00800044 	movi	r2,1
2109a948:	003f4d06 	br	2109a680 <__flash_rwdata_start+0xffff8438>
2109a94c:	197f942e 	bgeu	r3,r5,2109a7a0 <__flash_rwdata_start+0xffff8558>
2109a950:	10bfff84 	addi	r2,r2,-2
2109a954:	1dc7883a 	add	r3,r3,r23
2109a958:	003f9206 	br	2109a7a4 <__flash_rwdata_start+0xffff855c>
2109a95c:	15bf7e2e 	bgeu	r2,r22,2109a758 <__flash_rwdata_start+0xffff8510>
2109a960:	843fff84 	addi	r16,r16,-2
2109a964:	15c5883a 	add	r2,r2,r23
2109a968:	003f7c06 	br	2109a75c <__flash_rwdata_start+0xffff8514>
2109a96c:	2807883a 	mov	r3,r5
2109a970:	003fd206 	br	2109a8bc <__flash_rwdata_start+0xffff8674>
2109a974:	102f883a 	mov	r23,r2
2109a978:	003fbc06 	br	2109a86c <__flash_rwdata_start+0xffff8624>
2109a97c:	843fff84 	addi	r16,r16,-2
2109a980:	2489883a 	add	r4,r4,r18
2109a984:	003f2506 	br	2109a61c <__flash_rwdata_start+0xffff83d4>
2109a988:	843fff84 	addi	r16,r16,-2
2109a98c:	1485883a 	add	r2,r2,r18
2109a990:	003eca06 	br	2109a4bc <__flash_rwdata_start+0xffff8274>

2109a994 <__umoddi3>:
2109a994:	defff404 	addi	sp,sp,-48
2109a998:	ddc00915 	stw	r23,36(sp)
2109a99c:	dc400315 	stw	r17,12(sp)
2109a9a0:	dc000215 	stw	r16,8(sp)
2109a9a4:	dfc00b15 	stw	ra,44(sp)
2109a9a8:	df000a15 	stw	fp,40(sp)
2109a9ac:	dd800815 	stw	r22,32(sp)
2109a9b0:	dd400715 	stw	r21,28(sp)
2109a9b4:	dd000615 	stw	r20,24(sp)
2109a9b8:	dcc00515 	stw	r19,20(sp)
2109a9bc:	dc800415 	stw	r18,16(sp)
2109a9c0:	2021883a 	mov	r16,r4
2109a9c4:	2823883a 	mov	r17,r5
2109a9c8:	282f883a 	mov	r23,r5
2109a9cc:	3800381e 	bne	r7,zero,2109aab0 <__umoddi3+0x11c>
2109a9d0:	3027883a 	mov	r19,r6
2109a9d4:	2029883a 	mov	r20,r4
2109a9d8:	29804e2e 	bgeu	r5,r6,2109ab14 <__umoddi3+0x180>
2109a9dc:	00bfffd4 	movui	r2,65535
2109a9e0:	11809c36 	bltu	r2,r6,2109ac54 <__umoddi3+0x2c0>
2109a9e4:	00803fc4 	movi	r2,255
2109a9e8:	11813b2e 	bgeu	r2,r6,2109aed8 <__umoddi3+0x544>
2109a9ec:	01400204 	movi	r5,8
2109a9f0:	2805883a 	mov	r2,r5
2109a9f4:	314ad83a 	srl	r5,r6,r5
2109a9f8:	00c00034 	movhi	r3,0
2109a9fc:	18ce8904 	addi	r3,r3,14884
2109aa00:	194b883a 	add	r5,r3,r5
2109aa04:	29000003 	ldbu	r4,0(r5)
2109aa08:	2089883a 	add	r4,r4,r2
2109aa0c:	00800804 	movi	r2,32
2109aa10:	1105c83a 	sub	r2,r2,r4
2109aa14:	1000ec26 	beq	r2,zero,2109adc8 <__umoddi3+0x434>
2109aa18:	88a2983a 	sll	r17,r17,r2
2109aa1c:	8108d83a 	srl	r4,r16,r4
2109aa20:	30a6983a 	sll	r19,r6,r2
2109aa24:	80a8983a 	sll	r20,r16,r2
2109aa28:	1025883a 	mov	r18,r2
2109aa2c:	892eb03a 	or	r23,r17,r4
2109aa30:	982cd43a 	srli	r22,r19,16
2109aa34:	b809883a 	mov	r4,r23
2109aa38:	9d7fffcc 	andi	r21,r19,65535
2109aa3c:	b00b883a 	mov	r5,r22
2109aa40:	108d5800 	call	2108d580 <__umodsi3>
2109aa44:	b809883a 	mov	r4,r23
2109aa48:	b00b883a 	mov	r5,r22
2109aa4c:	1021883a 	mov	r16,r2
2109aa50:	108d5780 	call	2108d578 <__udivsi3>
2109aa54:	8020943a 	slli	r16,r16,16
2109aa58:	a00cd43a 	srli	r6,r20,16
2109aa5c:	1545383a 	mul	r2,r2,r21
2109aa60:	8188b03a 	or	r4,r16,r6
2109aa64:	2080042e 	bgeu	r4,r2,2109aa78 <__umoddi3+0xe4>
2109aa68:	24c9883a 	add	r4,r4,r19
2109aa6c:	24c00236 	bltu	r4,r19,2109aa78 <__umoddi3+0xe4>
2109aa70:	2080012e 	bgeu	r4,r2,2109aa78 <__umoddi3+0xe4>
2109aa74:	24c9883a 	add	r4,r4,r19
2109aa78:	20a3c83a 	sub	r17,r4,r2
2109aa7c:	8809883a 	mov	r4,r17
2109aa80:	b00b883a 	mov	r5,r22
2109aa84:	108d5800 	call	2108d580 <__umodsi3>
2109aa88:	8809883a 	mov	r4,r17
2109aa8c:	b00b883a 	mov	r5,r22
2109aa90:	1021883a 	mov	r16,r2
2109aa94:	108d5780 	call	2108d578 <__udivsi3>
2109aa98:	8006943a 	slli	r3,r16,16
2109aa9c:	1545383a 	mul	r2,r2,r21
2109aaa0:	a13fffcc 	andi	r4,r20,65535
2109aaa4:	1906b03a 	or	r3,r3,r4
2109aaa8:	1880532e 	bgeu	r3,r2,2109abf8 <__umoddi3+0x264>
2109aaac:	00004e06 	br	2109abe8 <__umoddi3+0x254>
2109aab0:	29c05536 	bltu	r5,r7,2109ac08 <__umoddi3+0x274>
2109aab4:	00bfffd4 	movui	r2,65535
2109aab8:	11c0612e 	bgeu	r2,r7,2109ac40 <__umoddi3+0x2ac>
2109aabc:	00804034 	movhi	r2,256
2109aac0:	10bfffc4 	addi	r2,r2,-1
2109aac4:	11c0f82e 	bgeu	r2,r7,2109aea8 <__umoddi3+0x514>
2109aac8:	01400604 	movi	r5,24
2109aacc:	282b883a 	mov	r21,r5
2109aad0:	394ad83a 	srl	r5,r7,r5
2109aad4:	00c00034 	movhi	r3,0
2109aad8:	18ce8904 	addi	r3,r3,14884
2109aadc:	194b883a 	add	r5,r3,r5
2109aae0:	28800003 	ldbu	r2,0(r5)
2109aae4:	00c00804 	movi	r3,32
2109aae8:	156b883a 	add	r21,r2,r21
2109aaec:	1d69c83a 	sub	r20,r3,r21
2109aaf0:	a000631e 	bne	r20,zero,2109ac80 <__umoddi3+0x2ec>
2109aaf4:	3c400136 	bltu	r7,r17,2109aafc <__umoddi3+0x168>
2109aaf8:	81810436 	bltu	r16,r6,2109af0c <__umoddi3+0x578>
2109aafc:	8185c83a 	sub	r2,r16,r6
2109ab00:	89e3c83a 	sub	r17,r17,r7
2109ab04:	8087803a 	cmpltu	r3,r16,r2
2109ab08:	88efc83a 	sub	r23,r17,r3
2109ab0c:	b807883a 	mov	r3,r23
2109ab10:	00003f06 	br	2109ac10 <__umoddi3+0x27c>
2109ab14:	3000041e 	bne	r6,zero,2109ab28 <__umoddi3+0x194>
2109ab18:	01000044 	movi	r4,1
2109ab1c:	000b883a 	mov	r5,zero
2109ab20:	108d5780 	call	2108d578 <__udivsi3>
2109ab24:	1027883a 	mov	r19,r2
2109ab28:	00bfffd4 	movui	r2,65535
2109ab2c:	14c04f2e 	bgeu	r2,r19,2109ac6c <__umoddi3+0x2d8>
2109ab30:	00804034 	movhi	r2,256
2109ab34:	10bfffc4 	addi	r2,r2,-1
2109ab38:	14c0e42e 	bgeu	r2,r19,2109aecc <__umoddi3+0x538>
2109ab3c:	00800604 	movi	r2,24
2109ab40:	1007883a 	mov	r3,r2
2109ab44:	9884d83a 	srl	r2,r19,r2
2109ab48:	01000034 	movhi	r4,0
2109ab4c:	210e8904 	addi	r4,r4,14884
2109ab50:	2085883a 	add	r2,r4,r2
2109ab54:	11000003 	ldbu	r4,0(r2)
2109ab58:	00800804 	movi	r2,32
2109ab5c:	20c7883a 	add	r3,r4,r3
2109ab60:	10c5c83a 	sub	r2,r2,r3
2109ab64:	10009a1e 	bne	r2,zero,2109add0 <__umoddi3+0x43c>
2109ab68:	982cd43a 	srli	r22,r19,16
2109ab6c:	8ce3c83a 	sub	r17,r17,r19
2109ab70:	9c3fffcc 	andi	r16,r19,65535
2109ab74:	0025883a 	mov	r18,zero
2109ab78:	8809883a 	mov	r4,r17
2109ab7c:	b00b883a 	mov	r5,r22
2109ab80:	108d5800 	call	2108d580 <__umodsi3>
2109ab84:	8809883a 	mov	r4,r17
2109ab88:	b00b883a 	mov	r5,r22
2109ab8c:	102b883a 	mov	r21,r2
2109ab90:	108d5780 	call	2108d578 <__udivsi3>
2109ab94:	a806943a 	slli	r3,r21,16
2109ab98:	a008d43a 	srli	r4,r20,16
2109ab9c:	1405383a 	mul	r2,r2,r16
2109aba0:	190cb03a 	or	r6,r3,r4
2109aba4:	3080032e 	bgeu	r6,r2,2109abb4 <__umoddi3+0x220>
2109aba8:	34cd883a 	add	r6,r6,r19
2109abac:	34c00136 	bltu	r6,r19,2109abb4 <__umoddi3+0x220>
2109abb0:	3080d436 	bltu	r6,r2,2109af04 <__umoddi3+0x570>
2109abb4:	30abc83a 	sub	r21,r6,r2
2109abb8:	a809883a 	mov	r4,r21
2109abbc:	b00b883a 	mov	r5,r22
2109abc0:	108d5800 	call	2108d580 <__umodsi3>
2109abc4:	1023883a 	mov	r17,r2
2109abc8:	a809883a 	mov	r4,r21
2109abcc:	b00b883a 	mov	r5,r22
2109abd0:	108d5780 	call	2108d578 <__udivsi3>
2109abd4:	8822943a 	slli	r17,r17,16
2109abd8:	1405383a 	mul	r2,r2,r16
2109abdc:	a13fffcc 	andi	r4,r20,65535
2109abe0:	8906b03a 	or	r3,r17,r4
2109abe4:	1880042e 	bgeu	r3,r2,2109abf8 <__umoddi3+0x264>
2109abe8:	1cc7883a 	add	r3,r3,r19
2109abec:	1cc00236 	bltu	r3,r19,2109abf8 <__umoddi3+0x264>
2109abf0:	1880012e 	bgeu	r3,r2,2109abf8 <__umoddi3+0x264>
2109abf4:	1cc7883a 	add	r3,r3,r19
2109abf8:	1887c83a 	sub	r3,r3,r2
2109abfc:	1c84d83a 	srl	r2,r3,r18
2109ac00:	0007883a 	mov	r3,zero
2109ac04:	00000206 	br	2109ac10 <__umoddi3+0x27c>
2109ac08:	2005883a 	mov	r2,r4
2109ac0c:	2807883a 	mov	r3,r5
2109ac10:	dfc00b17 	ldw	ra,44(sp)
2109ac14:	df000a17 	ldw	fp,40(sp)
2109ac18:	ddc00917 	ldw	r23,36(sp)
2109ac1c:	dd800817 	ldw	r22,32(sp)
2109ac20:	dd400717 	ldw	r21,28(sp)
2109ac24:	dd000617 	ldw	r20,24(sp)
2109ac28:	dcc00517 	ldw	r19,20(sp)
2109ac2c:	dc800417 	ldw	r18,16(sp)
2109ac30:	dc400317 	ldw	r17,12(sp)
2109ac34:	dc000217 	ldw	r16,8(sp)
2109ac38:	dec00c04 	addi	sp,sp,48
2109ac3c:	f800283a 	ret
2109ac40:	00803fc4 	movi	r2,255
2109ac44:	11c0952e 	bgeu	r2,r7,2109ae9c <__umoddi3+0x508>
2109ac48:	01400204 	movi	r5,8
2109ac4c:	282b883a 	mov	r21,r5
2109ac50:	003f9f06 	br	2109aad0 <__flash_rwdata_start+0xffff8888>
2109ac54:	00804034 	movhi	r2,256
2109ac58:	10bfffc4 	addi	r2,r2,-1
2109ac5c:	1180952e 	bgeu	r2,r6,2109aeb4 <__umoddi3+0x520>
2109ac60:	01400604 	movi	r5,24
2109ac64:	2805883a 	mov	r2,r5
2109ac68:	003f6206 	br	2109a9f4 <__flash_rwdata_start+0xffff87ac>
2109ac6c:	00803fc4 	movi	r2,255
2109ac70:	14c0932e 	bgeu	r2,r19,2109aec0 <__umoddi3+0x52c>
2109ac74:	00800204 	movi	r2,8
2109ac78:	1007883a 	mov	r3,r2
2109ac7c:	003fb106 	br	2109ab44 <__flash_rwdata_start+0xffff88fc>
2109ac80:	3548d83a 	srl	r4,r6,r21
2109ac84:	3d0e983a 	sll	r7,r7,r20
2109ac88:	8d10983a 	sll	r8,r17,r20
2109ac8c:	8d6cd83a 	srl	r22,r17,r21
2109ac90:	3922b03a 	or	r17,r7,r4
2109ac94:	882ed43a 	srli	r23,r17,16
2109ac98:	8564d83a 	srl	r18,r16,r21
2109ac9c:	b009883a 	mov	r4,r22
2109aca0:	b80b883a 	mov	r5,r23
2109aca4:	44a4b03a 	or	r18,r8,r18
2109aca8:	3526983a 	sll	r19,r6,r20
2109acac:	108d5800 	call	2108d580 <__umodsi3>
2109acb0:	b009883a 	mov	r4,r22
2109acb4:	b80b883a 	mov	r5,r23
2109acb8:	1039883a 	mov	fp,r2
2109acbc:	108d5780 	call	2108d578 <__udivsi3>
2109acc0:	102d883a 	mov	r22,r2
2109acc4:	8a3fffcc 	andi	r8,r17,65535
2109acc8:	e004943a 	slli	r2,fp,16
2109accc:	900cd43a 	srli	r6,r18,16
2109acd0:	b239383a 	mul	fp,r22,r8
2109acd4:	8520983a 	sll	r16,r16,r20
2109acd8:	118ab03a 	or	r5,r2,r6
2109acdc:	2f00042e 	bgeu	r5,fp,2109acf0 <__umoddi3+0x35c>
2109ace0:	2c4b883a 	add	r5,r5,r17
2109ace4:	b0bfffc4 	addi	r2,r22,-1
2109ace8:	2c40822e 	bgeu	r5,r17,2109aef4 <__umoddi3+0x560>
2109acec:	102d883a 	mov	r22,r2
2109acf0:	2f39c83a 	sub	fp,r5,fp
2109acf4:	e009883a 	mov	r4,fp
2109acf8:	b80b883a 	mov	r5,r23
2109acfc:	da000115 	stw	r8,4(sp)
2109ad00:	108d5800 	call	2108d580 <__umodsi3>
2109ad04:	e009883a 	mov	r4,fp
2109ad08:	b80b883a 	mov	r5,r23
2109ad0c:	d8800015 	stw	r2,0(sp)
2109ad10:	108d5780 	call	2108d578 <__udivsi3>
2109ad14:	d9800017 	ldw	r6,0(sp)
2109ad18:	da000117 	ldw	r8,4(sp)
2109ad1c:	94bfffcc 	andi	r18,r18,65535
2109ad20:	300c943a 	slli	r6,r6,16
2109ad24:	1209383a 	mul	r4,r2,r8
2109ad28:	3490b03a 	or	r8,r6,r18
2109ad2c:	4100042e 	bgeu	r8,r4,2109ad40 <__umoddi3+0x3ac>
2109ad30:	4451883a 	add	r8,r8,r17
2109ad34:	10ffffc4 	addi	r3,r2,-1
2109ad38:	44406a2e 	bgeu	r8,r17,2109aee4 <__umoddi3+0x550>
2109ad3c:	1805883a 	mov	r2,r3
2109ad40:	b012943a 	slli	r9,r22,16
2109ad44:	9abfffcc 	andi	r10,r19,65535
2109ad48:	980ed43a 	srli	r7,r19,16
2109ad4c:	124ab03a 	or	r5,r2,r9
2109ad50:	2a7fffcc 	andi	r9,r5,65535
2109ad54:	280ad43a 	srli	r5,r5,16
2109ad58:	4a8d383a 	mul	r6,r9,r10
2109ad5c:	49d3383a 	mul	r9,r9,r7
2109ad60:	2a95383a 	mul	r10,r5,r10
2109ad64:	3004d43a 	srli	r2,r6,16
2109ad68:	4111c83a 	sub	r8,r8,r4
2109ad6c:	5253883a 	add	r9,r10,r9
2109ad70:	4893883a 	add	r9,r9,r2
2109ad74:	29cb383a 	mul	r5,r5,r7
2109ad78:	4a80022e 	bgeu	r9,r10,2109ad84 <__umoddi3+0x3f0>
2109ad7c:	00800074 	movhi	r2,1
2109ad80:	288b883a 	add	r5,r5,r2
2109ad84:	4808d43a 	srli	r4,r9,16
2109ad88:	4812943a 	slli	r9,r9,16
2109ad8c:	31bfffcc 	andi	r6,r6,65535
2109ad90:	290b883a 	add	r5,r5,r4
2109ad94:	498d883a 	add	r6,r9,r6
2109ad98:	41403a36 	bltu	r8,r5,2109ae84 <__umoddi3+0x4f0>
2109ad9c:	41405d26 	beq	r8,r5,2109af14 <__umoddi3+0x580>
2109ada0:	4149c83a 	sub	r4,r8,r5
2109ada4:	300f883a 	mov	r7,r6
2109ada8:	81cfc83a 	sub	r7,r16,r7
2109adac:	81c7803a 	cmpltu	r3,r16,r7
2109adb0:	20c7c83a 	sub	r3,r4,r3
2109adb4:	1d44983a 	sll	r2,r3,r21
2109adb8:	3d0ed83a 	srl	r7,r7,r20
2109adbc:	1d06d83a 	srl	r3,r3,r20
2109adc0:	11c4b03a 	or	r2,r2,r7
2109adc4:	003f9206 	br	2109ac10 <__flash_rwdata_start+0xffff89c8>
2109adc8:	0025883a 	mov	r18,zero
2109adcc:	003f1806 	br	2109aa30 <__flash_rwdata_start+0xffff87e8>
2109add0:	98a6983a 	sll	r19,r19,r2
2109add4:	88e8d83a 	srl	r20,r17,r3
2109add8:	80c6d83a 	srl	r3,r16,r3
2109addc:	982cd43a 	srli	r22,r19,16
2109ade0:	88a2983a 	sll	r17,r17,r2
2109ade4:	a009883a 	mov	r4,r20
2109ade8:	b00b883a 	mov	r5,r22
2109adec:	88eab03a 	or	r21,r17,r3
2109adf0:	1025883a 	mov	r18,r2
2109adf4:	108d5800 	call	2108d580 <__umodsi3>
2109adf8:	a009883a 	mov	r4,r20
2109adfc:	b00b883a 	mov	r5,r22
2109ae00:	1023883a 	mov	r17,r2
2109ae04:	108d5780 	call	2108d578 <__udivsi3>
2109ae08:	9f3fffcc 	andi	fp,r19,65535
2109ae0c:	8822943a 	slli	r17,r17,16
2109ae10:	a80ad43a 	srli	r5,r21,16
2109ae14:	1705383a 	mul	r2,r2,fp
2109ae18:	84a8983a 	sll	r20,r16,r18
2109ae1c:	8948b03a 	or	r4,r17,r5
2109ae20:	2080042e 	bgeu	r4,r2,2109ae34 <__umoddi3+0x4a0>
2109ae24:	24c9883a 	add	r4,r4,r19
2109ae28:	24c00236 	bltu	r4,r19,2109ae34 <__umoddi3+0x4a0>
2109ae2c:	2080012e 	bgeu	r4,r2,2109ae34 <__umoddi3+0x4a0>
2109ae30:	24c9883a 	add	r4,r4,r19
2109ae34:	20afc83a 	sub	r23,r4,r2
2109ae38:	b809883a 	mov	r4,r23
2109ae3c:	b00b883a 	mov	r5,r22
2109ae40:	108d5800 	call	2108d580 <__umodsi3>
2109ae44:	1023883a 	mov	r17,r2
2109ae48:	b809883a 	mov	r4,r23
2109ae4c:	b00b883a 	mov	r5,r22
2109ae50:	108d5780 	call	2108d578 <__udivsi3>
2109ae54:	8822943a 	slli	r17,r17,16
2109ae58:	1705383a 	mul	r2,r2,fp
2109ae5c:	a93fffcc 	andi	r4,r21,65535
2109ae60:	8908b03a 	or	r4,r17,r4
2109ae64:	2080042e 	bgeu	r4,r2,2109ae78 <__umoddi3+0x4e4>
2109ae68:	24c9883a 	add	r4,r4,r19
2109ae6c:	24c00236 	bltu	r4,r19,2109ae78 <__umoddi3+0x4e4>
2109ae70:	2080012e 	bgeu	r4,r2,2109ae78 <__umoddi3+0x4e4>
2109ae74:	24c9883a 	add	r4,r4,r19
2109ae78:	20a3c83a 	sub	r17,r4,r2
2109ae7c:	e021883a 	mov	r16,fp
2109ae80:	003f3d06 	br	2109ab78 <__flash_rwdata_start+0xffff8930>
2109ae84:	34cfc83a 	sub	r7,r6,r19
2109ae88:	2c4bc83a 	sub	r5,r5,r17
2109ae8c:	31cd803a 	cmpltu	r6,r6,r7
2109ae90:	298dc83a 	sub	r6,r5,r6
2109ae94:	4189c83a 	sub	r4,r8,r6
2109ae98:	003fc306 	br	2109ada8 <__flash_rwdata_start+0xffff8b60>
2109ae9c:	000b883a 	mov	r5,zero
2109aea0:	002b883a 	mov	r21,zero
2109aea4:	003f0a06 	br	2109aad0 <__flash_rwdata_start+0xffff8888>
2109aea8:	01400404 	movi	r5,16
2109aeac:	282b883a 	mov	r21,r5
2109aeb0:	003f0706 	br	2109aad0 <__flash_rwdata_start+0xffff8888>
2109aeb4:	01400404 	movi	r5,16
2109aeb8:	2805883a 	mov	r2,r5
2109aebc:	003ecd06 	br	2109a9f4 <__flash_rwdata_start+0xffff87ac>
2109aec0:	0005883a 	mov	r2,zero
2109aec4:	0007883a 	mov	r3,zero
2109aec8:	003f1e06 	br	2109ab44 <__flash_rwdata_start+0xffff88fc>
2109aecc:	00800404 	movi	r2,16
2109aed0:	1007883a 	mov	r3,r2
2109aed4:	003f1b06 	br	2109ab44 <__flash_rwdata_start+0xffff88fc>
2109aed8:	000b883a 	mov	r5,zero
2109aedc:	0005883a 	mov	r2,zero
2109aee0:	003ec406 	br	2109a9f4 <__flash_rwdata_start+0xffff87ac>
2109aee4:	413f952e 	bgeu	r8,r4,2109ad3c <__flash_rwdata_start+0xffff8af4>
2109aee8:	10bfff84 	addi	r2,r2,-2
2109aeec:	4451883a 	add	r8,r8,r17
2109aef0:	003f9306 	br	2109ad40 <__flash_rwdata_start+0xffff8af8>
2109aef4:	2f3f7d2e 	bgeu	r5,fp,2109acec <__flash_rwdata_start+0xffff8aa4>
2109aef8:	b5bfff84 	addi	r22,r22,-2
2109aefc:	2c4b883a 	add	r5,r5,r17
2109af00:	003f7b06 	br	2109acf0 <__flash_rwdata_start+0xffff8aa8>
2109af04:	34cd883a 	add	r6,r6,r19
2109af08:	003f2a06 	br	2109abb4 <__flash_rwdata_start+0xffff896c>
2109af0c:	8005883a 	mov	r2,r16
2109af10:	003efe06 	br	2109ab0c <__flash_rwdata_start+0xffff88c4>
2109af14:	81bfdb36 	bltu	r16,r6,2109ae84 <__flash_rwdata_start+0xffff8c3c>
2109af18:	300f883a 	mov	r7,r6
2109af1c:	0009883a 	mov	r4,zero
2109af20:	003fa106 	br	2109ada8 <__flash_rwdata_start+0xffff8b60>

2109af24 <__eqdf2>:
2109af24:	2804d53a 	srli	r2,r5,20
2109af28:	3806d53a 	srli	r3,r7,20
2109af2c:	02000434 	movhi	r8,16
2109af30:	423fffc4 	addi	r8,r8,-1
2109af34:	1081ffcc 	andi	r2,r2,2047
2109af38:	0241ffc4 	movi	r9,2047
2109af3c:	2a14703a 	and	r10,r5,r8
2109af40:	18c1ffcc 	andi	r3,r3,2047
2109af44:	3a10703a 	and	r8,r7,r8
2109af48:	280ad7fa 	srli	r5,r5,31
2109af4c:	380ed7fa 	srli	r7,r7,31
2109af50:	12400f26 	beq	r2,r9,2109af90 <__eqdf2+0x6c>
2109af54:	0241ffc4 	movi	r9,2047
2109af58:	1a400326 	beq	r3,r9,2109af68 <__eqdf2+0x44>
2109af5c:	10c00526 	beq	r2,r3,2109af74 <__eqdf2+0x50>
2109af60:	00800044 	movi	r2,1
2109af64:	f800283a 	ret
2109af68:	4192b03a 	or	r9,r8,r6
2109af6c:	483ffc1e 	bne	r9,zero,2109af60 <__flash_rwdata_start+0xffff8d18>
2109af70:	10fffb1e 	bne	r2,r3,2109af60 <__flash_rwdata_start+0xffff8d18>
2109af74:	523ffa1e 	bne	r10,r8,2109af60 <__flash_rwdata_start+0xffff8d18>
2109af78:	21bff91e 	bne	r4,r6,2109af60 <__flash_rwdata_start+0xffff8d18>
2109af7c:	29c00826 	beq	r5,r7,2109afa0 <__eqdf2+0x7c>
2109af80:	103ff71e 	bne	r2,zero,2109af60 <__flash_rwdata_start+0xffff8d18>
2109af84:	5104b03a 	or	r2,r10,r4
2109af88:	1004c03a 	cmpne	r2,r2,zero
2109af8c:	f800283a 	ret
2109af90:	5112b03a 	or	r9,r10,r4
2109af94:	483fef26 	beq	r9,zero,2109af54 <__flash_rwdata_start+0xffff8d0c>
2109af98:	00800044 	movi	r2,1
2109af9c:	f800283a 	ret
2109afa0:	0005883a 	mov	r2,zero
2109afa4:	f800283a 	ret

2109afa8 <__ledf2>:
2109afa8:	2804d53a 	srli	r2,r5,20
2109afac:	3810d53a 	srli	r8,r7,20
2109afb0:	00c00434 	movhi	r3,16
2109afb4:	18ffffc4 	addi	r3,r3,-1
2109afb8:	0241ffc4 	movi	r9,2047
2109afbc:	1081ffcc 	andi	r2,r2,2047
2109afc0:	28d4703a 	and	r10,r5,r3
2109afc4:	4250703a 	and	r8,r8,r9
2109afc8:	38c6703a 	and	r3,r7,r3
2109afcc:	280ad7fa 	srli	r5,r5,31
2109afd0:	380ed7fa 	srli	r7,r7,31
2109afd4:	12400b26 	beq	r2,r9,2109b004 <__ledf2+0x5c>
2109afd8:	42401926 	beq	r8,r9,2109b040 <__ledf2+0x98>
2109afdc:	10000c1e 	bne	r2,zero,2109b010 <__ledf2+0x68>
2109afe0:	5112b03a 	or	r9,r10,r4
2109afe4:	4813003a 	cmpeq	r9,r9,zero
2109afe8:	4817883a 	mov	r11,r9
2109afec:	40000f26 	beq	r8,zero,2109b02c <__ledf2+0x84>
2109aff0:	39c03fcc 	andi	r7,r7,255
2109aff4:	58001826 	beq	r11,zero,2109b058 <__ledf2+0xb0>
2109aff8:	38000a1e 	bne	r7,zero,2109b024 <__ledf2+0x7c>
2109affc:	00bfffc4 	movi	r2,-1
2109b000:	f800283a 	ret
2109b004:	5112b03a 	or	r9,r10,r4
2109b008:	48000f1e 	bne	r9,zero,2109b048 <__ledf2+0xa0>
2109b00c:	40800c26 	beq	r8,r2,2109b040 <__ledf2+0x98>
2109b010:	4000101e 	bne	r8,zero,2109b054 <__ledf2+0xac>
2109b014:	1992b03a 	or	r9,r3,r6
2109b018:	0017883a 	mov	r11,zero
2109b01c:	483ff41e 	bne	r9,zero,2109aff0 <__flash_rwdata_start+0xffff8da8>
2109b020:	283ff61e 	bne	r5,zero,2109affc <__flash_rwdata_start+0xffff8db4>
2109b024:	00800044 	movi	r2,1
2109b028:	f800283a 	ret
2109b02c:	1998b03a 	or	r12,r3,r6
2109b030:	603fef1e 	bne	r12,zero,2109aff0 <__flash_rwdata_start+0xffff8da8>
2109b034:	483ffa26 	beq	r9,zero,2109b020 <__flash_rwdata_start+0xffff8dd8>
2109b038:	0005883a 	mov	r2,zero
2109b03c:	f800283a 	ret
2109b040:	1992b03a 	or	r9,r3,r6
2109b044:	48000226 	beq	r9,zero,2109b050 <__ledf2+0xa8>
2109b048:	00800084 	movi	r2,2
2109b04c:	f800283a 	ret
2109b050:	103fe326 	beq	r2,zero,2109afe0 <__flash_rwdata_start+0xffff8d98>
2109b054:	39c03fcc 	andi	r7,r7,255
2109b058:	29fff11e 	bne	r5,r7,2109b020 <__flash_rwdata_start+0xffff8dd8>
2109b05c:	40bff016 	blt	r8,r2,2109b020 <__flash_rwdata_start+0xffff8dd8>
2109b060:	12000316 	blt	r2,r8,2109b070 <__ledf2+0xc8>
2109b064:	1abfee36 	bltu	r3,r10,2109b020 <__flash_rwdata_start+0xffff8dd8>
2109b068:	50c00326 	beq	r10,r3,2109b078 <__ledf2+0xd0>
2109b06c:	50fff22e 	bgeu	r10,r3,2109b038 <__flash_rwdata_start+0xffff8df0>
2109b070:	283fe226 	beq	r5,zero,2109affc <__flash_rwdata_start+0xffff8db4>
2109b074:	003feb06 	br	2109b024 <__flash_rwdata_start+0xffff8ddc>
2109b078:	313fe936 	bltu	r6,r4,2109b020 <__flash_rwdata_start+0xffff8dd8>
2109b07c:	21bfee2e 	bgeu	r4,r6,2109b038 <__flash_rwdata_start+0xffff8df0>
2109b080:	283fde26 	beq	r5,zero,2109affc <__flash_rwdata_start+0xffff8db4>
2109b084:	003fe706 	br	2109b024 <__flash_rwdata_start+0xffff8ddc>

2109b088 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
2109b088:	defffd04 	addi	sp,sp,-12
2109b08c:	dc000015 	stw	r16,0(sp)
2109b090:	dfc00215 	stw	ra,8(sp)
2109b094:	dc400115 	stw	r17,4(sp)
2109b098:	2021883a 	mov	r16,r4
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
2109b09c:	20002016 	blt	r4,zero,2109b120 <close+0x98>
2109b0a0:	20c00324 	muli	r3,r4,12
2109b0a4:	00800034 	movhi	r2,0
2109b0a8:	10927504 	addi	r2,r2,18900
2109b0ac:	1885883a 	add	r2,r3,r2

  if (fd)
2109b0b0:	10001b26 	beq	r2,zero,2109b120 <close+0x98>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
2109b0b4:	10c00017 	ldw	r3,0(r2)
2109b0b8:	18c00417 	ldw	r3,16(r3)
2109b0bc:	18000c26 	beq	r3,zero,2109b0f0 <close+0x68>
2109b0c0:	1009883a 	mov	r4,r2
2109b0c4:	183ee83a 	callr	r3

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
2109b0c8:	8009883a 	mov	r4,r16
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
2109b0cc:	1023883a 	mov	r17,r2

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
2109b0d0:	109b6480 	call	2109b648 <alt_release_fd>
    if (rval < 0)
    {
      ALT_ERRNO = -rval;
      return -1;
    }
    return 0;
2109b0d4:	0005883a 	mov	r2,zero
    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
    if (rval < 0)
2109b0d8:	88000816 	blt	r17,zero,2109b0fc <close+0x74>
  else
  {
    ALT_ERRNO = EBADFD;
    return -1;
  }
}
2109b0dc:	dfc00217 	ldw	ra,8(sp)
2109b0e0:	dc400117 	ldw	r17,4(sp)
2109b0e4:	dc000017 	ldw	r16,0(sp)
2109b0e8:	dec00304 	addi	sp,sp,12
2109b0ec:	f800283a 	ret

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
2109b0f0:	109b6480 	call	2109b648 <alt_release_fd>
    if (rval < 0)
    {
      ALT_ERRNO = -rval;
      return -1;
    }
    return 0;
2109b0f4:	0005883a 	mov	r2,zero
2109b0f8:	003ff806 	br	2109b0dc <__flash_rwdata_start+0xffff8e94>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
2109b0fc:	00800034 	movhi	r2,0
2109b100:	10977504 	addi	r2,r2,24020
2109b104:	10800017 	ldw	r2,0(r2)
2109b108:	10000e26 	beq	r2,zero,2109b144 <close+0xbc>
2109b10c:	103ee83a 	callr	r2
    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
    if (rval < 0)
    {
      ALT_ERRNO = -rval;
2109b110:	0463c83a 	sub	r17,zero,r17
2109b114:	14400015 	stw	r17,0(r2)
      return -1;
2109b118:	00bfffc4 	movi	r2,-1
2109b11c:	003fef06 	br	2109b0dc <__flash_rwdata_start+0xffff8e94>
2109b120:	00800034 	movhi	r2,0
2109b124:	10977504 	addi	r2,r2,24020
2109b128:	10800017 	ldw	r2,0(r2)
2109b12c:	10000826 	beq	r2,zero,2109b150 <close+0xc8>
2109b130:	103ee83a 	callr	r2
    }
    return 0;
  }
  else
  {
    ALT_ERRNO = EBADFD;
2109b134:	00c01444 	movi	r3,81
2109b138:	10c00015 	stw	r3,0(r2)
    return -1;
2109b13c:	00bfffc4 	movi	r2,-1
2109b140:	003fe606 	br	2109b0dc <__flash_rwdata_start+0xffff8e94>
2109b144:	00800034 	movhi	r2,0
2109b148:	10978504 	addi	r2,r2,24084
2109b14c:	003ff006 	br	2109b110 <__flash_rwdata_start+0xffff8ec8>
2109b150:	00800034 	movhi	r2,0
2109b154:	10978504 	addi	r2,r2,24084
2109b158:	003ff606 	br	2109b134 <__flash_rwdata_start+0xffff8eec>

2109b15c <alt_dcache_flush>:
void alt_dcache_flush (void* start, alt_u32 len)
{
#if NIOS2_DCACHE_SIZE > 0

  char* i;
  char* end = ((char*) start) + len; 
2109b15c:	214b883a 	add	r5,r4,r5

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
2109b160:	2005883a 	mov	r2,r4
2109b164:	2140092e 	bgeu	r4,r5,2109b18c <alt_dcache_flush+0x30>
  { 
    ALT_FLUSH_DATA(i); 
2109b168:	1000001b 	flushda	0(r2)
#if NIOS2_DCACHE_SIZE > 0

  char* i;
  char* end = ((char*) start) + len; 

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
2109b16c:	10800804 	addi	r2,r2,32
2109b170:	117ffd36 	bltu	r2,r5,2109b168 <__flash_rwdata_start+0xffff8f20>
2109b174:	0104303a 	nor	r2,zero,r4
2109b178:	1145883a 	add	r2,r2,r5
2109b17c:	1004d17a 	srli	r2,r2,5
2109b180:	10800044 	addi	r2,r2,1
2109b184:	1004917a 	slli	r2,r2,5
2109b188:	2085883a 	add	r2,r4,r2
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_DCACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_DCACHE_LINE_SIZE - 1))
2109b18c:	210007cc 	andi	r4,r4,31
2109b190:	20000126 	beq	r4,zero,2109b198 <alt_dcache_flush+0x3c>
  {
    ALT_FLUSH_DATA(i);
2109b194:	1000001b 	flushda	0(r2)
2109b198:	f800283a 	ret

2109b19c <alt_dcache_flush_all>:
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
2109b19c:	0005883a 	mov	r2,zero
2109b1a0:	00d00004 	movi	r3,16384
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
2109b1a4:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
2109b1a8:	10800804 	addi	r2,r2,32
2109b1ac:	10fffd1e 	bne	r2,r3,2109b1a4 <__flash_rwdata_start+0xffff8f5c>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
2109b1b0:	f800283a 	ret

2109b1b4 <alt_dev_null_write>:
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  return len;
}
2109b1b4:	3005883a 	mov	r2,r6
2109b1b8:	f800283a 	ret

2109b1bc <_exit>:
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
2109b1bc:	20000226 	beq	r4,zero,2109b1c8 <_exit+0xc>
    ALT_SIM_FAIL();
2109b1c0:	002af070 	cmpltui	zero,zero,43969
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
2109b1c4:	003fff06 	br	2109b1c4 <__flash_rwdata_start+0xffff8f7c>
  } else {
    ALT_SIM_PASS();
2109b1c8:	002af0b0 	cmpltui	zero,zero,43970
2109b1cc:	003ffd06 	br	2109b1c4 <__flash_rwdata_start+0xffff8f7c>

2109b1d0 <fstat>:
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
2109b1d0:	20000d16 	blt	r4,zero,2109b208 <fstat+0x38>
2109b1d4:	21000324 	muli	r4,r4,12
2109b1d8:	00800034 	movhi	r2,0
2109b1dc:	10927504 	addi	r2,r2,18900
2109b1e0:	2089883a 	add	r4,r4,r2
  
  if (fd)
2109b1e4:	20000826 	beq	r4,zero,2109b208 <fstat+0x38>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
2109b1e8:	20800017 	ldw	r2,0(r4)
2109b1ec:	10800817 	ldw	r2,32(r2)
2109b1f0:	10000126 	beq	r2,zero,2109b1f8 <fstat+0x28>
    {
      return fd->dev->fstat(fd, st);
2109b1f4:	1000683a 	jmp	r2
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
2109b1f8:	00880004 	movi	r2,8192
2109b1fc:	28800115 	stw	r2,4(r5)
      return 0;
2109b200:	0005883a 	mov	r2,zero
2109b204:	f800283a 	ret
2109b208:	00800034 	movhi	r2,0
2109b20c:	10977504 	addi	r2,r2,24020
2109b210:	10800017 	ldw	r2,0(r2)
2109b214:	10000926 	beq	r2,zero,2109b23c <fstat+0x6c>
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
2109b218:	deffff04 	addi	sp,sp,-4
2109b21c:	dfc00015 	stw	ra,0(sp)
2109b220:	103ee83a 	callr	r2
      return 0;
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
2109b224:	00c01444 	movi	r3,81
2109b228:	10c00015 	stw	r3,0(r2)
    return -1;
2109b22c:	00bfffc4 	movi	r2,-1
  }
}
2109b230:	dfc00017 	ldw	ra,0(sp)
2109b234:	dec00104 	addi	sp,sp,4
2109b238:	f800283a 	ret
2109b23c:	00800034 	movhi	r2,0
2109b240:	10978504 	addi	r2,r2,24084
      return 0;
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
2109b244:	00c01444 	movi	r3,81
2109b248:	10c00015 	stw	r3,0(r2)
    return -1;
2109b24c:	00bfffc4 	movi	r2,-1
  }
}
2109b250:	f800283a 	ret

2109b254 <alt_irq_register>:
                      alt_isr_func handler)
{
  int rc = -EINVAL;  
  alt_irq_context status;

  if (id < ALT_NIRQ)
2109b254:	008007c4 	movi	r2,31
2109b258:	11002b36 	bltu	r2,r4,2109b308 <alt_irq_register+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109b25c:	000f303a 	rdctl	r7,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109b260:	00bfff84 	movi	r2,-2
2109b264:	3886703a 	and	r3,r7,r2
2109b268:	1801703a 	wrctl	status,r3
     * state.
     */

    status = alt_irq_disable_all ();

    alt_irq[id].handler = handler;
2109b26c:	200690fa 	slli	r3,r4,3
2109b270:	02000034 	movhi	r8,0
2109b274:	42199604 	addi	r8,r8,26200
2109b278:	40d3883a 	add	r9,r8,r3
2109b27c:	49800015 	stw	r6,0(r9)
    alt_irq[id].context = context;
2109b280:	49400115 	stw	r5,4(r9)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
2109b284:	30001026 	beq	r6,zero,2109b2c8 <alt_irq_register+0x74>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109b288:	000b303a 	rdctl	r5,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109b28c:	2884703a 	and	r2,r5,r2
2109b290:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
2109b294:	00800034 	movhi	r2,0
2109b298:	10978904 	addi	r2,r2,24100
2109b29c:	00c00044 	movi	r3,1
2109b2a0:	1908983a 	sll	r4,r3,r4
2109b2a4:	10c00017 	ldw	r3,0(r2)
2109b2a8:	20c8b03a 	or	r4,r4,r3
2109b2ac:	11000015 	stw	r4,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
2109b2b0:	10800017 	ldw	r2,0(r2)
2109b2b4:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109b2b8:	2801703a 	wrctl	status,r5
2109b2bc:	3801703a 	wrctl	status,r7
2109b2c0:	0005883a 	mov	r2,zero
2109b2c4:	f800283a 	ret
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109b2c8:	000b303a 	rdctl	r5,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109b2cc:	2884703a 	and	r2,r5,r2
2109b2d0:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
2109b2d4:	00800034 	movhi	r2,0
2109b2d8:	10978904 	addi	r2,r2,24100
2109b2dc:	00ffff84 	movi	r3,-2
2109b2e0:	1908183a 	rol	r4,r3,r4
2109b2e4:	10c00017 	ldw	r3,0(r2)
2109b2e8:	20c8703a 	and	r4,r4,r3
2109b2ec:	11000015 	stw	r4,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
2109b2f0:	10800017 	ldw	r2,0(r2)
2109b2f4:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109b2f8:	2801703a 	wrctl	status,r5
2109b2fc:	3801703a 	wrctl	status,r7
2109b300:	0005883a 	mov	r2,zero
2109b304:	f800283a 	ret
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
  int rc = -EINVAL;  
2109b308:	00bffa84 	movi	r2,-22
    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);

    alt_irq_enable_all(status);
  }
  return rc; 
}
2109b30c:	f800283a 	ret

2109b310 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
2109b310:	defff004 	addi	sp,sp,-64
2109b314:	dfc00f15 	stw	ra,60(sp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
2109b318:	20001316 	blt	r4,zero,2109b368 <isatty+0x58>
2109b31c:	20800324 	muli	r2,r4,12
2109b320:	00c00034 	movhi	r3,0
2109b324:	18d27504 	addi	r3,r3,18900
2109b328:	10c5883a 	add	r2,r2,r3
  
  if (fd)
2109b32c:	10000e26 	beq	r2,zero,2109b368 <isatty+0x58>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
2109b330:	10800017 	ldw	r2,0(r2)
2109b334:	10800817 	ldw	r2,32(r2)
2109b338:	10000726 	beq	r2,zero,2109b358 <isatty+0x48>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
2109b33c:	d80b883a 	mov	r5,sp
2109b340:	109b1d00 	call	2109b1d0 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
2109b344:	d8800117 	ldw	r2,4(sp)
2109b348:	10880020 	cmpeqi	r2,r2,8192
  else
  {
    ALT_ERRNO = EBADFD;
    return 0;
  }
}
2109b34c:	dfc00f17 	ldw	ra,60(sp)
2109b350:	dec01004 	addi	sp,sp,64
2109b354:	f800283a 	ret
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
    {
      return 1;
2109b358:	00800044 	movi	r2,1
  else
  {
    ALT_ERRNO = EBADFD;
    return 0;
  }
}
2109b35c:	dfc00f17 	ldw	ra,60(sp)
2109b360:	dec01004 	addi	sp,sp,64
2109b364:	f800283a 	ret
2109b368:	00800034 	movhi	r2,0
2109b36c:	10977504 	addi	r2,r2,24020
2109b370:	10800017 	ldw	r2,0(r2)
2109b374:	10000726 	beq	r2,zero,2109b394 <isatty+0x84>
2109b378:	103ee83a 	callr	r2
      return (stat.st_mode == _IFCHR) ? 1 : 0;
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
2109b37c:	00c01444 	movi	r3,81
2109b380:	10c00015 	stw	r3,0(r2)
    return 0;
2109b384:	0005883a 	mov	r2,zero
  }
}
2109b388:	dfc00f17 	ldw	ra,60(sp)
2109b38c:	dec01004 	addi	sp,sp,64
2109b390:	f800283a 	ret
2109b394:	00800034 	movhi	r2,0
2109b398:	10978504 	addi	r2,r2,24084
2109b39c:	003ff706 	br	2109b37c <__flash_rwdata_start+0xffff9134>

2109b3a0 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
2109b3a0:	deffff04 	addi	sp,sp,-4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
2109b3a4:	01000034 	movhi	r4,0
2109b3a8:	014842b4 	movhi	r5,8458
2109b3ac:	dfc00015 	stw	ra,0(sp)
2109b3b0:	210fcc04 	addi	r4,r4,16176
2109b3b4:	29489204 	addi	r5,r5,8776
2109b3b8:	21400a26 	beq	r4,r5,2109b3e4 <alt_load+0x44>
  {
    while( to != end )
2109b3bc:	00800034 	movhi	r2,0
2109b3c0:	10977e04 	addi	r2,r2,24056
2109b3c4:	20800726 	beq	r4,r2,2109b3e4 <alt_load+0x44>
    {
      *to++ = *from++;
2109b3c8:	21800104 	addi	r6,r4,4
2109b3cc:	118dc83a 	sub	r6,r2,r6
2109b3d0:	300cd0ba 	srli	r6,r6,2
2109b3d4:	31800044 	addi	r6,r6,1
2109b3d8:	318d883a 	add	r6,r6,r6
2109b3dc:	318d883a 	add	r6,r6,r6
2109b3e0:	108e1340 	call	2108e134 <memcpy>

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
2109b3e4:	01084234 	movhi	r4,8456
2109b3e8:	01484234 	movhi	r5,8456
2109b3ec:	21000804 	addi	r4,r4,32
2109b3f0:	29400804 	addi	r5,r5,32
2109b3f4:	21400a26 	beq	r4,r5,2109b420 <alt_load+0x80>
  {
    while( to != end )
2109b3f8:	00884234 	movhi	r2,8456
2109b3fc:	10806404 	addi	r2,r2,400
2109b400:	20800726 	beq	r4,r2,2109b420 <alt_load+0x80>
    {
      *to++ = *from++;
2109b404:	21800104 	addi	r6,r4,4
2109b408:	118dc83a 	sub	r6,r2,r6
2109b40c:	300cd0ba 	srli	r6,r6,2
2109b410:	31800044 	addi	r6,r6,1
2109b414:	318d883a 	add	r6,r6,r6
2109b418:	318d883a 	add	r6,r6,r6
2109b41c:	108e1340 	call	2108e134 <memcpy>

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
2109b420:	01000034 	movhi	r4,0
2109b424:	014842b4 	movhi	r5,8458
2109b428:	21000004 	addi	r4,r4,0
2109b42c:	2978c604 	addi	r5,r5,-7400
2109b430:	21400a26 	beq	r4,r5,2109b45c <alt_load+0xbc>
  {
    while( to != end )
2109b434:	00800034 	movhi	r2,0
2109b438:	108fcc04 	addi	r2,r2,16176
2109b43c:	20800726 	beq	r4,r2,2109b45c <alt_load+0xbc>
    {
      *to++ = *from++;
2109b440:	21800104 	addi	r6,r4,4
2109b444:	118dc83a 	sub	r6,r2,r6
2109b448:	300cd0ba 	srli	r6,r6,2
2109b44c:	31800044 	addi	r6,r6,1
2109b450:	318d883a 	add	r6,r6,r6
2109b454:	318d883a 	add	r6,r6,r6
2109b458:	108e1340 	call	2108e134 <memcpy>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
2109b45c:	109b19c0 	call	2109b19c <alt_dcache_flush_all>
  alt_icache_flush_all();
}
2109b460:	dfc00017 	ldw	ra,0(sp)
2109b464:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
2109b468:	109dad01 	jmpi	2109dad0 <alt_icache_flush_all>

2109b46c <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
2109b46c:	defffe04 	addi	sp,sp,-8
2109b470:	dfc00115 	stw	ra,4(sp)
2109b474:	dc000015 	stw	r16,0(sp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
2109b478:	20000e16 	blt	r4,zero,2109b4b4 <lseek+0x48>
2109b47c:	21000324 	muli	r4,r4,12
2109b480:	00800034 	movhi	r2,0
2109b484:	10927504 	addi	r2,r2,18900
2109b488:	2089883a 	add	r4,r4,r2
  
  if (fd) 
2109b48c:	20000926 	beq	r4,zero,2109b4b4 <lseek+0x48>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
2109b490:	20800017 	ldw	r2,0(r4)
2109b494:	10800717 	ldw	r2,28(r2)
2109b498:	10000f26 	beq	r2,zero,2109b4d8 <lseek+0x6c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
2109b49c:	103ee83a 	callr	r2
  else  
  {
    rc = -EBADFD;
  }

  if (rc < 0)
2109b4a0:	10001216 	blt	r2,zero,2109b4ec <lseek+0x80>
    ALT_ERRNO = -rc;
    rc = -1;
  }

  return rc;
}
2109b4a4:	dfc00117 	ldw	ra,4(sp)
2109b4a8:	dc000017 	ldw	r16,0(sp)
2109b4ac:	dec00204 	addi	sp,sp,8
2109b4b0:	f800283a 	ret
2109b4b4:	04001444 	movi	r16,81
2109b4b8:	00800034 	movhi	r2,0
2109b4bc:	10977504 	addi	r2,r2,24020
2109b4c0:	10800017 	ldw	r2,0(r2)
2109b4c4:	10000626 	beq	r2,zero,2109b4e0 <lseek+0x74>
2109b4c8:	103ee83a 	callr	r2
    rc = -EBADFD;
  }

  if (rc < 0)
  {
    ALT_ERRNO = -rc;
2109b4cc:	14000015 	stw	r16,0(r2)
    rc = -1;
2109b4d0:	00bfffc4 	movi	r2,-1
2109b4d4:	003ff306 	br	2109b4a4 <__flash_rwdata_start+0xffff925c>
2109b4d8:	04002184 	movi	r16,134
2109b4dc:	003ff606 	br	2109b4b8 <__flash_rwdata_start+0xffff9270>
2109b4e0:	00800034 	movhi	r2,0
2109b4e4:	10978504 	addi	r2,r2,24084
2109b4e8:	003ff806 	br	2109b4cc <__flash_rwdata_start+0xffff9284>
2109b4ec:	00a1c83a 	sub	r16,zero,r2
2109b4f0:	003ff106 	br	2109b4b8 <__flash_rwdata_start+0xffff9270>

2109b4f4 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
2109b4f4:	defffe04 	addi	sp,sp,-8
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
2109b4f8:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
2109b4fc:	dfc00115 	stw	ra,4(sp)
2109b500:	dc000015 	stw	r16,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
2109b504:	109b93c0 	call	2109b93c <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
2109b508:	109b95c0 	call	2109b95c <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
2109b50c:	01000034 	movhi	r4,0
2109b510:	210f4d04 	addi	r4,r4,15668
2109b514:	200b883a 	mov	r5,r4
2109b518:	200d883a 	mov	r6,r4
2109b51c:	109dbe00 	call	2109dbe0 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
2109b520:	109d9900 	call	2109d990 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
2109b524:	010842b4 	movhi	r4,8458
2109b528:	21367d04 	addi	r4,r4,-9740
2109b52c:	109e1f00 	call	2109e1f0 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
2109b530:	d1202917 	ldw	r4,-32604(gp)
2109b534:	d1602817 	ldw	r5,-32608(gp)
2109b538:	d1a02717 	ldw	r6,-32612(gp)
2109b53c:	108a0e40 	call	2108a0e4 <main>
  close(STDOUT_FILENO);
2109b540:	01000044 	movi	r4,1
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
2109b544:	1021883a 	mov	r16,r2
  close(STDOUT_FILENO);
2109b548:	109b0880 	call	2109b088 <close>
  exit (result);
2109b54c:	8009883a 	mov	r4,r16
2109b550:	108d5880 	call	2108d588 <exit>

2109b554 <__malloc_lock>:
 * configuration is single threaded, so there is nothing to do here. Note that 
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
2109b554:	f800283a 	ret

2109b558 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
2109b558:	f800283a 	ret

2109b55c <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
2109b55c:	defffe04 	addi	sp,sp,-8
2109b560:	dfc00115 	stw	ra,4(sp)
2109b564:	dc000015 	stw	r16,0(sp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
2109b568:	20002516 	blt	r4,zero,2109b600 <read+0xa4>
2109b56c:	20800324 	muli	r2,r4,12
2109b570:	00c00034 	movhi	r3,0
2109b574:	18d27504 	addi	r3,r3,18900
2109b578:	10c9883a 	add	r4,r2,r3
  
  if (fd)
2109b57c:	20002026 	beq	r4,zero,2109b600 <read+0xa4>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
2109b580:	20800217 	ldw	r2,8(r4)
2109b584:	00c00044 	movi	r3,1
2109b588:	108000cc 	andi	r2,r2,3
2109b58c:	10c00a26 	beq	r2,r3,2109b5b8 <read+0x5c>
        (fd->dev->read))
2109b590:	20800017 	ldw	r2,0(r4)
2109b594:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
2109b598:	10000726 	beq	r2,zero,2109b5b8 <read+0x5c>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
2109b59c:	103ee83a 	callr	r2
2109b5a0:	1021883a 	mov	r16,r2
2109b5a4:	80000d16 	blt	r16,zero,2109b5dc <read+0x80>
  else
  {
    ALT_ERRNO = EBADFD;
  }
  return -1;
}
2109b5a8:	dfc00117 	ldw	ra,4(sp)
2109b5ac:	dc000017 	ldw	r16,0(sp)
2109b5b0:	dec00204 	addi	sp,sp,8
2109b5b4:	f800283a 	ret
2109b5b8:	00800034 	movhi	r2,0
2109b5bc:	10977504 	addi	r2,r2,24020
2109b5c0:	10800017 	ldw	r2,0(r2)
2109b5c4:	10001726 	beq	r2,zero,2109b624 <read+0xc8>
2109b5c8:	103ee83a 	callr	r2
        }
        return rval;
      }
      else
      {
        ALT_ERRNO = EACCES;
2109b5cc:	00c00344 	movi	r3,13
2109b5d0:	10c00015 	stw	r3,0(r2)
    }
  else
  {
    ALT_ERRNO = EBADFD;
  }
  return -1;
2109b5d4:	00bfffc4 	movi	r2,-1
2109b5d8:	003ff306 	br	2109b5a8 <__flash_rwdata_start+0xffff9360>
2109b5dc:	00800034 	movhi	r2,0
2109b5e0:	10977504 	addi	r2,r2,24020
2109b5e4:	10800017 	ldw	r2,0(r2)
2109b5e8:	10001126 	beq	r2,zero,2109b630 <read+0xd4>
2109b5ec:	103ee83a 	callr	r2
    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
        {
          ALT_ERRNO = -rval;
2109b5f0:	0421c83a 	sub	r16,zero,r16
2109b5f4:	14000015 	stw	r16,0(r2)
          return -1;
2109b5f8:	00bfffc4 	movi	r2,-1
2109b5fc:	003fea06 	br	2109b5a8 <__flash_rwdata_start+0xffff9360>
2109b600:	00800034 	movhi	r2,0
2109b604:	10977504 	addi	r2,r2,24020
2109b608:	10800017 	ldw	r2,0(r2)
2109b60c:	10000b26 	beq	r2,zero,2109b63c <read+0xe0>
2109b610:	103ee83a 	callr	r2
        ALT_ERRNO = EACCES;
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
2109b614:	00c01444 	movi	r3,81
2109b618:	10c00015 	stw	r3,0(r2)
  }
  return -1;
2109b61c:	00bfffc4 	movi	r2,-1
2109b620:	003fe106 	br	2109b5a8 <__flash_rwdata_start+0xffff9360>
2109b624:	00800034 	movhi	r2,0
2109b628:	10978504 	addi	r2,r2,24084
2109b62c:	003fe706 	br	2109b5cc <__flash_rwdata_start+0xffff9384>
2109b630:	00800034 	movhi	r2,0
2109b634:	10978504 	addi	r2,r2,24084
2109b638:	003fed06 	br	2109b5f0 <__flash_rwdata_start+0xffff93a8>
2109b63c:	00800034 	movhi	r2,0
2109b640:	10978504 	addi	r2,r2,24084
2109b644:	003ff306 	br	2109b614 <__flash_rwdata_start+0xffff93cc>

2109b648 <alt_release_fd>:
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
  if (fd > 2)
2109b648:	00800084 	movi	r2,2
2109b64c:	1100060e 	bge	r2,r4,2109b668 <alt_release_fd+0x20>
  {
    alt_fd_list[fd].fd_flags = 0;
2109b650:	21000324 	muli	r4,r4,12
2109b654:	00800034 	movhi	r2,0
2109b658:	10927504 	addi	r2,r2,18900
2109b65c:	1107883a 	add	r3,r2,r4
2109b660:	18000215 	stw	zero,8(r3)
    alt_fd_list[fd].dev      = 0;
2109b664:	18000015 	stw	zero,0(r3)
2109b668:	f800283a 	ret

2109b66c <sbrk>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109b66c:	000b303a 	rdctl	r5,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109b670:	00bfff84 	movi	r2,-2
2109b674:	2884703a 	and	r2,r5,r2
2109b678:	1001703a 	wrctl	status,r2
  char *prev_heap_end; 

  context = alt_irq_disable_all();

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
2109b67c:	d0a01417 	ldw	r2,-32688(gp)
2109b680:	00ffff04 	movi	r3,-4
2109b684:	108000c4 	addi	r2,r2,3
2109b688:	10c4703a 	and	r2,r2,r3
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
2109b68c:	00c40034 	movhi	r3,4096
  char *prev_heap_end; 

  context = alt_irq_disable_all();

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
2109b690:	d0a01415 	stw	r2,-32688(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
2109b694:	1109883a 	add	r4,r2,r4
2109b698:	18c00004 	addi	r3,r3,0
2109b69c:	19000336 	bltu	r3,r4,2109b6ac <sbrk+0x40>
    return (caddr_t)-1;
  }
#endif

  prev_heap_end = heap_end; 
  heap_end += incr; 
2109b6a0:	d1201415 	stw	r4,-32688(gp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109b6a4:	2801703a 	wrctl	status,r5
#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
} 
2109b6a8:	f800283a 	ret
2109b6ac:	2801703a 	wrctl	status,r5
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
2109b6b0:	00bfffc4 	movi	r2,-1
2109b6b4:	f800283a 	ret

2109b6b8 <alt_alarm_stop>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109b6b8:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109b6bc:	00bfff84 	movi	r2,-2
2109b6c0:	1884703a 	and	r2,r3,r2
2109b6c4:	1001703a 	wrctl	status,r2
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
2109b6c8:	21400117 	ldw	r5,4(r4)
2109b6cc:	20800017 	ldw	r2,0(r4)
2109b6d0:	11400115 	stw	r5,4(r2)
  entry->previous->next = entry->next;
2109b6d4:	21400117 	ldw	r5,4(r4)
2109b6d8:	28800015 	stw	r2,0(r5)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
2109b6dc:	21000115 	stw	r4,4(r4)
  entry->next     = entry;
2109b6e0:	21000015 	stw	r4,0(r4)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109b6e4:	1801703a 	wrctl	status,r3
2109b6e8:	f800283a 	ret

2109b6ec <alt_tick>:

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
2109b6ec:	d0a02a17 	ldw	r2,-32600(gp)
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
2109b6f0:	defffa04 	addi	sp,sp,-24
2109b6f4:	dc000015 	stw	r16,0(sp)
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
2109b6f8:	d4201517 	ldw	r16,-32684(gp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
2109b6fc:	10800044 	addi	r2,r2,1
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
2109b700:	dc800215 	stw	r18,8(sp)
2109b704:	dfc00515 	stw	ra,20(sp)
2109b708:	dd000415 	stw	r20,16(sp)
2109b70c:	dcc00315 	stw	r19,12(sp)
2109b710:	dc400115 	stw	r17,4(sp)
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
2109b714:	d4a01504 	addi	r18,gp,-32684

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
2109b718:	d0a02a15 	stw	r2,-32600(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
2109b71c:	84801726 	beq	r16,r18,2109b77c <alt_tick+0x90>
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
        {
          alarm->rollover = 1;
2109b720:	04c00044 	movi	r19,1
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109b724:	053fff84 	movi	r20,-2
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
2109b728:	80800403 	ldbu	r2,16(r16)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  {
    next = (alt_alarm*) alarm->llist.next;
2109b72c:	84400017 	ldw	r17,0(r16)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
2109b730:	10000326 	beq	r2,zero,2109b740 <alt_tick+0x54>
2109b734:	d0a02a17 	ldw	r2,-32600(gp)
2109b738:	1000181e 	bne	r2,zero,2109b79c <alt_tick+0xb0>
    {
      alarm->rollover = 0;
2109b73c:	80000405 	stb	zero,16(r16)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
2109b740:	d0e02a17 	ldw	r3,-32600(gp)
2109b744:	80800217 	ldw	r2,8(r16)
2109b748:	18800a36 	bltu	r3,r2,2109b774 <alt_tick+0x88>
    {
      next_callback = alarm->callback (alarm->context);
2109b74c:	80800317 	ldw	r2,12(r16)
2109b750:	81000517 	ldw	r4,20(r16)
2109b754:	103ee83a 	callr	r2

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
2109b758:	10001426 	beq	r2,zero,2109b7ac <alt_tick+0xc0>
      {
        alt_alarm_stop (alarm);
      }
      else
      {
        alarm->time += next_callback;
2109b75c:	80c00217 	ldw	r3,8(r16)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
2109b760:	d1202a17 	ldw	r4,-32600(gp)
      {
        alt_alarm_stop (alarm);
      }
      else
      {
        alarm->time += next_callback;
2109b764:	10c5883a 	add	r2,r2,r3
2109b768:	80800215 	stw	r2,8(r16)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
2109b76c:	1100012e 	bgeu	r2,r4,2109b774 <alt_tick+0x88>
        {
          alarm->rollover = 1;
2109b770:	84c00405 	stb	r19,16(r16)
2109b774:	8821883a 	mov	r16,r17

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
2109b778:	8cbfeb1e 	bne	r17,r18,2109b728 <__flash_rwdata_start+0xffff94e0>
  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
}
2109b77c:	dfc00517 	ldw	ra,20(sp)
2109b780:	dd000417 	ldw	r20,16(sp)
2109b784:	dcc00317 	ldw	r19,12(sp)
2109b788:	dc800217 	ldw	r18,8(sp)
2109b78c:	dc400117 	ldw	r17,4(sp)
2109b790:	dc000017 	ldw	r16,0(sp)
2109b794:	dec00604 	addi	sp,sp,24
2109b798:	f800283a 	ret
    {
      alarm->rollover = 0;
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
2109b79c:	d0a02a17 	ldw	r2,-32600(gp)
2109b7a0:	8821883a 	mov	r16,r17

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
2109b7a4:	8cbfe01e 	bne	r17,r18,2109b728 <__flash_rwdata_start+0xffff94e0>
2109b7a8:	003ff406 	br	2109b77c <__flash_rwdata_start+0xffff9534>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109b7ac:	0005303a 	rdctl	r2,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109b7b0:	1506703a 	and	r3,r2,r20
2109b7b4:	1801703a 	wrctl	status,r3
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
2109b7b8:	81000117 	ldw	r4,4(r16)
2109b7bc:	80c00017 	ldw	r3,0(r16)
2109b7c0:	19000115 	stw	r4,4(r3)
  entry->previous->next = entry->next;
2109b7c4:	81000117 	ldw	r4,4(r16)
2109b7c8:	20c00015 	stw	r3,0(r4)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
2109b7cc:	84000115 	stw	r16,4(r16)
  entry->next     = entry;
2109b7d0:	84000015 	stw	r16,0(r16)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109b7d4:	1001703a 	wrctl	status,r2
2109b7d8:	8821883a 	mov	r16,r17
2109b7dc:	8cbfd21e 	bne	r17,r18,2109b728 <__flash_rwdata_start+0xffff94e0>
2109b7e0:	003fe606 	br	2109b77c <__flash_rwdata_start+0xffff9534>

2109b7e4 <alt_uncached_free>:
void 
alt_uncached_free(volatile void* ptr)
{
#if ALT_CPU_DCACHE_SIZE > 0
#ifdef ALT_CPU_DCACHE_BYPASS_MASK
  free((void*) (((alt_u32)ptr) & ~ALT_CPU_DCACHE_BYPASS_MASK));
2109b7e4:	00a00034 	movhi	r2,32768
2109b7e8:	10bfffc4 	addi	r2,r2,-1
2109b7ec:	2088703a 	and	r4,r4,r2
2109b7f0:	108d8fc1 	jmpi	2108d8fc <free>

2109b7f4 <alt_uncached_malloc>:
 * Return pointer to the block of memory or NULL if can't allocate it.
 */

volatile void* 
alt_uncached_malloc(size_t size)
{
2109b7f4:	defffd04 	addi	sp,sp,-12

  void* ptr;

  /* Round up size to an integer number of data cache lines. Required to guarantee that
   * cacheable and non-cacheable data won't be mixed on the same cache line. */ 
  const size_t num_lines = (size + ALT_CPU_DCACHE_LINE_SIZE - 1) / ALT_CPU_DCACHE_LINE_SIZE;
2109b7f8:	210007c4 	addi	r4,r4,31
 * Return pointer to the block of memory or NULL if can't allocate it.
 */

volatile void* 
alt_uncached_malloc(size_t size)
{
2109b7fc:	dc000015 	stw	r16,0(sp)

  void* ptr;

  /* Round up size to an integer number of data cache lines. Required to guarantee that
   * cacheable and non-cacheable data won't be mixed on the same cache line. */ 
  const size_t num_lines = (size + ALT_CPU_DCACHE_LINE_SIZE - 1) / ALT_CPU_DCACHE_LINE_SIZE;
2109b800:	2020d17a 	srli	r16,r4,5
  const size_t aligned_size = num_lines * ALT_CPU_DCACHE_LINE_SIZE;

  /* Use memalign() Newlib routine to allocate starting on a data cache aligned address.
   * Required to guarantee that cacheable and non-cacheable data won't be mixed on the
   * same cache line. */ 
  ptr = memalign(ALT_CPU_DCACHE_LINE_SIZE, aligned_size);
2109b804:	01000804 	movi	r4,32
 * Return pointer to the block of memory or NULL if can't allocate it.
 */

volatile void* 
alt_uncached_malloc(size_t size)
{
2109b808:	dc400115 	stw	r17,4(sp)
  void* ptr;

  /* Round up size to an integer number of data cache lines. Required to guarantee that
   * cacheable and non-cacheable data won't be mixed on the same cache line. */ 
  const size_t num_lines = (size + ALT_CPU_DCACHE_LINE_SIZE - 1) / ALT_CPU_DCACHE_LINE_SIZE;
  const size_t aligned_size = num_lines * ALT_CPU_DCACHE_LINE_SIZE;
2109b80c:	8020917a 	slli	r16,r16,5
 * Return pointer to the block of memory or NULL if can't allocate it.
 */

volatile void* 
alt_uncached_malloc(size_t size)
{
2109b810:	dfc00215 	stw	ra,8(sp)
  const size_t aligned_size = num_lines * ALT_CPU_DCACHE_LINE_SIZE;

  /* Use memalign() Newlib routine to allocate starting on a data cache aligned address.
   * Required to guarantee that cacheable and non-cacheable data won't be mixed on the
   * same cache line. */ 
  ptr = memalign(ALT_CPU_DCACHE_LINE_SIZE, aligned_size);
2109b814:	800b883a 	mov	r5,r16
2109b818:	108d7180 	call	2108d718 <memalign>
2109b81c:	1023883a 	mov	r17,r2

  if (ptr == NULL) {
2109b820:	10000926 	beq	r2,zero,2109b848 <alt_uncached_malloc+0x54>
    return NULL; /* Out of memory */
  }

  /* Ensure that the memory region isn't in the data cache. */
  alt_dcache_flush(ptr, aligned_size);
2109b824:	1009883a 	mov	r4,r2
2109b828:	800b883a 	mov	r5,r16
2109b82c:	109b15c0 	call	2109b15c <alt_dcache_flush>

  return (volatile void*) (((alt_u32)ptr) | ALT_CPU_DCACHE_BYPASS_MASK);
2109b830:	88a00034 	orhi	r2,r17,32768
#endif /* No address mask option enabled. */
#else /* No data cache */
  /* Just use regular malloc. */
  return malloc(size);
#endif /* No data cache */
}
2109b834:	dfc00217 	ldw	ra,8(sp)
2109b838:	dc400117 	ldw	r17,4(sp)
2109b83c:	dc000017 	ldw	r16,0(sp)
2109b840:	dec00304 	addi	sp,sp,12
2109b844:	f800283a 	ret
   * Required to guarantee that cacheable and non-cacheable data won't be mixed on the
   * same cache line. */ 
  ptr = memalign(ALT_CPU_DCACHE_LINE_SIZE, aligned_size);

  if (ptr == NULL) {
    return NULL; /* Out of memory */
2109b848:	0005883a 	mov	r2,zero
2109b84c:	003ff906 	br	2109b834 <__flash_rwdata_start+0xffff95ec>

2109b850 <usleep>:
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
  return alt_busy_sleep(us);
2109b850:	109d8b81 	jmpi	2109d8b8 <alt_busy_sleep>

2109b854 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
2109b854:	defffe04 	addi	sp,sp,-8
2109b858:	dfc00115 	stw	ra,4(sp)
2109b85c:	dc000015 	stw	r16,0(sp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
2109b860:	20002716 	blt	r4,zero,2109b900 <write+0xac>
2109b864:	20800324 	muli	r2,r4,12
2109b868:	00c00034 	movhi	r3,0
2109b86c:	18d27504 	addi	r3,r3,18900
2109b870:	10c9883a 	add	r4,r2,r3
  
  if (fd)
2109b874:	20002226 	beq	r4,zero,2109b900 <write+0xac>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
2109b878:	20800217 	ldw	r2,8(r4)
2109b87c:	108000cc 	andi	r2,r2,3
2109b880:	10000a26 	beq	r2,zero,2109b8ac <write+0x58>
2109b884:	20800017 	ldw	r2,0(r4)
2109b888:	10800617 	ldw	r2,24(r2)
2109b88c:	10000726 	beq	r2,zero,2109b8ac <write+0x58>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
2109b890:	103ee83a 	callr	r2
2109b894:	1021883a 	mov	r16,r2
2109b898:	80001016 	blt	r16,zero,2109b8dc <write+0x88>
  else  
  {
    ALT_ERRNO = EBADFD;
  }
  return -1;
}
2109b89c:	dfc00117 	ldw	ra,4(sp)
2109b8a0:	dc000017 	ldw	r16,0(sp)
2109b8a4:	dec00204 	addi	sp,sp,8
2109b8a8:	f800283a 	ret
2109b8ac:	00800034 	movhi	r2,0
2109b8b0:	10977504 	addi	r2,r2,24020
2109b8b4:	10800017 	ldw	r2,0(r2)
2109b8b8:	10000526 	beq	r2,zero,2109b8d0 <write+0x7c>
2109b8bc:	103ee83a 	callr	r2
      }
      return rval;
    }
    else
    {
      ALT_ERRNO = EACCES;
2109b8c0:	00c00344 	movi	r3,13
2109b8c4:	10c00015 	stw	r3,0(r2)
  }
  else  
  {
    ALT_ERRNO = EBADFD;
  }
  return -1;
2109b8c8:	00bfffc4 	movi	r2,-1
2109b8cc:	003ff306 	br	2109b89c <__flash_rwdata_start+0xffff9654>
2109b8d0:	00800034 	movhi	r2,0
2109b8d4:	10978504 	addi	r2,r2,24084
2109b8d8:	003ff906 	br	2109b8c0 <__flash_rwdata_start+0xffff9678>
2109b8dc:	00800034 	movhi	r2,0
2109b8e0:	10977504 	addi	r2,r2,24020
2109b8e4:	10800017 	ldw	r2,0(r2)
2109b8e8:	10000e26 	beq	r2,zero,2109b924 <write+0xd0>
2109b8ec:	103ee83a 	callr	r2
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
      {
        ALT_ERRNO = -rval;
2109b8f0:	0421c83a 	sub	r16,zero,r16
2109b8f4:	14000015 	stw	r16,0(r2)
        return -1;
2109b8f8:	00bfffc4 	movi	r2,-1
2109b8fc:	003fe706 	br	2109b89c <__flash_rwdata_start+0xffff9654>
2109b900:	00800034 	movhi	r2,0
2109b904:	10977504 	addi	r2,r2,24020
2109b908:	10800017 	ldw	r2,0(r2)
2109b90c:	10000826 	beq	r2,zero,2109b930 <write+0xdc>
2109b910:	103ee83a 	callr	r2
      ALT_ERRNO = EACCES;
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
2109b914:	00c01444 	movi	r3,81
2109b918:	10c00015 	stw	r3,0(r2)
  }
  return -1;
2109b91c:	00bfffc4 	movi	r2,-1
2109b920:	003fde06 	br	2109b89c <__flash_rwdata_start+0xffff9654>
2109b924:	00800034 	movhi	r2,0
2109b928:	10978504 	addi	r2,r2,24084
2109b92c:	003ff006 	br	2109b8f0 <__flash_rwdata_start+0xffff96a8>
2109b930:	00800034 	movhi	r2,0
2109b934:	10978504 	addi	r2,r2,24084
2109b938:	003ff606 	br	2109b914 <__flash_rwdata_start+0xffff96cc>

2109b93c <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
2109b93c:	deffff04 	addi	sp,sp,-4
2109b940:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( CPU_0, cpu_0);
2109b944:	109e0240 	call	2109e024 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
2109b948:	00800044 	movi	r2,1
2109b94c:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
2109b950:	dfc00017 	ldw	ra,0(sp)
2109b954:	dec00104 	addi	sp,sp,4
2109b958:	f800283a 	ret

2109b95c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
2109b95c:	defffe04 	addi	sp,sp,-8
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
2109b960:	00c80034 	movhi	r3,8192
2109b964:	00800034 	movhi	r2,0
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
2109b968:	dfc00115 	stw	ra,4(sp)
2109b96c:	dc000015 	stw	r16,0(sp)
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
2109b970:	18c13004 	addi	r3,r3,1216
2109b974:	10979004 	addi	r2,r2,24128
    ALTERA_AVALON_TIMER_INIT ( TIMER_1, timer_1);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
2109b978:	04000034 	movhi	r16,0
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
2109b97c:	10c00015 	stw	r3,0(r2)
    ALTERA_AVALON_TIMER_INIT ( TIMER_1, timer_1);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
2109b980:	84135504 	addi	r16,r16,19796
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
2109b984:	00c1dcf4 	movhi	r3,1907
2109b988:	00800034 	movhi	r2,0
2109b98c:	18d65004 	addi	r3,r3,22848
    ALTERA_AVALON_TIMER_INIT ( TIMER_1, timer_1);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
2109b990:	01800044 	movi	r6,1
2109b994:	8009883a 	mov	r4,r16
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
2109b998:	10978f04 	addi	r2,r2,24124
    ALTERA_AVALON_TIMER_INIT ( TIMER_1, timer_1);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
2109b99c:	000b883a 	mov	r5,zero
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
2109b9a0:	10c00015 	stw	r3,0(r2)
    ALTERA_AVALON_TIMER_INIT ( TIMER_1, timer_1);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
2109b9a4:	109bbbc0 	call	2109bbbc <altera_avalon_jtag_uart_init>

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
2109b9a8:	01400034 	movhi	r5,0
2109b9ac:	813ff604 	addi	r4,r16,-40
2109b9b0:	29577104 	addi	r5,r5,24004
2109b9b4:	109d9180 	call	2109d918 <alt_dev_llist_insert>
    ALTERA_AVALON_MAILBOX_SIMPLE_INIT ( MAILBOX_SIMPLE_0_1, mailbox_simple_0_1);
2109b9b8:	01000034 	movhi	r4,0
2109b9bc:	21133904 	addi	r4,r4,19684
2109b9c0:	000b883a 	mov	r5,zero
2109b9c4:	01bfffc4 	movi	r6,-1
2109b9c8:	109c0cc0 	call	2109c0cc <altera_avalon_mailbox_simple_init>
    ALTERA_AVALON_MAILBOX_SIMPLE_INIT ( MAILBOX_SIMPLE_1_0, mailbox_simple_1_0);
2109b9cc:	01000034 	movhi	r4,0
2109b9d0:	21132704 	addi	r4,r4,19612
2109b9d4:	000b883a 	mov	r5,zero
2109b9d8:	01800204 	movi	r6,8
2109b9dc:	109c0cc0 	call	2109c0cc <altera_avalon_mailbox_simple_init>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
    ALTERA_MSGDMA_INIT ( READ_DMA_Y, read_dma_y);
2109b9e0:	01000034 	movhi	r4,0
2109b9e4:	21130f04 	addi	r4,r4,19516
2109b9e8:	21400717 	ldw	r5,28(r4)
2109b9ec:	21800817 	ldw	r6,32(r4)
2109b9f0:	109d0500 	call	2109d050 <alt_msgdma_init>
    ALTERA_MSGDMA_INIT ( VIDEO_DMA, video_dma);
2109b9f4:	01000034 	movhi	r4,0
2109b9f8:	2112f704 	addi	r4,r4,19420
2109b9fc:	21400717 	ldw	r5,28(r4)
2109ba00:	21800817 	ldw	r6,32(r4)
2109ba04:	109d0500 	call	2109d050 <alt_msgdma_init>
    ALTERA_MSGDMA_INIT ( WRITE_DMA, write_dma);
2109ba08:	01000034 	movhi	r4,0
2109ba0c:	2112df04 	addi	r4,r4,19324
2109ba10:	21400717 	ldw	r5,28(r4)
2109ba14:	21800817 	ldw	r6,32(r4)
}
2109ba18:	dfc00117 	ldw	ra,4(sp)
2109ba1c:	dc000017 	ldw	r16,0(sp)
2109ba20:	dec00204 	addi	sp,sp,8
    ALTERA_AVALON_MAILBOX_SIMPLE_INIT ( MAILBOX_SIMPLE_0_1, mailbox_simple_0_1);
    ALTERA_AVALON_MAILBOX_SIMPLE_INIT ( MAILBOX_SIMPLE_1_0, mailbox_simple_1_0);
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
    ALTERA_MSGDMA_INIT ( READ_DMA_Y, read_dma_y);
    ALTERA_MSGDMA_INIT ( VIDEO_DMA, video_dma);
    ALTERA_MSGDMA_INIT ( WRITE_DMA, write_dma);
2109ba24:	109d0501 	jmpi	2109d050 <alt_msgdma_init>

2109ba28 <altera_avalon_jtag_uart_read_fd>:
int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
2109ba28:	20800017 	ldw	r2,0(r4)
2109ba2c:	21c00217 	ldw	r7,8(r4)
2109ba30:	11000a04 	addi	r4,r2,40
2109ba34:	109bd001 	jmpi	2109bd00 <altera_avalon_jtag_uart_read>

2109ba38 <altera_avalon_jtag_uart_write_fd>:
int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
2109ba38:	20800017 	ldw	r2,0(r4)
2109ba3c:	21c00217 	ldw	r7,8(r4)
2109ba40:	11000a04 	addi	r4,r2,40
2109ba44:	109be3c1 	jmpi	2109be3c <altera_avalon_jtag_uart_write>

2109ba48 <altera_avalon_jtag_uart_close_fd>:
int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
2109ba48:	20800017 	ldw	r2,0(r4)
2109ba4c:	21400217 	ldw	r5,8(r4)
2109ba50:	11000a04 	addi	r4,r2,40
2109ba54:	109bc3c1 	jmpi	2109bc3c <altera_avalon_jtag_uart_close>

2109ba58 <altera_avalon_jtag_uart_ioctl_fd>:
int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
2109ba58:	21000017 	ldw	r4,0(r4)
2109ba5c:	21000a04 	addi	r4,r4,40
2109ba60:	109bc8c1 	jmpi	2109bc8c <altera_avalon_jtag_uart_ioctl>

2109ba64 <altera_avalon_jtag_uart_timeout>:
static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
2109ba64:	20800017 	ldw	r2,0(r4)
2109ba68:	10800104 	addi	r2,r2,4
2109ba6c:	10c00037 	ldwio	r3,0(r2)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
2109ba70:	18c1000c 	andi	r3,r3,1024
2109ba74:	18000a1e 	bne	r3,zero,2109baa0 <altera_avalon_jtag_uart_timeout+0x3c>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
    sp->host_inactive = 0;
  }
  else if (sp->host_inactive < INT_MAX - 2) {
2109ba78:	20800917 	ldw	r2,36(r4)
2109ba7c:	00e00034 	movhi	r3,32768
2109ba80:	18ffff04 	addi	r3,r3,-4
2109ba84:	18800236 	bltu	r3,r2,2109ba90 <altera_avalon_jtag_uart_timeout+0x2c>
    sp->host_inactive++;
2109ba88:	10800044 	addi	r2,r2,1
2109ba8c:	20800915 	stw	r2,36(r4)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
2109ba90:	00800034 	movhi	r2,0
2109ba94:	10978e04 	addi	r2,r2,24120
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
2109ba98:	10800017 	ldw	r2,0(r2)
2109ba9c:	f800283a 	ret

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
2109baa0:	20c00817 	ldw	r3,32(r4)
2109baa4:	18c10014 	ori	r3,r3,1024
2109baa8:	10c00035 	stwio	r3,0(r2)
2109baac:	00800034 	movhi	r2,0
2109bab0:	10978e04 	addi	r2,r2,24120
    sp->host_inactive = 0;
2109bab4:	20000915 	stw	zero,36(r4)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
2109bab8:	10800017 	ldw	r2,0(r2)
2109babc:	f800283a 	ret

2109bac0 <altera_avalon_jtag_uart_irq>:
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
  unsigned int base = sp->base;
2109bac0:	21c00017 	ldw	r7,0(r4)
      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
2109bac4:	02bfff84 	movi	r10,-2
      }

      if (space > 0)
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
2109bac8:	02ffff44 	movi	r11,-3
2109bacc:	3a400104 	addi	r9,r7,4
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
2109bad0:	4a000037 	ldwio	r8,0(r9)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
2109bad4:	4080c00c 	andi	r2,r8,768
2109bad8:	10003726 	beq	r2,zero,2109bbb8 <altera_avalon_jtag_uart_irq+0xf8>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
2109badc:	4080400c 	andi	r2,r8,256
2109bae0:	10001626 	beq	r2,zero,2109bb3c <altera_avalon_jtag_uart_irq+0x7c>
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
2109bae4:	20800a17 	ldw	r2,40(r4)
        if (next == sp->rx_out)
2109bae8:	21800b17 	ldw	r6,44(r4)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
2109baec:	10800044 	addi	r2,r2,1
2109baf0:	1081ffcc 	andi	r2,r2,2047
        if (next == sp->rx_out)
2109baf4:	30800c1e 	bne	r6,r2,2109bb28 <altera_avalon_jtag_uart_irq+0x68>
2109baf8:	00002906 	br	2109bba0 <altera_avalon_jtag_uart_irq+0xe0>
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
2109bafc:	20c00a17 	ldw	r3,40(r4)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
2109bb00:	20800a17 	ldw	r2,40(r4)
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
2109bb04:	20c7883a 	add	r3,r4,r3
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
2109bb08:	10800044 	addi	r2,r2,1
2109bb0c:	1081ffcc 	andi	r2,r2,2047
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
2109bb10:	19400e05 	stb	r5,56(r3)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
2109bb14:	20800a15 	stw	r2,40(r4)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
2109bb18:	20800a17 	ldw	r2,40(r4)
2109bb1c:	10800044 	addi	r2,r2,1
2109bb20:	1081ffcc 	andi	r2,r2,2047
        if (next == sp->rx_out)
2109bb24:	30800326 	beq	r6,r2,2109bb34 <altera_avalon_jtag_uart_irq+0x74>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
2109bb28:	39400037 	ldwio	r5,0(r7)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
2109bb2c:	28a0000c 	andi	r2,r5,32768
2109bb30:	103ff21e 	bne	r2,zero,2109bafc <__flash_rwdata_start+0xffff98b4>

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
2109bb34:	297fffec 	andhi	r5,r5,65535
2109bb38:	2800191e 	bne	r5,zero,2109bba0 <altera_avalon_jtag_uart_irq+0xe0>
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
2109bb3c:	4080800c 	andi	r2,r8,512
2109bb40:	103fe326 	beq	r2,zero,2109bad0 <__flash_rwdata_start+0xffff9888>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
2109bb44:	4010d43a 	srli	r8,r8,16

      while (space > 0 && sp->tx_out != sp->tx_in)
2109bb48:	40000b1e 	bne	r8,zero,2109bb78 <altera_avalon_jtag_uart_irq+0xb8>
2109bb4c:	003fe006 	br	2109bad0 <__flash_rwdata_start+0xffff9888>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
2109bb50:	20800d17 	ldw	r2,52(r4)
2109bb54:	2085883a 	add	r2,r4,r2
2109bb58:	10820e07 	ldb	r2,2104(r2)
2109bb5c:	38800035 	stwio	r2,0(r7)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
2109bb60:	20800d17 	ldw	r2,52(r4)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
2109bb64:	423fffc4 	addi	r8,r8,-1

      while (space > 0 && sp->tx_out != sp->tx_in)
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
2109bb68:	10800044 	addi	r2,r2,1
2109bb6c:	1081ffcc 	andi	r2,r2,2047
2109bb70:	20800d15 	stw	r2,52(r4)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
2109bb74:	403fd626 	beq	r8,zero,2109bad0 <__flash_rwdata_start+0xffff9888>
2109bb78:	20c00d17 	ldw	r3,52(r4)
2109bb7c:	20800c17 	ldw	r2,48(r4)
2109bb80:	18bff31e 	bne	r3,r2,2109bb50 <__flash_rwdata_start+0xffff9908>
      }

      if (space > 0)
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
2109bb84:	20800817 	ldw	r2,32(r4)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
2109bb88:	20c00017 	ldw	r3,0(r4)
      }

      if (space > 0)
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
2109bb8c:	12c4703a 	and	r2,r2,r11
2109bb90:	20800815 	stw	r2,32(r4)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
2109bb94:	18800135 	stwio	r2,4(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
2109bb98:	48800037 	ldwio	r2,0(r9)
2109bb9c:	003fcc06 	br	2109bad0 <__flash_rwdata_start+0xffff9888>
      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
2109bba0:	20800817 	ldw	r2,32(r4)
2109bba4:	1284703a 	and	r2,r2,r10
2109bba8:	20800815 	stw	r2,32(r4)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
2109bbac:	48800035 	stwio	r2,0(r9)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
2109bbb0:	48800037 	ldwio	r2,0(r9)
2109bbb4:	003fe106 	br	2109bb3c <__flash_rwdata_start+0xffff98f4>
2109bbb8:	f800283a 	ret

2109bbbc <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
2109bbbc:	defffd04 	addi	sp,sp,-12
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
2109bbc0:	21c00017 	ldw	r7,0(r4)
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
2109bbc4:	dc000115 	stw	r16,4(sp)
2109bbc8:	dfc00215 	stw	ra,8(sp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
2109bbcc:	00800044 	movi	r2,1
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
2109bbd0:	2021883a 	mov	r16,r4
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
2109bbd4:	20800815 	stw	r2,32(r4)
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
2109bbd8:	2809883a 	mov	r4,r5
2109bbdc:	300b883a 	mov	r5,r6
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
2109bbe0:	38800135 	stwio	r2,4(r7)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
2109bbe4:	018842b4 	movhi	r6,8458
2109bbe8:	31aeb004 	addi	r6,r6,-17728
2109bbec:	800f883a 	mov	r7,r16
2109bbf0:	d8000015 	stw	zero,0(sp)
2109bbf4:	109dadc0 	call	2109dadc <alt_ic_isr_register>
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
2109bbf8:	00800034 	movhi	r2,0
2109bbfc:	10978e04 	addi	r2,r2,24120
2109bc00:	11400017 	ldw	r5,0(r2)
2109bc04:	018842b4 	movhi	r6,8458
2109bc08:	31ae9904 	addi	r6,r6,-17820
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
2109bc0c:	80000915 	stw	zero,36(r16)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
2109bc10:	81000204 	addi	r4,r16,8
2109bc14:	800f883a 	mov	r7,r16
2109bc18:	109d8240 	call	2109d824 <alt_alarm_start>
2109bc1c:	1000030e 	bge	r2,zero,2109bc2c <altera_avalon_jtag_uart_init+0x70>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
2109bc20:	00a00034 	movhi	r2,32768
2109bc24:	10bfffc4 	addi	r2,r2,-1
2109bc28:	80800115 	stw	r2,4(r16)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
2109bc2c:	dfc00217 	ldw	ra,8(sp)
2109bc30:	dc000117 	ldw	r16,4(sp)
2109bc34:	dec00304 	addi	sp,sp,12
2109bc38:	f800283a 	ret

2109bc3c <altera_avalon_jtag_uart_close>:
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
    if (flags & O_NONBLOCK) {
2109bc3c:	2890000c 	andi	r2,r5,16384
2109bc40:	21c00c17 	ldw	r7,48(r4)
2109bc44:	10000426 	beq	r2,zero,2109bc58 <altera_avalon_jtag_uart_close+0x1c>
2109bc48:	00000606 	br	2109bc64 <altera_avalon_jtag_uart_close+0x28>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
2109bc4c:	21800917 	ldw	r6,36(r4)
2109bc50:	20c00117 	ldw	r3,4(r4)
2109bc54:	30c00a2e 	bgeu	r6,r3,2109bc80 <altera_avalon_jtag_uart_close+0x44>
2109bc58:	20c00d17 	ldw	r3,52(r4)
2109bc5c:	19fffb1e 	bne	r3,r7,2109bc4c <__flash_rwdata_start+0xffff9a04>
      return -EWOULDBLOCK; 
    }
  }

  return 0;
}
2109bc60:	f800283a 	ret
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
2109bc64:	20800d17 	ldw	r2,52(r4)
2109bc68:	11c00626 	beq	r2,r7,2109bc84 <altera_avalon_jtag_uart_close+0x48>
2109bc6c:	20c00917 	ldw	r3,36(r4)
2109bc70:	20800117 	ldw	r2,4(r4)
2109bc74:	1880032e 	bgeu	r3,r2,2109bc84 <altera_avalon_jtag_uart_close+0x48>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
2109bc78:	00bffd44 	movi	r2,-11
    }
  }

  return 0;
}
2109bc7c:	f800283a 	ret
2109bc80:	f800283a 	ret
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
2109bc84:	0005883a 	mov	r2,zero
2109bc88:	f800283a 	ret

2109bc8c <altera_avalon_jtag_uart_ioctl>:
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
  int rc = -ENOTTY;

  switch (req)
2109bc8c:	009a8044 	movi	r2,27137
2109bc90:	28800d26 	beq	r5,r2,2109bcc8 <altera_avalon_jtag_uart_ioctl+0x3c>
2109bc94:	009a8084 	movi	r2,27138
2109bc98:	2880091e 	bne	r5,r2,2109bcc0 <altera_avalon_jtag_uart_ioctl+0x34>
    }
    break;

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
2109bc9c:	21400117 	ldw	r5,4(r4)
2109bca0:	00a00034 	movhi	r2,32768
2109bca4:	10bfffc4 	addi	r2,r2,-1
2109bca8:	28800526 	beq	r5,r2,2109bcc0 <altera_avalon_jtag_uart_ioctl+0x34>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
2109bcac:	20c00917 	ldw	r3,36(r4)
      rc = 0;
2109bcb0:	0005883a 	mov	r2,zero

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
2109bcb4:	1947803a 	cmpltu	r3,r3,r5
2109bcb8:	30c00015 	stw	r3,0(r6)
2109bcbc:	f800283a 	ret

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
  int rc = -ENOTTY;
2109bcc0:	00bff9c4 	movi	r2,-25
  default:
    break;
  }

  return rc;
}
2109bcc4:	f800283a 	ret

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
2109bcc8:	20c00117 	ldw	r3,4(r4)
2109bccc:	00a00034 	movhi	r2,32768
2109bcd0:	10bfffc4 	addi	r2,r2,-1
2109bcd4:	18bffa26 	beq	r3,r2,2109bcc0 <__flash_rwdata_start+0xffff9a78>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
2109bcd8:	30800017 	ldw	r2,0(r6)
2109bcdc:	01600034 	movhi	r5,32768
2109bce0:	297fff04 	addi	r5,r5,-4
2109bce4:	10ffff84 	addi	r3,r2,-2
2109bce8:	28c0022e 	bgeu	r5,r3,2109bcf4 <altera_avalon_jtag_uart_ioctl+0x68>
2109bcec:	00a00034 	movhi	r2,32768
2109bcf0:	10bfff84 	addi	r2,r2,-2
2109bcf4:	20800115 	stw	r2,4(r4)
      rc = 0;
2109bcf8:	0005883a 	mov	r2,zero
2109bcfc:	f800283a 	ret

2109bd00 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
2109bd00:	defff604 	addi	sp,sp,-40
2109bd04:	dcc00315 	stw	r19,12(sp)
2109bd08:	dfc00915 	stw	ra,36(sp)
2109bd0c:	df000815 	stw	fp,32(sp)
2109bd10:	ddc00715 	stw	r23,28(sp)
2109bd14:	dd800615 	stw	r22,24(sp)
2109bd18:	dd400515 	stw	r21,20(sp)
2109bd1c:	dd000415 	stw	r20,16(sp)
2109bd20:	dc800215 	stw	r18,8(sp)
2109bd24:	dc400115 	stw	r17,4(sp)
2109bd28:	dc000015 	stw	r16,0(sp)
2109bd2c:	3027883a 	mov	r19,r6
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
2109bd30:	01803e0e 	bge	zero,r6,2109be2c <altera_avalon_jtag_uart_read+0x12c>
2109bd34:	24000b17 	ldw	r16,44(r4)
2109bd38:	2025883a 	mov	r18,r4
2109bd3c:	282b883a 	mov	r21,r5
    /* If we read any data then return it */
    if (ptr != buffer)
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
2109bd40:	3d90000c 	andi	r22,r7,16384
      out = sp->rx_out;

      if (in >= out)
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
2109bd44:	05020004 	movi	r20,2048
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
2109bd48:	a839883a 	mov	fp,r21
2109bd4c:	00000a06 	br	2109bd78 <altera_avalon_jtag_uart_read+0x78>
2109bd50:	9880012e 	bgeu	r19,r2,2109bd58 <altera_avalon_jtag_uart_read+0x58>
2109bd54:	9823883a 	mov	r17,r19

      memcpy(ptr, sp->rx_buf + out, n);
      ptr   += n;
      space -= n;

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
2109bd58:	8c21883a 	add	r16,r17,r16
        break; /* No more data available */

      if (n > space)
        n = space;

      memcpy(ptr, sp->rx_buf + out, n);
2109bd5c:	880d883a 	mov	r6,r17
      ptr   += n;
      space -= n;

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
2109bd60:	8401ffcc 	andi	r16,r16,2047
        break; /* No more data available */

      if (n > space)
        n = space;

      memcpy(ptr, sp->rx_buf + out, n);
2109bd64:	108e1340 	call	2108e134 <memcpy>
      ptr   += n;
      space -= n;
2109bd68:	9c67c83a 	sub	r19,r19,r17

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
2109bd6c:	94000b15 	stw	r16,44(r18)

      if (n > space)
        n = space;

      memcpy(ptr, sp->rx_buf + out, n);
      ptr   += n;
2109bd70:	e479883a 	add	fp,fp,r17
      space -= n;

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);
2109bd74:	04c0090e 	bge	zero,r19,2109bd9c <altera_avalon_jtag_uart_read+0x9c>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
2109bd78:	95c00a17 	ldw	r23,40(r18)
      out = sp->rx_out;

      if (in >= out)
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
2109bd7c:	a405c83a 	sub	r2,r20,r16
    do
    {
      in  = sp->rx_in;
      out = sp->rx_out;

      if (in >= out)
2109bd80:	bc000136 	bltu	r23,r16,2109bd88 <altera_avalon_jtag_uart_read+0x88>
        n = in - out;
2109bd84:	bc05c83a 	sub	r2,r23,r16
        break; /* No more data available */

      if (n > space)
        n = space;

      memcpy(ptr, sp->rx_buf + out, n);
2109bd88:	81400e04 	addi	r5,r16,56
2109bd8c:	e009883a 	mov	r4,fp
2109bd90:	914b883a 	add	r5,r18,r5
2109bd94:	1023883a 	mov	r17,r2
      if (in >= out)
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
2109bd98:	103fed1e 	bne	r2,zero,2109bd50 <__flash_rwdata_start+0xffff9b08>
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
2109bd9c:	e540171e 	bne	fp,r21,2109bdfc <altera_avalon_jtag_uart_read+0xfc>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
2109bda0:	b0000426 	beq	r22,zero,2109bdb4 <altera_avalon_jtag_uart_read+0xb4>
2109bda4:	00002306 	br	2109be34 <altera_avalon_jtag_uart_read+0x134>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
2109bda8:	90c00917 	ldw	r3,36(r18)
2109bdac:	90800117 	ldw	r2,4(r18)
2109bdb0:	1880022e 	bgeu	r3,r2,2109bdbc <altera_avalon_jtag_uart_read+0xbc>
2109bdb4:	90800a17 	ldw	r2,40(r18)
2109bdb8:	15fffb26 	beq	r2,r23,2109bda8 <__flash_rwdata_start+0xffff9b60>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
2109bdbc:	90800a17 	ldw	r2,40(r18)
2109bdc0:	15c00126 	beq	r2,r23,2109bdc8 <altera_avalon_jtag_uart_read+0xc8>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
2109bdc4:	04ffe016 	blt	zero,r19,2109bd48 <__flash_rwdata_start+0xffff9b00>
  if (ptr != buffer)
    return ptr - buffer;
  else if (flags & O_NONBLOCK)
    return -EWOULDBLOCK;
  else
    return -EIO;
2109bdc8:	00bffec4 	movi	r2,-5
}
2109bdcc:	dfc00917 	ldw	ra,36(sp)
2109bdd0:	df000817 	ldw	fp,32(sp)
2109bdd4:	ddc00717 	ldw	r23,28(sp)
2109bdd8:	dd800617 	ldw	r22,24(sp)
2109bddc:	dd400517 	ldw	r21,20(sp)
2109bde0:	dd000417 	ldw	r20,16(sp)
2109bde4:	dcc00317 	ldw	r19,12(sp)
2109bde8:	dc800217 	ldw	r18,8(sp)
2109bdec:	dc400117 	ldw	r17,4(sp)
2109bdf0:	dc000017 	ldw	r16,0(sp)
2109bdf4:	dec00a04 	addi	sp,sp,40
2109bdf8:	f800283a 	ret
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109bdfc:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109be00:	00bfff84 	movi	r2,-2
2109be04:	1884703a 	and	r2,r3,r2
2109be08:	1001703a 	wrctl	status,r2

  if (ptr != buffer)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
2109be0c:	90800817 	ldw	r2,32(r18)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
2109be10:	91000017 	ldw	r4,0(r18)

  if (ptr != buffer)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
2109be14:	10800054 	ori	r2,r2,1
2109be18:	90800815 	stw	r2,32(r18)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
2109be1c:	20800135 	stwio	r2,4(r4)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109be20:	1801703a 	wrctl	status,r3
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
    return ptr - buffer;
2109be24:	e545c83a 	sub	r2,fp,r21
2109be28:	003fe806 	br	2109bdcc <__flash_rwdata_start+0xffff9b84>
2109be2c:	39d0000c 	andi	r7,r7,16384
  else if (flags & O_NONBLOCK)
2109be30:	383fe526 	beq	r7,zero,2109bdc8 <__flash_rwdata_start+0xffff9b80>
    return -EWOULDBLOCK;
2109be34:	00bffd44 	movi	r2,-11
2109be38:	003fe406 	br	2109bdcc <__flash_rwdata_start+0xffff9b84>

2109be3c <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
2109be3c:	defff604 	addi	sp,sp,-40
2109be40:	df000815 	stw	fp,32(sp)
2109be44:	dc000015 	stw	r16,0(sp)
2109be48:	dfc00915 	stw	ra,36(sp)
2109be4c:	ddc00715 	stw	r23,28(sp)
2109be50:	dd800615 	stw	r22,24(sp)
2109be54:	dd400515 	stw	r21,20(sp)
2109be58:	dd000415 	stw	r20,16(sp)
2109be5c:	dcc00315 	stw	r19,12(sp)
2109be60:	dc800215 	stw	r18,8(sp)
2109be64:	dc400115 	stw	r17,4(sp)
2109be68:	3039883a 	mov	fp,r6
2109be6c:	2021883a 	mov	r16,r4
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
2109be70:	01804a0e 	bge	zero,r6,2109bf9c <altera_avalon_jtag_uart_write+0x160>
2109be74:	2827883a 	mov	r19,r5
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
2109be78:	3c50000c 	andi	r17,r7,16384
2109be7c:	2829883a 	mov	r20,r5
      if (in < out)
        n = out - 1 - in;
      else if (out > 0)
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
2109be80:	0541ffc4 	movi	r21,2047
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109be84:	04bfff84 	movi	r18,-2
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
2109be88:	85c00c17 	ldw	r23,48(r16)
      out = sp->tx_out;
2109be8c:	80c00d17 	ldw	r3,52(r16)

      if (in < out)
2109be90:	b8c03c2e 	bgeu	r23,r3,2109bf84 <altera_avalon_jtag_uart_write+0x148>
2109be94:	1dbfffc4 	addi	r22,r3,-1
        n = out - 1 - in;
2109be98:	b5edc83a 	sub	r22,r22,r23
      else if (out > 0)
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
2109be9c:	b0002526 	beq	r22,zero,2109bf34 <altera_avalon_jtag_uart_write+0xf8>
2109bea0:	e580012e 	bgeu	fp,r22,2109bea8 <altera_avalon_jtag_uart_write+0x6c>
2109bea4:	e02d883a 	mov	r22,fp
        break;

      if (n > count)
        n = count;

      memcpy(sp->tx_buf + in, ptr, n);
2109bea8:	b9020e04 	addi	r4,r23,2104
      ptr   += n;
      count -= n;

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
2109beac:	b5ef883a 	add	r23,r22,r23
        break;

      if (n > count)
        n = count;

      memcpy(sp->tx_buf + in, ptr, n);
2109beb0:	a00b883a 	mov	r5,r20
2109beb4:	8109883a 	add	r4,r16,r4
2109beb8:	b00d883a 	mov	r6,r22
      ptr   += n;
      count -= n;

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
2109bebc:	bdc1ffcc 	andi	r23,r23,2047
        break;

      if (n > count)
        n = count;

      memcpy(sp->tx_buf + in, ptr, n);
2109bec0:	108e1340 	call	2108e134 <memcpy>
      ptr   += n;
      count -= n;
2109bec4:	e5b9c83a 	sub	fp,fp,r22

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
2109bec8:	85c00c15 	stw	r23,48(r16)

      if (n > count)
        n = count;

      memcpy(sp->tx_buf + in, ptr, n);
      ptr   += n;
2109becc:	a5a9883a 	add	r20,r20,r22
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
2109bed0:	073fed16 	blt	zero,fp,2109be88 <__flash_rwdata_start+0xffff9c40>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109bed4:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109bed8:	00bfff84 	movi	r2,-2
2109bedc:	1884703a 	and	r2,r3,r2
2109bee0:	1001703a 	wrctl	status,r2
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
2109bee4:	80800817 	ldw	r2,32(r16)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
2109bee8:	81000017 	ldw	r4,0(r16)
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
2109beec:	10800094 	ori	r2,r2,2
2109bef0:	80800815 	stw	r2,32(r16)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
2109bef4:	20800135 	stwio	r2,4(r4)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109bef8:	1801703a 	wrctl	status,r3
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
2109befc:	9d003226 	beq	r19,r20,2109bfc8 <altera_avalon_jtag_uart_write+0x18c>
    return ptr - start;
2109bf00:	a4c5c83a 	sub	r2,r20,r19
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
}
2109bf04:	dfc00917 	ldw	ra,36(sp)
2109bf08:	df000817 	ldw	fp,32(sp)
2109bf0c:	ddc00717 	ldw	r23,28(sp)
2109bf10:	dd800617 	ldw	r22,24(sp)
2109bf14:	dd400517 	ldw	r21,20(sp)
2109bf18:	dd000417 	ldw	r20,16(sp)
2109bf1c:	dcc00317 	ldw	r19,12(sp)
2109bf20:	dc800217 	ldw	r18,8(sp)
2109bf24:	dc400117 	ldw	r17,4(sp)
2109bf28:	dc000017 	ldw	r16,0(sp)
2109bf2c:	dec00a04 	addi	sp,sp,40
2109bf30:	f800283a 	ret
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109bf34:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109bf38:	2484703a 	and	r2,r4,r18
2109bf3c:	1001703a 	wrctl	status,r2
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
2109bf40:	80800817 	ldw	r2,32(r16)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
2109bf44:	81400017 	ldw	r5,0(r16)
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
2109bf48:	10800094 	ori	r2,r2,2
2109bf4c:	80800815 	stw	r2,32(r16)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
2109bf50:	28800135 	stwio	r2,4(r5)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109bf54:	2001703a 	wrctl	status,r4
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
2109bf58:	88001e1e 	bne	r17,zero,2109bfd4 <altera_avalon_jtag_uart_write+0x198>
2109bf5c:	81000917 	ldw	r4,36(r16)
2109bf60:	00000206 	br	2109bf6c <altera_avalon_jtag_uart_write+0x130>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
2109bf64:	80800117 	ldw	r2,4(r16)
2109bf68:	2080022e 	bgeu	r4,r2,2109bf74 <altera_avalon_jtag_uart_write+0x138>
2109bf6c:	80800d17 	ldw	r2,52(r16)
2109bf70:	18bffc26 	beq	r3,r2,2109bf64 <__flash_rwdata_start+0xffff9d1c>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
2109bf74:	203fc426 	beq	r4,zero,2109be88 <__flash_rwdata_start+0xffff9c40>
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
2109bf78:	9d3fe11e 	bne	r19,r20,2109bf00 <__flash_rwdata_start+0xffff9cb8>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
2109bf7c:	00bffec4 	movi	r2,-5
2109bf80:	003fe006 	br	2109bf04 <__flash_rwdata_start+0xffff9cbc>
      in  = sp->tx_in;
      out = sp->tx_out;

      if (in < out)
        n = out - 1 - in;
      else if (out > 0)
2109bf84:	18000326 	beq	r3,zero,2109bf94 <altera_avalon_jtag_uart_write+0x158>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
2109bf88:	00820004 	movi	r2,2048
2109bf8c:	15edc83a 	sub	r22,r2,r23
2109bf90:	003fc206 	br	2109be9c <__flash_rwdata_start+0xffff9c54>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
2109bf94:	adedc83a 	sub	r22,r21,r23
2109bf98:	003fc006 	br	2109be9c <__flash_rwdata_start+0xffff9c54>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109bf9c:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109bfa0:	00bfff84 	movi	r2,-2
2109bfa4:	1884703a 	and	r2,r3,r2
2109bfa8:	1001703a 	wrctl	status,r2
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
2109bfac:	20800817 	ldw	r2,32(r4)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
2109bfb0:	21000017 	ldw	r4,0(r4)
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
2109bfb4:	10800094 	ori	r2,r2,2
2109bfb8:	80800815 	stw	r2,32(r16)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
2109bfbc:	20800135 	stwio	r2,4(r4)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109bfc0:	1801703a 	wrctl	status,r3
2109bfc4:	3c50000c 	andi	r17,r7,16384
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
    return ptr - start;
  else if (flags & O_NONBLOCK)
2109bfc8:	883fec26 	beq	r17,zero,2109bf7c <__flash_rwdata_start+0xffff9d34>
    return -EWOULDBLOCK;
2109bfcc:	00bffd44 	movi	r2,-11
2109bfd0:	003fcc06 	br	2109bf04 <__flash_rwdata_start+0xffff9cbc>
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
2109bfd4:	9d3fca1e 	bne	r19,r20,2109bf00 <__flash_rwdata_start+0xffff9cb8>
2109bfd8:	003ffc06 	br	2109bfcc <__flash_rwdata_start+0xffff9d84>

2109bfdc <altera_avalon_mailbox_simple_rx_isr>:
{
    altera_avalon_mailbox_dev *dev = (altera_avalon_mailbox_dev*) context;
    alt_irq_context cpu_sr;
    alt_u32 inbox[2];

    inbox[1] = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST));
2109bfdc:	20800a17 	ldw	r2,40(r4)
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_mailbox_simple_rx_isr(void *context)
#else
static void altera_avalon_mailbox_simple_rx_isr(void *context, alt_u32 id)
#endif
{
2109bfe0:	defffc04 	addi	sp,sp,-16
2109bfe4:	dfc00315 	stw	ra,12(sp)
2109bfe8:	dc000215 	stw	r16,8(sp)
    altera_avalon_mailbox_dev *dev = (altera_avalon_mailbox_dev*) context;
    alt_irq_context cpu_sr;
    alt_u32 inbox[2];

    inbox[1] = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST));
2109bfec:	10c00137 	ldwio	r3,4(r2)
2109bff0:	d8c00115 	stw	r3,4(sp)
    inbox[0] = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_CMD_OFST));
2109bff4:	10800037 	ldwio	r2,0(r2)

    /*
     * Other interrupts are explicitly disabled if callbacks are registered
     * because there is no guarantee that they are preemption-safe.
     */
    if (dev->rx_cb)
2109bff8:	20c00e17 	ldw	r3,56(r4)
    altera_avalon_mailbox_dev *dev = (altera_avalon_mailbox_dev*) context;
    alt_irq_context cpu_sr;
    alt_u32 inbox[2];

    inbox[1] = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST));
    inbox[0] = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_CMD_OFST));
2109bffc:	d8800015 	stw	r2,0(sp)

    /*
     * Other interrupts are explicitly disabled if callbacks are registered
     * because there is no guarantee that they are preemption-safe.
     */
    if (dev->rx_cb)
2109c000:	18000726 	beq	r3,zero,2109c020 <altera_avalon_mailbox_simple_rx_isr+0x44>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109c004:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109c008:	00bfff84 	movi	r2,-2
2109c00c:	8084703a 	and	r2,r16,r2
2109c010:	1001703a 	wrctl	status,r2
    {
        cpu_sr = alt_irq_disable_all();
        (dev->rx_cb)(inbox);
2109c014:	d809883a 	mov	r4,sp
2109c018:	183ee83a 	callr	r3
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109c01c:	8001703a 	wrctl	status,r16
        alt_irq_enable_all(cpu_sr);
    }
}
2109c020:	dfc00317 	ldw	ra,12(sp)
2109c024:	dc000217 	ldw	r16,8(sp)
2109c028:	dec00404 	addi	sp,sp,16
2109c02c:	f800283a 	ret

2109c030 <altera_avalon_mailbox_simple_tx_isr>:
    alt_u32 data;
    alt_irq_context cpu_sr;
    alt_u32 *message = dev->mbox_msg;

    /* Mask mailbox interrupt */
    data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST) &
2109c030:	20800a17 	ldw	r2,40(r4)
{
    altera_avalon_mailbox_dev *dev = (altera_avalon_mailbox_dev*) context;
    int status = 0;
    alt_u32 data;
    alt_irq_context cpu_sr;
    alt_u32 *message = dev->mbox_msg;
2109c034:	20c01017 	ldw	r3,64(r4)

    /* Mask mailbox interrupt */
    data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST) &
2109c038:	10800304 	addi	r2,r2,12
2109c03c:	11800037 	ldwio	r6,0(r2)
2109c040:	017fff44 	movi	r5,-3
2109c044:	314a703a 	and	r5,r6,r5
               (~ALTERA_AVALON_MAILBOX_SIMPLE_INTR_SPACE_MSK);
    IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);
2109c048:	11400035 	stwio	r5,0(r2)

    if (message != NULL)
2109c04c:	18001e26 	beq	r3,zero,2109c0c8 <altera_avalon_mailbox_simple_tx_isr+0x98>
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_mailbox_simple_tx_isr(void *context)
#else
static void altera_avalon_mailbox_simple_tx_isr(void *context, alt_u32 id)
#endif
{
2109c050:	defffd04 	addi	sp,sp,-12
2109c054:	dc000015 	stw	r16,0(sp)
    IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);

    if (message != NULL)
    {
        /* Post out message requested */
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST, message[1]);
2109c058:	20800a17 	ldw	r2,40(r4)
2109c05c:	2021883a 	mov	r16,r4
2109c060:	19000117 	ldw	r4,4(r3)
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_mailbox_simple_tx_isr(void *context)
#else
static void altera_avalon_mailbox_simple_tx_isr(void *context, alt_u32 id)
#endif
{
2109c064:	dfc00215 	stw	ra,8(sp)
2109c068:	dc400115 	stw	r17,4(sp)
    IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);

    if (message != NULL)
    {
        /* Post out message requested */
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST, message[1]);
2109c06c:	11000135 	stwio	r4,4(r2)
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_CMD_OFST, message[0]);
2109c070:	80800a17 	ldw	r2,40(r16)
2109c074:	19000017 	ldw	r4,0(r3)
2109c078:	11000035 	stwio	r4,0(r2)
    /*
     * Other interrupts are explicitly disabled if callbacks are registered
     * because there is no guarantee that they are preemption-safe.
     */
        status = (IORD_ALTERA_AVALON_MAILBOX_STS(dev->base)
2109c07c:	80800a17 	ldw	r2,40(r16)
2109c080:	11400237 	ldwio	r5,8(r2)
        		  & ALTERA_AVALON_MAILBOX_SIMPLE_STS_FULL_MSK) >> 1;
        if (dev->tx_cb)
2109c084:	81800d17 	ldw	r6,52(r16)
2109c088:	30000926 	beq	r6,zero,2109c0b0 <altera_avalon_mailbox_simple_tx_isr+0x80>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109c08c:	0023303a 	rdctl	r17,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109c090:	00bfff84 	movi	r2,-2
2109c094:	8884703a 	and	r2,r17,r2
2109c098:	1001703a 	wrctl	status,r2
    /*
     * Other interrupts are explicitly disabled if callbacks are registered
     * because there is no guarantee that they are preemption-safe.
     */
        status = (IORD_ALTERA_AVALON_MAILBOX_STS(dev->base)
        		  & ALTERA_AVALON_MAILBOX_SIMPLE_STS_FULL_MSK) >> 1;
2109c09c:	2940008c 	andi	r5,r5,2
        if (dev->tx_cb)
        {
            cpu_sr = alt_irq_disable_all();
  	        (dev->tx_cb)(message, status);
2109c0a0:	280ad07a 	srli	r5,r5,1
2109c0a4:	1809883a 	mov	r4,r3
2109c0a8:	303ee83a 	callr	r6
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109c0ac:	8801703a 	wrctl	status,r17
            alt_irq_enable_all(cpu_sr);
        }
        /* Clear mailbox message to NULL after message being posted */
        dev->mbox_msg = NULL;
2109c0b0:	80001015 	stw	zero,64(r16)
        dev->lock = 0;
2109c0b4:	80001105 	stb	zero,68(r16)
    }
}
2109c0b8:	dfc00217 	ldw	ra,8(sp)
2109c0bc:	dc400117 	ldw	r17,4(sp)
2109c0c0:	dc000017 	ldw	r16,0(sp)
2109c0c4:	dec00304 	addi	sp,sp,12
2109c0c8:	f800283a 	ret

2109c0cc <altera_avalon_mailbox_simple_init>:
 * Altera avalon mailbox init
 * Initialize mailbox device and identify sender/receiver mailbox
 */
void altera_avalon_mailbox_simple_init (altera_avalon_mailbox_dev *dev,
		                               int intr_id, int irq)
{
2109c0cc:	defffc04 	addi	sp,sp,-16
2109c0d0:	dc400115 	stw	r17,4(sp)
2109c0d4:	2823883a 	mov	r17,r5
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_mailbox_simple_list);
2109c0d8:	d1601704 	addi	r5,gp,-32676
 * Altera avalon mailbox init
 * Initialize mailbox device and identify sender/receiver mailbox
 */
void altera_avalon_mailbox_simple_init (altera_avalon_mailbox_dev *dev,
		                               int intr_id, int irq)
{
2109c0dc:	dc800215 	stw	r18,8(sp)
2109c0e0:	dc000015 	stw	r16,0(sp)
2109c0e4:	3025883a 	mov	r18,r6
2109c0e8:	2021883a 	mov	r16,r4
2109c0ec:	dfc00315 	stw	ra,12(sp)
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_mailbox_simple_list);
2109c0f0:	109d9180 	call	2109d918 <alt_dev_llist_insert>
static void altera_avalon_mailbox_identify (altera_avalon_mailbox_dev *dev)
{
    /* Random signature to test mailbox ownership */
    alt_u32 magic_num = 0x3A11B045;

    IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST, magic_num);
2109c0f4:	80800a17 	ldw	r2,40(r16)
2109c0f8:	00ce84b4 	movhi	r3,14866
2109c0fc:	18ec1144 	addi	r3,r3,-20411
void altera_avalon_mailbox_simple_init (altera_avalon_mailbox_dev *dev,
		                               int intr_id, int irq)
{
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_mailbox_simple_list);
    
    dev->mailbox_irq    = irq;
2109c100:	84800b15 	stw	r18,44(r16)
    dev->mailbox_intr_ctrl_id = intr_id;
2109c104:	84400c15 	stw	r17,48(r16)
    dev->rx_cb = NULL;
2109c108:	80000e15 	stw	zero,56(r16)
    dev->tx_cb = NULL;
2109c10c:	80000d15 	stw	zero,52(r16)
    dev->mbox_msg = NULL;
2109c110:	80001015 	stw	zero,64(r16)
static void altera_avalon_mailbox_identify (altera_avalon_mailbox_dev *dev)
{
    /* Random signature to test mailbox ownership */
    alt_u32 magic_num = 0x3A11B045;

    IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST, magic_num);
2109c114:	10c00135 	stwio	r3,4(r2)
    if((IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST)) == magic_num)
2109c118:	80800a17 	ldw	r2,40(r16)
2109c11c:	10800104 	addi	r2,r2,4
2109c120:	11000037 	ldwio	r4,0(r2)
2109c124:	20c00826 	beq	r4,r3,2109c148 <altera_avalon_mailbox_simple_init+0x7c>
        dev-> mbox_type = MBOX_TX;
        /* Clear message_ptr to default */
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST, 0x0);
    } else
    {
	    dev->mbox_type = MBOX_RX;
2109c128:	00800044 	movi	r2,1
2109c12c:	80800f15 	stw	r2,60(r16)
    dev->mbox_msg = NULL;
    
    ALT_SEM_CREATE (&dev->write_lock, 1);

    altera_avalon_mailbox_identify(dev);
}
2109c130:	dfc00317 	ldw	ra,12(sp)
2109c134:	dc800217 	ldw	r18,8(sp)
2109c138:	dc400117 	ldw	r17,4(sp)
2109c13c:	dc000017 	ldw	r16,0(sp)
2109c140:	dec00404 	addi	sp,sp,16
2109c144:	f800283a 	ret
    alt_u32 magic_num = 0x3A11B045;

    IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST, magic_num);
    if((IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST)) == magic_num)
    {
        dev-> mbox_type = MBOX_TX;
2109c148:	80000f15 	stw	zero,60(r16)
        /* Clear message_ptr to default */
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST, 0x0);
2109c14c:	10000035 	stwio	zero,0(r2)
2109c150:	003ff706 	br	2109c130 <__flash_rwdata_start+0xffff9ee8>

2109c154 <altera_avalon_mailbox_open>:
 * Search the list of registered mailboxes for one with the supplied name.
 * The return value will be NULL on failure, and non-NULL otherwise.
 */
altera_avalon_mailbox_dev* altera_avalon_mailbox_open (const char *name,
		altera_mailbox_tx_cb tx_callback, altera_mailbox_rx_cb rx_callback)
{
2109c154:	defffb04 	addi	sp,sp,-20
2109c158:	dc400215 	stw	r17,8(sp)
2109c15c:	2823883a 	mov	r17,r5
    altera_avalon_mailbox_dev *dev;
    alt_u32 data;

    /* Find requested device */
    dev = (altera_avalon_mailbox_dev*) alt_find_dev (name, &alt_mailbox_simple_list);
2109c160:	d1601704 	addi	r5,gp,-32676
 * Search the list of registered mailboxes for one with the supplied name.
 * The return value will be NULL on failure, and non-NULL otherwise.
 */
altera_avalon_mailbox_dev* altera_avalon_mailbox_open (const char *name,
		altera_mailbox_tx_cb tx_callback, altera_mailbox_rx_cb rx_callback)
{
2109c164:	dc800315 	stw	r18,12(sp)
2109c168:	dc000115 	stw	r16,4(sp)
2109c16c:	dfc00415 	stw	ra,16(sp)
2109c170:	3025883a 	mov	r18,r6
    altera_avalon_mailbox_dev *dev;
    alt_u32 data;

    /* Find requested device */
    dev = (altera_avalon_mailbox_dev*) alt_find_dev (name, &alt_mailbox_simple_list);
2109c174:	109da580 	call	2109da58 <alt_find_dev>
2109c178:	1021883a 	mov	r16,r2
    if (dev == NULL)
2109c17c:	10002526 	beq	r2,zero,2109c214 <altera_avalon_mailbox_open+0xc0>
    {
        return NULL;
    }

    /* Mask mailbox interrupt before ISR is being registered. */
    data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST);
2109c180:	10800a17 	ldw	r2,40(r2)
2109c184:	10800304 	addi	r2,r2,12
2109c188:	11000037 	ldwio	r4,0(r2)
    if (dev->mbox_type == MBOX_TX) {
2109c18c:	80c00f17 	ldw	r3,60(r16)
2109c190:	18002226 	beq	r3,zero,2109c21c <altera_avalon_mailbox_open+0xc8>
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, \
            (data & ~(ALTERA_AVALON_MAILBOX_SIMPLE_INTR_SPACE_MSK)));
    }
    if (dev->mbox_type == MBOX_RX) {
2109c194:	00800044 	movi	r2,1
2109c198:	18802626 	beq	r3,r2,2109c234 <altera_avalon_mailbox_open+0xe0>
    }

    /* If IRQ not connected, return device pointer without ISR register,
     * in polling mode.
     */
    if (dev->mailbox_irq == ALT_IRQ_NOT_CONNECTED)
2109c19c:	81400b17 	ldw	r5,44(r16)
2109c1a0:	00ffffc4 	movi	r3,-1
2109c1a4:	28c00f26 	beq	r5,r3,2109c1e4 <altera_avalon_mailbox_open+0x90>
        return dev;

    /* For IRQ connected case */

    if ((tx_callback == NULL) && (rx_callback == NULL))
2109c1a8:	88002726 	beq	r17,zero,2109c248 <altera_avalon_mailbox_open+0xf4>
    }

    /* Ensure user correctly use the mailbox
     * Return - Null if wrong direction set
     */
    if (((dev->mbox_type == MBOX_TX) && (rx_callback != NULL)) ||
2109c1ac:	80c00f17 	ldw	r3,60(r16)
2109c1b0:	1800131e 	bne	r3,zero,2109c200 <altera_avalon_mailbox_open+0xac>
2109c1b4:	9000171e 	bne	r18,zero,2109c214 <altera_avalon_mailbox_open+0xc0>

    /* Register Mailbox's ISR */
    if (dev->mbox_type == MBOX_TX)
    {
    #ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_ic_isr_register(dev->mailbox_intr_ctrl_id, dev->mailbox_irq, altera_avalon_mailbox_simple_tx_isr,
2109c1b8:	81000c17 	ldw	r4,48(r16)
        return NULL;

    /* IRQ is valid register callback
     * to current mailbox device
     */
    dev->tx_cb  = tx_callback;
2109c1bc:	84400d15 	stw	r17,52(r16)
    dev->rx_cb  = rx_callback;
2109c1c0:	80000e15 	stw	zero,56(r16)

    /* Register Mailbox's ISR */
    if (dev->mbox_type == MBOX_TX)
    {
    #ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_ic_isr_register(dev->mailbox_intr_ctrl_id, dev->mailbox_irq, altera_avalon_mailbox_simple_tx_isr,
2109c1c4:	018842b4 	movhi	r6,8458
2109c1c8:	31b00c04 	addi	r6,r6,-16336
2109c1cc:	d8000015 	stw	zero,0(sp)
2109c1d0:	800f883a 	mov	r7,r16
2109c1d4:	109dadc0 	call	2109dadc <alt_ic_isr_register>
    #else
        alt_irq_register(dev->mailbox_irq, dev, altera_avalon_mailbox_simple_tx_isr);
    #endif
    }
  
    if (dev->mbox_type == MBOX_RX)
2109c1d8:	80c00f17 	ldw	r3,60(r16)
2109c1dc:	00800044 	movi	r2,1
2109c1e0:	18802d26 	beq	r3,r2,2109c298 <altera_avalon_mailbox_open+0x144>

    /* IRQ is valid register callback
     * to current mailbox device
     */
    dev->tx_cb  = tx_callback;
    dev->rx_cb  = rx_callback;
2109c1e4:	8005883a 	mov	r2,r16
        data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST) |
  	             (ALTERA_AVALON_MAILBOX_SIMPLE_INTR_PEN_MSK);
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);
    }
    return dev;
}
2109c1e8:	dfc00417 	ldw	ra,16(sp)
2109c1ec:	dc800317 	ldw	r18,12(sp)
2109c1f0:	dc400217 	ldw	r17,8(sp)
2109c1f4:	dc000117 	ldw	r16,4(sp)
2109c1f8:	dec00504 	addi	sp,sp,20
2109c1fc:	f800283a 	ret
    }

    /* Ensure user correctly use the mailbox
     * Return - Null if wrong direction set
     */
    if (((dev->mbox_type == MBOX_TX) && (rx_callback != NULL)) ||
2109c200:	00800044 	movi	r2,1
2109c204:	18800326 	beq	r3,r2,2109c214 <altera_avalon_mailbox_open+0xc0>
        return NULL;

    /* IRQ is valid register callback
     * to current mailbox device
     */
    dev->tx_cb  = tx_callback;
2109c208:	84400d15 	stw	r17,52(r16)
    dev->rx_cb  = rx_callback;
2109c20c:	84800e15 	stw	r18,56(r16)
2109c210:	003ff406 	br	2109c1e4 <__flash_rwdata_start+0xffff9f9c>

    /* Find requested device */
    dev = (altera_avalon_mailbox_dev*) alt_find_dev (name, &alt_mailbox_simple_list);
    if (dev == NULL)
    {
        return NULL;
2109c214:	0005883a 	mov	r2,zero
2109c218:	003ff306 	br	2109c1e8 <__flash_rwdata_start+0xffff9fa0>
    }

    /* Mask mailbox interrupt before ISR is being registered. */
    data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST);
    if (dev->mbox_type == MBOX_TX) {
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, \
2109c21c:	00ffff44 	movi	r3,-3
2109c220:	20c6703a 	and	r3,r4,r3
2109c224:	10c00035 	stwio	r3,0(r2)
2109c228:	80c00f17 	ldw	r3,60(r16)
            (data & ~(ALTERA_AVALON_MAILBOX_SIMPLE_INTR_SPACE_MSK)));
    }
    if (dev->mbox_type == MBOX_RX) {
2109c22c:	00800044 	movi	r2,1
2109c230:	18bfda1e 	bne	r3,r2,2109c19c <__flash_rwdata_start+0xffff9f54>
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, \
2109c234:	80c00a17 	ldw	r3,40(r16)
2109c238:	00bfff84 	movi	r2,-2
2109c23c:	2088703a 	and	r4,r4,r2
2109c240:	19000335 	stwio	r4,12(r3)
2109c244:	003fd506 	br	2109c19c <__flash_rwdata_start+0xffff9f54>
    if (dev->mailbox_irq == ALT_IRQ_NOT_CONNECTED)
        return dev;

    /* For IRQ connected case */

    if ((tx_callback == NULL) && (rx_callback == NULL))
2109c248:	903fe626 	beq	r18,zero,2109c1e4 <__flash_rwdata_start+0xffff9f9c>
    }

    /* Ensure user correctly use the mailbox
     * Return - Null if wrong direction set
     */
    if (((dev->mbox_type == MBOX_TX) && (rx_callback != NULL)) ||
2109c24c:	80c00f17 	ldw	r3,60(r16)
2109c250:	183ff026 	beq	r3,zero,2109c214 <__flash_rwdata_start+0xffff9fcc>
2109c254:	01000044 	movi	r4,1
2109c258:	193feb1e 	bne	r3,r4,2109c208 <__flash_rwdata_start+0xffff9fc0>
        return NULL;

    /* IRQ is valid register callback
     * to current mailbox device
     */
    dev->tx_cb  = tx_callback;
2109c25c:	80000d15 	stw	zero,52(r16)
    dev->rx_cb  = rx_callback;
2109c260:	84800e15 	stw	r18,56(r16)
    }
  
    if (dev->mbox_type == MBOX_RX)
    {
    #ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_ic_isr_register(dev->mailbox_intr_ctrl_id, dev->mailbox_irq, altera_avalon_mailbox_simple_rx_isr,
2109c264:	81000c17 	ldw	r4,48(r16)
2109c268:	018842b4 	movhi	r6,8458
2109c26c:	31aff704 	addi	r6,r6,-16420
2109c270:	d8000015 	stw	zero,0(sp)
2109c274:	800f883a 	mov	r7,r16
2109c278:	109dadc0 	call	2109dadc <alt_ic_isr_register>
                            dev, NULL);
    #else
        alt_irq_register(dev->mailbox_irq, dev, altera_avalon_mailbox_simple_rx_isr);
    #endif
        /* Enable Receiver interrupt to listen mode */
        data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST) |
2109c27c:	80800a17 	ldw	r2,40(r16)
2109c280:	10800304 	addi	r2,r2,12
2109c284:	10c00037 	ldwio	r3,0(r2)
2109c288:	18c00054 	ori	r3,r3,1
  	             (ALTERA_AVALON_MAILBOX_SIMPLE_INTR_PEN_MSK);
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);
2109c28c:	10c00035 	stwio	r3,0(r2)
2109c290:	8005883a 	mov	r2,r16
2109c294:	003fd406 	br	2109c1e8 <__flash_rwdata_start+0xffff9fa0>
2109c298:	81400b17 	ldw	r5,44(r16)
2109c29c:	003ff106 	br	2109c264 <__flash_rwdata_start+0xffffa01c>

2109c2a0 <altera_avalon_mailbox_close>:
 * Disable mailbox interrupt and irq
 */
void altera_avalon_mailbox_close (altera_avalon_mailbox_dev *dev)
{
    alt_u32 data;
    if ((dev != NULL) && (dev->mailbox_irq != ALT_IRQ_NOT_CONNECTED))
2109c2a0:	20001526 	beq	r4,zero,2109c2f8 <altera_avalon_mailbox_close+0x58>
2109c2a4:	21400b17 	ldw	r5,44(r4)
2109c2a8:	00bfffc4 	movi	r2,-1
2109c2ac:	28801226 	beq	r5,r2,2109c2f8 <altera_avalon_mailbox_close+0x58>
    {
        /* Mask interrupt */
        if (dev->mbox_type == MBOX_TX)
2109c2b0:	20800f17 	ldw	r2,60(r4)
/*
 * altera_avalon_mailbox_close
 * Disable mailbox interrupt and irq
 */
void altera_avalon_mailbox_close (altera_avalon_mailbox_dev *dev)
{
2109c2b4:	defffd04 	addi	sp,sp,-12
2109c2b8:	dc000115 	stw	r16,4(sp)
2109c2bc:	dfc00215 	stw	ra,8(sp)
2109c2c0:	2021883a 	mov	r16,r4
    alt_u32 data;
    if ((dev != NULL) && (dev->mailbox_irq != ALT_IRQ_NOT_CONNECTED))
    {
        /* Mask interrupt */
        if (dev->mbox_type == MBOX_TX)
2109c2c4:	10000d26 	beq	r2,zero,2109c2fc <altera_avalon_mailbox_close+0x5c>
        {
            data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST) &
                       (~ALTERA_AVALON_MAILBOX_SIMPLE_INTR_SPACE_MSK);
            IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);
        }
        if (dev->mbox_type == MBOX_RX)
2109c2c8:	00c00044 	movi	r3,1
2109c2cc:	10c01826 	beq	r2,r3,2109c330 <altera_avalon_mailbox_close+0x90>
  
        /* De-register mailbox irq) */
        if (dev->mailbox_irq != ALT_IRQ_NOT_CONNECTED)
        {
        #ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
            alt_ic_isr_register(dev->mailbox_intr_ctrl_id, dev->mailbox_irq, NULL,
2109c2d0:	81000c17 	ldw	r4,48(r16)
2109c2d4:	000d883a 	mov	r6,zero
2109c2d8:	d8000015 	stw	zero,0(sp)
2109c2dc:	800f883a 	mov	r7,r16
2109c2e0:	109dadc0 	call	2109dadc <alt_ic_isr_register>
        #else
            alt_irq_register(dev->mailbox_irq, dev, NULL);
        #endif
        }
        /* De-registering callback to mailbox */
        dev->tx_cb  = NULL;
2109c2e4:	80000d15 	stw	zero,52(r16)
        dev->rx_cb  = NULL;
2109c2e8:	80000e15 	stw	zero,56(r16)
    }
}
2109c2ec:	dfc00217 	ldw	ra,8(sp)
2109c2f0:	dc000117 	ldw	r16,4(sp)
2109c2f4:	dec00304 	addi	sp,sp,12
2109c2f8:	f800283a 	ret
    if ((dev != NULL) && (dev->mailbox_irq != ALT_IRQ_NOT_CONNECTED))
    {
        /* Mask interrupt */
        if (dev->mbox_type == MBOX_TX)
        {
            data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST) &
2109c2fc:	20800a17 	ldw	r2,40(r4)
2109c300:	10800304 	addi	r2,r2,12
2109c304:	11000037 	ldwio	r4,0(r2)
2109c308:	00ffff44 	movi	r3,-3
2109c30c:	20c6703a 	and	r3,r4,r3
                       (~ALTERA_AVALON_MAILBOX_SIMPLE_INTR_SPACE_MSK);
            IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);
2109c310:	10c00035 	stwio	r3,0(r2)
        }
        if (dev->mbox_type == MBOX_RX)
2109c314:	80c00f17 	ldw	r3,60(r16)
2109c318:	00800044 	movi	r2,1
2109c31c:	18800426 	beq	r3,r2,2109c330 <altera_avalon_mailbox_close+0x90>
                       (~ALTERA_AVALON_MAILBOX_SIMPLE_INTR_PEN_MSK);
            IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);
        }
  
        /* De-register mailbox irq) */
        if (dev->mailbox_irq != ALT_IRQ_NOT_CONNECTED)
2109c320:	81400b17 	ldw	r5,44(r16)
2109c324:	00bfffc4 	movi	r2,-1
2109c328:	28bfe91e 	bne	r5,r2,2109c2d0 <__flash_rwdata_start+0xffffa088>
2109c32c:	003fed06 	br	2109c2e4 <__flash_rwdata_start+0xffffa09c>
                       (~ALTERA_AVALON_MAILBOX_SIMPLE_INTR_SPACE_MSK);
            IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);
        }
        if (dev->mbox_type == MBOX_RX)
        {
            data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST) &
2109c330:	80800a17 	ldw	r2,40(r16)
2109c334:	10800304 	addi	r2,r2,12
2109c338:	11000037 	ldwio	r4,0(r2)
2109c33c:	00ffff84 	movi	r3,-2
2109c340:	20c6703a 	and	r3,r4,r3
                       (~ALTERA_AVALON_MAILBOX_SIMPLE_INTR_PEN_MSK);
            IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);
2109c344:	10c00035 	stwio	r3,0(r2)
2109c348:	003ff506 	br	2109c320 <__flash_rwdata_start+0xffffa0d8>

2109c34c <altera_avalon_mailbox_status>:

alt_u32 altera_avalon_mailbox_status (altera_avalon_mailbox_dev *dev)
{
    alt_u32 mailbox_sts = 0;

    mailbox_sts = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_STS_OFST) & ALTERA_AVALON_MAILBOX_SIMPLE_STS_MSK);
2109c34c:	20800a17 	ldw	r2,40(r4)
2109c350:	10800237 	ldwio	r2,8(r2)

    if (dev->mbox_type == MBOX_TX)
2109c354:	20c00f17 	ldw	r3,60(r4)
2109c358:	1800031e 	bne	r3,zero,2109c368 <altera_avalon_mailbox_status+0x1c>
        mailbox_sts = (mailbox_sts & ALTERA_AVALON_MAILBOX_SIMPLE_STS_FULL_MSK) >> 1;
2109c35c:	1080008c 	andi	r2,r2,2
2109c360:	1004d07a 	srli	r2,r2,1
2109c364:	f800283a 	ret

    if (dev->mbox_type == MBOX_RX)
2109c368:	01000044 	movi	r4,1
2109c36c:	1900021e 	bne	r3,r4,2109c378 <altera_avalon_mailbox_status+0x2c>
        mailbox_sts = mailbox_sts & ALTERA_AVALON_MAILBOX_SIMPLE_STS_PENDING_MSK;
2109c370:	1080004c 	andi	r2,r2,1

    return mailbox_sts;
}
2109c374:	f800283a 	ret

alt_u32 altera_avalon_mailbox_status (altera_avalon_mailbox_dev *dev)
{
    alt_u32 mailbox_sts = 0;

    mailbox_sts = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_STS_OFST) & ALTERA_AVALON_MAILBOX_SIMPLE_STS_MSK);
2109c378:	108000cc 	andi	r2,r2,3
2109c37c:	f800283a 	ret

2109c380 <altera_avalon_mailbox_send>:
     * Obtain the "write_lock"semaphore to ensures 
     * that writing to the device is thread-safe in multi-thread enviroment
     */
    ALT_SEM_PEND (dev->write_lock, 0);

    if (dev->lock || (IORD_ALTERA_AVALON_MAILBOX_STS(dev->base)
2109c380:	20801103 	ldbu	r2,68(r4)
2109c384:	10004d1e 	bne	r2,zero,2109c4bc <altera_avalon_mailbox_send+0x13c>
2109c388:	20c00a17 	ldw	r3,40(r4)
2109c38c:	18800237 	ldwio	r2,8(r3)
    		          & ALTERA_AVALON_MAILBOX_SIMPLE_STS_FULL_MSK))
2109c390:	1080008c 	andi	r2,r2,2
     * Obtain the "write_lock"semaphore to ensures 
     * that writing to the device is thread-safe in multi-thread enviroment
     */
    ALT_SEM_PEND (dev->write_lock, 0);

    if (dev->lock || (IORD_ALTERA_AVALON_MAILBOX_STS(dev->base)
2109c394:	1000491e 	bne	r2,zero,2109c4bc <altera_avalon_mailbox_send+0x13c>
     */
    ALT_SEM_POST (dev->write_lock);



    if ((dev->mailbox_irq == ALT_IRQ_NOT_CONNECTED) || (event==POLL))
2109c398:	22400b17 	ldw	r9,44(r4)
    	return -1;
    }
    else
    {
        dev->mbox_msg = message;
        dev->lock = 1;
2109c39c:	02000044 	movi	r8,1
2109c3a0:	22001105 	stb	r8,68(r4)
    	/* dev is lock or no free space to send */
    	return -1;
    }
    else
    {
        dev->mbox_msg = message;
2109c3a4:	21401015 	stw	r5,64(r4)
     */
    ALT_SEM_POST (dev->write_lock);



    if ((dev->mailbox_irq == ALT_IRQ_NOT_CONNECTED) || (event==POLL))
2109c3a8:	023fffc4 	movi	r8,-1
2109c3ac:	4a000726 	beq	r9,r8,2109c3cc <altera_avalon_mailbox_send+0x4c>
2109c3b0:	02000044 	movi	r8,1
2109c3b4:	3a000526 	beq	r7,r8,2109c3cc <altera_avalon_mailbox_send+0x4c>
        dev->lock =0;
        return status;
    } else
    {
        /* Enable Sender interrupt */
        data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST) |
2109c3b8:	18c00304 	addi	r3,r3,12
2109c3bc:	19000037 	ldwio	r4,0(r3)
2109c3c0:	21000094 	ori	r4,r4,2
                   (ALTERA_AVALON_MAILBOX_SIMPLE_INTR_SPACE_MSK);
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);
2109c3c4:	19000035 	stwio	r4,0(r3)
    }
  return 0;
2109c3c8:	f800283a 	ret
2109c3cc:	20800f17 	ldw	r2,60(r4)

alt_u32 altera_avalon_mailbox_status (altera_avalon_mailbox_dev *dev)
{
    alt_u32 mailbox_sts = 0;

    mailbox_sts = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_STS_OFST) & ALTERA_AVALON_MAILBOX_SIMPLE_STS_MSK);
2109c3d0:	18c00204 	addi	r3,r3,8


    if ((dev->mailbox_irq == ALT_IRQ_NOT_CONNECTED) || (event==POLL))
    {
        /* Polling mode */
        if (timeout ==0)
2109c3d4:	3000111e 	bne	r6,zero,2109c41c <altera_avalon_mailbox_send+0x9c>
2109c3d8:	10002326 	beq	r2,zero,2109c468 <altera_avalon_mailbox_send+0xe8>
2109c3dc:	01800044 	movi	r6,1
2109c3e0:	1180281e 	bne	r2,r6,2109c484 <altera_avalon_mailbox_send+0x104>

alt_u32 altera_avalon_mailbox_status (altera_avalon_mailbox_dev *dev)
{
    alt_u32 mailbox_sts = 0;

    mailbox_sts = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_STS_OFST) & ALTERA_AVALON_MAILBOX_SIMPLE_STS_MSK);
2109c3e4:	18800037 	ldwio	r2,0(r3)

    if (dev->mbox_type == MBOX_TX)
        mailbox_sts = (mailbox_sts & ALTERA_AVALON_MAILBOX_SIMPLE_STS_FULL_MSK) >> 1;

    if (dev->mbox_type == MBOX_RX)
        mailbox_sts = mailbox_sts & ALTERA_AVALON_MAILBOX_SIMPLE_STS_PENDING_MSK;
2109c3e8:	1080004c 	andi	r2,r2,1
        if (timeout ==0)
        {
            do
            {
                mbox_status = altera_avalon_mailbox_status(dev);
            } while (mbox_status);
2109c3ec:	103ffd1e 	bne	r2,zero,2109c3e4 <__flash_rwdata_start+0xffffa19c>
 */
static alt_32 altera_avalon_mailbox_post (altera_avalon_mailbox_dev *dev,  void *message)
{
    alt_u32 *mbox_msg = (alt_u32*) message ;

    if (mbox_msg != NULL) {
2109c3f0:	28003426 	beq	r5,zero,2109c4c4 <altera_avalon_mailbox_send+0x144>
        /* When message space available, post the message out */
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST, mbox_msg[1]);
2109c3f4:	20800a17 	ldw	r2,40(r4)
2109c3f8:	28c00117 	ldw	r3,4(r5)
2109c3fc:	10c00135 	stwio	r3,4(r2)
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_CMD_OFST, mbox_msg[0]);
2109c400:	20800a17 	ldw	r2,40(r4)
2109c404:	28c00017 	ldw	r3,0(r5)
2109c408:	10c00035 	stwio	r3,0(r2)
        return 0;
2109c40c:	0005883a 	mov	r2,zero
                return -ETIME;
            }
        }
        status = altera_avalon_mailbox_post (dev, message);
        /* Clear mailbox message to NULL after message being posted */
        dev->mbox_msg = NULL;
2109c410:	20001015 	stw	zero,64(r4)
        /* Release lock when message posted */
        dev->lock =0;
2109c414:	20001105 	stb	zero,68(r4)
        return status;
2109c418:	f800283a 	ret
2109c41c:	10000c26 	beq	r2,zero,2109c450 <altera_avalon_mailbox_send+0xd0>
2109c420:	01c00044 	movi	r7,1
2109c424:	11c00226 	beq	r2,r7,2109c430 <altera_avalon_mailbox_send+0xb0>
2109c428:	00001e06 	br	2109c4a4 <altera_avalon_mailbox_send+0x124>
        {
            do
            {
                mbox_status = altera_avalon_mailbox_status(dev);
                timeout--;
            } while (mbox_status && (timeout != 0));
2109c42c:	30000526 	beq	r6,zero,2109c444 <altera_avalon_mailbox_send+0xc4>

alt_u32 altera_avalon_mailbox_status (altera_avalon_mailbox_dev *dev)
{
    alt_u32 mailbox_sts = 0;

    mailbox_sts = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_STS_OFST) & ALTERA_AVALON_MAILBOX_SIMPLE_STS_MSK);
2109c430:	18800037 	ldwio	r2,0(r3)

    if (dev->mbox_type == MBOX_TX)
        mailbox_sts = (mailbox_sts & ALTERA_AVALON_MAILBOX_SIMPLE_STS_FULL_MSK) >> 1;

    if (dev->mbox_type == MBOX_RX)
        mailbox_sts = mailbox_sts & ALTERA_AVALON_MAILBOX_SIMPLE_STS_PENDING_MSK;
2109c434:	1080004c 	andi	r2,r2,1
        } else
        {
            do
            {
                mbox_status = altera_avalon_mailbox_status(dev);
                timeout--;
2109c438:	31bfffc4 	addi	r6,r6,-1
            } while (mbox_status && (timeout != 0));
2109c43c:	103ffb1e 	bne	r2,zero,2109c42c <__flash_rwdata_start+0xffffa1e4>
            if (timeout == 0)
2109c440:	303feb1e 	bne	r6,zero,2109c3f0 <__flash_rwdata_start+0xffffa1a8>
            {    /* Timeout occur or fail sending */
                return -ETIME;
2109c444:	00bff084 	movi	r2,-62
        data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST) |
                   (ALTERA_AVALON_MAILBOX_SIMPLE_INTR_SPACE_MSK);
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);
    }
  return 0;
}
2109c448:	f800283a 	ret
        {
            do
            {
                mbox_status = altera_avalon_mailbox_status(dev);
                timeout--;
            } while (mbox_status && (timeout != 0));
2109c44c:	303ffd26 	beq	r6,zero,2109c444 <__flash_rwdata_start+0xffffa1fc>

alt_u32 altera_avalon_mailbox_status (altera_avalon_mailbox_dev *dev)
{
    alt_u32 mailbox_sts = 0;

    mailbox_sts = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_STS_OFST) & ALTERA_AVALON_MAILBOX_SIMPLE_STS_MSK);
2109c450:	18800037 	ldwio	r2,0(r3)

    if (dev->mbox_type == MBOX_TX)
        mailbox_sts = (mailbox_sts & ALTERA_AVALON_MAILBOX_SIMPLE_STS_FULL_MSK) >> 1;
2109c454:	1080008c 	andi	r2,r2,2
        } else
        {
            do
            {
                mbox_status = altera_avalon_mailbox_status(dev);
                timeout--;
2109c458:	31bfffc4 	addi	r6,r6,-1
            } while (mbox_status && (timeout != 0));
2109c45c:	103ffb1e 	bne	r2,zero,2109c44c <__flash_rwdata_start+0xffffa204>
            if (timeout == 0)
2109c460:	303fe31e 	bne	r6,zero,2109c3f0 <__flash_rwdata_start+0xffffa1a8>
2109c464:	003ff706 	br	2109c444 <__flash_rwdata_start+0xffffa1fc>

alt_u32 altera_avalon_mailbox_status (altera_avalon_mailbox_dev *dev)
{
    alt_u32 mailbox_sts = 0;

    mailbox_sts = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_STS_OFST) & ALTERA_AVALON_MAILBOX_SIMPLE_STS_MSK);
2109c468:	18800037 	ldwio	r2,0(r3)

    if (dev->mbox_type == MBOX_TX)
        mailbox_sts = (mailbox_sts & ALTERA_AVALON_MAILBOX_SIMPLE_STS_FULL_MSK) >> 1;
2109c46c:	1080008c 	andi	r2,r2,2
        if (timeout ==0)
        {
            do
            {
                mbox_status = altera_avalon_mailbox_status(dev);
            } while (mbox_status);
2109c470:	103fdf26 	beq	r2,zero,2109c3f0 <__flash_rwdata_start+0xffffa1a8>

alt_u32 altera_avalon_mailbox_status (altera_avalon_mailbox_dev *dev)
{
    alt_u32 mailbox_sts = 0;

    mailbox_sts = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_STS_OFST) & ALTERA_AVALON_MAILBOX_SIMPLE_STS_MSK);
2109c474:	18800037 	ldwio	r2,0(r3)

    if (dev->mbox_type == MBOX_TX)
        mailbox_sts = (mailbox_sts & ALTERA_AVALON_MAILBOX_SIMPLE_STS_FULL_MSK) >> 1;
2109c478:	1080008c 	andi	r2,r2,2
        if (timeout ==0)
        {
            do
            {
                mbox_status = altera_avalon_mailbox_status(dev);
            } while (mbox_status);
2109c47c:	103ffa1e 	bne	r2,zero,2109c468 <__flash_rwdata_start+0xffffa220>
2109c480:	003fdb06 	br	2109c3f0 <__flash_rwdata_start+0xffffa1a8>

alt_u32 altera_avalon_mailbox_status (altera_avalon_mailbox_dev *dev)
{
    alt_u32 mailbox_sts = 0;

    mailbox_sts = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_STS_OFST) & ALTERA_AVALON_MAILBOX_SIMPLE_STS_MSK);
2109c484:	18800037 	ldwio	r2,0(r3)
2109c488:	108000cc 	andi	r2,r2,3
        if (timeout ==0)
        {
            do
            {
                mbox_status = altera_avalon_mailbox_status(dev);
            } while (mbox_status);
2109c48c:	103fd826 	beq	r2,zero,2109c3f0 <__flash_rwdata_start+0xffffa1a8>

alt_u32 altera_avalon_mailbox_status (altera_avalon_mailbox_dev *dev)
{
    alt_u32 mailbox_sts = 0;

    mailbox_sts = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_STS_OFST) & ALTERA_AVALON_MAILBOX_SIMPLE_STS_MSK);
2109c490:	18800037 	ldwio	r2,0(r3)
2109c494:	108000cc 	andi	r2,r2,3
        if (timeout ==0)
        {
            do
            {
                mbox_status = altera_avalon_mailbox_status(dev);
            } while (mbox_status);
2109c498:	103ffa1e 	bne	r2,zero,2109c484 <__flash_rwdata_start+0xffffa23c>
2109c49c:	003fd406 	br	2109c3f0 <__flash_rwdata_start+0xffffa1a8>
        {
            do
            {
                mbox_status = altera_avalon_mailbox_status(dev);
                timeout--;
            } while (mbox_status && (timeout != 0));
2109c4a0:	303fe826 	beq	r6,zero,2109c444 <__flash_rwdata_start+0xffffa1fc>

alt_u32 altera_avalon_mailbox_status (altera_avalon_mailbox_dev *dev)
{
    alt_u32 mailbox_sts = 0;

    mailbox_sts = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_STS_OFST) & ALTERA_AVALON_MAILBOX_SIMPLE_STS_MSK);
2109c4a4:	18800037 	ldwio	r2,0(r3)
2109c4a8:	108000cc 	andi	r2,r2,3
        } else
        {
            do
            {
                mbox_status = altera_avalon_mailbox_status(dev);
                timeout--;
2109c4ac:	31bfffc4 	addi	r6,r6,-1
            } while (mbox_status && (timeout != 0));
2109c4b0:	103ffb1e 	bne	r2,zero,2109c4a0 <__flash_rwdata_start+0xffffa258>
            if (timeout == 0)
2109c4b4:	303fce1e 	bne	r6,zero,2109c3f0 <__flash_rwdata_start+0xffffa1a8>
2109c4b8:	003fe206 	br	2109c444 <__flash_rwdata_start+0xffffa1fc>

    if (dev->lock || (IORD_ALTERA_AVALON_MAILBOX_STS(dev->base)
    		          & ALTERA_AVALON_MAILBOX_SIMPLE_STS_FULL_MSK))
    {
    	/* dev is lock or no free space to send */
    	return -1;
2109c4bc:	00bfffc4 	movi	r2,-1
2109c4c0:	f800283a 	ret
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST, mbox_msg[1]);
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_CMD_OFST, mbox_msg[0]);
        return 0;
    }
    /* Invalid NULL message received */
    return -EINVAL;
2109c4c4:	00bffa84 	movi	r2,-22
2109c4c8:	003fd106 	br	2109c410 <__flash_rwdata_start+0xffffa1c8>

2109c4cc <altera_avalon_mailbox_retrieve_poll>:
int altera_avalon_mailbox_retrieve_poll (altera_avalon_mailbox_dev *dev, alt_u32 *message, alt_u32 timeout)
{
    alt_u32 status = 0;
    alt_u32 data;

    if (dev != NULL && message != NULL)
2109c4cc:	20004226 	beq	r4,zero,2109c5d8 <altera_avalon_mailbox_retrieve_poll+0x10c>
2109c4d0:	28004126 	beq	r5,zero,2109c5d8 <altera_avalon_mailbox_retrieve_poll+0x10c>
    {
        /* Mask receiver mailbox interrupt when in polling mode */
        data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST);
2109c4d4:	20800a17 	ldw	r2,40(r4)
2109c4d8:	10800304 	addi	r2,r2,12
2109c4dc:	11c00037 	ldwio	r7,0(r2)
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST,
2109c4e0:	00ffff84 	movi	r3,-2
2109c4e4:	38c6703a 	and	r3,r7,r3
2109c4e8:	10c00035 	stwio	r3,0(r2)
2109c4ec:	22000a17 	ldw	r8,40(r4)
2109c4f0:	20800f17 	ldw	r2,60(r4)

alt_u32 altera_avalon_mailbox_status (altera_avalon_mailbox_dev *dev)
{
    alt_u32 mailbox_sts = 0;

    mailbox_sts = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_STS_OFST) & ALTERA_AVALON_MAILBOX_SIMPLE_STS_MSK);
2109c4f4:	40c00204 	addi	r3,r8,8
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST,
            (data & (~ALTERA_AVALON_MAILBOX_SIMPLE_INTR_PEN_MSK)));


        /* If timeout is '0', poll till message availabe in mailbox */
        if (timeout == 0)
2109c4f8:	30000f1e 	bne	r6,zero,2109c538 <altera_avalon_mailbox_retrieve_poll+0x6c>
2109c4fc:	10002726 	beq	r2,zero,2109c59c <altera_avalon_mailbox_retrieve_poll+0xd0>
2109c500:	01800044 	movi	r6,1
2109c504:	11802c1e 	bne	r2,r6,2109c5b8 <altera_avalon_mailbox_retrieve_poll+0xec>

alt_u32 altera_avalon_mailbox_status (altera_avalon_mailbox_dev *dev)
{
    alt_u32 mailbox_sts = 0;

    mailbox_sts = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_STS_OFST) & ALTERA_AVALON_MAILBOX_SIMPLE_STS_MSK);
2109c508:	18800037 	ldwio	r2,0(r3)

    if (dev->mbox_type == MBOX_TX)
        mailbox_sts = (mailbox_sts & ALTERA_AVALON_MAILBOX_SIMPLE_STS_FULL_MSK) >> 1;

    if (dev->mbox_type == MBOX_RX)
        mailbox_sts = mailbox_sts & ALTERA_AVALON_MAILBOX_SIMPLE_STS_PENDING_MSK;
2109c50c:	1080004c 	andi	r2,r2,1
        if (timeout == 0)
        {
            do
            {
                status = altera_avalon_mailbox_status (dev);
            } while (status == 0);
2109c510:	103ffd26 	beq	r2,zero,2109c508 <__flash_rwdata_start+0xffffa2c0>
        }

        /* if timeout, status remain 0 */
        if (status)
        {
            message[1] = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST));
2109c514:	40800137 	ldwio	r2,4(r8)
2109c518:	28800115 	stw	r2,4(r5)
            message[0] = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_CMD_OFST));
2109c51c:	20800a17 	ldw	r2,40(r4)
2109c520:	10800037 	ldwio	r2,0(r2)
2109c524:	28800015 	stw	r2,0(r5)
        }
        /* Restore original state of interrupt mask */
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);
2109c528:	20800a17 	ldw	r2,40(r4)
2109c52c:	11c00335 	stwio	r7,12(r2)

        /* Return success on complete retrieve message
         * otherwise timeout and exit with error
         */
        if (status)
          return 0;
2109c530:	0005883a 	mov	r2,zero
2109c534:	f800283a 	ret
2109c538:	10000d26 	beq	r2,zero,2109c570 <altera_avalon_mailbox_retrieve_poll+0xa4>
2109c53c:	02400044 	movi	r9,1
2109c540:	1240111e 	bne	r2,r9,2109c588 <altera_avalon_mailbox_retrieve_poll+0xbc>

alt_u32 altera_avalon_mailbox_status (altera_avalon_mailbox_dev *dev)
{
    alt_u32 mailbox_sts = 0;

    mailbox_sts = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_STS_OFST) & ALTERA_AVALON_MAILBOX_SIMPLE_STS_MSK);
2109c544:	18800037 	ldwio	r2,0(r3)

    if (dev->mbox_type == MBOX_TX)
        mailbox_sts = (mailbox_sts & ALTERA_AVALON_MAILBOX_SIMPLE_STS_FULL_MSK) >> 1;

    if (dev->mbox_type == MBOX_RX)
        mailbox_sts = mailbox_sts & ALTERA_AVALON_MAILBOX_SIMPLE_STS_PENDING_MSK;
2109c548:	1080004c 	andi	r2,r2,1
        } else
        {
            do
            {
                 status = altera_avalon_mailbox_status (dev);
                 timeout-- ;
2109c54c:	31bfffc4 	addi	r6,r6,-1
            } while ((status == 0) && timeout);
2109c550:	103ff01e 	bne	r2,zero,2109c514 <__flash_rwdata_start+0xffffa2cc>
2109c554:	30001f26 	beq	r6,zero,2109c5d4 <altera_avalon_mailbox_retrieve_poll+0x108>

alt_u32 altera_avalon_mailbox_status (altera_avalon_mailbox_dev *dev)
{
    alt_u32 mailbox_sts = 0;

    mailbox_sts = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_STS_OFST) & ALTERA_AVALON_MAILBOX_SIMPLE_STS_MSK);
2109c558:	18800037 	ldwio	r2,0(r3)

    if (dev->mbox_type == MBOX_TX)
        mailbox_sts = (mailbox_sts & ALTERA_AVALON_MAILBOX_SIMPLE_STS_FULL_MSK) >> 1;

    if (dev->mbox_type == MBOX_RX)
        mailbox_sts = mailbox_sts & ALTERA_AVALON_MAILBOX_SIMPLE_STS_PENDING_MSK;
2109c55c:	1080004c 	andi	r2,r2,1
        } else
        {
            do
            {
                 status = altera_avalon_mailbox_status (dev);
                 timeout-- ;
2109c560:	31bfffc4 	addi	r6,r6,-1
            } while ((status == 0) && timeout);
2109c564:	103ffb26 	beq	r2,zero,2109c554 <__flash_rwdata_start+0xffffa30c>
2109c568:	003fea06 	br	2109c514 <__flash_rwdata_start+0xffffa2cc>
2109c56c:	30001926 	beq	r6,zero,2109c5d4 <altera_avalon_mailbox_retrieve_poll+0x108>

alt_u32 altera_avalon_mailbox_status (altera_avalon_mailbox_dev *dev)
{
    alt_u32 mailbox_sts = 0;

    mailbox_sts = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_STS_OFST) & ALTERA_AVALON_MAILBOX_SIMPLE_STS_MSK);
2109c570:	18800037 	ldwio	r2,0(r3)

    if (dev->mbox_type == MBOX_TX)
        mailbox_sts = (mailbox_sts & ALTERA_AVALON_MAILBOX_SIMPLE_STS_FULL_MSK) >> 1;
2109c574:	1080008c 	andi	r2,r2,2
        } else
        {
            do
            {
                 status = altera_avalon_mailbox_status (dev);
                 timeout-- ;
2109c578:	31bfffc4 	addi	r6,r6,-1
            } while ((status == 0) && timeout);
2109c57c:	103ffb26 	beq	r2,zero,2109c56c <__flash_rwdata_start+0xffffa324>
2109c580:	003fe406 	br	2109c514 <__flash_rwdata_start+0xffffa2cc>
2109c584:	30001326 	beq	r6,zero,2109c5d4 <altera_avalon_mailbox_retrieve_poll+0x108>

alt_u32 altera_avalon_mailbox_status (altera_avalon_mailbox_dev *dev)
{
    alt_u32 mailbox_sts = 0;

    mailbox_sts = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_STS_OFST) & ALTERA_AVALON_MAILBOX_SIMPLE_STS_MSK);
2109c588:	18800037 	ldwio	r2,0(r3)
2109c58c:	108000cc 	andi	r2,r2,3
        } else
        {
            do
            {
                 status = altera_avalon_mailbox_status (dev);
                 timeout-- ;
2109c590:	31bfffc4 	addi	r6,r6,-1
            } while ((status == 0) && timeout);
2109c594:	103ffb26 	beq	r2,zero,2109c584 <__flash_rwdata_start+0xffffa33c>
2109c598:	003fde06 	br	2109c514 <__flash_rwdata_start+0xffffa2cc>

alt_u32 altera_avalon_mailbox_status (altera_avalon_mailbox_dev *dev)
{
    alt_u32 mailbox_sts = 0;

    mailbox_sts = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_STS_OFST) & ALTERA_AVALON_MAILBOX_SIMPLE_STS_MSK);
2109c59c:	18800037 	ldwio	r2,0(r3)

    if (dev->mbox_type == MBOX_TX)
        mailbox_sts = (mailbox_sts & ALTERA_AVALON_MAILBOX_SIMPLE_STS_FULL_MSK) >> 1;
2109c5a0:	1080008c 	andi	r2,r2,2
        if (timeout == 0)
        {
            do
            {
                status = altera_avalon_mailbox_status (dev);
            } while (status == 0);
2109c5a4:	103fdb1e 	bne	r2,zero,2109c514 <__flash_rwdata_start+0xffffa2cc>

alt_u32 altera_avalon_mailbox_status (altera_avalon_mailbox_dev *dev)
{
    alt_u32 mailbox_sts = 0;

    mailbox_sts = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_STS_OFST) & ALTERA_AVALON_MAILBOX_SIMPLE_STS_MSK);
2109c5a8:	18800037 	ldwio	r2,0(r3)

    if (dev->mbox_type == MBOX_TX)
        mailbox_sts = (mailbox_sts & ALTERA_AVALON_MAILBOX_SIMPLE_STS_FULL_MSK) >> 1;
2109c5ac:	1080008c 	andi	r2,r2,2
        if (timeout == 0)
        {
            do
            {
                status = altera_avalon_mailbox_status (dev);
            } while (status == 0);
2109c5b0:	103ffa26 	beq	r2,zero,2109c59c <__flash_rwdata_start+0xffffa354>
2109c5b4:	003fd706 	br	2109c514 <__flash_rwdata_start+0xffffa2cc>

alt_u32 altera_avalon_mailbox_status (altera_avalon_mailbox_dev *dev)
{
    alt_u32 mailbox_sts = 0;

    mailbox_sts = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_STS_OFST) & ALTERA_AVALON_MAILBOX_SIMPLE_STS_MSK);
2109c5b8:	18800037 	ldwio	r2,0(r3)
2109c5bc:	108000cc 	andi	r2,r2,3
        if (timeout == 0)
        {
            do
            {
                status = altera_avalon_mailbox_status (dev);
            } while (status == 0);
2109c5c0:	103fd41e 	bne	r2,zero,2109c514 <__flash_rwdata_start+0xffffa2cc>

alt_u32 altera_avalon_mailbox_status (altera_avalon_mailbox_dev *dev)
{
    alt_u32 mailbox_sts = 0;

    mailbox_sts = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_STS_OFST) & ALTERA_AVALON_MAILBOX_SIMPLE_STS_MSK);
2109c5c4:	18800037 	ldwio	r2,0(r3)
2109c5c8:	108000cc 	andi	r2,r2,3
        if (timeout == 0)
        {
            do
            {
                status = altera_avalon_mailbox_status (dev);
            } while (status == 0);
2109c5cc:	103ffa26 	beq	r2,zero,2109c5b8 <__flash_rwdata_start+0xffffa370>
2109c5d0:	003fd006 	br	2109c514 <__flash_rwdata_start+0xffffa2cc>
        {
            message[1] = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST));
            message[0] = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_CMD_OFST));
        }
        /* Restore original state of interrupt mask */
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);
2109c5d4:	41c00335 	stwio	r7,12(r8)
         */
        if (status)
          return 0;
      }
      /* Invalid Null dev and message */
      message[1] = 0;
2109c5d8:	28000115 	stw	zero,4(r5)
      message[0] = 0;
2109c5dc:	28000015 	stw	zero,0(r5)
      return -EINVAL;
2109c5e0:	00bffa84 	movi	r2,-22
2109c5e4:	f800283a 	ret

2109c5e8 <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
2109c5e8:	defffd04 	addi	sp,sp,-12
2109c5ec:	dc000015 	stw	r16,0(sp)
2109c5f0:	dfc00215 	stw	ra,8(sp)
2109c5f4:	dc400115 	stw	r17,4(sp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
2109c5f8:	20801783 	ldbu	r2,94(r4)
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
2109c5fc:	2021883a 	mov	r16,r4
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
2109c600:	10001d26 	beq	r2,zero,2109c678 <alt_msgdma_irq+0x90>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
2109c604:	20c00617 	ldw	r3,24(r4)
2109c608:	19000037 	ldwio	r4,0(r3)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
2109c60c:	00bffdc4 	movi	r2,-9
2109c610:	2084703a 	and	r2,r4,r2
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
2109c614:	18800035 	stwio	r2,0(r3)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
2109c618:	80800617 	ldw	r2,24(r16)
2109c61c:	00c00044 	movi	r3,1
2109c620:	10c00435 	stwio	r3,16(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
2109c624:	80c00b17 	ldw	r3,44(r16)
2109c628:	18000726 	beq	r3,zero,2109c648 <alt_msgdma_irq+0x60>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109c62c:	0023303a 	rdctl	r17,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109c630:	00bfff84 	movi	r2,-2
2109c634:	8884703a 	and	r2,r17,r2
2109c638:	1001703a 	wrctl	status,r2
    {
        cpu_sr = alt_irq_disable_all();
        dev->callback (dev->callback_context);
2109c63c:	81000c17 	ldw	r4,48(r16)
2109c640:	183ee83a 	callr	r3
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109c644:	8801703a 	wrctl	status,r17
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
2109c648:	80801783 	ldbu	r2,94(r16)
2109c64c:	1000141e 	bne	r2,zero,2109c6a0 <alt_msgdma_irq+0xb8>
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
2109c650:	80800317 	ldw	r2,12(r16)
2109c654:	10800104 	addi	r2,r2,4
2109c658:	10c00037 	ldwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
2109c65c:	18c00414 	ori	r3,r3,16
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
2109c660:	10c00035 	stwio	r3,0(r2)
    }

    return;
}
2109c664:	dfc00217 	ldw	ra,8(sp)
2109c668:	dc400117 	ldw	r17,4(sp)
2109c66c:	dc000017 	ldw	r16,0(sp)
2109c670:	dec00304 	addi	sp,sp,12
2109c674:	f800283a 	ret
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
2109c678:	20800317 	ldw	r2,12(r4)
2109c67c:	10800104 	addi	r2,r2,4
2109c680:	11000037 	ldwio	r4,0(r2)
2109c684:	00fffbc4 	movi	r3,-17
2109c688:	20c6703a 	and	r3,r4,r3
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
2109c68c:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
2109c690:	80800317 	ldw	r2,12(r16)
2109c694:	00c08004 	movi	r3,512
2109c698:	10c00035 	stwio	r3,0(r2)
2109c69c:	003fe106 	br	2109c624 <__flash_rwdata_start+0xffffa3dc>

    /* enable global interrupt */
    if (dev->prefetcher_enable)
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
2109c6a0:	80c00617 	ldw	r3,24(r16)
2109c6a4:	18800037 	ldwio	r2,0(r3)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
2109c6a8:	10800214 	ori	r2,r2,8
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
2109c6ac:	18800035 	stwio	r2,0(r3)
2109c6b0:	003fec06 	br	2109c664 <__flash_rwdata_start+0xffffa41c>

2109c6b4 <alt_msgdma_construct_standard_st_to_mm_descriptor>:
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
2109c6b4:	20801217 	ldw	r2,72(r4)
2109c6b8:	11c00a36 	bltu	r2,r7,2109c6e4 <alt_msgdma_construct_standard_st_to_mm_descriptor+0x30>
2109c6bc:	20801703 	ldbu	r2,92(r4)
2109c6c0:	1000081e 	bne	r2,zero,2109c6e4 <alt_msgdma_construct_standard_st_to_mm_descriptor+0x30>
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
2109c6c4:	d8800017 	ldw	r2,0(sp)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
2109c6c8:	28000015 	stw	zero,0(r5)
    descriptor->write_address = write_address;
2109c6cc:	29800115 	stw	r6,4(r5)
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
2109c6d0:	10a00034 	orhi	r2,r2,32768
2109c6d4:	28800315 	stw	r2,12(r5)
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
2109c6d8:	29c00215 	stw	r7,8(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
2109c6dc:	0005883a 	mov	r2,zero
2109c6e0:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
2109c6e4:	00bffa84 	movi	r2,-22
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
            write_address, length, control);
}
2109c6e8:	f800283a 	ret

2109c6ec <alt_msgdma_construct_standard_mm_to_st_descriptor>:
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
2109c6ec:	20801217 	ldw	r2,72(r4)
2109c6f0:	11c00a36 	bltu	r2,r7,2109c71c <alt_msgdma_construct_standard_mm_to_st_descriptor+0x30>
2109c6f4:	20801703 	ldbu	r2,92(r4)
2109c6f8:	1000081e 	bne	r2,zero,2109c71c <alt_msgdma_construct_standard_mm_to_st_descriptor+0x30>
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
2109c6fc:	d8800017 	ldw	r2,0(sp)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
2109c700:	29800015 	stw	r6,0(r5)
    descriptor->write_address = write_address;
2109c704:	28000115 	stw	zero,4(r5)
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
2109c708:	10a00034 	orhi	r2,r2,32768
2109c70c:	28800315 	stw	r2,12(r5)
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
2109c710:	29c00215 	stw	r7,8(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
2109c714:	0005883a 	mov	r2,zero
2109c718:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
2109c71c:	00bffa84 	movi	r2,-22
	alt_u32 control)
{
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
            NULL, length, control);

}
2109c720:	f800283a 	ret

2109c724 <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
2109c724:	d8c00017 	ldw	r3,0(sp)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
2109c728:	20801217 	ldw	r2,72(r4)
2109c72c:	10c00a36 	bltu	r2,r3,2109c758 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0x34>
2109c730:	20801703 	ldbu	r2,92(r4)
2109c734:	1000081e 	bne	r2,zero,2109c758 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0x34>
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
2109c738:	d8800117 	ldw	r2,4(sp)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
2109c73c:	29800015 	stw	r6,0(r5)
    descriptor->write_address = write_address;
2109c740:	29c00115 	stw	r7,4(r5)
    descriptor->transfer_length = length;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
2109c744:	10a00034 	orhi	r2,r2,32768
2109c748:	28800315 	stw	r2,12(r5)
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
    descriptor->write_address = write_address;
    descriptor->transfer_length = length;
2109c74c:	28c00215 	stw	r3,8(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
2109c750:	0005883a 	mov	r2,zero
2109c754:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
2109c758:	00bffa84 	movi	r2,-22
	alt_u32 length, 
	alt_u32 control)
{
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
            write_address, length, control);
}
2109c75c:	f800283a 	ret

2109c760 <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
2109c760:	20801217 	ldw	r2,72(r4)
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
2109c764:	da400117 	ldw	r9,4(sp)
2109c768:	da000217 	ldw	r8,8(sp)
2109c76c:	d8c00317 	ldw	r3,12(sp)
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
2109c770:	11c01736 	bltu	r2,r7,2109c7d0 <alt_msgdma_construct_extended_st_to_mm_descriptor+0x70>
       dev->max_stride < read_stride ||
2109c774:	20801417 	ldw	r2,80(r4)
       dev->max_stride < write_stride ||
2109c778:	1abfffcc 	andi	r10,r3,65535
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
2109c77c:	10001226 	beq	r2,zero,2109c7c8 <alt_msgdma_construct_extended_st_to_mm_descriptor+0x68>
       dev->max_stride < write_stride ||
2109c780:	21001703 	ldbu	r4,92(r4)
2109c784:	00800044 	movi	r2,1
2109c788:	2080111e 	bne	r4,r2,2109c7d0 <alt_msgdma_construct_extended_st_to_mm_descriptor+0x70>
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
2109c78c:	d8800017 	ldw	r2,0(sp)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
2109c790:	28000015 	stw	zero,0(r5)
    descriptor->write_address_low = write_address;
2109c794:	29800115 	stw	r6,4(r5)
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
2109c798:	10a00034 	orhi	r2,r2,32768
2109c79c:	28800715 	stw	r2,28(r5)
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
    descriptor->write_address_low = write_address;
    descriptor->transfer_length = length;
2109c7a0:	29c00215 	stw	r7,8(r5)
    descriptor->sequence_number = sequence_number;
2109c7a4:	2a40030d 	sth	r9,12(r5)
    descriptor->read_burst_count = read_burst_count;
2109c7a8:	28000385 	stb	zero,14(r5)
    descriptor->write_burst_count = write_burst_count;
2109c7ac:	2a0003c5 	stb	r8,15(r5)
    descriptor->read_stride = read_stride;
2109c7b0:	2800040d 	sth	zero,16(r5)
    descriptor->write_stride = write_stride;
2109c7b4:	28c0048d 	sth	r3,18(r5)
    descriptor->read_address_high = NULL;
2109c7b8:	28000515 	stw	zero,20(r5)
    descriptor->write_address_high = NULL;
2109c7bc:	28000615 	stw	zero,24(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
2109c7c0:	0005883a 	mov	r2,zero
2109c7c4:	f800283a 	ret
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
2109c7c8:	20801317 	ldw	r2,76(r4)
2109c7cc:	12bfec2e 	bgeu	r2,r10,2109c780 <__flash_rwdata_start+0xffffa538>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
2109c7d0:	00bffa84 	movi	r2,-22
	alt_u16 write_stride)
{
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
2109c7d4:	f800283a 	ret

2109c7d8 <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
2109c7d8:	20801217 	ldw	r2,72(r4)
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
2109c7dc:	da400117 	ldw	r9,4(sp)
2109c7e0:	da000217 	ldw	r8,8(sp)
2109c7e4:	d8c00317 	ldw	r3,12(sp)
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
2109c7e8:	11c01736 	bltu	r2,r7,2109c848 <alt_msgdma_construct_extended_mm_to_st_descriptor+0x70>
2109c7ec:	20801417 	ldw	r2,80(r4)
       dev->max_stride < read_stride ||
2109c7f0:	1abfffcc 	andi	r10,r3,65535
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
2109c7f4:	10001226 	beq	r2,zero,2109c840 <alt_msgdma_construct_extended_mm_to_st_descriptor+0x68>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
2109c7f8:	21001703 	ldbu	r4,92(r4)
2109c7fc:	00800044 	movi	r2,1
2109c800:	2080111e 	bne	r4,r2,2109c848 <alt_msgdma_construct_extended_mm_to_st_descriptor+0x70>
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
2109c804:	d8800017 	ldw	r2,0(sp)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
2109c808:	29800015 	stw	r6,0(r5)
    descriptor->write_address_low = write_address;
2109c80c:	28000115 	stw	zero,4(r5)
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
2109c810:	10a00034 	orhi	r2,r2,32768
2109c814:	28800715 	stw	r2,28(r5)
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
    descriptor->write_address_low = write_address;
    descriptor->transfer_length = length;
2109c818:	29c00215 	stw	r7,8(r5)
    descriptor->sequence_number = sequence_number;
2109c81c:	2a40030d 	sth	r9,12(r5)
    descriptor->read_burst_count = read_burst_count;
2109c820:	2a000385 	stb	r8,14(r5)
    descriptor->write_burst_count = write_burst_count;
2109c824:	280003c5 	stb	zero,15(r5)
    descriptor->read_stride = read_stride;
2109c828:	28c0040d 	sth	r3,16(r5)
    descriptor->write_stride = write_stride;
2109c82c:	2800048d 	sth	zero,18(r5)
    descriptor->read_address_high = NULL;
2109c830:	28000515 	stw	zero,20(r5)
    descriptor->write_address_high = NULL;
2109c834:	28000615 	stw	zero,24(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
2109c838:	0005883a 	mov	r2,zero
2109c83c:	f800283a 	ret
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
2109c840:	20801317 	ldw	r2,76(r4)
2109c844:	12bfec2e 	bgeu	r2,r10,2109c7f8 <__flash_rwdata_start+0xffffa5b0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
2109c848:	00bffa84 	movi	r2,-22
{
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
2109c84c:	f800283a 	ret

2109c850 <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
2109c850:	d8c00017 	ldw	r3,0(sp)
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
2109c854:	20801217 	ldw	r2,72(r4)
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
2109c858:	db000217 	ldw	r12,8(sp)
2109c85c:	dac00317 	ldw	r11,12(sp)
2109c860:	da800417 	ldw	r10,16(sp)
2109c864:	da000517 	ldw	r8,20(sp)
2109c868:	da400617 	ldw	r9,24(sp)
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
2109c86c:	10c01936 	bltu	r2,r3,2109c8d4 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x84>
       dev->max_stride < read_stride ||
2109c870:	20801417 	ldw	r2,80(r4)
2109c874:	23401317 	ldw	r13,76(r4)
2109c878:	43bfffcc 	andi	r14,r8,65535
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
2109c87c:	10001726 	beq	r2,zero,2109c8dc <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x8c>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
2109c880:	4bbfffcc 	andi	r14,r9,65535
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
2109c884:	10001226 	beq	r2,zero,2109c8d0 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x80>
       dev->max_stride < write_stride ||
2109c888:	21001703 	ldbu	r4,92(r4)
2109c88c:	00800044 	movi	r2,1
2109c890:	2080101e 	bne	r4,r2,2109c8d4 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0x84>
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
2109c894:	d8800117 	ldw	r2,4(sp)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
2109c898:	29800015 	stw	r6,0(r5)
    descriptor->write_address_low = write_address;
2109c89c:	29c00115 	stw	r7,4(r5)
    descriptor->write_burst_count = write_burst_count;
    descriptor->read_stride = read_stride;
    descriptor->write_stride = write_stride;
    descriptor->read_address_high = NULL;
    descriptor->write_address_high = NULL;
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
2109c8a0:	10a00034 	orhi	r2,r2,32768
2109c8a4:	28800715 	stw	r2,28(r5)
        return -EINVAL;
    }
    
    descriptor->read_address_low = read_address;
    descriptor->write_address_low = write_address;
    descriptor->transfer_length = length;
2109c8a8:	28c00215 	stw	r3,8(r5)
    descriptor->sequence_number = sequence_number;
2109c8ac:	2b00030d 	sth	r12,12(r5)
    descriptor->read_burst_count = read_burst_count;
2109c8b0:	2ac00385 	stb	r11,14(r5)
    descriptor->write_burst_count = write_burst_count;
2109c8b4:	2a8003c5 	stb	r10,15(r5)
    descriptor->read_stride = read_stride;
2109c8b8:	2a00040d 	sth	r8,16(r5)
    descriptor->write_stride = write_stride;
2109c8bc:	2a40048d 	sth	r9,18(r5)
    descriptor->read_address_high = NULL;
2109c8c0:	28000515 	stw	zero,20(r5)
    descriptor->write_address_high = NULL;
2109c8c4:	28000615 	stw	zero,24(r5)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
2109c8c8:	0005883a 	mov	r2,zero
2109c8cc:	f800283a 	ret
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
2109c8d0:	6bbfed2e 	bgeu	r13,r14,2109c888 <__flash_rwdata_start+0xffffa640>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
2109c8d4:	00bffa84 	movi	r2,-22
{
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
2109c8d8:	f800283a 	ret
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
2109c8dc:	6bbfe82e 	bgeu	r13,r14,2109c880 <__flash_rwdata_start+0xffffa638>
2109c8e0:	003ffc06 	br	2109c8d4 <__flash_rwdata_start+0xffffa68c>

2109c8e4 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
2109c8e4:	d8c00017 	ldw	r3,0(sp)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
2109c8e8:	20801217 	ldw	r2,72(r4)
2109c8ec:	10c00e36 	bltu	r2,r3,2109c928 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0x44>
2109c8f0:	20801703 	ldbu	r2,92(r4)
2109c8f4:	10000c1e 	bne	r2,zero,2109c928 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0x44>
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
2109c8f8:	d9000117 	ldw	r4,4(sp)
2109c8fc:	00900034 	movhi	r2,16384
2109c900:	10bfffc4 	addi	r2,r2,-1
2109c904:	2084703a 	and	r2,r4,r2
2109c908:	10a00034 	orhi	r2,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
2109c90c:	28800715 	stw	r2,28(r5)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
2109c910:	29800015 	stw	r6,0(r5)
    descriptor->write_address = write_address;
2109c914:	29c00115 	stw	r7,4(r5)
    descriptor->transfer_length = length;
2109c918:	28c00215 	stw	r3,8(r5)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
2109c91c:	29400315 	stw	r5,12(r5)
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
2109c920:	0005883a 	mov	r2,zero
2109c924:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
2109c928:	00bffa84 	movi	r2,-22
	alt_u32 length,
	alt_u32 control)
{
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
    		read_address, write_address, length, control);
}
2109c92c:	f800283a 	ret

2109c930 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
2109c930:	20801217 	ldw	r2,72(r4)
2109c934:	11c00e36 	bltu	r2,r7,2109c970 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0x40>
2109c938:	20801703 	ldbu	r2,92(r4)
2109c93c:	10000c1e 	bne	r2,zero,2109c970 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0x40>
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
2109c940:	d8c00017 	ldw	r3,0(sp)
2109c944:	00900034 	movhi	r2,16384
2109c948:	10bfffc4 	addi	r2,r2,-1
2109c94c:	1884703a 	and	r2,r3,r2
2109c950:	10a00034 	orhi	r2,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
2109c954:	28800715 	stw	r2,28(r5)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
2109c958:	28000015 	stw	zero,0(r5)
    descriptor->write_address = write_address;
2109c95c:	29800115 	stw	r6,4(r5)
    descriptor->transfer_length = length;
2109c960:	29c00215 	stw	r7,8(r5)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
2109c964:	29400315 	stw	r5,12(r5)
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
2109c968:	0005883a 	mov	r2,zero
2109c96c:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
2109c970:	00bffa84 	movi	r2,-22
	alt_u32 length, 
	alt_u32 control)
{
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
    		0, write_address, length, control);
}
2109c974:	f800283a 	ret

2109c978 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
2109c978:	20801217 	ldw	r2,72(r4)
2109c97c:	11c00e36 	bltu	r2,r7,2109c9b8 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0x40>
2109c980:	20801703 	ldbu	r2,92(r4)
2109c984:	10000c1e 	bne	r2,zero,2109c9b8 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0x40>
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
2109c988:	d8c00017 	ldw	r3,0(sp)
2109c98c:	00900034 	movhi	r2,16384
2109c990:	10bfffc4 	addi	r2,r2,-1
2109c994:	1884703a 	and	r2,r3,r2
2109c998:	10a00034 	orhi	r2,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
2109c99c:	28800715 	stw	r2,28(r5)
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
    }
    descriptor->read_address = read_address;
2109c9a0:	29800015 	stw	r6,0(r5)
    descriptor->write_address = write_address;
2109c9a4:	28000115 	stw	zero,4(r5)
    descriptor->transfer_length = length;
2109c9a8:	29c00215 	stw	r7,8(r5)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
2109c9ac:	29400315 	stw	r5,12(r5)
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
2109c9b0:	0005883a 	mov	r2,zero
2109c9b4:	f800283a 	ret
{
    if(dev->max_byte < length ||
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
2109c9b8:	00bffa84 	movi	r2,-22
	alt_u32 length, 
	alt_u32 control)
{
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
    		read_address, 0, length, control);
}
2109c9bc:	f800283a 	ret

2109c9c0 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
2109c9c0:	d8c00017 	ldw	r3,0(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
2109c9c4:	20801217 	ldw	r2,72(r4)
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
2109c9c8:	da800217 	ldw	r10,8(sp)
2109c9cc:	da400317 	ldw	r9,12(sp)
2109c9d0:	da000417 	ldw	r8,16(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
2109c9d4:	10c01c36 	bltu	r2,r3,2109ca48 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0x88>
       dev->max_stride < read_stride ||
2109c9d8:	20801417 	ldw	r2,80(r4)
       dev->max_stride < write_stride ||
2109c9dc:	42ffffcc 	andi	r11,r8,65535
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
2109c9e0:	10001726 	beq	r2,zero,2109ca40 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0x80>
       dev->max_stride < write_stride ||
2109c9e4:	21001703 	ldbu	r4,92(r4)
2109c9e8:	00800044 	movi	r2,1
2109c9ec:	2080161e 	bne	r4,r2,2109ca48 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0x88>
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
2109c9f0:	d9000117 	ldw	r4,4(sp)
2109c9f4:	00900034 	movhi	r2,16384
2109c9f8:	10bfffc4 	addi	r2,r2,-1
2109c9fc:	2084703a 	and	r2,r4,r2
2109ca00:	10a00034 	orhi	r2,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
2109ca04:	28800f15 	stw	r2,60(r5)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
2109ca08:	28000915 	stw	zero,36(r5)
    descriptor->read_address_low = read_address_low;
2109ca0c:	28000015 	stw	zero,0(r5)
    descriptor->write_address_high = write_address_high;
2109ca10:	29800a15 	stw	r6,40(r5)
    descriptor->write_address_low = write_address_low;
2109ca14:	29c00115 	stw	r7,4(r5)
    descriptor->transfer_length = length;
2109ca18:	28c00215 	stw	r3,8(r5)
    descriptor->sequence_number = sequence_number;
2109ca1c:	2a80070d 	sth	r10,28(r5)
    descriptor->read_burst_count = read_burst_count;
2109ca20:	28000785 	stb	zero,30(r5)
    descriptor->write_burst_count = write_burst_count;
2109ca24:	2a4007c5 	stb	r9,31(r5)
    descriptor->read_stride = read_stride;
2109ca28:	2800080d 	sth	zero,32(r5)
    descriptor->write_stride = write_stride;
2109ca2c:	2a00088d 	sth	r8,34(r5)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
2109ca30:	29400315 	stw	r5,12(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
2109ca34:	28000b15 	stw	zero,44(r5)
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
2109ca38:	0005883a 	mov	r2,zero
2109ca3c:	f800283a 	ret
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
2109ca40:	20801317 	ldw	r2,76(r4)
2109ca44:	12ffe72e 	bgeu	r2,r11,2109c9e4 <__flash_rwdata_start+0xffffa79c>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
2109ca48:	00bffa84 	movi	r2,-22
	alt_u16 write_stride)
{
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
2109ca4c:	f800283a 	ret

2109ca50 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
2109ca50:	d8c00017 	ldw	r3,0(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
2109ca54:	20801217 	ldw	r2,72(r4)
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
2109ca58:	da800217 	ldw	r10,8(sp)
2109ca5c:	da400317 	ldw	r9,12(sp)
2109ca60:	da000417 	ldw	r8,16(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
2109ca64:	10c01c36 	bltu	r2,r3,2109cad8 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0x88>
2109ca68:	20801417 	ldw	r2,80(r4)
       dev->max_stride < read_stride ||
2109ca6c:	42ffffcc 	andi	r11,r8,65535
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
2109ca70:	10001726 	beq	r2,zero,2109cad0 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0x80>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
2109ca74:	21001703 	ldbu	r4,92(r4)
2109ca78:	00800044 	movi	r2,1
2109ca7c:	2080161e 	bne	r4,r2,2109cad8 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0x88>
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
2109ca80:	d9000117 	ldw	r4,4(sp)
2109ca84:	00900034 	movhi	r2,16384
2109ca88:	10bfffc4 	addi	r2,r2,-1
2109ca8c:	2084703a 	and	r2,r4,r2
2109ca90:	10a00034 	orhi	r2,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
2109ca94:	28800f15 	stw	r2,60(r5)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
2109ca98:	29800915 	stw	r6,36(r5)
    descriptor->read_address_low = read_address_low;
2109ca9c:	29c00015 	stw	r7,0(r5)
    descriptor->write_address_high = write_address_high;
2109caa0:	28000a15 	stw	zero,40(r5)
    descriptor->write_address_low = write_address_low;
2109caa4:	28000115 	stw	zero,4(r5)
    descriptor->transfer_length = length;
2109caa8:	28c00215 	stw	r3,8(r5)
    descriptor->sequence_number = sequence_number;
2109caac:	2a80070d 	sth	r10,28(r5)
    descriptor->read_burst_count = read_burst_count;
2109cab0:	2a400785 	stb	r9,30(r5)
    descriptor->write_burst_count = write_burst_count;
2109cab4:	280007c5 	stb	zero,31(r5)
    descriptor->read_stride = read_stride;
2109cab8:	2a00080d 	sth	r8,32(r5)
    descriptor->write_stride = write_stride;
2109cabc:	2800088d 	sth	zero,34(r5)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
2109cac0:	29400315 	stw	r5,12(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
2109cac4:	28000b15 	stw	zero,44(r5)
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
2109cac8:	0005883a 	mov	r2,zero
2109cacc:	f800283a 	ret
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
2109cad0:	20801317 	ldw	r2,76(r4)
2109cad4:	12ffe72e 	bgeu	r2,r11,2109ca74 <__flash_rwdata_start+0xffffa82c>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
2109cad8:	00bffa84 	movi	r2,-22
	alt_u16 read_stride)
{
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
2109cadc:	f800283a 	ret

2109cae0 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
2109cae0:	d8c00217 	ldw	r3,8(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
2109cae4:	20801217 	ldw	r2,72(r4)
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
2109cae8:	db000417 	ldw	r12,16(sp)
2109caec:	dac00517 	ldw	r11,20(sp)
2109caf0:	da800617 	ldw	r10,24(sp)
2109caf4:	da000717 	ldw	r8,28(sp)
2109caf8:	da400817 	ldw	r9,32(sp)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
2109cafc:	10c02036 	bltu	r2,r3,2109cb80 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xa0>
       dev->max_stride < read_stride ||
2109cb00:	20801417 	ldw	r2,80(r4)
2109cb04:	23401317 	ldw	r13,76(r4)
2109cb08:	43bfffcc 	andi	r14,r8,65535
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
2109cb0c:	10001e26 	beq	r2,zero,2109cb88 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xa8>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
2109cb10:	4bbfffcc 	andi	r14,r9,65535
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
2109cb14:	10001926 	beq	r2,zero,2109cb7c <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0x9c>
       dev->max_stride < write_stride ||
2109cb18:	21001703 	ldbu	r4,92(r4)
2109cb1c:	00800044 	movi	r2,1
2109cb20:	2080171e 	bne	r4,r2,2109cb80 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xa0>
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
2109cb24:	d9000317 	ldw	r4,12(sp)
2109cb28:	00900034 	movhi	r2,16384
2109cb2c:	10bfffc4 	addi	r2,r2,-1
2109cb30:	2084703a 	and	r2,r4,r2
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
    descriptor->read_address_low = read_address_low;
    descriptor->write_address_high = write_address_high;
2109cb34:	d9000017 	ldw	r4,0(sp)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
2109cb38:	10a00034 	orhi	r2,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
2109cb3c:	28800f15 	stw	r2,60(r5)
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
    descriptor->read_address_low = read_address_low;
    descriptor->write_address_high = write_address_high;
2109cb40:	29000a15 	stw	r4,40(r5)
    descriptor->write_address_low = write_address_low;
2109cb44:	d9000117 	ldw	r4,4(sp)
      )
    {
        return -EINVAL;
    }
    
    descriptor->read_address_high = read_address_high;
2109cb48:	29800915 	stw	r6,36(r5)
    descriptor->read_address_low = read_address_low;
2109cb4c:	29c00015 	stw	r7,0(r5)
    descriptor->write_address_high = write_address_high;
    descriptor->write_address_low = write_address_low;
2109cb50:	29000115 	stw	r4,4(r5)
    descriptor->transfer_length = length;
2109cb54:	28c00215 	stw	r3,8(r5)
    descriptor->sequence_number = sequence_number;
2109cb58:	2b00070d 	sth	r12,28(r5)
    descriptor->read_burst_count = read_burst_count;
2109cb5c:	2ac00785 	stb	r11,30(r5)
    descriptor->write_burst_count = write_burst_count;
2109cb60:	2a8007c5 	stb	r10,31(r5)
    descriptor->read_stride = read_stride;
2109cb64:	2a00080d 	sth	r8,32(r5)
    descriptor->write_stride = write_stride;
2109cb68:	2a40088d 	sth	r9,34(r5)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
2109cb6c:	29400315 	stw	r5,12(r5)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
2109cb70:	28000b15 	stw	zero,44(r5)
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
2109cb74:	0005883a 	mov	r2,zero
2109cb78:	f800283a 	ret
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
2109cb7c:	6bbfe62e 	bgeu	r13,r14,2109cb18 <__flash_rwdata_start+0xffffa8d0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
2109cb80:	00bffa84 	movi	r2,-22
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
2109cb84:	f800283a 	ret
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
2109cb88:	6bbfe12e 	bgeu	r13,r14,2109cb10 <__flash_rwdata_start+0xffffa8c8>
2109cb8c:	003ffc06 	br	2109cb80 <__flash_rwdata_start+0xffffa938>

2109cb90 <alt_msgdma_prefetcher_add_standard_desc_to_list>:
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
2109cb90:	28001226 	beq	r5,zero,2109cbdc <alt_msgdma_prefetcher_add_standard_desc_to_list+0x4c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
2109cb94:	29800317 	ldw	r6,12(r5)
2109cb98:	2980101e 	bne	r5,r6,2109cbdc <alt_msgdma_prefetcher_add_standard_desc_to_list+0x4c>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
	}
	if (*list == NULL)
2109cb9c:	20c00017 	ldw	r3,0(r4)
2109cba0:	18001026 	beq	r3,zero,2109cbe4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x54>
	{
		*list = descriptor;  /* make this root-node if list is empty */
		return 0;  /* successfully added */
	}
	if (*list == descriptor)
2109cba4:	28c00d26 	beq	r5,r3,2109cbdc <alt_msgdma_prefetcher_add_standard_desc_to_list+0x4c>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
2109cba8:	18800317 	ldw	r2,12(r3)
2109cbac:	1809883a 	mov	r4,r3
2109cbb0:	18800626 	beq	r3,r2,2109cbcc <alt_msgdma_prefetcher_add_standard_desc_to_list+0x3c>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
2109cbb4:	2880021e 	bne	r5,r2,2109cbc0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x30>
2109cbb8:	00000806 	br	2109cbdc <alt_msgdma_prefetcher_add_standard_desc_to_list+0x4c>
2109cbbc:	30800726 	beq	r6,r2,2109cbdc <alt_msgdma_prefetcher_add_standard_desc_to_list+0x4c>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
2109cbc0:	1007883a 	mov	r3,r2
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
2109cbc4:	10800317 	ldw	r2,12(r2)
2109cbc8:	113ffc1e 	bne	r2,r4,2109cbbc <__flash_rwdata_start+0xffffa974>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
2109cbcc:	19800315 	stw	r6,12(r3)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
2109cbd0:	29000315 	stw	r4,12(r5)
	return 0; /* successfully added */
2109cbd4:	0005883a 	mov	r2,zero
2109cbd8:	f800283a 	ret
{
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
2109cbdc:	00bffa84 	movi	r2,-22
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
	return 0; /* successfully added */
}
2109cbe0:	f800283a 	ret
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
	}
	if (*list == NULL)
	{
		*list = descriptor;  /* make this root-node if list is empty */
2109cbe4:	21400015 	stw	r5,0(r4)
		return 0;  /* successfully added */
2109cbe8:	0005883a 	mov	r2,zero
2109cbec:	f800283a 	ret

2109cbf0 <alt_msgdma_prefetcher_add_extended_desc_to_list>:
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
2109cbf0:	28001526 	beq	r5,zero,2109cc48 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x58>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
2109cbf4:	28800317 	ldw	r2,12(r5)
2109cbf8:	11400226 	beq	r2,r5,2109cc04 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x14>
2109cbfc:	28800b17 	ldw	r2,44(r5)
2109cc00:	1000111e 	bne	r2,zero,2109cc48 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x58>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
	}
	
	if (*list == NULL)
2109cc04:	21800017 	ldw	r6,0(r4)
2109cc08:	30001726 	beq	r6,zero,2109cc68 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x78>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
		return 0;
	}
	if (*list == descriptor)
2109cc0c:	29800e26 	beq	r5,r6,2109cc48 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x58>
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
2109cc10:	30800317 	ldw	r2,12(r6)
2109cc14:	300f883a 	mov	r7,r6
2109cc18:	11800d26 	beq	r2,r6,2109cc50 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x60>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
2109cc1c:	30c00b17 	ldw	r3,44(r6)
2109cc20:	1800051e 	bne	r3,zero,2109cc38 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x48>
2109cc24:	00000a06 	br	2109cc50 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x60>
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
2109cc28:	10800317 	ldw	r2,12(r2)
2109cc2c:	11c00826 	beq	r2,r7,2109cc50 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x60>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
2109cc30:	20c00b17 	ldw	r3,44(r4)
2109cc34:	18000626 	beq	r3,zero,2109cc50 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x60>
			&& (last_descr_ptr->next_desc_ptr_high == next_node_addr.u32[1]))
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
2109cc38:	1009883a 	mov	r4,r2
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
2109cc3c:	100d883a 	mov	r6,r2
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* first check if descriptor already in the list */
		next_node_addr.u64 = (uintptr_t)descriptor;
		if ((last_descr_ptr->next_desc_ptr_low == next_node_addr.u32[0])
2109cc40:	28bff91e 	bne	r5,r2,2109cc28 <__flash_rwdata_start+0xffffa9e0>
			&& (last_descr_ptr->next_desc_ptr_high == next_node_addr.u32[1]))
2109cc44:	183ff81e 	bne	r3,zero,2109cc28 <__flash_rwdata_start+0xffffa9e0>
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
2109cc48:	00bffa84 	movi	r2,-22
2109cc4c:	f800283a 	ret
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
2109cc50:	31400315 	stw	r5,12(r6)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
2109cc54:	30000b15 	stw	zero,44(r6)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
2109cc58:	29c00315 	stw	r7,12(r5)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
2109cc5c:	28000b15 	stw	zero,44(r5)
	return 0;
2109cc60:	0005883a 	mov	r2,zero
}
2109cc64:	f800283a 	ret
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
	}
	
	if (*list == NULL)
	{
		*list = descriptor;  /* make this the root-node if list is empty */
2109cc68:	21400015 	stw	r5,0(r4)
		return 0;
2109cc6c:	0005883a 	mov	r2,zero
2109cc70:	f800283a 	ret

2109cc74 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
	alt_u32 descriptor_control_field = 0;
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
2109cc74:	20000e26 	beq	r4,zero,2109ccb0 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x3c>
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
2109cc78:	20800317 	ldw	r2,12(r4)
2109cc7c:	200b883a 	mov	r5,r4
2109cc80:	11000626 	beq	r2,r4,2109cc9c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x28>
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
2109cc84:	20c00717 	ldw	r3,28(r4)
2109cc88:	18d00034 	orhi	r3,r3,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
2109cc8c:	20c00715 	stw	r3,28(r4)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
2109cc90:	1009883a 	mov	r4,r2
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
2109cc94:	10800317 	ldw	r2,12(r2)
2109cc98:	117ffa1e 	bne	r2,r5,2109cc84 <__flash_rwdata_start+0xffffaa3c>
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
2109cc9c:	20c00717 	ldw	r3,28(r4)
	
	return 0;
2109cca0:	0005883a 	mov	r2,zero
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
2109cca4:	18d00034 	orhi	r3,r3,16384
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
2109cca8:	20c00715 	stw	r3,28(r4)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
2109ccac:	f800283a 	ret
{
	alt_u32 descriptor_control_field = 0;
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
	{
		return -EINVAL;  /* this list cannot be empty */
2109ccb0:	00bffa84 	movi	r2,-22
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
}
2109ccb4:	f800283a 	ret

2109ccb8 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
{
	alt_u32 descriptor_control_field = 0;
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
2109ccb8:	20001426 	beq	r4,zero,2109cd0c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x54>
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
2109ccbc:	20800317 	ldw	r2,12(r4)
2109ccc0:	200d883a 	mov	r6,r4
2109ccc4:	11000c26 	beq	r2,r4,2109ccf8 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x40>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
2109ccc8:	20c00b17 	ldw	r3,44(r4)
2109cccc:	1800031e 	bne	r3,zero,2109ccdc <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x24>
2109ccd0:	00000906 	br	2109ccf8 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x40>
2109ccd4:	28c00b17 	ldw	r3,44(r5)
2109ccd8:	18000726 	beq	r3,zero,2109ccf8 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x40>
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
2109ccdc:	20c00f17 	ldw	r3,60(r4)
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
2109cce0:	100b883a 	mov	r5,r2
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
2109cce4:	18d00034 	orhi	r3,r3,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
2109cce8:	20c00f15 	stw	r3,60(r4)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
2109ccec:	1009883a 	mov	r4,r2
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
2109ccf0:	10800317 	ldw	r2,12(r2)
2109ccf4:	11bff71e 	bne	r2,r6,2109ccd4 <__flash_rwdata_start+0xffffaa8c>
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
2109ccf8:	20c00f17 	ldw	r3,60(r4)
	return 0;
2109ccfc:	0005883a 	mov	r2,zero
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
2109cd00:	18d00034 	orhi	r3,r3,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
2109cd04:	20c00f15 	stw	r3,60(r4)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
2109cd08:	f800283a 	ret
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
	{
		return -EINVAL;  /* this list cannot be empty */
2109cd0c:	00bffa84 	movi	r2,-22
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
}
2109cd10:	f800283a 	ret

2109cd14 <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
2109cd14:	da400017 	ldw	r9,0(sp)
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
2109cd18:	20800617 	ldw	r2,24(r4)
2109cd1c:	10800037 	ldwio	r2,0(r2)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
2109cd20:	10c0004c 	andi	r3,r2,1
2109cd24:	18003d1e 	bne	r3,zero,2109ce1c <alt_msgdma_start_prefetcher_with_list_addr+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109cd28:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109cd2c:	023fff84 	movi	r8,-2
2109cd30:	1a14703a 	and	r10,r3,r8
2109cd34:	5001703a 	wrctl	status,r10
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
2109cd38:	22800317 	ldw	r10,12(r4)
2109cd3c:	02c00804 	movi	r11,32
2109cd40:	52c00135 	stwio	r11,4(r10)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
2109cd44:	22800317 	ldw	r10,12(r4)
2109cd48:	52c00037 	ldwio	r11,0(r10)
2109cd4c:	52c00035 	stwio	r11,0(r10)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109cd50:	1801703a 	wrctl	status,r3
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
2109cd54:	20c00b17 	ldw	r3,44(r4)
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
2109cd58:	22800d17 	ldw	r10,52(r4)
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
2109cd5c:	18002926 	beq	r3,zero,2109ce04 <alt_msgdma_start_prefetcher_with_list_addr+0xf0>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
2109cd60:	00fff7c4 	movi	r3,-33
2109cd64:	50c6703a 	and	r3,r10,r3
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
2109cd68:	10800214 	ori	r2,r2,8
	 */
	if(dev->callback)
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
2109cd6c:	18c00514 	ori	r3,r3,20
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109cd70:	0015303a 	rdctl	r10,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109cd74:	5210703a 	and	r8,r10,r8
2109cd78:	4001703a 	wrctl	status,r8
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
2109cd7c:	22000317 	ldw	r8,12(r4)
2109cd80:	40c00135 	stwio	r3,4(r8)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
2109cd84:	20c00617 	ldw	r3,24(r4)
2109cd88:	18800035 	stwio	r2,0(r3)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109cd8c:	5001703a 	wrctl	status,r10
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
2109cd90:	20c00617 	ldw	r3,24(r4)
2109cd94:	19400135 	stwio	r5,4(r3)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
2109cd98:	20c00617 	ldw	r3,24(r4)
2109cd9c:	19800235 	stwio	r6,8(r3)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
2109cda0:	39c03fcc 	andi	r7,r7,255
2109cda4:	38000b1e 	bne	r7,zero,2109cdd4 <alt_msgdma_start_prefetcher_with_list_addr+0xc0>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
2109cda8:	00fffbc4 	movi	r3,-17
2109cdac:	10c4703a 	and	r2,r2,r3
	 }
	 
	 /* set poll-en */
	 if (poll_en){
2109cdb0:	48c03fcc 	andi	r3,r9,255
2109cdb4:	18000a1e 	bne	r3,zero,2109cde0 <alt_msgdma_start_prefetcher_with_list_addr+0xcc>
2109cdb8:	20c00617 	ldw	r3,24(r4)
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
2109cdbc:	013fff44 	movi	r4,-3
2109cdc0:	1104703a 	and	r2,r2,r4
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
2109cdc4:	10800054 	ori	r2,r2,1
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
2109cdc8:	18800035 	stwio	r2,0(r3)
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
	 
	 return 0;
2109cdcc:	0005883a 	mov	r2,zero
2109cdd0:	f800283a 	ret
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
	 }
	 
	 /* set poll-en */
	 if (poll_en){
2109cdd4:	48c03fcc 	andi	r3,r9,255
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
2109cdd8:	10800414 	ori	r2,r2,16
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
	 }
	 
	 /* set poll-en */
	 if (poll_en){
2109cddc:	183ff626 	beq	r3,zero,2109cdb8 <__flash_rwdata_start+0xffffab70>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
2109cde0:	20c00617 	ldw	r3,24(r4)
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
	 }
	 
	 /* set poll-en */
	 if (poll_en){
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
2109cde4:	10800094 	ori	r2,r2,2
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
2109cde8:	19400304 	addi	r5,r3,12
2109cdec:	29800037 	ldwio	r6,0(r5)
2109cdf0:	303ff41e 	bne	r6,zero,2109cdc4 <__flash_rwdata_start+0xffffab7c>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
2109cdf4:	00c03fc4 	movi	r3,255
2109cdf8:	28c00035 	stwio	r3,0(r5)
2109cdfc:	20c00617 	ldw	r3,24(r4)
2109ce00:	003ff006 	br	2109cdc4 <__flash_rwdata_start+0xffffab7c>
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
2109ce04:	00fff3c4 	movi	r3,-49
2109ce08:	50c6703a 	and	r3,r10,r3
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
2109ce0c:	02bffdc4 	movi	r10,-9
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
2109ce10:	18c00114 	ori	r3,r3,4
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
2109ce14:	1284703a 	and	r2,r2,r10
2109ce18:	003fd506 	br	2109cd70 <__flash_rwdata_start+0xffffab28>
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
		return -EBUSY;
2109ce1c:	00bffc04 	movi	r2,-16
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
	 
	 return 0;
}
2109ce20:	f800283a 	ret

2109ce24 <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
	alt_u32 descriptor_control_field = 0;
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
2109ce24:	28004726 	beq	r5,zero,2109cf44 <alt_msgdma_start_prefetcher_with_std_desc_list+0x120>
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
2109ce28:	28800317 	ldw	r2,12(r5)
2109ce2c:	2811883a 	mov	r8,r5
2109ce30:	11400626 	beq	r2,r5,2109ce4c <alt_msgdma_start_prefetcher_with_std_desc_list+0x28>
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
2109ce34:	28c00717 	ldw	r3,28(r5)
2109ce38:	18d00034 	orhi	r3,r3,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
2109ce3c:	28c00715 	stw	r3,28(r5)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
2109ce40:	100b883a 	mov	r5,r2
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
2109ce44:	10800317 	ldw	r2,12(r2)
2109ce48:	123ffa1e 	bne	r2,r8,2109ce34 <__flash_rwdata_start+0xffffabec>
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
2109ce4c:	28800717 	ldw	r2,28(r5)
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
2109ce50:	20c00617 	ldw	r3,24(r4)
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
2109ce54:	10900034 	orhi	r2,r2,16384
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
2109ce58:	28800715 	stw	r2,28(r5)
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
2109ce5c:	18800037 	ldwio	r2,0(r3)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
2109ce60:	10c0004c 	andi	r3,r2,1
2109ce64:	18003f1e 	bne	r3,zero,2109cf64 <alt_msgdma_start_prefetcher_with_std_desc_list+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109ce68:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109ce6c:	017fff84 	movi	r5,-2
2109ce70:	1952703a 	and	r9,r3,r5
2109ce74:	4801703a 	wrctl	status,r9
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
2109ce78:	22400317 	ldw	r9,12(r4)
2109ce7c:	02800804 	movi	r10,32
2109ce80:	4a800135 	stwio	r10,4(r9)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
2109ce84:	22400317 	ldw	r9,12(r4)
2109ce88:	4a800037 	ldwio	r10,0(r9)
2109ce8c:	4a800035 	stwio	r10,0(r9)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109ce90:	1801703a 	wrctl	status,r3
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
2109ce94:	20c00b17 	ldw	r3,44(r4)
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
2109ce98:	22400d17 	ldw	r9,52(r4)
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
2109ce9c:	18002b26 	beq	r3,zero,2109cf4c <alt_msgdma_start_prefetcher_with_std_desc_list+0x128>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
2109cea0:	00fff7c4 	movi	r3,-33
2109cea4:	48c6703a 	and	r3,r9,r3
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
2109cea8:	10800214 	ori	r2,r2,8
	 */
	if(dev->callback)
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
2109ceac:	18c00514 	ori	r3,r3,20
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109ceb0:	0013303a 	rdctl	r9,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109ceb4:	494a703a 	and	r5,r9,r5
2109ceb8:	2801703a 	wrctl	status,r5
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
2109cebc:	21400317 	ldw	r5,12(r4)
2109cec0:	28c00135 	stwio	r3,4(r5)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
2109cec4:	20c00617 	ldw	r3,24(r4)
2109cec8:	18800035 	stwio	r2,0(r3)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109cecc:	4801703a 	wrctl	status,r9
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
2109ced0:	20c00617 	ldw	r3,24(r4)
2109ced4:	1a000135 	stwio	r8,4(r3)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
2109ced8:	20c00617 	ldw	r3,24(r4)
2109cedc:	18000235 	stwio	zero,8(r3)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
2109cee0:	31803fcc 	andi	r6,r6,255
2109cee4:	30000b1e 	bne	r6,zero,2109cf14 <alt_msgdma_start_prefetcher_with_std_desc_list+0xf0>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
2109cee8:	00fffbc4 	movi	r3,-17
	 }
	 
	 /* set poll-en */
	 if (poll_en){
2109ceec:	39c03fcc 	andi	r7,r7,255
	 /* set park-mode */
	 if (park_mode_en){
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
2109cef0:	10c4703a 	and	r2,r2,r3
	 }
	 
	 /* set poll-en */
	 if (poll_en){
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
2109cef4:	20c00617 	ldw	r3,24(r4)
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
	 }
	 
	 /* set poll-en */
	 if (poll_en){
2109cef8:	38000a1e 	bne	r7,zero,2109cf24 <alt_msgdma_start_prefetcher_with_std_desc_list+0x100>
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
2109cefc:	013fff44 	movi	r4,-3
2109cf00:	1104703a 	and	r2,r2,r4
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
2109cf04:	10800054 	ori	r2,r2,1
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
2109cf08:	18800035 	stwio	r2,0(r3)
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
	 
	 return 0;
2109cf0c:	0005883a 	mov	r2,zero
2109cf10:	f800283a 	ret
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
	 }
	 
	 /* set poll-en */
	 if (poll_en){
2109cf14:	39c03fcc 	andi	r7,r7,255
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
2109cf18:	10800414 	ori	r2,r2,16
	 }
	 
	 /* set poll-en */
	 if (poll_en){
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
2109cf1c:	20c00617 	ldw	r3,24(r4)
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
	 }
	 
	 /* set poll-en */
	 if (poll_en){
2109cf20:	383ff626 	beq	r7,zero,2109cefc <__flash_rwdata_start+0xffffacb4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
2109cf24:	10800094 	ori	r2,r2,2
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
2109cf28:	19400304 	addi	r5,r3,12
2109cf2c:	29800037 	ldwio	r6,0(r5)
2109cf30:	303ff41e 	bne	r6,zero,2109cf04 <__flash_rwdata_start+0xffffacbc>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
2109cf34:	00c03fc4 	movi	r3,255
2109cf38:	28c00035 	stwio	r3,0(r5)
2109cf3c:	20c00617 	ldw	r3,24(r4)
2109cf40:	003ff006 	br	2109cf04 <__flash_rwdata_start+0xffffacbc>
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
		return -EINVAL;
2109cf44:	00bffa84 	movi	r2,-22
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
			park_mode_en, poll_en);
}
2109cf48:	f800283a 	ret
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
2109cf4c:	00fff3c4 	movi	r3,-49
2109cf50:	48c6703a 	and	r3,r9,r3
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
2109cf54:	027ffdc4 	movi	r9,-9
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
2109cf58:	18c00114 	ori	r3,r3,4
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
2109cf5c:	1244703a 	and	r2,r2,r9
2109cf60:	003fd306 	br	2109ceb0 <__flash_rwdata_start+0xffffac68>
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
		return -EBUSY;
2109cf64:	00bffc04 	movi	r2,-16
{	
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
		return -EINVAL;
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
2109cf68:	f800283a 	ret

2109cf6c <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
2109cf6c:	defffe04 	addi	sp,sp,-8
2109cf70:	dfc00115 	stw	ra,4(sp)
{
	alt_u32 descriptor_control_field = 0;
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
2109cf74:	28001d26 	beq	r5,zero,2109cfec <alt_msgdma_start_prefetcher_with_extd_desc_list+0x80>
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
2109cf78:	28800317 	ldw	r2,12(r5)
2109cf7c:	3015883a 	mov	r10,r6
2109cf80:	2813883a 	mov	r9,r5
	}
	
	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;
2109cf84:	280d883a 	mov	r6,r5

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
2109cf88:	11400c26 	beq	r2,r5,2109cfbc <alt_msgdma_start_prefetcher_with_extd_desc_list+0x50>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
2109cf8c:	28c00b17 	ldw	r3,44(r5)
2109cf90:	1800031e 	bne	r3,zero,2109cfa0 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x34>
2109cf94:	00000906 	br	2109cfbc <alt_msgdma_start_prefetcher_with_extd_desc_list+0x50>
2109cf98:	40c00b17 	ldw	r3,44(r8)
2109cf9c:	18000726 	beq	r3,zero,2109cfbc <alt_msgdma_start_prefetcher_with_extd_desc_list+0x50>
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
2109cfa0:	28c00f17 	ldw	r3,60(r5)
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
2109cfa4:	1011883a 	mov	r8,r2
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
2109cfa8:	18d00034 	orhi	r3,r3,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
2109cfac:	28c00f15 	stw	r3,60(r5)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
2109cfb0:	100b883a 	mov	r5,r2
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
2109cfb4:	10800317 	ldw	r2,12(r2)
2109cfb8:	127ff71e 	bne	r2,r9,2109cf98 <__flash_rwdata_start+0xffffad50>
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
2109cfbc:	28c00f17 	ldw	r3,60(r5)
	alt_u8 poll_en)
{
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
		return -EINVAL;
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
2109cfc0:	38803fcc 	andi	r2,r7,255
2109cfc4:	51c03fcc 	andi	r7,r10,255
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
2109cfc8:	18d00034 	orhi	r3,r3,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
2109cfcc:	28c00f15 	stw	r3,60(r5)
	alt_u8 poll_en)
{
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
		return -EINVAL;
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
2109cfd0:	d8800015 	stw	r2,0(sp)
2109cfd4:	300b883a 	mov	r5,r6
2109cfd8:	000d883a 	mov	r6,zero
2109cfdc:	109cd140 	call	2109cd14 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
2109cfe0:	dfc00117 	ldw	ra,4(sp)
2109cfe4:	dec00204 	addi	sp,sp,8
2109cfe8:	f800283a 	ret
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
		return -EINVAL;
2109cfec:	00bffa84 	movi	r2,-22
2109cff0:	003ffb06 	br	2109cfe0 <__flash_rwdata_start+0xffffad98>

2109cff4 <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
2109cff4:	defffe04 	addi	sp,sp,-8
    alt_msgdma_dev* dev = NULL;

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
2109cff8:	d1601904 	addi	r5,gp,-32668
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
2109cffc:	dc000015 	stw	r16,0(sp)
2109d000:	dfc00115 	stw	ra,4(sp)
    alt_msgdma_dev* dev = NULL;

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
2109d004:	109da580 	call	2109da58 <alt_find_dev>
2109d008:	1021883a 	mov	r16,r2

    if (NULL == dev)
2109d00c:	10000526 	beq	r2,zero,2109d024 <alt_msgdma_open+0x30>
    {
        ALT_ERRNO = ENODEV;
    }

    return dev;
}
2109d010:	8005883a 	mov	r2,r16
2109d014:	dfc00117 	ldw	ra,4(sp)
2109d018:	dc000017 	ldw	r16,0(sp)
2109d01c:	dec00204 	addi	sp,sp,8
2109d020:	f800283a 	ret
2109d024:	00800034 	movhi	r2,0
2109d028:	10977504 	addi	r2,r2,24020
2109d02c:	10800017 	ldw	r2,0(r2)
2109d030:	10000426 	beq	r2,zero,2109d044 <alt_msgdma_open+0x50>
2109d034:	103ee83a 	callr	r2

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);

    if (NULL == dev)
    {
        ALT_ERRNO = ENODEV;
2109d038:	00c004c4 	movi	r3,19
2109d03c:	10c00015 	stw	r3,0(r2)
2109d040:	003ff306 	br	2109d010 <__flash_rwdata_start+0xffffadc8>
2109d044:	00800034 	movhi	r2,0
2109d048:	10978504 	addi	r2,r2,24084
2109d04c:	003ffa06 	br	2109d038 <__flash_rwdata_start+0xffffadf0>

2109d050 <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
2109d050:	defffb04 	addi	sp,sp,-20
2109d054:	dc800315 	stw	r18,12(sp)
2109d058:	dc400215 	stw	r17,8(sp)
2109d05c:	dc000115 	stw	r16,4(sp)
2109d060:	dfc00415 	stw	ra,16(sp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
2109d064:	20801783 	ldbu	r2,94(r4)
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
2109d068:	2021883a 	mov	r16,r4
2109d06c:	2825883a 	mov	r18,r5
2109d070:	3023883a 	mov	r17,r6
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
2109d074:	1000261e 	bne	r2,zero,2109d110 <alt_msgdma_init+0xc0>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
2109d078:	80800317 	ldw	r2,12(r16)
2109d07c:	00c00084 	movi	r3,2
2109d080:	10c00135 	stwio	r3,4(r2)
2109d084:	80c00317 	ldw	r3,12(r16)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
2109d088:	18800037 	ldwio	r2,0(r3)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
2109d08c:	1080100c 	andi	r2,r2,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
2109d090:	103ffd1e 	bne	r2,zero,2109d088 <__flash_rwdata_start+0xffffae40>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
2109d094:	18c00104 	addi	r3,r3,4
2109d098:	19000037 	ldwio	r4,0(r3)
2109d09c:	00bffbc4 	movi	r2,-17
2109d0a0:	2084703a 	and	r2,r4,r2
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
2109d0a4:	10800814 	ori	r2,r2,32
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
2109d0a8:	18800035 	stwio	r2,0(r3)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
2109d0ac:	80800317 	ldw	r2,12(r16)
2109d0b0:	10c00037 	ldwio	r3,0(r2)
2109d0b4:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
2109d0b8:	80801783 	ldbu	r2,94(r16)
2109d0bc:	10000426 	beq	r2,zero,2109d0d0 <alt_msgdma_init+0x80>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
2109d0c0:	80800617 	ldw	r2,24(r16)
2109d0c4:	10800404 	addi	r2,r2,16
2109d0c8:	10c00037 	ldwio	r3,0(r2)
2109d0cc:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
2109d0d0:	8009883a 	mov	r4,r16
2109d0d4:	d1601904 	addi	r5,gp,-32668
2109d0d8:	109d9180 	call	2109d918 <alt_dev_llist_insert>
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
            
    if (!error)
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
2109d0dc:	018842b4 	movhi	r6,8458
2109d0e0:	31b17a04 	addi	r6,r6,-14872
2109d0e4:	d8000015 	stw	zero,0(sp)
2109d0e8:	9009883a 	mov	r4,r18
2109d0ec:	880b883a 	mov	r5,r17
2109d0f0:	800f883a 	mov	r7,r16
2109d0f4:	109dadc0 	call	2109dadc <alt_ic_isr_register>
        alt_printf("failed to create semaphores\n");
    }
    
    return;

}
2109d0f8:	dfc00417 	ldw	ra,16(sp)
2109d0fc:	dc800317 	ldw	r18,12(sp)
2109d100:	dc400217 	ldw	r17,8(sp)
2109d104:	dc000117 	ldw	r16,4(sp)
2109d108:	dec00504 	addi	sp,sp,20
2109d10c:	f800283a 	ret
    int error;

    if (dev->prefetcher_enable)
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
2109d110:	20800617 	ldw	r2,24(r4)
2109d114:	00c00104 	movi	r3,4
2109d118:	10c00035 	stwio	r3,0(r2)
2109d11c:	20c00617 	ldw	r3,24(r4)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
2109d120:	18800037 	ldwio	r2,0(r3)
2109d124:	1080010c 	andi	r2,r2,4
2109d128:	103ffd1e 	bne	r2,zero,2109d120 <__flash_rwdata_start+0xffffaed8>
2109d12c:	003fd206 	br	2109d078 <__flash_rwdata_start+0xffffae30>

2109d130 <alt_msgdma_register_callback>:
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
    dev->callback         = callback;
2109d130:	21400b15 	stw	r5,44(r4)
    dev->callback_context = context;
2109d134:	21c00c15 	stw	r7,48(r4)
    dev->control          = control;
2109d138:	21800d15 	stw	r6,52(r4)
2109d13c:	f800283a 	ret

2109d140 <alt_msgdma_standard_descriptor_async_transfer>:
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
2109d140:	21c00317 	ldw	r7,12(r4)
2109d144:	39800204 	addi	r6,r7,8
2109d148:	30800037 	ldwio	r2,0(r6)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
2109d14c:	10ffffcc 	andi	r3,r2,65535
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
2109d150:	30800037 	ldwio	r2,0(r6)
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
2109d154:	21800917 	ldw	r6,36(r4)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
2109d158:	1004d43a 	srli	r2,r2,16
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
2109d15c:	1180452e 	bgeu	r2,r6,2109d274 <alt_msgdma_standard_descriptor_async_transfer+0x134>
2109d160:	1980442e 	bgeu	r3,r6,2109d274 <alt_msgdma_standard_descriptor_async_transfer+0x134>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109d164:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109d168:	00bfff84 	movi	r2,-2
2109d16c:	1884703a 	and	r2,r3,r2
2109d170:	1001703a 	wrctl	status,r2
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
2109d174:	00800804 	movi	r2,32
2109d178:	38800135 	stwio	r2,4(r7)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
2109d17c:	20800317 	ldw	r2,12(r4)
2109d180:	11800037 	ldwio	r6,0(r2)
2109d184:	11800035 	stwio	r6,0(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109d188:	1801703a 	wrctl	status,r3
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
2109d18c:	28003726 	beq	r5,zero,2109d26c <alt_msgdma_standard_descriptor_async_transfer+0x12c>
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_standard_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
2109d190:	defffc04 	addi	sp,sp,-16
2109d194:	dc800215 	stw	r18,8(sp)
2109d198:	dc400115 	stw	r17,4(sp)
2109d19c:	dc000015 	stw	r16,0(sp)
2109d1a0:	dfc00315 	stw	ra,12(sp)
2109d1a4:	2825883a 	mov	r18,r5
2109d1a8:	2023883a 	mov	r17,r4
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
2109d1ac:	0404e244 	movi	r16,5001
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
2109d1b0:	88c00417 	ldw	r3,16(r17)
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
2109d1b4:	88800317 	ldw	r2,12(r17)
2109d1b8:	10800037 	ldwio	r2,0(r2)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
2109d1bc:	01000044 	movi	r4,1
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
2109d1c0:	1080010c 	andi	r2,r2,4
2109d1c4:	10000a26 	beq	r2,zero,2109d1f0 <alt_msgdma_standard_descriptor_async_transfer+0xb0>
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
2109d1c8:	109d8b80 	call	2109d8b8 <alt_busy_sleep>
2109d1cc:	80bfffc4 	addi	r2,r16,-1
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
2109d1d0:	10ffffcc 	andi	r3,r2,65535
2109d1d4:	1021883a 	mov	r16,r2
2109d1d8:	183ff51e 	bne	r3,zero,2109d1b0 <__flash_rwdata_start+0xffffaf68>
            {
                alt_printf("time out after 5 msec while waiting" 
2109d1dc:	01000034 	movhi	r4,0
2109d1e0:	210f5804 	addi	r4,r4,15712
2109d1e4:	109de940 	call	2109de94 <alt_printf>
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
				
                return -ETIME;
2109d1e8:	00bff084 	movi	r2,-62
2109d1ec:	00001506 	br	2109d244 <alt_msgdma_standard_descriptor_async_transfer+0x104>
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
2109d1f0:	91000017 	ldw	r4,0(r18)
2109d1f4:	19000035 	stwio	r4,0(r3)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
2109d1f8:	91000117 	ldw	r4,4(r18)
2109d1fc:	19000135 	stwio	r4,4(r3)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
2109d200:	91000217 	ldw	r4,8(r18)
2109d204:	19000235 	stwio	r4,8(r3)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
2109d208:	91000317 	ldw	r4,12(r18)
2109d20c:	19000335 	stwio	r4,12(r3)
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
2109d210:	88c00b17 	ldw	r3,44(r17)
    {

        control |= (dev->control |
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
2109d214:	89000d17 	ldw	r4,52(r17)
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
2109d218:	18001026 	beq	r3,zero,2109d25c <alt_msgdma_standard_descriptor_async_transfer+0x11c>
    {

        control |= (dev->control |
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
2109d21c:	00fff7c4 	movi	r3,-33
2109d220:	20c6703a 	and	r3,r4,r3
2109d224:	18c00514 	ori	r3,r3,20
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109d228:	000b303a 	rdctl	r5,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109d22c:	013fff84 	movi	r4,-2
2109d230:	2908703a 	and	r4,r5,r4
2109d234:	2001703a 	wrctl	status,r4
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
2109d238:	89000317 	ldw	r4,12(r17)
2109d23c:	20c00135 	stwio	r3,4(r4)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109d240:	2801703a 	wrctl	status,r5
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);

}
2109d244:	dfc00317 	ldw	ra,12(sp)
2109d248:	dc800217 	ldw	r18,8(sp)
2109d24c:	dc400117 	ldw	r17,4(sp)
2109d250:	dc000017 	ldw	r16,0(sp)
2109d254:	dec00404 	addi	sp,sp,16
2109d258:	f800283a 	ret
    */
    else
    {
        control |= (dev->control |
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
2109d25c:	00fff3c4 	movi	r3,-49
2109d260:	20c6703a 	and	r3,r4,r3
2109d264:	18c00114 	ori	r3,r3,4
2109d268:	003fef06 	br	2109d228 <__flash_rwdata_start+0xffffafe0>
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
2109d26c:	00bfffc4 	movi	r2,-1
2109d270:	f800283a 	ret
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
2109d274:	00bff904 	movi	r2,-28
2109d278:	f800283a 	ret

2109d27c <alt_msgdma_extended_descriptor_async_transfer>:
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
2109d27c:	21c00317 	ldw	r7,12(r4)
2109d280:	39800204 	addi	r6,r7,8
2109d284:	30800037 	ldwio	r2,0(r6)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
2109d288:	10ffffcc 	andi	r3,r2,65535
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
2109d28c:	30800037 	ldwio	r2,0(r6)
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
2109d290:	21800917 	ldw	r6,36(r4)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
2109d294:	1004d43a 	srli	r2,r2,16
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
2109d298:	11804f2e 	bgeu	r2,r6,2109d3d8 <alt_msgdma_extended_descriptor_async_transfer+0x15c>
2109d29c:	19804e2e 	bgeu	r3,r6,2109d3d8 <alt_msgdma_extended_descriptor_async_transfer+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109d2a0:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109d2a4:	00bfff84 	movi	r2,-2
2109d2a8:	1884703a 	and	r2,r3,r2
2109d2ac:	1001703a 	wrctl	status,r2
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
2109d2b0:	00800804 	movi	r2,32
2109d2b4:	38800135 	stwio	r2,4(r7)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
2109d2b8:	20800317 	ldw	r2,12(r4)
2109d2bc:	11800037 	ldwio	r6,0(r2)
2109d2c0:	11800035 	stwio	r6,0(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109d2c4:	1801703a 	wrctl	status,r3
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
2109d2c8:	28004526 	beq	r5,zero,2109d3e0 <alt_msgdma_extended_descriptor_async_transfer+0x164>
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
2109d2cc:	defffc04 	addi	sp,sp,-16
2109d2d0:	dc800215 	stw	r18,8(sp)
2109d2d4:	dc400115 	stw	r17,4(sp)
2109d2d8:	dc000015 	stw	r16,0(sp)
2109d2dc:	dfc00315 	stw	ra,12(sp)
2109d2e0:	2821883a 	mov	r16,r5
2109d2e4:	2023883a 	mov	r17,r4
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
2109d2e8:	0484e244 	movi	r18,5001
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
2109d2ec:	88c00417 	ldw	r3,16(r17)
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
2109d2f0:	88800317 	ldw	r2,12(r17)
2109d2f4:	10800037 	ldwio	r2,0(r2)
2109d2f8:	1080010c 	andi	r2,r2,4
2109d2fc:	1000271e 	bne	r2,zero,2109d39c <alt_msgdma_extended_descriptor_async_transfer+0x120>
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
2109d300:	81000017 	ldw	r4,0(r16)
2109d304:	19000035 	stwio	r4,0(r3)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
2109d308:	81000117 	ldw	r4,4(r16)
2109d30c:	19000135 	stwio	r4,4(r3)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
2109d310:	81000217 	ldw	r4,8(r16)
2109d314:	19000235 	stwio	r4,8(r3)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
2109d318:	8100030b 	ldhu	r4,12(r16)
2109d31c:	1900032d 	sthio	r4,12(r3)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
2109d320:	81000383 	ldbu	r4,14(r16)
2109d324:	190003a5 	stbio	r4,14(r3)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
2109d328:	810003c3 	ldbu	r4,15(r16)
2109d32c:	190003e5 	stbio	r4,15(r3)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
2109d330:	8100040b 	ldhu	r4,16(r16)
2109d334:	1900042d 	sthio	r4,16(r3)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
2109d338:	8100048b 	ldhu	r4,18(r16)
2109d33c:	190004ad 	sthio	r4,18(r3)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
2109d340:	18000535 	stwio	zero,20(r3)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
2109d344:	18000635 	stwio	zero,24(r3)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
2109d348:	81000717 	ldw	r4,28(r16)
2109d34c:	19000735 	stwio	r4,28(r3)
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
2109d350:	88c00b17 	ldw	r3,44(r17)
    {

        control |= (dev->control |
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
2109d354:	89000d17 	ldw	r4,52(r17)
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
2109d358:	18001b26 	beq	r3,zero,2109d3c8 <alt_msgdma_extended_descriptor_async_transfer+0x14c>
    {

        control |= (dev->control |
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
2109d35c:	00fff7c4 	movi	r3,-33
2109d360:	20c6703a 	and	r3,r4,r3
2109d364:	18c00514 	ori	r3,r3,20
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109d368:	000b303a 	rdctl	r5,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109d36c:	013fff84 	movi	r4,-2
2109d370:	2908703a 	and	r4,r5,r4
2109d374:	2001703a 	wrctl	status,r4
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
2109d378:	89000317 	ldw	r4,12(r17)
2109d37c:	20c00135 	stwio	r3,4(r4)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109d380:	2801703a 	wrctl	status,r5
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
}
2109d384:	dfc00317 	ldw	ra,12(sp)
2109d388:	dc800217 	ldw	r18,8(sp)
2109d38c:	dc400117 	ldw	r17,4(sp)
2109d390:	dc000017 	ldw	r16,0(sp)
2109d394:	dec00404 	addi	sp,sp,16
2109d398:	f800283a 	ret
        while(0 != alt_msgdma_write_extended_descriptor (
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
2109d39c:	01000044 	movi	r4,1
2109d3a0:	109d8b80 	call	2109d8b8 <alt_busy_sleep>
2109d3a4:	90bfffc4 	addi	r2,r18,-1
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
2109d3a8:	10ffffcc 	andi	r3,r2,65535
2109d3ac:	1025883a 	mov	r18,r2
2109d3b0:	183fce1e 	bne	r3,zero,2109d2ec <__flash_rwdata_start+0xffffb0a4>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
2109d3b4:	01000034 	movhi	r4,0
2109d3b8:	210f6e04 	addi	r4,r4,15800
2109d3bc:	109de940 	call	2109de94 <alt_printf>
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
				
                return -ETIME;
2109d3c0:	00bff084 	movi	r2,-62
2109d3c4:	003fef06 	br	2109d384 <__flash_rwdata_start+0xffffb13c>
    */
    else
    {
        control |= (dev->control |
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
2109d3c8:	00fff3c4 	movi	r3,-49
2109d3cc:	20c6703a 	and	r3,r4,r3
2109d3d0:	18c00114 	ori	r3,r3,4
2109d3d4:	003fe406 	br	2109d368 <__flash_rwdata_start+0xffffb120>
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
2109d3d8:	00bff904 	movi	r2,-28
2109d3dc:	f800283a 	ret
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
2109d3e0:	00bfffc4 	movi	r2,-1
2109d3e4:	f800283a 	ret

2109d3e8 <alt_msgdma_standard_descriptor_sync_transfer>:
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
2109d3e8:	21800317 	ldw	r6,12(r4)
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
2109d3ec:	defffa04 	addi	sp,sp,-24
2109d3f0:	dc800215 	stw	r18,8(sp)
2109d3f4:	dc400115 	stw	r17,4(sp)
2109d3f8:	2825883a 	mov	r18,r5
2109d3fc:	2023883a 	mov	r17,r4
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
2109d400:	31000204 	addi	r4,r6,8
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
2109d404:	dfc00515 	stw	ra,20(sp)
2109d408:	dd000415 	stw	r20,16(sp)
2109d40c:	dcc00315 	stw	r19,12(sp)
2109d410:	dc000015 	stw	r16,0(sp)
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
2109d414:	20800037 	ldwio	r2,0(r4)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
2109d418:	10ffffcc 	andi	r3,r2,65535
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
2109d41c:	20800037 	ldwio	r2,0(r4)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
2109d420:	0404e244 	movi	r16,5001
2109d424:	1004d43a 	srli	r2,r2,16
2109d428:	00000b06 	br	2109d458 <alt_msgdma_standard_descriptor_sync_transfer+0x70>
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
2109d42c:	109d8b80 	call	2109d8b8 <alt_busy_sleep>
2109d430:	80bfffc4 	addi	r2,r16,-1
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
2109d434:	10ffffcc 	andi	r3,r2,65535
2109d438:	1021883a 	mov	r16,r2
2109d43c:	18005826 	beq	r3,zero,2109d5a0 <alt_msgdma_standard_descriptor_sync_transfer+0x1b8>
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
2109d440:	89800317 	ldw	r6,12(r17)
2109d444:	31000204 	addi	r4,r6,8
2109d448:	20800037 	ldwio	r2,0(r4)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
2109d44c:	10ffffcc 	andi	r3,r2,65535
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
2109d450:	20800037 	ldwio	r2,0(r4)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
2109d454:	1004d43a 	srli	r2,r2,16
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
2109d458:	89400917 	ldw	r5,36(r17)
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
2109d45c:	01000044 	movi	r4,1
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
2109d460:	117ff22e 	bgeu	r2,r5,2109d42c <__flash_rwdata_start+0xffffb1e4>
2109d464:	197ff12e 	bgeu	r3,r5,2109d42c <__flash_rwdata_start+0xffffb1e4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109d468:	0029303a 	rdctl	r20,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109d46c:	00bfff84 	movi	r2,-2
2109d470:	a084703a 	and	r2,r20,r2
2109d474:	1001703a 	wrctl	status,r2
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
2109d478:	00800804 	movi	r2,32
2109d47c:	30800135 	stwio	r2,4(r6)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
2109d480:	88800317 	ldw	r2,12(r17)
2109d484:	10c00037 	ldwio	r3,0(r2)
2109d488:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
2109d48c:	90005626 	beq	r18,zero,2109d5e8 <alt_msgdma_standard_descriptor_sync_transfer+0x200>
2109d490:	04c4e244 	movi	r19,5001
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
2109d494:	88800417 	ldw	r2,16(r17)
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
2109d498:	88c00317 	ldw	r3,12(r17)
2109d49c:	1c000037 	ldwio	r16,0(r3)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
2109d4a0:	01000044 	movi	r4,1
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
2109d4a4:	8400010c 	andi	r16,r16,4
2109d4a8:	80000a26 	beq	r16,zero,2109d4d4 <alt_msgdma_standard_descriptor_sync_transfer+0xec>
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
2109d4ac:	109d8b80 	call	2109d8b8 <alt_busy_sleep>
2109d4b0:	98bfffc4 	addi	r2,r19,-1
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
2109d4b4:	10ffffcc 	andi	r3,r2,65535
2109d4b8:	1027883a 	mov	r19,r2
2109d4bc:	183ff51e 	bne	r3,zero,2109d494 <__flash_rwdata_start+0xffffb24c>
            {
                alt_printf("time out after 5 msec while writing standard" 
2109d4c0:	01000034 	movhi	r4,0
2109d4c4:	210f9804 	addi	r4,r4,15968
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
				
                return -ETIME;
2109d4c8:	043ff084 	movi	r16,-62
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
            {
                alt_printf("time out after 5 msec while writing standard" 
2109d4cc:	109de940 	call	2109de94 <alt_printf>
2109d4d0:	00002a06 	br	2109d57c <alt_msgdma_standard_descriptor_sync_transfer+0x194>
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
2109d4d4:	90c00017 	ldw	r3,0(r18)
2109d4d8:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
2109d4dc:	90c00117 	ldw	r3,4(r18)
2109d4e0:	10c00135 	stwio	r3,4(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
2109d4e4:	90c00217 	ldw	r3,8(r18)
2109d4e8:	10c00235 	stwio	r3,8(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
2109d4ec:	90c00317 	ldw	r3,12(r18)
2109d4f0:	10c00335 	stwio	r3,12(r2)
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
2109d4f4:	89000d17 	ldw	r4,52(r17)
2109d4f8:	88c00317 	ldw	r3,12(r17)
2109d4fc:	00bff2c4 	movi	r2,-53
2109d500:	2084703a 	and	r2,r4,r2
2109d504:	10800114 	ori	r2,r2,4
2109d508:	18800135 	stwio	r2,4(r3)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109d50c:	a001703a 	wrctl	status,r20
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
2109d510:	89800317 	ldw	r6,12(r17)
2109d514:	30800037 	ldwio	r2,0(r6)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
2109d518:	10c0780c 	andi	r3,r2,480
2109d51c:	1800161e 	bne	r3,zero,2109d578 <alt_msgdma_standard_descriptor_sync_transfer+0x190>
2109d520:	1080004c 	andi	r2,r2,1
2109d524:	10002326 	beq	r2,zero,2109d5b4 <alt_msgdma_standard_descriptor_sync_transfer+0x1cc>
    {
        alt_busy_sleep(1); /* delay 1us */
2109d528:	01000044 	movi	r4,1
2109d52c:	109d8b80 	call	2109d8b8 <alt_busy_sleep>
2109d530:	0484e204 	movi	r18,5000
			ALT_SEM_POST (dev->regs_lock);
			
            return -ETIME;
        }
        counter++;
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
2109d534:	89800317 	ldw	r6,12(r17)
2109d538:	30800037 	ldwio	r2,0(r6)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
    {
        alt_busy_sleep(1); /* delay 1us */
2109d53c:	01000044 	movi	r4,1
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
2109d540:	10c0780c 	andi	r3,r2,480
2109d544:	1104703a 	and	r2,r2,r4
2109d548:	18000b1e 	bne	r3,zero,2109d578 <alt_msgdma_standard_descriptor_sync_transfer+0x190>
2109d54c:	10001926 	beq	r2,zero,2109d5b4 <alt_msgdma_standard_descriptor_sync_transfer+0x1cc>
    {
        alt_busy_sleep(1); /* delay 1us */
2109d550:	109d8b80 	call	2109d8b8 <alt_busy_sleep>
2109d554:	90bfffc4 	addi	r2,r18,-1
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
2109d558:	10ffffcc 	andi	r3,r2,65535
2109d55c:	1025883a 	mov	r18,r2
2109d560:	183ff41e 	bne	r3,zero,2109d534 <__flash_rwdata_start+0xffffb2ec>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
2109d564:	01000034 	movhi	r4,0
2109d568:	210fa904 	addi	r4,r4,16036
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
			
            return -ETIME;
2109d56c:	043ff084 	movi	r16,-62
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
    {
        alt_busy_sleep(1); /* delay 1us */
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
2109d570:	109de940 	call	2109de94 <alt_printf>
2109d574:	00000106 	br	2109d57c <alt_msgdma_standard_descriptor_sync_transfer+0x194>
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
		
        return error;
2109d578:	04007804 	movi	r16,480
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
}
2109d57c:	8005883a 	mov	r2,r16
2109d580:	dfc00517 	ldw	ra,20(sp)
2109d584:	dd000417 	ldw	r20,16(sp)
2109d588:	dcc00317 	ldw	r19,12(sp)
2109d58c:	dc800217 	ldw	r18,8(sp)
2109d590:	dc400117 	ldw	r17,4(sp)
2109d594:	dc000017 	ldw	r16,0(sp)
2109d598:	dec00604 	addi	sp,sp,24
2109d59c:	f800283a 	ret
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
2109d5a0:	01000034 	movhi	r4,0
2109d5a4:	210f8404 	addi	r4,r4,15888
				" for storing descriptor\n");
            return -ETIME;
2109d5a8:	043ff084 	movi	r16,-62
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
2109d5ac:	109de940 	call	2109de94 <alt_printf>
2109d5b0:	003ff206 	br	2109d57c <__flash_rwdata_start+0xffffb334>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
2109d5b4:	31800104 	addi	r6,r6,4
2109d5b8:	30800037 	ldwio	r2,0(r6)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109d5bc:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109d5c0:	00ffff84 	movi	r3,-2
2109d5c4:	20c6703a 	and	r3,r4,r3
2109d5c8:	1801703a 	wrctl	status,r3
2109d5cc:	10800814 	ori	r2,r2,32
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
2109d5d0:	30800035 	stwio	r2,0(r6)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
2109d5d4:	88800317 	ldw	r2,12(r17)
2109d5d8:	10c00037 	ldwio	r3,0(r2)
2109d5dc:	10c00035 	stwio	r3,0(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109d5e0:	2001703a 	wrctl	status,r4
2109d5e4:	003fe506 	br	2109d57c <__flash_rwdata_start+0xffffb334>
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
2109d5e8:	043fffc4 	movi	r16,-1
2109d5ec:	003fe306 	br	2109d57c <__flash_rwdata_start+0xffffb334>

2109d5f0 <alt_msgdma_extended_descriptor_sync_transfer>:
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
2109d5f0:	20c00317 	ldw	r3,12(r4)
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
2109d5f4:	defffa04 	addi	sp,sp,-24
2109d5f8:	dc800215 	stw	r18,8(sp)
2109d5fc:	dc000015 	stw	r16,0(sp)
2109d600:	2825883a 	mov	r18,r5
2109d604:	2021883a 	mov	r16,r4
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
2109d608:	19000204 	addi	r4,r3,8
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
2109d60c:	dfc00515 	stw	ra,20(sp)
2109d610:	dd000415 	stw	r20,16(sp)
2109d614:	dcc00315 	stw	r19,12(sp)
2109d618:	dc400115 	stw	r17,4(sp)
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
2109d61c:	20800037 	ldwio	r2,0(r4)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
2109d620:	117fffcc 	andi	r5,r2,65535
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
2109d624:	20800037 	ldwio	r2,0(r4)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
2109d628:	0444e244 	movi	r17,5001
2109d62c:	1004d43a 	srli	r2,r2,16
2109d630:	00000b06 	br	2109d660 <alt_msgdma_extended_descriptor_sync_transfer+0x70>
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
2109d634:	109d8b80 	call	2109d8b8 <alt_busy_sleep>
2109d638:	88bfffc4 	addi	r2,r17,-1
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
2109d63c:	10ffffcc 	andi	r3,r2,65535
2109d640:	1023883a 	mov	r17,r2
2109d644:	18007026 	beq	r3,zero,2109d808 <alt_msgdma_extended_descriptor_sync_transfer+0x218>
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
2109d648:	80c00317 	ldw	r3,12(r16)
2109d64c:	19000204 	addi	r4,r3,8
2109d650:	20800037 	ldwio	r2,0(r4)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
2109d654:	117fffcc 	andi	r5,r2,65535
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
2109d658:	20800037 	ldwio	r2,0(r4)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
2109d65c:	1004d43a 	srli	r2,r2,16
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
2109d660:	81800917 	ldw	r6,36(r16)
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
2109d664:	01000044 	movi	r4,1
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
2109d668:	11bff22e 	bgeu	r2,r6,2109d634 <__flash_rwdata_start+0xffffb3ec>
2109d66c:	29bff12e 	bgeu	r5,r6,2109d634 <__flash_rwdata_start+0xffffb3ec>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109d670:	0027303a 	rdctl	r19,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109d674:	00bfff84 	movi	r2,-2
2109d678:	9884703a 	and	r2,r19,r2
2109d67c:	1001703a 	wrctl	status,r2
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
2109d680:	00800804 	movi	r2,32
2109d684:	18800135 	stwio	r2,4(r3)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
2109d688:	80800317 	ldw	r2,12(r16)
2109d68c:	10c00037 	ldwio	r3,0(r2)
2109d690:	10c00035 	stwio	r3,0(r2)
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
2109d694:	90006126 	beq	r18,zero,2109d81c <alt_msgdma_extended_descriptor_sync_transfer+0x22c>
2109d698:	0504e244 	movi	r20,5001
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
2109d69c:	80c00417 	ldw	r3,16(r16)
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
2109d6a0:	80800317 	ldw	r2,12(r16)
2109d6a4:	14400037 	ldwio	r17,0(r2)
2109d6a8:	8c40010c 	andi	r17,r17,4
2109d6ac:	8800341e 	bne	r17,zero,2109d780 <alt_msgdma_extended_descriptor_sync_transfer+0x190>
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
2109d6b0:	90800017 	ldw	r2,0(r18)
2109d6b4:	18800035 	stwio	r2,0(r3)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
2109d6b8:	90800117 	ldw	r2,4(r18)
2109d6bc:	18800135 	stwio	r2,4(r3)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
2109d6c0:	90800217 	ldw	r2,8(r18)
2109d6c4:	18800235 	stwio	r2,8(r3)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
2109d6c8:	9080030b 	ldhu	r2,12(r18)
2109d6cc:	1880032d 	sthio	r2,12(r3)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
2109d6d0:	90800383 	ldbu	r2,14(r18)
2109d6d4:	188003a5 	stbio	r2,14(r3)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
2109d6d8:	908003c3 	ldbu	r2,15(r18)
2109d6dc:	188003e5 	stbio	r2,15(r3)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
2109d6e0:	9080040b 	ldhu	r2,16(r18)
2109d6e4:	1880042d 	sthio	r2,16(r3)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
2109d6e8:	9080048b 	ldhu	r2,18(r18)
2109d6ec:	188004ad 	sthio	r2,18(r3)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
2109d6f0:	18000535 	stwio	zero,20(r3)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
2109d6f4:	18000635 	stwio	zero,24(r3)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
2109d6f8:	90800717 	ldw	r2,28(r18)
2109d6fc:	18800735 	stwio	r2,28(r3)
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
2109d700:	81000d17 	ldw	r4,52(r16)
2109d704:	80800317 	ldw	r2,12(r16)
2109d708:	00fff2c4 	movi	r3,-53
2109d70c:	20c6703a 	and	r3,r4,r3
2109d710:	18c00114 	ori	r3,r3,4
2109d714:	10c00135 	stwio	r3,4(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109d718:	9801703a 	wrctl	status,r19
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
2109d71c:	80c00317 	ldw	r3,12(r16)
2109d720:	18800037 	ldwio	r2,0(r3)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
2109d724:	1100780c 	andi	r4,r2,480
2109d728:	2000201e 	bne	r4,zero,2109d7ac <alt_msgdma_extended_descriptor_sync_transfer+0x1bc>
2109d72c:	1080004c 	andi	r2,r2,1
2109d730:	10002826 	beq	r2,zero,2109d7d4 <alt_msgdma_extended_descriptor_sync_transfer+0x1e4>
    {
        alt_busy_sleep(1); /* delay 1us */
2109d734:	01000044 	movi	r4,1
2109d738:	109d8b80 	call	2109d8b8 <alt_busy_sleep>
2109d73c:	0484e204 	movi	r18,5000
			ALT_SEM_POST (dev->regs_lock);
			
            return -ETIME;
        }
        counter++;
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
2109d740:	80c00317 	ldw	r3,12(r16)
2109d744:	18800037 	ldwio	r2,0(r3)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
    {
        alt_busy_sleep(1); /* delay 1us */
2109d748:	01000044 	movi	r4,1
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
2109d74c:	1140780c 	andi	r5,r2,480
2109d750:	1104703a 	and	r2,r2,r4
2109d754:	2800151e 	bne	r5,zero,2109d7ac <alt_msgdma_extended_descriptor_sync_transfer+0x1bc>
2109d758:	10001e26 	beq	r2,zero,2109d7d4 <alt_msgdma_extended_descriptor_sync_transfer+0x1e4>
    {
        alt_busy_sleep(1); /* delay 1us */
2109d75c:	109d8b80 	call	2109d8b8 <alt_busy_sleep>
2109d760:	94bfffc4 	addi	r18,r18,-1
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
2109d764:	90bfffcc 	andi	r2,r18,65535
2109d768:	103ff51e 	bne	r2,zero,2109d740 <__flash_rwdata_start+0xffffb4f8>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
2109d76c:	01000034 	movhi	r4,0
2109d770:	210fa904 	addi	r4,r4,16036
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
			
            return -ETIME;
2109d774:	047ff084 	movi	r17,-62
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
    {
        alt_busy_sleep(1); /* delay 1us */
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
2109d778:	109de940 	call	2109de94 <alt_printf>
2109d77c:	00000c06 	br	2109d7b0 <alt_msgdma_extended_descriptor_sync_transfer+0x1c0>
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
2109d780:	01000044 	movi	r4,1
2109d784:	109d8b80 	call	2109d8b8 <alt_busy_sleep>
2109d788:	a0bfffc4 	addi	r2,r20,-1
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
2109d78c:	10ffffcc 	andi	r3,r2,65535
2109d790:	1029883a 	mov	r20,r2
2109d794:	183fc11e 	bne	r3,zero,2109d69c <__flash_rwdata_start+0xffffb454>
            {
                alt_printf("time out after 5 msec while writing extended" 
2109d798:	01000034 	movhi	r4,0
2109d79c:	210fbb04 	addi	r4,r4,16108
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
				
                return -ETIME;
2109d7a0:	047ff084 	movi	r17,-62
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
            {
                alt_printf("time out after 5 msec while writing extended" 
2109d7a4:	109de940 	call	2109de94 <alt_printf>
2109d7a8:	00000106 	br	2109d7b0 <alt_msgdma_extended_descriptor_sync_transfer+0x1c0>
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
		
        return error;
2109d7ac:	04407804 	movi	r17,480
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
}
2109d7b0:	8805883a 	mov	r2,r17
2109d7b4:	dfc00517 	ldw	ra,20(sp)
2109d7b8:	dd000417 	ldw	r20,16(sp)
2109d7bc:	dcc00317 	ldw	r19,12(sp)
2109d7c0:	dc800217 	ldw	r18,8(sp)
2109d7c4:	dc400117 	ldw	r17,4(sp)
2109d7c8:	dc000017 	ldw	r16,0(sp)
2109d7cc:	dec00604 	addi	sp,sp,24
2109d7d0:	f800283a 	ret
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
2109d7d4:	18c00104 	addi	r3,r3,4
2109d7d8:	18800037 	ldwio	r2,0(r3)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109d7dc:	000b303a 	rdctl	r5,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109d7e0:	013fff84 	movi	r4,-2
2109d7e4:	2908703a 	and	r4,r5,r4
2109d7e8:	2001703a 	wrctl	status,r4
2109d7ec:	10800814 	ori	r2,r2,32
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
2109d7f0:	18800035 	stwio	r2,0(r3)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
2109d7f4:	80800317 	ldw	r2,12(r16)
2109d7f8:	10c00037 	ldwio	r3,0(r2)
2109d7fc:	10c00035 	stwio	r3,0(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109d800:	2801703a 	wrctl	status,r5
2109d804:	003fea06 	br	2109d7b0 <__flash_rwdata_start+0xffffb568>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
2109d808:	01000034 	movhi	r4,0
2109d80c:	210f8404 	addi	r4,r4,15888
				" for storing descriptor\n");
            return -ETIME;
2109d810:	047ff084 	movi	r17,-62
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
2109d814:	109de940 	call	2109de94 <alt_printf>
2109d818:	003fe506 	br	2109d7b0 <__flash_rwdata_start+0xffffb568>
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
2109d81c:	047fffc4 	movi	r17,-1
2109d820:	003fe306 	br	2109d7b0 <__flash_rwdata_start+0xffffb568>

2109d824 <alt_alarm_start>:
                     void* context)
{
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
  
  if (alt_ticks_per_second ())
2109d824:	00800034 	movhi	r2,0
2109d828:	10978e04 	addi	r2,r2,24120
2109d82c:	10800017 	ldw	r2,0(r2)
2109d830:	10001d26 	beq	r2,zero,2109d8a8 <alt_alarm_start+0x84>
  {
    if (alarm)
2109d834:	20001e26 	beq	r4,zero,2109d8b0 <alt_alarm_start+0x8c>
    {
      alarm->callback = callback;
2109d838:	21800315 	stw	r6,12(r4)
      alarm->context  = context;
2109d83c:	21c00515 	stw	r7,20(r4)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109d840:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109d844:	00bfff84 	movi	r2,-2
2109d848:	1884703a 	and	r2,r3,r2
2109d84c:	1001703a 	wrctl	status,r2
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
2109d850:	00800034 	movhi	r2,0
2109d854:	10978d04 	addi	r2,r2,24116
2109d858:	10800017 	ldw	r2,0(r2)
2109d85c:	11800044 	addi	r6,r2,1
 
      irq_context = alt_irq_disable_all ();
      
      current_nticks = alt_nticks();
      
      alarm->time = nticks + current_nticks + 1; 
2109d860:	314b883a 	add	r5,r6,r5
2109d864:	21400215 	stw	r5,8(r4)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
2109d868:	28800c36 	bltu	r5,r2,2109d89c <alt_alarm_start+0x78>
      {
        alarm->rollover = 1;
      }
      else
      {
        alarm->rollover = 0;
2109d86c:	20000405 	stb	zero,16(r4)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
2109d870:	00800034 	movhi	r2,0
2109d874:	10977804 	addi	r2,r2,24032
  entry->next     = list->next;
2109d878:	11400017 	ldw	r5,0(r2)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
2109d87c:	20800115 	stw	r2,4(r4)
  entry->next     = list->next;
2109d880:	21400015 	stw	r5,0(r4)

  list->next->previous = entry;
2109d884:	11400017 	ldw	r5,0(r2)
  list->next           = entry;
2109d888:	11000015 	stw	r4,0(r2)
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;

  list->next->previous = entry;
2109d88c:	29000115 	stw	r4,4(r5)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109d890:	1801703a 	wrctl	status,r3
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
      alt_irq_enable_all (irq_context);

      return 0;
2109d894:	0005883a 	mov	r2,zero
2109d898:	f800283a 	ret
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
      {
        alarm->rollover = 1;
2109d89c:	00800044 	movi	r2,1
2109d8a0:	20800405 	stb	r2,16(r4)
2109d8a4:	003ff206 	br	2109d870 <__flash_rwdata_start+0xffffb628>
      return -EINVAL;
    }
  }
  else
  {
    return -ENOTSUP;
2109d8a8:	00bfde84 	movi	r2,-134
2109d8ac:	f800283a 	ret

      return 0;
    }
    else
    {
      return -EINVAL;
2109d8b0:	00bffa84 	movi	r2,-22
  }
  else
  {
    return -ENOTSUP;
  }
}
2109d8b4:	f800283a 	ret

2109d8b8 <alt_busy_sleep>:
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
2109d8b8:	00c0c7f4 	movhi	r3,799
2109d8bc:	18ce0c44 	addi	r3,r3,14385
2109d8c0:	20c7203a 	divu	r3,r4,r3
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
2109d8c4:	18000f26 	beq	r3,zero,2109d904 <alt_busy_sleep+0x4c>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
2109d8c8:	01a00034 	movhi	r6,32768
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
2109d8cc:	017f3874 	movhi	r5,64737
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
2109d8d0:	31bfffc4 	addi	r6,r6,-1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
2109d8d4:	2971f3c4 	addi	r5,r5,-14385
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
2109d8d8:	0005883a 	mov	r2,zero
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
2109d8dc:	31bfffc4 	addi	r6,r6,-1
2109d8e0:	303ffe1e 	bne	r6,zero,2109d8dc <__flash_rwdata_start+0xffffb694>
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
2109d8e4:	10800044 	addi	r2,r2,1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
2109d8e8:	2149883a 	add	r4,r4,r5
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
2109d8ec:	10fffb16 	blt	r2,r3,2109d8dc <__flash_rwdata_start+0xffffb694>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
2109d8f0:	21000a64 	muli	r4,r4,41
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
2109d8f4:	213fffc4 	addi	r4,r4,-1
2109d8f8:	203ffe1e 	bne	r4,zero,2109d8f4 <__flash_rwdata_start+0xffffb6ac>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
2109d8fc:	0005883a 	mov	r2,zero
2109d900:	f800283a 	ret
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
2109d904:	21000a64 	muli	r4,r4,41
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
2109d908:	213fffc4 	addi	r4,r4,-1
2109d90c:	013ffe16 	blt	zero,r4,2109d908 <__flash_rwdata_start+0xffffb6c0>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
2109d910:	0005883a 	mov	r2,zero
2109d914:	f800283a 	ret

2109d918 <alt_dev_llist_insert>:
{
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
2109d918:	20000a26 	beq	r4,zero,2109d944 <alt_dev_llist_insert+0x2c>
2109d91c:	20800217 	ldw	r2,8(r4)
2109d920:	10000826 	beq	r2,zero,2109d944 <alt_dev_llist_insert+0x2c>

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;
2109d924:	28c00017 	ldw	r3,0(r5)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
2109d928:	21400115 	stw	r5,4(r4)
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
2109d92c:	0005883a 	mov	r2,zero
  entry->next     = list->next;
2109d930:	20c00015 	stw	r3,0(r4)

  list->next->previous = entry;
2109d934:	28c00017 	ldw	r3,0(r5)
2109d938:	19000115 	stw	r4,4(r3)
  list->next           = entry;
2109d93c:	29000015 	stw	r4,0(r5)
2109d940:	f800283a 	ret
2109d944:	00800034 	movhi	r2,0
2109d948:	10977504 	addi	r2,r2,24020
2109d94c:	10800017 	ldw	r2,0(r2)
2109d950:	10000926 	beq	r2,zero,2109d978 <alt_dev_llist_insert+0x60>
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
2109d954:	deffff04 	addi	sp,sp,-4
2109d958:	dfc00015 	stw	ra,0(sp)
2109d95c:	103ee83a 	callr	r2
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
2109d960:	00c00584 	movi	r3,22
2109d964:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
2109d968:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
2109d96c:	dfc00017 	ldw	ra,0(sp)
2109d970:	dec00104 	addi	sp,sp,4
2109d974:	f800283a 	ret
2109d978:	00800034 	movhi	r2,0
2109d97c:	10978504 	addi	r2,r2,24084
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
2109d980:	00c00584 	movi	r3,22
2109d984:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
2109d988:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
2109d98c:	f800283a 	ret

2109d990 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
2109d990:	defffc04 	addi	sp,sp,-16
2109d994:	dc800215 	stw	r18,8(sp)
2109d998:	dc000015 	stw	r16,0(sp)
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
2109d99c:	048842b4 	movhi	r18,8458
2109d9a0:	040842b4 	movhi	r16,8458
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
2109d9a4:	dfc00315 	stw	ra,12(sp)
2109d9a8:	dc400115 	stw	r17,4(sp)
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
2109d9ac:	8438c504 	addi	r16,r16,-7404
2109d9b0:	94b8c604 	addi	r18,r18,-7400
2109d9b4:	84800936 	bltu	r16,r18,2109d9dc <_do_ctors+0x4c>
2109d9b8:	84a5c83a 	sub	r18,r16,r18
2109d9bc:	9024d0ba 	srli	r18,r18,2
2109d9c0:	0023883a 	mov	r17,zero
2109d9c4:	94800044 	addi	r18,r18,1
        (*ctor) (); 
2109d9c8:	80800017 	ldw	r2,0(r16)
2109d9cc:	8c400044 	addi	r17,r17,1

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
2109d9d0:	843fff04 	addi	r16,r16,-4
        (*ctor) (); 
2109d9d4:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
2109d9d8:	8cbffb1e 	bne	r17,r18,2109d9c8 <__flash_rwdata_start+0xffffb780>
        (*ctor) (); 
}
2109d9dc:	dfc00317 	ldw	ra,12(sp)
2109d9e0:	dc800217 	ldw	r18,8(sp)
2109d9e4:	dc400117 	ldw	r17,4(sp)
2109d9e8:	dc000017 	ldw	r16,0(sp)
2109d9ec:	dec00404 	addi	sp,sp,16
2109d9f0:	f800283a 	ret

2109d9f4 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
2109d9f4:	defffc04 	addi	sp,sp,-16
2109d9f8:	dc800215 	stw	r18,8(sp)
2109d9fc:	dc000015 	stw	r16,0(sp)
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
2109da00:	048842b4 	movhi	r18,8458
2109da04:	040842b4 	movhi	r16,8458
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
2109da08:	dfc00315 	stw	ra,12(sp)
2109da0c:	dc400115 	stw	r17,4(sp)
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
2109da10:	8438c504 	addi	r16,r16,-7404
2109da14:	94b8c604 	addi	r18,r18,-7400
2109da18:	84800936 	bltu	r16,r18,2109da40 <_do_dtors+0x4c>
2109da1c:	84a5c83a 	sub	r18,r16,r18
2109da20:	9024d0ba 	srli	r18,r18,2
2109da24:	0023883a 	mov	r17,zero
2109da28:	94800044 	addi	r18,r18,1
        (*dtor) (); 
2109da2c:	80800017 	ldw	r2,0(r16)
2109da30:	8c400044 	addi	r17,r17,1

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
2109da34:	843fff04 	addi	r16,r16,-4
        (*dtor) (); 
2109da38:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
2109da3c:	8cbffb1e 	bne	r17,r18,2109da2c <__flash_rwdata_start+0xffffb7e4>
        (*dtor) (); 
}
2109da40:	dfc00317 	ldw	ra,12(sp)
2109da44:	dc800217 	ldw	r18,8(sp)
2109da48:	dc400117 	ldw	r17,4(sp)
2109da4c:	dc000017 	ldw	r16,0(sp)
2109da50:	dec00404 	addi	sp,sp,16
2109da54:	f800283a 	ret

2109da58 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
2109da58:	defffb04 	addi	sp,sp,-20
2109da5c:	dc000015 	stw	r16,0(sp)
  alt_dev* next = (alt_dev*) llist->next;
2109da60:	2c000017 	ldw	r16,0(r5)
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
2109da64:	dcc00315 	stw	r19,12(sp)
2109da68:	dc800215 	stw	r18,8(sp)
2109da6c:	dc400115 	stw	r17,4(sp)
2109da70:	dfc00415 	stw	ra,16(sp)
2109da74:	2823883a 	mov	r17,r5
2109da78:	2027883a 	mov	r19,r4
  alt_dev* next = (alt_dev*) llist->next;
  alt_32 len;

  len  = strlen(name) + 1;
2109da7c:	108e7200 	call	2108e720 <strlen>
2109da80:	14800044 	addi	r18,r2,1
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
2109da84:	8c00031e 	bne	r17,r16,2109da94 <alt_find_dev+0x3c>
2109da88:	00000906 	br	2109dab0 <alt_find_dev+0x58>
    {
      /* match found */

      return next;
    }
    next = (alt_dev*) next->llist.next;
2109da8c:	84000017 	ldw	r16,0(r16)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
2109da90:	8c000726 	beq	r17,r16,2109dab0 <alt_find_dev+0x58>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
2109da94:	81000217 	ldw	r4,8(r16)
2109da98:	980b883a 	mov	r5,r19
2109da9c:	900d883a 	mov	r6,r18
2109daa0:	108e0b80 	call	2108e0b8 <memcmp>
2109daa4:	103ff91e 	bne	r2,zero,2109da8c <__flash_rwdata_start+0xffffb844>
    {
      /* match found */

      return next;
2109daa8:	8005883a 	mov	r2,r16
2109daac:	00000106 	br	2109dab4 <alt_find_dev+0x5c>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
2109dab0:	0005883a 	mov	r2,zero
}
2109dab4:	dfc00417 	ldw	ra,16(sp)
2109dab8:	dcc00317 	ldw	r19,12(sp)
2109dabc:	dc800217 	ldw	r18,8(sp)
2109dac0:	dc400117 	ldw	r17,4(sp)
2109dac4:	dc000017 	ldw	r16,0(sp)
2109dac8:	dec00504 	addi	sp,sp,20
2109dacc:	f800283a 	ret

2109dad0 <alt_icache_flush_all>:
 */

void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
2109dad0:	0009883a 	mov	r4,zero
2109dad4:	01440004 	movi	r5,4096
2109dad8:	109e12c1 	jmpi	2109e12c <alt_icache_flush>

2109dadc <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
2109dadc:	109db781 	jmpi	2109db78 <alt_iic_isr_register>

2109dae0 <alt_ic_irq_enable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109dae0:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109dae4:	00bfff84 	movi	r2,-2
2109dae8:	2084703a 	and	r2,r4,r2
2109daec:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
2109daf0:	00800034 	movhi	r2,0
2109daf4:	10978904 	addi	r2,r2,24100
2109daf8:	00c00044 	movi	r3,1
2109dafc:	194a983a 	sll	r5,r3,r5
2109db00:	10c00017 	ldw	r3,0(r2)
2109db04:	28cab03a 	or	r5,r5,r3
2109db08:	11400015 	stw	r5,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
2109db0c:	10800017 	ldw	r2,0(r2)
2109db10:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109db14:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
2109db18:	0005883a 	mov	r2,zero
2109db1c:	f800283a 	ret

2109db20 <alt_ic_irq_disable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109db20:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109db24:	00bfff84 	movi	r2,-2
2109db28:	2084703a 	and	r2,r4,r2
2109db2c:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
2109db30:	00800034 	movhi	r2,0
2109db34:	10978904 	addi	r2,r2,24100
2109db38:	00ffff84 	movi	r3,-2
2109db3c:	194a183a 	rol	r5,r3,r5
2109db40:	10c00017 	ldw	r3,0(r2)
2109db44:	28ca703a 	and	r5,r5,r3
2109db48:	11400015 	stw	r5,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
2109db4c:	10800017 	ldw	r2,0(r2)
2109db50:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109db54:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
2109db58:	0005883a 	mov	r2,zero
2109db5c:	f800283a 	ret

2109db60 <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
2109db60:	000530fa 	rdctl	r2,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
2109db64:	00c00044 	movi	r3,1
2109db68:	194a983a 	sll	r5,r3,r5
2109db6c:	1144703a 	and	r2,r2,r5
}
2109db70:	1004c03a 	cmpne	r2,r2,zero
2109db74:	f800283a 	ret

2109db78 <alt_iic_isr_register>:
{
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
2109db78:	00c007c4 	movi	r3,31
2109db7c:	19401616 	blt	r3,r5,2109dbd8 <alt_iic_isr_register+0x60>
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
2109db80:	defffe04 	addi	sp,sp,-8
2109db84:	dfc00115 	stw	ra,4(sp)
2109db88:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2109db8c:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2109db90:	00ffff84 	movi	r3,-2
2109db94:	80c6703a 	and	r3,r16,r3
2109db98:	1801703a 	wrctl	status,r3
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
2109db9c:	280490fa 	slli	r2,r5,3
2109dba0:	00c00034 	movhi	r3,0
2109dba4:	18d99604 	addi	r3,r3,26200
2109dba8:	1891883a 	add	r8,r3,r2
2109dbac:	41800015 	stw	r6,0(r8)
    alt_irq[id].context = isr_context;
2109dbb0:	41c00115 	stw	r7,4(r8)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
2109dbb4:	30000626 	beq	r6,zero,2109dbd0 <alt_iic_isr_register+0x58>
2109dbb8:	109dae00 	call	2109dae0 <alt_ic_irq_enable>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2109dbbc:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
2109dbc0:	dfc00117 	ldw	ra,4(sp)
2109dbc4:	dc000017 	ldw	r16,0(sp)
2109dbc8:	dec00204 	addi	sp,sp,8
2109dbcc:	f800283a 	ret
    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
    alt_irq[id].context = isr_context;

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
2109dbd0:	109db200 	call	2109db20 <alt_ic_irq_disable>
2109dbd4:	003ff906 	br	2109dbbc <__flash_rwdata_start+0xffffb974>
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  int rc = -EINVAL;  
2109dbd8:	00bffa84 	movi	r2,-22
2109dbdc:	f800283a 	ret

2109dbe0 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
2109dbe0:	defffd04 	addi	sp,sp,-12
2109dbe4:	dc400115 	stw	r17,4(sp)
2109dbe8:	dc000015 	stw	r16,0(sp)
2109dbec:	2823883a 	mov	r17,r5
2109dbf0:	3021883a 	mov	r16,r6

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
  int old;

  old = open (name, flags, mode);
2109dbf4:	01400044 	movi	r5,1
2109dbf8:	01807fc4 	movi	r6,511
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
2109dbfc:	dfc00215 	stw	ra,8(sp)

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
  int old;

  old = open (name, flags, mode);
2109dc00:	109dcf00 	call	2109dcf0 <open>

  if (old >= 0)
2109dc04:	10000d16 	blt	r2,zero,2109dc3c <alt_io_redirect+0x5c>
  {
    fd->dev      = alt_fd_list[old].dev;
2109dc08:	11c00324 	muli	r7,r2,12
2109dc0c:	00c00034 	movhi	r3,0
2109dc10:	18d27504 	addi	r3,r3,18900
2109dc14:	19cb883a 	add	r5,r3,r7
    fd->priv     = alt_fd_list[old].priv;
    fd->fd_flags = alt_fd_list[old].fd_flags;

    alt_release_fd (old);
2109dc18:	1009883a 	mov	r4,r2
  old = open (name, flags, mode);

  if (old >= 0)
  {
    fd->dev      = alt_fd_list[old].dev;
    fd->priv     = alt_fd_list[old].priv;
2109dc1c:	2805883a 	mov	r2,r5

  old = open (name, flags, mode);

  if (old >= 0)
  {
    fd->dev      = alt_fd_list[old].dev;
2109dc20:	29800017 	ldw	r6,0(r5)
    fd->priv     = alt_fd_list[old].priv;
    fd->fd_flags = alt_fd_list[old].fd_flags;
2109dc24:	10800217 	ldw	r2,8(r2)
  old = open (name, flags, mode);

  if (old >= 0)
  {
    fd->dev      = alt_fd_list[old].dev;
    fd->priv     = alt_fd_list[old].priv;
2109dc28:	29400117 	ldw	r5,4(r5)

  old = open (name, flags, mode);

  if (old >= 0)
  {
    fd->dev      = alt_fd_list[old].dev;
2109dc2c:	19800315 	stw	r6,12(r3)
    fd->priv     = alt_fd_list[old].priv;
    fd->fd_flags = alt_fd_list[old].fd_flags;
2109dc30:	18800515 	stw	r2,20(r3)
  old = open (name, flags, mode);

  if (old >= 0)
  {
    fd->dev      = alt_fd_list[old].dev;
    fd->priv     = alt_fd_list[old].priv;
2109dc34:	19400415 	stw	r5,16(r3)
    fd->fd_flags = alt_fd_list[old].fd_flags;

    alt_release_fd (old);
2109dc38:	109b6480 	call	2109b648 <alt_release_fd>

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
  int old;

  old = open (name, flags, mode);
2109dc3c:	8809883a 	mov	r4,r17
2109dc40:	000b883a 	mov	r5,zero
2109dc44:	01807fc4 	movi	r6,511
2109dc48:	109dcf00 	call	2109dcf0 <open>

  if (old >= 0)
2109dc4c:	10000d16 	blt	r2,zero,2109dc84 <alt_io_redirect+0xa4>
  {
    fd->dev      = alt_fd_list[old].dev;
2109dc50:	11400324 	muli	r5,r2,12
2109dc54:	00c00034 	movhi	r3,0
2109dc58:	18d27504 	addi	r3,r3,18900
2109dc5c:	194d883a 	add	r6,r3,r5
    fd->priv     = alt_fd_list[old].priv;
    fd->fd_flags = alt_fd_list[old].fd_flags;

    alt_release_fd (old);
2109dc60:	1009883a 	mov	r4,r2
  old = open (name, flags, mode);

  if (old >= 0)
  {
    fd->dev      = alt_fd_list[old].dev;
    fd->priv     = alt_fd_list[old].priv;
2109dc64:	3005883a 	mov	r2,r6

  old = open (name, flags, mode);

  if (old >= 0)
  {
    fd->dev      = alt_fd_list[old].dev;
2109dc68:	31c00017 	ldw	r7,0(r6)
    fd->priv     = alt_fd_list[old].priv;
    fd->fd_flags = alt_fd_list[old].fd_flags;
2109dc6c:	10800217 	ldw	r2,8(r2)
  old = open (name, flags, mode);

  if (old >= 0)
  {
    fd->dev      = alt_fd_list[old].dev;
    fd->priv     = alt_fd_list[old].priv;
2109dc70:	31800117 	ldw	r6,4(r6)

  old = open (name, flags, mode);

  if (old >= 0)
  {
    fd->dev      = alt_fd_list[old].dev;
2109dc74:	19c00015 	stw	r7,0(r3)
    fd->priv     = alt_fd_list[old].priv;
    fd->fd_flags = alt_fd_list[old].fd_flags;
2109dc78:	18800215 	stw	r2,8(r3)
  old = open (name, flags, mode);

  if (old >= 0)
  {
    fd->dev      = alt_fd_list[old].dev;
    fd->priv     = alt_fd_list[old].priv;
2109dc7c:	19800115 	stw	r6,4(r3)
    fd->fd_flags = alt_fd_list[old].fd_flags;

    alt_release_fd (old);
2109dc80:	109b6480 	call	2109b648 <alt_release_fd>

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
  int old;

  old = open (name, flags, mode);
2109dc84:	8009883a 	mov	r4,r16
2109dc88:	01400044 	movi	r5,1
2109dc8c:	01807fc4 	movi	r6,511
2109dc90:	109dcf00 	call	2109dcf0 <open>

  if (old >= 0)
2109dc94:	10001116 	blt	r2,zero,2109dcdc <alt_io_redirect+0xfc>
  {
    fd->dev      = alt_fd_list[old].dev;
2109dc98:	11400324 	muli	r5,r2,12
2109dc9c:	00c00034 	movhi	r3,0
2109dca0:	18d27504 	addi	r3,r3,18900
2109dca4:	194d883a 	add	r6,r3,r5
    fd->priv     = alt_fd_list[old].priv;
    fd->fd_flags = alt_fd_list[old].fd_flags;

    alt_release_fd (old);
2109dca8:	1009883a 	mov	r4,r2
  old = open (name, flags, mode);

  if (old >= 0)
  {
    fd->dev      = alt_fd_list[old].dev;
    fd->priv     = alt_fd_list[old].priv;
2109dcac:	3005883a 	mov	r2,r6

  old = open (name, flags, mode);

  if (old >= 0)
  {
    fd->dev      = alt_fd_list[old].dev;
2109dcb0:	31c00017 	ldw	r7,0(r6)
    fd->priv     = alt_fd_list[old].priv;
    fd->fd_flags = alt_fd_list[old].fd_flags;
2109dcb4:	10800217 	ldw	r2,8(r2)
  old = open (name, flags, mode);

  if (old >= 0)
  {
    fd->dev      = alt_fd_list[old].dev;
    fd->priv     = alt_fd_list[old].priv;
2109dcb8:	31800117 	ldw	r6,4(r6)

  old = open (name, flags, mode);

  if (old >= 0)
  {
    fd->dev      = alt_fd_list[old].dev;
2109dcbc:	19c00615 	stw	r7,24(r3)
    fd->priv     = alt_fd_list[old].priv;
    fd->fd_flags = alt_fd_list[old].fd_flags;
2109dcc0:	18800815 	stw	r2,32(r3)
  old = open (name, flags, mode);

  if (old >= 0)
  {
    fd->dev      = alt_fd_list[old].dev;
    fd->priv     = alt_fd_list[old].priv;
2109dcc4:	19800715 	stw	r6,28(r3)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
}  
2109dcc8:	dfc00217 	ldw	ra,8(sp)
2109dccc:	dc400117 	ldw	r17,4(sp)
2109dcd0:	dc000017 	ldw	r16,0(sp)
2109dcd4:	dec00304 	addi	sp,sp,12
  {
    fd->dev      = alt_fd_list[old].dev;
    fd->priv     = alt_fd_list[old].priv;
    fd->fd_flags = alt_fd_list[old].fd_flags;

    alt_release_fd (old);
2109dcd8:	109b6481 	jmpi	2109b648 <alt_release_fd>
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
}  
2109dcdc:	dfc00217 	ldw	ra,8(sp)
2109dce0:	dc400117 	ldw	r17,4(sp)
2109dce4:	dc000017 	ldw	r16,0(sp)
2109dce8:	dec00304 	addi	sp,sp,12
2109dcec:	f800283a 	ret

2109dcf0 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
2109dcf0:	defffa04 	addi	sp,sp,-24
2109dcf4:	dc800215 	stw	r18,8(sp)
2109dcf8:	2825883a 	mov	r18,r5
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
2109dcfc:	01400034 	movhi	r5,0
2109dd00:	29577104 	addi	r5,r5,24004
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
2109dd04:	dcc00315 	stw	r19,12(sp)
2109dd08:	dc400115 	stw	r17,4(sp)
2109dd0c:	dc000015 	stw	r16,0(sp)
2109dd10:	dfc00515 	stw	ra,20(sp)
2109dd14:	dd000415 	stw	r20,16(sp)
2109dd18:	2023883a 	mov	r17,r4
2109dd1c:	3027883a 	mov	r19,r6
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
2109dd20:	109da580 	call	2109da58 <alt_find_dev>
2109dd24:	1021883a 	mov	r16,r2
2109dd28:	10003e26 	beq	r2,zero,2109de24 <open+0x134>
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
  {
    if ((index = alt_get_fd (dev)) < 0)
2109dd2c:	1009883a 	mov	r4,r2
2109dd30:	109e0dc0 	call	2109e0dc <alt_get_fd>
2109dd34:	1029883a 	mov	r20,r2
2109dd38:	10002d16 	blt	r2,zero,2109ddf0 <open+0x100>
    {
      status = index;
    }
    else
    {
      fd = &alt_fd_list[index];
2109dd3c:	a1400324 	muli	r5,r20,12
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
2109dd40:	00900034 	movhi	r2,16384
    {
      status = index;
    }
    else
    {
      fd = &alt_fd_list[index];
2109dd44:	00c00034 	movhi	r3,0
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
2109dd48:	10bfffc4 	addi	r2,r2,-1
    {
      status = index;
    }
    else
    {
      fd = &alt_fd_list[index];
2109dd4c:	18d27504 	addi	r3,r3,18900
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
2109dd50:	9084703a 	and	r2,r18,r2
    {
      status = index;
    }
    else
    {
      fd = &alt_fd_list[index];
2109dd54:	28c9883a 	add	r4,r5,r3

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
2109dd58:	10900034 	orhi	r2,r2,16384
2109dd5c:	20800215 	stw	r2,8(r4)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
2109dd60:	00800034 	movhi	r2,0
2109dd64:	10977004 	addi	r2,r2,24000
2109dd68:	11800017 	ldw	r6,0(r2)
2109dd6c:	21400017 	ldw	r5,0(r4)
2109dd70:	1a400204 	addi	r9,r3,8
2109dd74:	0011883a 	mov	r8,zero
2109dd78:	00000606 	br	2109dd94 <open+0xa4>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
2109dd7c:	48800017 	ldw	r2,0(r9)
2109dd80:	1000010e 	bge	r2,zero,2109dd88 <open+0x98>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
2109dd84:	20c02e1e 	bne	r4,r3,2109de40 <open+0x150>
2109dd88:	18c00304 	addi	r3,r3,12
2109dd8c:	4a400304 	addi	r9,r9,12
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
2109dd90:	32000636 	bltu	r6,r8,2109ddac <open+0xbc>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
2109dd94:	1a800017 	ldw	r10,0(r3)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
2109dd98:	42000044 	addi	r8,r8,1
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
2109dd9c:	517ff726 	beq	r10,r5,2109dd7c <__flash_rwdata_start+0xffffbb34>
2109dda0:	18c00304 	addi	r3,r3,12
2109dda4:	4a400304 	addi	r9,r9,12
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
2109dda8:	323ffa2e 	bgeu	r6,r8,2109dd94 <__flash_rwdata_start+0xffffbb4c>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
2109ddac:	80800317 	ldw	r2,12(r16)
2109ddb0:	10001a26 	beq	r2,zero,2109de1c <open+0x12c>
2109ddb4:	880b883a 	mov	r5,r17
2109ddb8:	900d883a 	mov	r6,r18
2109ddbc:	980f883a 	mov	r7,r19
2109ddc0:	103ee83a 	callr	r2
2109ddc4:	1007883a 	mov	r3,r2
2109ddc8:	a005883a 	mov	r2,r20
    status = -ENODEV;
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
2109ddcc:	18002116 	blt	r3,zero,2109de54 <open+0x164>
  }
  
  /* return the reference upon success */

  return index;
}
2109ddd0:	dfc00517 	ldw	ra,20(sp)
2109ddd4:	dd000417 	ldw	r20,16(sp)
2109ddd8:	dcc00317 	ldw	r19,12(sp)
2109dddc:	dc800217 	ldw	r18,8(sp)
2109dde0:	dc400117 	ldw	r17,4(sp)
2109dde4:	dc000017 	ldw	r16,0(sp)
2109dde8:	dec00604 	addi	sp,sp,24
2109ddec:	f800283a 	ret
2109ddf0:	0521c83a 	sub	r16,zero,r20

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
  {
    alt_release_fd (index);  
2109ddf4:	a009883a 	mov	r4,r20
2109ddf8:	109b6480 	call	2109b648 <alt_release_fd>
2109ddfc:	00800034 	movhi	r2,0
2109de00:	10977504 	addi	r2,r2,24020
2109de04:	10800017 	ldw	r2,0(r2)
2109de08:	10000f26 	beq	r2,zero,2109de48 <open+0x158>
2109de0c:	103ee83a 	callr	r2
    ALT_ERRNO = -status;
2109de10:	14000015 	stw	r16,0(r2)
    return -1;
2109de14:	00bfffc4 	movi	r2,-1
2109de18:	003fed06 	br	2109ddd0 <__flash_rwdata_start+0xffffbb88>
2109de1c:	a005883a 	mov	r2,r20
2109de20:	003feb06 	br	2109ddd0 <__flash_rwdata_start+0xffffbb88>
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
2109de24:	8809883a 	mov	r4,r17
2109de28:	109e02c0 	call	2109e02c <alt_find_file>
2109de2c:	1021883a 	mov	r16,r2

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
2109de30:	10000a1e 	bne	r2,zero,2109de5c <open+0x16c>
2109de34:	040004c4 	movi	r16,19
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
2109de38:	053fffc4 	movi	r20,-1
2109de3c:	003fed06 	br	2109ddf4 <__flash_rwdata_start+0xffffbbac>
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
2109de40:	04000344 	movi	r16,13
2109de44:	003feb06 	br	2109ddf4 <__flash_rwdata_start+0xffffbbac>
2109de48:	00800034 	movhi	r2,0
2109de4c:	10978504 	addi	r2,r2,24084
2109de50:	003fef06 	br	2109de10 <__flash_rwdata_start+0xffffbbc8>
2109de54:	00e1c83a 	sub	r16,zero,r3
2109de58:	003fe606 	br	2109ddf4 <__flash_rwdata_start+0xffffbbac>
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
  {
    if ((index = alt_get_fd (dev)) < 0)
2109de5c:	1009883a 	mov	r4,r2
2109de60:	109e0dc0 	call	2109e0dc <alt_get_fd>
2109de64:	1029883a 	mov	r20,r2
2109de68:	103fe116 	blt	r2,zero,2109ddf0 <__flash_rwdata_start+0xffffbba8>
    {
      status = index;
    }
    else
    {
      fd = &alt_fd_list[index];
2109de6c:	a1000324 	muli	r4,r20,12
2109de70:	00800034 	movhi	r2,0
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
2109de74:	00d00034 	movhi	r3,16384
    {
      status = index;
    }
    else
    {
      fd = &alt_fd_list[index];
2109de78:	10927504 	addi	r2,r2,18900
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
2109de7c:	18ffffc4 	addi	r3,r3,-1
2109de80:	110b883a 	add	r5,r2,r4
2109de84:	90c6703a 	and	r3,r18,r3
    {
      status = index;
    }
    else
    {
      fd = &alt_fd_list[index];
2109de88:	2809883a 	mov	r4,r5
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
2109de8c:	28c00215 	stw	r3,8(r5)
2109de90:	003fc606 	br	2109ddac <__flash_rwdata_start+0xffffbb64>

2109de94 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
2109de94:	defff304 	addi	sp,sp,-52
2109de98:	dfc00915 	stw	ra,36(sp)
2109de9c:	df000815 	stw	fp,32(sp)
2109dea0:	ddc00715 	stw	r23,28(sp)
2109dea4:	dd800615 	stw	r22,24(sp)
2109dea8:	dd400515 	stw	r21,20(sp)
2109deac:	dd000415 	stw	r20,16(sp)
2109deb0:	dcc00315 	stw	r19,12(sp)
2109deb4:	dc800215 	stw	r18,8(sp)
2109deb8:	dc400115 	stw	r17,4(sp)
2109debc:	dc000015 	stw	r16,0(sp)
2109dec0:	d9400a15 	stw	r5,40(sp)
2109dec4:	d9800b15 	stw	r6,44(sp)
2109dec8:	d9c00c15 	stw	r7,48(sp)
    w = fmt;
    while ((c = *w++) != 0)
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
2109decc:	04400944 	movi	r17,37
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
2109ded0:	2021883a 	mov	r16,r4
	va_list args;
	va_start(args, fmt);
2109ded4:	dcc00a04 	addi	r19,sp,40
                if (c == '%')
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
2109ded8:	054018c4 	movi	r21,99
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
                }
                else if (c == 'x')
2109dedc:	05801e04 	movi	r22,120
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
2109dee0:	048003c4 	movi	r18,15
                        if (digit <= 9)
2109dee4:	05000244 	movi	r20,9
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
2109dee8:	81000007 	ldb	r4,0(r16)
2109deec:	20000526 	beq	r4,zero,2109df04 <alt_printf+0x70>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
2109def0:	24401026 	beq	r4,r17,2109df34 <alt_printf+0xa0>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
2109def4:	84000044 	addi	r16,r16,1
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
        {
            alt_putchar(c);
2109def8:	109e0100 	call	2109e010 <alt_putchar>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
2109defc:	81000007 	ldb	r4,0(r16)
2109df00:	203ffb1e 	bne	r4,zero,2109def0 <__flash_rwdata_start+0xffffbca8>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
2109df04:	dfc00917 	ldw	ra,36(sp)
2109df08:	df000817 	ldw	fp,32(sp)
2109df0c:	ddc00717 	ldw	r23,28(sp)
2109df10:	dd800617 	ldw	r22,24(sp)
2109df14:	dd400517 	ldw	r21,20(sp)
2109df18:	dd000417 	ldw	r20,16(sp)
2109df1c:	dcc00317 	ldw	r19,12(sp)
2109df20:	dc800217 	ldw	r18,8(sp)
2109df24:	dc400117 	ldw	r17,4(sp)
2109df28:	dc000017 	ldw	r16,0(sp)
2109df2c:	dec00d04 	addi	sp,sp,52
2109df30:	f800283a 	ret
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
2109df34:	80800047 	ldb	r2,1(r16)
2109df38:	84000084 	addi	r16,r16,2
2109df3c:	103ff126 	beq	r2,zero,2109df04 <__flash_rwdata_start+0xffffbcbc>
            {
                if (c == '%')
2109df40:	14402926 	beq	r2,r17,2109dfe8 <alt_printf+0x154>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
2109df44:	15402b26 	beq	r2,r21,2109dff4 <alt_printf+0x160>
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
                }
                else if (c == 'x')
2109df48:	15800b26 	beq	r2,r22,2109df78 <alt_printf+0xe4>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
2109df4c:	00c01cc4 	movi	r3,115
2109df50:	10ffe51e 	bne	r2,r3,2109dee8 <__flash_rwdata_start+0xffffbca0>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
2109df54:	9f000017 	ldw	fp,0(r19)
2109df58:	9cc00104 	addi	r19,r19,4

                    while(*s)
2109df5c:	e1000007 	ldb	r4,0(fp)
2109df60:	203fe126 	beq	r4,zero,2109dee8 <__flash_rwdata_start+0xffffbca0>
                      alt_putchar(*s++);
2109df64:	e7000044 	addi	fp,fp,1
2109df68:	109e0100 	call	2109e010 <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
2109df6c:	e1000007 	ldb	r4,0(fp)
2109df70:	203ffc1e 	bne	r4,zero,2109df64 <__flash_rwdata_start+0xffffbd1c>
2109df74:	003fdc06 	br	2109dee8 <__flash_rwdata_start+0xffffbca0>
                    alt_putchar(v);
                }
                else if (c == 'x')
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
2109df78:	9dc00017 	ldw	r23,0(r19)
2109df7c:	9cc00104 	addi	r19,r19,4
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
2109df80:	b8002026 	beq	r23,zero,2109e004 <alt_printf+0x170>
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
2109df84:	b8bc002c 	andhi	r2,r23,61440
2109df88:	07000704 	movi	fp,28
2109df8c:	1000101e 	bne	r2,zero,2109dfd0 <alt_printf+0x13c>
                        digit_shift -= 4;
2109df90:	e73fff04 	addi	fp,fp,-4
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
2109df94:	9704983a 	sll	r2,r18,fp
2109df98:	15c4703a 	and	r2,r2,r23
2109df9c:	103ffc26 	beq	r2,zero,2109df90 <__flash_rwdata_start+0xffffbd48>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
2109dfa0:	e03fd116 	blt	fp,zero,2109dee8 <__flash_rwdata_start+0xffffbca0>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
2109dfa4:	9704983a 	sll	r2,r18,fp
2109dfa8:	15c4703a 	and	r2,r2,r23
2109dfac:	1704d83a 	srl	r2,r2,fp
                        if (digit <= 9)
2109dfb0:	a0800b36 	bltu	r20,r2,2109dfe0 <alt_printf+0x14c>
                            c = '0' + digit;
2109dfb4:	11000c04 	addi	r4,r2,48
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
2109dfb8:	21003fcc 	andi	r4,r4,255
2109dfbc:	2100201c 	xori	r4,r4,128
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
2109dfc0:	e73fff04 	addi	fp,fp,-4
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
                        if (digit <= 9)
                            c = '0' + digit;
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
2109dfc4:	213fe004 	addi	r4,r4,-128
2109dfc8:	109e0100 	call	2109e010 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
2109dfcc:	e03fc616 	blt	fp,zero,2109dee8 <__flash_rwdata_start+0xffffbca0>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
2109dfd0:	9704983a 	sll	r2,r18,fp
2109dfd4:	15c4703a 	and	r2,r2,r23
2109dfd8:	1704d83a 	srl	r2,r2,fp
                        if (digit <= 9)
2109dfdc:	a0bff52e 	bgeu	r20,r2,2109dfb4 <__flash_rwdata_start+0xffffbd6c>
                            c = '0' + digit;
                        else
                            c = 'a' + digit - 10;
2109dfe0:	110015c4 	addi	r4,r2,87
2109dfe4:	003ff406 	br	2109dfb8 <__flash_rwdata_start+0xffffbd70>
            if ((c = *w++) != 0)
            {
                if (c == '%')
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
2109dfe8:	8809883a 	mov	r4,r17
2109dfec:	109e0100 	call	2109e010 <alt_putchar>
2109dff0:	003fbd06 	br	2109dee8 <__flash_rwdata_start+0xffffbca0>
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
2109dff4:	99000017 	ldw	r4,0(r19)
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
2109dff8:	9cc00104 	addi	r19,r19,4
                    alt_putchar(v);
2109dffc:	109e0100 	call	2109e010 <alt_putchar>
2109e000:	003fb906 	br	2109dee8 <__flash_rwdata_start+0xffffbca0>
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
                    {
                        alt_putchar('0');
2109e004:	01000c04 	movi	r4,48
2109e008:	109e0100 	call	2109e010 <alt_putchar>
                        continue;
2109e00c:	003fb606 	br	2109dee8 <__flash_rwdata_start+0xffffbca0>

2109e010 <alt_putchar>:
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
2109e010:	00800034 	movhi	r2,0
2109e014:	10976b04 	addi	r2,r2,23980
2109e018:	10800017 	ldw	r2,0(r2)
2109e01c:	11400217 	ldw	r5,8(r2)
2109e020:	1096acc1 	jmpi	21096acc <putc>

2109e024 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
2109e024:	000170fa 	wrctl	ienable,zero
2109e028:	f800283a 	ret

2109e02c <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
2109e02c:	defffa04 	addi	sp,sp,-24
2109e030:	dd000415 	stw	r20,16(sp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
2109e034:	05000034 	movhi	r20,0
2109e038:	a5177304 	addi	r20,r20,24012
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
2109e03c:	dc000015 	stw	r16,0(sp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
2109e040:	a4000017 	ldw	r16,0(r20)
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
2109e044:	dfc00515 	stw	ra,20(sp)
2109e048:	dcc00315 	stw	r19,12(sp)
2109e04c:	dc800215 	stw	r18,8(sp)
2109e050:	dc400115 	stw	r17,4(sp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
2109e054:	85001626 	beq	r16,r20,2109e0b0 <alt_find_file+0x84>
2109e058:	2025883a 	mov	r18,r4
  {
    len = strlen(next->name);
    
    if (next->name[len-1] == '/')
2109e05c:	04c00bc4 	movi	r19,47
2109e060:	00000806 	br	2109e084 <alt_find_file+0x58>
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
2109e064:	9185883a 	add	r2,r18,r6
2109e068:	10800007 	ldb	r2,0(r2)
2109e06c:	14c00126 	beq	r2,r19,2109e074 <alt_find_file+0x48>
2109e070:	1000021e 	bne	r2,zero,2109e07c <alt_find_file+0x50>
        !memcmp (next->name, name, len))
2109e074:	108e0b80 	call	2108e0b8 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
2109e078:	10001626 	beq	r2,zero,2109e0d4 <alt_find_file+0xa8>
    {
      /* match found */

      return next;
    }
    next = (alt_dev*) next->llist.next;
2109e07c:	84000017 	ldw	r16,0(r16)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
2109e080:	85000b26 	beq	r16,r20,2109e0b0 <alt_find_file+0x84>
  {
    len = strlen(next->name);
2109e084:	84400217 	ldw	r17,8(r16)
2109e088:	8809883a 	mov	r4,r17
2109e08c:	108e7200 	call	2108e720 <strlen>
2109e090:	100d883a 	mov	r6,r2
    
    if (next->name[len-1] == '/')
2109e094:	8885883a 	add	r2,r17,r2
2109e098:	10bfffc7 	ldb	r2,-1(r2)
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
        !memcmp (next->name, name, len))
2109e09c:	8809883a 	mov	r4,r17
2109e0a0:	900b883a 	mov	r5,r18
 
  while (next != (alt_dev*) &alt_fs_list)
  {
    len = strlen(next->name);
    
    if (next->name[len-1] == '/')
2109e0a4:	14ffef1e 	bne	r2,r19,2109e064 <__flash_rwdata_start+0xffffbe1c>
    {
      len -= 1;
2109e0a8:	31bfffc4 	addi	r6,r6,-1
2109e0ac:	003fed06 	br	2109e064 <__flash_rwdata_start+0xffffbe1c>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
2109e0b0:	0005883a 	mov	r2,zero
}
2109e0b4:	dfc00517 	ldw	ra,20(sp)
2109e0b8:	dd000417 	ldw	r20,16(sp)
2109e0bc:	dcc00317 	ldw	r19,12(sp)
2109e0c0:	dc800217 	ldw	r18,8(sp)
2109e0c4:	dc400117 	ldw	r17,4(sp)
2109e0c8:	dc000017 	ldw	r16,0(sp)
2109e0cc:	dec00604 	addi	sp,sp,24
2109e0d0:	f800283a 	ret
    if (((name[len] == '/') || (name[len] == '\0')) && 
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
2109e0d4:	8005883a 	mov	r2,r16
2109e0d8:	003ff606 	br	2109e0b4 <__flash_rwdata_start+0xffffbe6c>

2109e0dc <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
2109e0dc:	01800034 	movhi	r6,0
2109e0e0:	31927504 	addi	r6,r6,18900
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
2109e0e4:	0005883a 	mov	r2,zero
2109e0e8:	01c00804 	movi	r7,32
2109e0ec:	00000206 	br	2109e0f8 <alt_get_fd+0x1c>
2109e0f0:	10800044 	addi	r2,r2,1
2109e0f4:	11c00b26 	beq	r2,r7,2109e124 <alt_get_fd+0x48>
2109e0f8:	10c00324 	muli	r3,r2,12
2109e0fc:	1987883a 	add	r3,r3,r6
  {
    if (!alt_fd_list[i].dev)
2109e100:	19400017 	ldw	r5,0(r3)
2109e104:	283ffa1e 	bne	r5,zero,2109e0f0 <__flash_rwdata_start+0xffffbea8>
    {
      alt_fd_list[i].dev = dev;
      if (i > alt_max_fd)
2109e108:	01400034 	movhi	r5,0
2109e10c:	29577004 	addi	r5,r5,24000

  for (i = 0; i < ALT_MAX_FD; i++)
  {
    if (!alt_fd_list[i].dev)
    {
      alt_fd_list[i].dev = dev;
2109e110:	19000015 	stw	r4,0(r3)
      if (i > alt_max_fd)
2109e114:	28c00017 	ldw	r3,0(r5)
2109e118:	1880030e 	bge	r3,r2,2109e128 <alt_get_fd+0x4c>
      {
        alt_max_fd = i;
2109e11c:	28800015 	stw	r2,0(r5)
      }
      rc = i;
      goto alt_get_fd_exit;
2109e120:	f800283a 	ret
 */

int alt_get_fd (alt_dev* dev)
{
  alt_32 i;
  int rc = -EMFILE;
2109e124:	00bffa04 	movi	r2,-24
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
}
2109e128:	f800283a 	ret

2109e12c <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
2109e12c:	00840004 	movi	r2,4096
2109e130:	1140012e 	bgeu	r2,r5,2109e138 <alt_icache_flush+0xc>
2109e134:	100b883a 	mov	r5,r2
  if (len > NIOS2_ICACHE_SIZE)
  {
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;
2109e138:	214b883a 	add	r5,r4,r5

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
2109e13c:	2005883a 	mov	r2,r4
2109e140:	2140092e 	bgeu	r4,r5,2109e168 <alt_icache_flush+0x3c>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
2109e144:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
2109e148:	10800804 	addi	r2,r2,32
2109e14c:	117ffd36 	bltu	r2,r5,2109e144 <__flash_rwdata_start+0xffffbefc>
2109e150:	0104303a 	nor	r2,zero,r4
2109e154:	2885883a 	add	r2,r5,r2
2109e158:	1004d17a 	srli	r2,r2,5
2109e15c:	10800044 	addi	r2,r2,1
2109e160:	1004917a 	slli	r2,r2,5
2109e164:	2085883a 	add	r2,r4,r2
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
2109e168:	210007cc 	andi	r4,r4,31
2109e16c:	20000126 	beq	r4,zero,2109e174 <alt_icache_flush+0x48>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
2109e170:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
2109e174:	0000203a 	flushp
2109e178:	f800283a 	ret

2109e17c <alt_exception_cause_generated_bad_addr>:
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
  switch (cause) {
2109e17c:	213ffe84 	addi	r4,r4,-6
2109e180:	008003c4 	movi	r2,15
2109e184:	11001636 	bltu	r2,r4,2109e1e0 <alt_exception_cause_generated_bad_addr+0x64>
2109e188:	200890ba 	slli	r4,r4,2
2109e18c:	008842b4 	movhi	r2,8458
2109e190:	10b86804 	addi	r2,r2,-7776
2109e194:	2089883a 	add	r4,r4,r2
2109e198:	20800017 	ldw	r2,0(r4)
2109e19c:	1000683a 	jmp	r2
2109e1a0:	2109e1e8 	cmpgeui	r4,r4,10119
2109e1a4:	2109e1e8 	cmpgeui	r4,r4,10119
2109e1a8:	2109e1e0 	cmpeqi	r4,r4,10119
2109e1ac:	2109e1e0 	cmpeqi	r4,r4,10119
2109e1b0:	2109e1e0 	cmpeqi	r4,r4,10119
2109e1b4:	2109e1e8 	cmpgeui	r4,r4,10119
2109e1b8:	2109e1e0 	cmpeqi	r4,r4,10119
2109e1bc:	2109e1e0 	cmpeqi	r4,r4,10119
2109e1c0:	2109e1e8 	cmpgeui	r4,r4,10119
2109e1c4:	2109e1e8 	cmpgeui	r4,r4,10119
2109e1c8:	2109e1e0 	cmpeqi	r4,r4,10119
2109e1cc:	2109e1e8 	cmpgeui	r4,r4,10119
2109e1d0:	2109e1e0 	cmpeqi	r4,r4,10119
2109e1d4:	2109e1e0 	cmpeqi	r4,r4,10119
2109e1d8:	2109e1e0 	cmpeqi	r4,r4,10119
2109e1dc:	2109e1e8 	cmpgeui	r4,r4,10119
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
2109e1e0:	0005883a 	mov	r2,zero
2109e1e4:	f800283a 	ret
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
2109e1e8:	00800044 	movi	r2,1
    return 0;

  default:
    return 0;
  }
}
2109e1ec:	f800283a 	ret

2109e1f0 <atexit>:
2109e1f0:	200b883a 	mov	r5,r4
2109e1f4:	000d883a 	mov	r6,zero
2109e1f8:	0009883a 	mov	r4,zero
2109e1fc:	000f883a 	mov	r7,zero
2109e200:	109e2041 	jmpi	2109e204 <__register_exitproc>

2109e204 <__register_exitproc>:
2109e204:	00800034 	movhi	r2,0
2109e208:	defffa04 	addi	sp,sp,-24
2109e20c:	10976a04 	addi	r2,r2,23976
2109e210:	dc000315 	stw	r16,12(sp)
2109e214:	14000017 	ldw	r16,0(r2)
2109e218:	dc400415 	stw	r17,16(sp)
2109e21c:	dfc00515 	stw	ra,20(sp)
2109e220:	80805217 	ldw	r2,328(r16)
2109e224:	2023883a 	mov	r17,r4
2109e228:	10003626 	beq	r2,zero,2109e304 <__register_exitproc+0x100>
2109e22c:	10c00117 	ldw	r3,4(r2)
2109e230:	010007c4 	movi	r4,31
2109e234:	20c00e16 	blt	r4,r3,2109e270 <__register_exitproc+0x6c>
2109e238:	1a400044 	addi	r9,r3,1
2109e23c:	8800211e 	bne	r17,zero,2109e2c4 <__register_exitproc+0xc0>
2109e240:	18c00084 	addi	r3,r3,2
2109e244:	18c7883a 	add	r3,r3,r3
2109e248:	18c7883a 	add	r3,r3,r3
2109e24c:	12400115 	stw	r9,4(r2)
2109e250:	10c7883a 	add	r3,r2,r3
2109e254:	19400015 	stw	r5,0(r3)
2109e258:	0005883a 	mov	r2,zero
2109e25c:	dfc00517 	ldw	ra,20(sp)
2109e260:	dc400417 	ldw	r17,16(sp)
2109e264:	dc000317 	ldw	r16,12(sp)
2109e268:	dec00604 	addi	sp,sp,24
2109e26c:	f800283a 	ret
2109e270:	00884274 	movhi	r2,8457
2109e274:	10b63a04 	addi	r2,r2,-10008
2109e278:	10002526 	beq	r2,zero,2109e310 <__register_exitproc+0x10c>
2109e27c:	01006404 	movi	r4,400
2109e280:	d9400015 	stw	r5,0(sp)
2109e284:	d9800115 	stw	r6,4(sp)
2109e288:	d9c00215 	stw	r7,8(sp)
2109e28c:	108d8e80 	call	2108d8e8 <malloc>
2109e290:	d9400017 	ldw	r5,0(sp)
2109e294:	d9800117 	ldw	r6,4(sp)
2109e298:	d9c00217 	ldw	r7,8(sp)
2109e29c:	10001c26 	beq	r2,zero,2109e310 <__register_exitproc+0x10c>
2109e2a0:	80c05217 	ldw	r3,328(r16)
2109e2a4:	10000115 	stw	zero,4(r2)
2109e2a8:	02400044 	movi	r9,1
2109e2ac:	10c00015 	stw	r3,0(r2)
2109e2b0:	80805215 	stw	r2,328(r16)
2109e2b4:	10006215 	stw	zero,392(r2)
2109e2b8:	10006315 	stw	zero,396(r2)
2109e2bc:	0007883a 	mov	r3,zero
2109e2c0:	883fdf26 	beq	r17,zero,2109e240 <__flash_rwdata_start+0xffffbff8>
2109e2c4:	18d1883a 	add	r8,r3,r3
2109e2c8:	4211883a 	add	r8,r8,r8
2109e2cc:	1211883a 	add	r8,r2,r8
2109e2d0:	41802215 	stw	r6,136(r8)
2109e2d4:	01000044 	movi	r4,1
2109e2d8:	11806217 	ldw	r6,392(r2)
2109e2dc:	20c8983a 	sll	r4,r4,r3
2109e2e0:	310cb03a 	or	r6,r6,r4
2109e2e4:	11806215 	stw	r6,392(r2)
2109e2e8:	41c04215 	stw	r7,264(r8)
2109e2ec:	01800084 	movi	r6,2
2109e2f0:	89bfd31e 	bne	r17,r6,2109e240 <__flash_rwdata_start+0xffffbff8>
2109e2f4:	11806317 	ldw	r6,396(r2)
2109e2f8:	3108b03a 	or	r4,r6,r4
2109e2fc:	11006315 	stw	r4,396(r2)
2109e300:	003fcf06 	br	2109e240 <__flash_rwdata_start+0xffffbff8>
2109e304:	80805304 	addi	r2,r16,332
2109e308:	80805215 	stw	r2,328(r16)
2109e30c:	003fc706 	br	2109e22c <__flash_rwdata_start+0xffffbfe4>
2109e310:	00bfffc4 	movi	r2,-1
2109e314:	003fd106 	br	2109e25c <__flash_rwdata_start+0xffffc014>
